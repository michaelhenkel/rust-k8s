// This file is generated by rust-protobuf 2.27.1. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `k8s.io_api_core_v1_generated.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_27_1;

#[derive(PartialEq,Clone,Default)]
pub struct AWSElasticBlockStoreVolumeSource {
    // message fields
    volumeID: ::protobuf::SingularField<::std::string::String>,
    fsType: ::protobuf::SingularField<::std::string::String>,
    partition: ::std::option::Option<i32>,
    readOnly: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AWSElasticBlockStoreVolumeSource {
    fn default() -> &'a AWSElasticBlockStoreVolumeSource {
        <AWSElasticBlockStoreVolumeSource as ::protobuf::Message>::default_instance()
    }
}

impl AWSElasticBlockStoreVolumeSource {
    pub fn new() -> AWSElasticBlockStoreVolumeSource {
        ::std::default::Default::default()
    }

    // optional string volumeID = 1;


    pub fn get_volumeID(&self) -> &str {
        match self.volumeID.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_volumeID(&mut self) {
        self.volumeID.clear();
    }

    pub fn has_volumeID(&self) -> bool {
        self.volumeID.is_some()
    }

    // Param is passed by value, moved
    pub fn set_volumeID(&mut self, v: ::std::string::String) {
        self.volumeID = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_volumeID(&mut self) -> &mut ::std::string::String {
        if self.volumeID.is_none() {
            self.volumeID.set_default();
        }
        self.volumeID.as_mut().unwrap()
    }

    // Take field
    pub fn take_volumeID(&mut self) -> ::std::string::String {
        self.volumeID.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string fsType = 2;


    pub fn get_fsType(&self) -> &str {
        match self.fsType.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_fsType(&mut self) {
        self.fsType.clear();
    }

    pub fn has_fsType(&self) -> bool {
        self.fsType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fsType(&mut self, v: ::std::string::String) {
        self.fsType = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fsType(&mut self) -> &mut ::std::string::String {
        if self.fsType.is_none() {
            self.fsType.set_default();
        }
        self.fsType.as_mut().unwrap()
    }

    // Take field
    pub fn take_fsType(&mut self) -> ::std::string::String {
        self.fsType.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 partition = 3;


    pub fn get_partition(&self) -> i32 {
        self.partition.unwrap_or(0)
    }
    pub fn clear_partition(&mut self) {
        self.partition = ::std::option::Option::None;
    }

    pub fn has_partition(&self) -> bool {
        self.partition.is_some()
    }

    // Param is passed by value, moved
    pub fn set_partition(&mut self, v: i32) {
        self.partition = ::std::option::Option::Some(v);
    }

    // optional bool readOnly = 4;


    pub fn get_readOnly(&self) -> bool {
        self.readOnly.unwrap_or(false)
    }
    pub fn clear_readOnly(&mut self) {
        self.readOnly = ::std::option::Option::None;
    }

    pub fn has_readOnly(&self) -> bool {
        self.readOnly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readOnly(&mut self, v: bool) {
        self.readOnly = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for AWSElasticBlockStoreVolumeSource {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.volumeID)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.fsType)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.partition = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.readOnly = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.volumeID.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.fsType.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.partition {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.readOnly {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.volumeID.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.fsType.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.partition {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.readOnly {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AWSElasticBlockStoreVolumeSource {
        AWSElasticBlockStoreVolumeSource::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "volumeID",
                |m: &AWSElasticBlockStoreVolumeSource| { &m.volumeID },
                |m: &mut AWSElasticBlockStoreVolumeSource| { &mut m.volumeID },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "fsType",
                |m: &AWSElasticBlockStoreVolumeSource| { &m.fsType },
                |m: &mut AWSElasticBlockStoreVolumeSource| { &mut m.fsType },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "partition",
                |m: &AWSElasticBlockStoreVolumeSource| { &m.partition },
                |m: &mut AWSElasticBlockStoreVolumeSource| { &mut m.partition },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "readOnly",
                |m: &AWSElasticBlockStoreVolumeSource| { &m.readOnly },
                |m: &mut AWSElasticBlockStoreVolumeSource| { &mut m.readOnly },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AWSElasticBlockStoreVolumeSource>(
                "AWSElasticBlockStoreVolumeSource",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AWSElasticBlockStoreVolumeSource {
        static instance: ::protobuf::rt::LazyV2<AWSElasticBlockStoreVolumeSource> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AWSElasticBlockStoreVolumeSource::new)
    }
}

impl ::protobuf::Clear for AWSElasticBlockStoreVolumeSource {
    fn clear(&mut self) {
        self.volumeID.clear();
        self.fsType.clear();
        self.partition = ::std::option::Option::None;
        self.readOnly = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AWSElasticBlockStoreVolumeSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AWSElasticBlockStoreVolumeSource {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Affinity {
    // message fields
    pub nodeAffinity: ::protobuf::SingularPtrField<NodeAffinity>,
    pub podAffinity: ::protobuf::SingularPtrField<PodAffinity>,
    pub podAntiAffinity: ::protobuf::SingularPtrField<PodAntiAffinity>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Affinity {
    fn default() -> &'a Affinity {
        <Affinity as ::protobuf::Message>::default_instance()
    }
}

impl Affinity {
    pub fn new() -> Affinity {
        ::std::default::Default::default()
    }

    // optional .k8s.io.api.core.v1.NodeAffinity nodeAffinity = 1;


    pub fn get_nodeAffinity(&self) -> &NodeAffinity {
        self.nodeAffinity.as_ref().unwrap_or_else(|| <NodeAffinity as ::protobuf::Message>::default_instance())
    }
    pub fn clear_nodeAffinity(&mut self) {
        self.nodeAffinity.clear();
    }

    pub fn has_nodeAffinity(&self) -> bool {
        self.nodeAffinity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nodeAffinity(&mut self, v: NodeAffinity) {
        self.nodeAffinity = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nodeAffinity(&mut self) -> &mut NodeAffinity {
        if self.nodeAffinity.is_none() {
            self.nodeAffinity.set_default();
        }
        self.nodeAffinity.as_mut().unwrap()
    }

    // Take field
    pub fn take_nodeAffinity(&mut self) -> NodeAffinity {
        self.nodeAffinity.take().unwrap_or_else(|| NodeAffinity::new())
    }

    // optional .k8s.io.api.core.v1.PodAffinity podAffinity = 2;


    pub fn get_podAffinity(&self) -> &PodAffinity {
        self.podAffinity.as_ref().unwrap_or_else(|| <PodAffinity as ::protobuf::Message>::default_instance())
    }
    pub fn clear_podAffinity(&mut self) {
        self.podAffinity.clear();
    }

    pub fn has_podAffinity(&self) -> bool {
        self.podAffinity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_podAffinity(&mut self, v: PodAffinity) {
        self.podAffinity = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_podAffinity(&mut self) -> &mut PodAffinity {
        if self.podAffinity.is_none() {
            self.podAffinity.set_default();
        }
        self.podAffinity.as_mut().unwrap()
    }

    // Take field
    pub fn take_podAffinity(&mut self) -> PodAffinity {
        self.podAffinity.take().unwrap_or_else(|| PodAffinity::new())
    }

    // optional .k8s.io.api.core.v1.PodAntiAffinity podAntiAffinity = 3;


    pub fn get_podAntiAffinity(&self) -> &PodAntiAffinity {
        self.podAntiAffinity.as_ref().unwrap_or_else(|| <PodAntiAffinity as ::protobuf::Message>::default_instance())
    }
    pub fn clear_podAntiAffinity(&mut self) {
        self.podAntiAffinity.clear();
    }

    pub fn has_podAntiAffinity(&self) -> bool {
        self.podAntiAffinity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_podAntiAffinity(&mut self, v: PodAntiAffinity) {
        self.podAntiAffinity = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_podAntiAffinity(&mut self) -> &mut PodAntiAffinity {
        if self.podAntiAffinity.is_none() {
            self.podAntiAffinity.set_default();
        }
        self.podAntiAffinity.as_mut().unwrap()
    }

    // Take field
    pub fn take_podAntiAffinity(&mut self) -> PodAntiAffinity {
        self.podAntiAffinity.take().unwrap_or_else(|| PodAntiAffinity::new())
    }
}

impl ::protobuf::Message for Affinity {
    fn is_initialized(&self) -> bool {
        for v in &self.nodeAffinity {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.podAffinity {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.podAntiAffinity {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.nodeAffinity)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.podAffinity)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.podAntiAffinity)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.nodeAffinity.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.podAffinity.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.podAntiAffinity.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.nodeAffinity.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.podAffinity.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.podAntiAffinity.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Affinity {
        Affinity::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NodeAffinity>>(
                "nodeAffinity",
                |m: &Affinity| { &m.nodeAffinity },
                |m: &mut Affinity| { &mut m.nodeAffinity },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PodAffinity>>(
                "podAffinity",
                |m: &Affinity| { &m.podAffinity },
                |m: &mut Affinity| { &mut m.podAffinity },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PodAntiAffinity>>(
                "podAntiAffinity",
                |m: &Affinity| { &m.podAntiAffinity },
                |m: &mut Affinity| { &mut m.podAntiAffinity },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Affinity>(
                "Affinity",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Affinity {
        static instance: ::protobuf::rt::LazyV2<Affinity> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Affinity::new)
    }
}

impl ::protobuf::Clear for Affinity {
    fn clear(&mut self) {
        self.nodeAffinity.clear();
        self.podAffinity.clear();
        self.podAntiAffinity.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Affinity {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Affinity {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AttachedVolume {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    devicePath: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AttachedVolume {
    fn default() -> &'a AttachedVolume {
        <AttachedVolume as ::protobuf::Message>::default_instance()
    }
}

impl AttachedVolume {
    pub fn new() -> AttachedVolume {
        ::std::default::Default::default()
    }

    // optional string name = 1;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string devicePath = 2;


    pub fn get_devicePath(&self) -> &str {
        match self.devicePath.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_devicePath(&mut self) {
        self.devicePath.clear();
    }

    pub fn has_devicePath(&self) -> bool {
        self.devicePath.is_some()
    }

    // Param is passed by value, moved
    pub fn set_devicePath(&mut self, v: ::std::string::String) {
        self.devicePath = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_devicePath(&mut self) -> &mut ::std::string::String {
        if self.devicePath.is_none() {
            self.devicePath.set_default();
        }
        self.devicePath.as_mut().unwrap()
    }

    // Take field
    pub fn take_devicePath(&mut self) -> ::std::string::String {
        self.devicePath.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for AttachedVolume {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.devicePath)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.devicePath.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.devicePath.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AttachedVolume {
        AttachedVolume::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &AttachedVolume| { &m.name },
                |m: &mut AttachedVolume| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "devicePath",
                |m: &AttachedVolume| { &m.devicePath },
                |m: &mut AttachedVolume| { &mut m.devicePath },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AttachedVolume>(
                "AttachedVolume",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AttachedVolume {
        static instance: ::protobuf::rt::LazyV2<AttachedVolume> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AttachedVolume::new)
    }
}

impl ::protobuf::Clear for AttachedVolume {
    fn clear(&mut self) {
        self.name.clear();
        self.devicePath.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AttachedVolume {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AttachedVolume {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AvoidPods {
    // message fields
    pub preferAvoidPods: ::protobuf::RepeatedField<PreferAvoidPodsEntry>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AvoidPods {
    fn default() -> &'a AvoidPods {
        <AvoidPods as ::protobuf::Message>::default_instance()
    }
}

impl AvoidPods {
    pub fn new() -> AvoidPods {
        ::std::default::Default::default()
    }

    // repeated .k8s.io.api.core.v1.PreferAvoidPodsEntry preferAvoidPods = 1;


    pub fn get_preferAvoidPods(&self) -> &[PreferAvoidPodsEntry] {
        &self.preferAvoidPods
    }
    pub fn clear_preferAvoidPods(&mut self) {
        self.preferAvoidPods.clear();
    }

    // Param is passed by value, moved
    pub fn set_preferAvoidPods(&mut self, v: ::protobuf::RepeatedField<PreferAvoidPodsEntry>) {
        self.preferAvoidPods = v;
    }

    // Mutable pointer to the field.
    pub fn mut_preferAvoidPods(&mut self) -> &mut ::protobuf::RepeatedField<PreferAvoidPodsEntry> {
        &mut self.preferAvoidPods
    }

    // Take field
    pub fn take_preferAvoidPods(&mut self) -> ::protobuf::RepeatedField<PreferAvoidPodsEntry> {
        ::std::mem::replace(&mut self.preferAvoidPods, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for AvoidPods {
    fn is_initialized(&self) -> bool {
        for v in &self.preferAvoidPods {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.preferAvoidPods)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.preferAvoidPods {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.preferAvoidPods {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AvoidPods {
        AvoidPods::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PreferAvoidPodsEntry>>(
                "preferAvoidPods",
                |m: &AvoidPods| { &m.preferAvoidPods },
                |m: &mut AvoidPods| { &mut m.preferAvoidPods },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AvoidPods>(
                "AvoidPods",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AvoidPods {
        static instance: ::protobuf::rt::LazyV2<AvoidPods> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AvoidPods::new)
    }
}

impl ::protobuf::Clear for AvoidPods {
    fn clear(&mut self) {
        self.preferAvoidPods.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AvoidPods {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AvoidPods {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AzureDiskVolumeSource {
    // message fields
    diskName: ::protobuf::SingularField<::std::string::String>,
    diskURI: ::protobuf::SingularField<::std::string::String>,
    cachingMode: ::protobuf::SingularField<::std::string::String>,
    fsType: ::protobuf::SingularField<::std::string::String>,
    readOnly: ::std::option::Option<bool>,
    kind: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AzureDiskVolumeSource {
    fn default() -> &'a AzureDiskVolumeSource {
        <AzureDiskVolumeSource as ::protobuf::Message>::default_instance()
    }
}

impl AzureDiskVolumeSource {
    pub fn new() -> AzureDiskVolumeSource {
        ::std::default::Default::default()
    }

    // optional string diskName = 1;


    pub fn get_diskName(&self) -> &str {
        match self.diskName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_diskName(&mut self) {
        self.diskName.clear();
    }

    pub fn has_diskName(&self) -> bool {
        self.diskName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_diskName(&mut self, v: ::std::string::String) {
        self.diskName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_diskName(&mut self) -> &mut ::std::string::String {
        if self.diskName.is_none() {
            self.diskName.set_default();
        }
        self.diskName.as_mut().unwrap()
    }

    // Take field
    pub fn take_diskName(&mut self) -> ::std::string::String {
        self.diskName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string diskURI = 2;


    pub fn get_diskURI(&self) -> &str {
        match self.diskURI.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_diskURI(&mut self) {
        self.diskURI.clear();
    }

    pub fn has_diskURI(&self) -> bool {
        self.diskURI.is_some()
    }

    // Param is passed by value, moved
    pub fn set_diskURI(&mut self, v: ::std::string::String) {
        self.diskURI = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_diskURI(&mut self) -> &mut ::std::string::String {
        if self.diskURI.is_none() {
            self.diskURI.set_default();
        }
        self.diskURI.as_mut().unwrap()
    }

    // Take field
    pub fn take_diskURI(&mut self) -> ::std::string::String {
        self.diskURI.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string cachingMode = 3;


    pub fn get_cachingMode(&self) -> &str {
        match self.cachingMode.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_cachingMode(&mut self) {
        self.cachingMode.clear();
    }

    pub fn has_cachingMode(&self) -> bool {
        self.cachingMode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cachingMode(&mut self, v: ::std::string::String) {
        self.cachingMode = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cachingMode(&mut self) -> &mut ::std::string::String {
        if self.cachingMode.is_none() {
            self.cachingMode.set_default();
        }
        self.cachingMode.as_mut().unwrap()
    }

    // Take field
    pub fn take_cachingMode(&mut self) -> ::std::string::String {
        self.cachingMode.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string fsType = 4;


    pub fn get_fsType(&self) -> &str {
        match self.fsType.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_fsType(&mut self) {
        self.fsType.clear();
    }

    pub fn has_fsType(&self) -> bool {
        self.fsType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fsType(&mut self, v: ::std::string::String) {
        self.fsType = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fsType(&mut self) -> &mut ::std::string::String {
        if self.fsType.is_none() {
            self.fsType.set_default();
        }
        self.fsType.as_mut().unwrap()
    }

    // Take field
    pub fn take_fsType(&mut self) -> ::std::string::String {
        self.fsType.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool readOnly = 5;


    pub fn get_readOnly(&self) -> bool {
        self.readOnly.unwrap_or(false)
    }
    pub fn clear_readOnly(&mut self) {
        self.readOnly = ::std::option::Option::None;
    }

    pub fn has_readOnly(&self) -> bool {
        self.readOnly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readOnly(&mut self, v: bool) {
        self.readOnly = ::std::option::Option::Some(v);
    }

    // optional string kind = 6;


    pub fn get_kind(&self) -> &str {
        match self.kind.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_kind(&mut self) {
        self.kind.clear();
    }

    pub fn has_kind(&self) -> bool {
        self.kind.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kind(&mut self, v: ::std::string::String) {
        self.kind = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kind(&mut self) -> &mut ::std::string::String {
        if self.kind.is_none() {
            self.kind.set_default();
        }
        self.kind.as_mut().unwrap()
    }

    // Take field
    pub fn take_kind(&mut self) -> ::std::string::String {
        self.kind.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for AzureDiskVolumeSource {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.diskName)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.diskURI)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.cachingMode)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.fsType)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.readOnly = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.kind)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.diskName.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.diskURI.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.cachingMode.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.fsType.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.readOnly {
            my_size += 2;
        }
        if let Some(ref v) = self.kind.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.diskName.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.diskURI.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.cachingMode.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.fsType.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(v) = self.readOnly {
            os.write_bool(5, v)?;
        }
        if let Some(ref v) = self.kind.as_ref() {
            os.write_string(6, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AzureDiskVolumeSource {
        AzureDiskVolumeSource::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "diskName",
                |m: &AzureDiskVolumeSource| { &m.diskName },
                |m: &mut AzureDiskVolumeSource| { &mut m.diskName },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "diskURI",
                |m: &AzureDiskVolumeSource| { &m.diskURI },
                |m: &mut AzureDiskVolumeSource| { &mut m.diskURI },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "cachingMode",
                |m: &AzureDiskVolumeSource| { &m.cachingMode },
                |m: &mut AzureDiskVolumeSource| { &mut m.cachingMode },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "fsType",
                |m: &AzureDiskVolumeSource| { &m.fsType },
                |m: &mut AzureDiskVolumeSource| { &mut m.fsType },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "readOnly",
                |m: &AzureDiskVolumeSource| { &m.readOnly },
                |m: &mut AzureDiskVolumeSource| { &mut m.readOnly },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "kind",
                |m: &AzureDiskVolumeSource| { &m.kind },
                |m: &mut AzureDiskVolumeSource| { &mut m.kind },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AzureDiskVolumeSource>(
                "AzureDiskVolumeSource",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AzureDiskVolumeSource {
        static instance: ::protobuf::rt::LazyV2<AzureDiskVolumeSource> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AzureDiskVolumeSource::new)
    }
}

impl ::protobuf::Clear for AzureDiskVolumeSource {
    fn clear(&mut self) {
        self.diskName.clear();
        self.diskURI.clear();
        self.cachingMode.clear();
        self.fsType.clear();
        self.readOnly = ::std::option::Option::None;
        self.kind.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AzureDiskVolumeSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AzureDiskVolumeSource {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AzureFilePersistentVolumeSource {
    // message fields
    secretName: ::protobuf::SingularField<::std::string::String>,
    shareName: ::protobuf::SingularField<::std::string::String>,
    readOnly: ::std::option::Option<bool>,
    secretNamespace: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AzureFilePersistentVolumeSource {
    fn default() -> &'a AzureFilePersistentVolumeSource {
        <AzureFilePersistentVolumeSource as ::protobuf::Message>::default_instance()
    }
}

impl AzureFilePersistentVolumeSource {
    pub fn new() -> AzureFilePersistentVolumeSource {
        ::std::default::Default::default()
    }

    // optional string secretName = 1;


    pub fn get_secretName(&self) -> &str {
        match self.secretName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_secretName(&mut self) {
        self.secretName.clear();
    }

    pub fn has_secretName(&self) -> bool {
        self.secretName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secretName(&mut self, v: ::std::string::String) {
        self.secretName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_secretName(&mut self) -> &mut ::std::string::String {
        if self.secretName.is_none() {
            self.secretName.set_default();
        }
        self.secretName.as_mut().unwrap()
    }

    // Take field
    pub fn take_secretName(&mut self) -> ::std::string::String {
        self.secretName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string shareName = 2;


    pub fn get_shareName(&self) -> &str {
        match self.shareName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_shareName(&mut self) {
        self.shareName.clear();
    }

    pub fn has_shareName(&self) -> bool {
        self.shareName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shareName(&mut self, v: ::std::string::String) {
        self.shareName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_shareName(&mut self) -> &mut ::std::string::String {
        if self.shareName.is_none() {
            self.shareName.set_default();
        }
        self.shareName.as_mut().unwrap()
    }

    // Take field
    pub fn take_shareName(&mut self) -> ::std::string::String {
        self.shareName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool readOnly = 3;


    pub fn get_readOnly(&self) -> bool {
        self.readOnly.unwrap_or(false)
    }
    pub fn clear_readOnly(&mut self) {
        self.readOnly = ::std::option::Option::None;
    }

    pub fn has_readOnly(&self) -> bool {
        self.readOnly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readOnly(&mut self, v: bool) {
        self.readOnly = ::std::option::Option::Some(v);
    }

    // optional string secretNamespace = 4;


    pub fn get_secretNamespace(&self) -> &str {
        match self.secretNamespace.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_secretNamespace(&mut self) {
        self.secretNamespace.clear();
    }

    pub fn has_secretNamespace(&self) -> bool {
        self.secretNamespace.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secretNamespace(&mut self, v: ::std::string::String) {
        self.secretNamespace = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_secretNamespace(&mut self) -> &mut ::std::string::String {
        if self.secretNamespace.is_none() {
            self.secretNamespace.set_default();
        }
        self.secretNamespace.as_mut().unwrap()
    }

    // Take field
    pub fn take_secretNamespace(&mut self) -> ::std::string::String {
        self.secretNamespace.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for AzureFilePersistentVolumeSource {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.secretName)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.shareName)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.readOnly = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.secretNamespace)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.secretName.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.shareName.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.readOnly {
            my_size += 2;
        }
        if let Some(ref v) = self.secretNamespace.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.secretName.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.shareName.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.readOnly {
            os.write_bool(3, v)?;
        }
        if let Some(ref v) = self.secretNamespace.as_ref() {
            os.write_string(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AzureFilePersistentVolumeSource {
        AzureFilePersistentVolumeSource::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "secretName",
                |m: &AzureFilePersistentVolumeSource| { &m.secretName },
                |m: &mut AzureFilePersistentVolumeSource| { &mut m.secretName },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "shareName",
                |m: &AzureFilePersistentVolumeSource| { &m.shareName },
                |m: &mut AzureFilePersistentVolumeSource| { &mut m.shareName },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "readOnly",
                |m: &AzureFilePersistentVolumeSource| { &m.readOnly },
                |m: &mut AzureFilePersistentVolumeSource| { &mut m.readOnly },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "secretNamespace",
                |m: &AzureFilePersistentVolumeSource| { &m.secretNamespace },
                |m: &mut AzureFilePersistentVolumeSource| { &mut m.secretNamespace },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AzureFilePersistentVolumeSource>(
                "AzureFilePersistentVolumeSource",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AzureFilePersistentVolumeSource {
        static instance: ::protobuf::rt::LazyV2<AzureFilePersistentVolumeSource> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AzureFilePersistentVolumeSource::new)
    }
}

impl ::protobuf::Clear for AzureFilePersistentVolumeSource {
    fn clear(&mut self) {
        self.secretName.clear();
        self.shareName.clear();
        self.readOnly = ::std::option::Option::None;
        self.secretNamespace.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AzureFilePersistentVolumeSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AzureFilePersistentVolumeSource {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AzureFileVolumeSource {
    // message fields
    secretName: ::protobuf::SingularField<::std::string::String>,
    shareName: ::protobuf::SingularField<::std::string::String>,
    readOnly: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AzureFileVolumeSource {
    fn default() -> &'a AzureFileVolumeSource {
        <AzureFileVolumeSource as ::protobuf::Message>::default_instance()
    }
}

impl AzureFileVolumeSource {
    pub fn new() -> AzureFileVolumeSource {
        ::std::default::Default::default()
    }

    // optional string secretName = 1;


    pub fn get_secretName(&self) -> &str {
        match self.secretName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_secretName(&mut self) {
        self.secretName.clear();
    }

    pub fn has_secretName(&self) -> bool {
        self.secretName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secretName(&mut self, v: ::std::string::String) {
        self.secretName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_secretName(&mut self) -> &mut ::std::string::String {
        if self.secretName.is_none() {
            self.secretName.set_default();
        }
        self.secretName.as_mut().unwrap()
    }

    // Take field
    pub fn take_secretName(&mut self) -> ::std::string::String {
        self.secretName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string shareName = 2;


    pub fn get_shareName(&self) -> &str {
        match self.shareName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_shareName(&mut self) {
        self.shareName.clear();
    }

    pub fn has_shareName(&self) -> bool {
        self.shareName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shareName(&mut self, v: ::std::string::String) {
        self.shareName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_shareName(&mut self) -> &mut ::std::string::String {
        if self.shareName.is_none() {
            self.shareName.set_default();
        }
        self.shareName.as_mut().unwrap()
    }

    // Take field
    pub fn take_shareName(&mut self) -> ::std::string::String {
        self.shareName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool readOnly = 3;


    pub fn get_readOnly(&self) -> bool {
        self.readOnly.unwrap_or(false)
    }
    pub fn clear_readOnly(&mut self) {
        self.readOnly = ::std::option::Option::None;
    }

    pub fn has_readOnly(&self) -> bool {
        self.readOnly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readOnly(&mut self, v: bool) {
        self.readOnly = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for AzureFileVolumeSource {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.secretName)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.shareName)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.readOnly = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.secretName.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.shareName.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.readOnly {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.secretName.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.shareName.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.readOnly {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AzureFileVolumeSource {
        AzureFileVolumeSource::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "secretName",
                |m: &AzureFileVolumeSource| { &m.secretName },
                |m: &mut AzureFileVolumeSource| { &mut m.secretName },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "shareName",
                |m: &AzureFileVolumeSource| { &m.shareName },
                |m: &mut AzureFileVolumeSource| { &mut m.shareName },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "readOnly",
                |m: &AzureFileVolumeSource| { &m.readOnly },
                |m: &mut AzureFileVolumeSource| { &mut m.readOnly },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AzureFileVolumeSource>(
                "AzureFileVolumeSource",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AzureFileVolumeSource {
        static instance: ::protobuf::rt::LazyV2<AzureFileVolumeSource> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AzureFileVolumeSource::new)
    }
}

impl ::protobuf::Clear for AzureFileVolumeSource {
    fn clear(&mut self) {
        self.secretName.clear();
        self.shareName.clear();
        self.readOnly = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AzureFileVolumeSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AzureFileVolumeSource {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Binding {
    // message fields
    pub metadata: ::protobuf::SingularPtrField<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta>,
    pub target: ::protobuf::SingularPtrField<ObjectReference>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Binding {
    fn default() -> &'a Binding {
        <Binding as ::protobuf::Message>::default_instance()
    }
}

impl Binding {
    pub fn new() -> Binding {
        ::std::default::Default::default()
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;


    pub fn get_metadata(&self) -> &super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta::new())
    }

    // optional .k8s.io.api.core.v1.ObjectReference target = 2;


    pub fn get_target(&self) -> &ObjectReference {
        self.target.as_ref().unwrap_or_else(|| <ObjectReference as ::protobuf::Message>::default_instance())
    }
    pub fn clear_target(&mut self) {
        self.target.clear();
    }

    pub fn has_target(&self) -> bool {
        self.target.is_some()
    }

    // Param is passed by value, moved
    pub fn set_target(&mut self, v: ObjectReference) {
        self.target = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_target(&mut self) -> &mut ObjectReference {
        if self.target.is_none() {
            self.target.set_default();
        }
        self.target.as_mut().unwrap()
    }

    // Take field
    pub fn take_target(&mut self) -> ObjectReference {
        self.target.take().unwrap_or_else(|| ObjectReference::new())
    }
}

impl ::protobuf::Message for Binding {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.target {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.target)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.target.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.target.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Binding {
        Binding::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta>>(
                "metadata",
                |m: &Binding| { &m.metadata },
                |m: &mut Binding| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ObjectReference>>(
                "target",
                |m: &Binding| { &m.target },
                |m: &mut Binding| { &mut m.target },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Binding>(
                "Binding",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Binding {
        static instance: ::protobuf::rt::LazyV2<Binding> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Binding::new)
    }
}

impl ::protobuf::Clear for Binding {
    fn clear(&mut self) {
        self.metadata.clear();
        self.target.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Binding {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Binding {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CSIPersistentVolumeSource {
    // message fields
    driver: ::protobuf::SingularField<::std::string::String>,
    volumeHandle: ::protobuf::SingularField<::std::string::String>,
    readOnly: ::std::option::Option<bool>,
    fsType: ::protobuf::SingularField<::std::string::String>,
    pub volumeAttributes: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    pub controllerPublishSecretRef: ::protobuf::SingularPtrField<SecretReference>,
    pub nodeStageSecretRef: ::protobuf::SingularPtrField<SecretReference>,
    pub nodePublishSecretRef: ::protobuf::SingularPtrField<SecretReference>,
    pub controllerExpandSecretRef: ::protobuf::SingularPtrField<SecretReference>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CSIPersistentVolumeSource {
    fn default() -> &'a CSIPersistentVolumeSource {
        <CSIPersistentVolumeSource as ::protobuf::Message>::default_instance()
    }
}

impl CSIPersistentVolumeSource {
    pub fn new() -> CSIPersistentVolumeSource {
        ::std::default::Default::default()
    }

    // optional string driver = 1;


    pub fn get_driver(&self) -> &str {
        match self.driver.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_driver(&mut self) {
        self.driver.clear();
    }

    pub fn has_driver(&self) -> bool {
        self.driver.is_some()
    }

    // Param is passed by value, moved
    pub fn set_driver(&mut self, v: ::std::string::String) {
        self.driver = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_driver(&mut self) -> &mut ::std::string::String {
        if self.driver.is_none() {
            self.driver.set_default();
        }
        self.driver.as_mut().unwrap()
    }

    // Take field
    pub fn take_driver(&mut self) -> ::std::string::String {
        self.driver.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string volumeHandle = 2;


    pub fn get_volumeHandle(&self) -> &str {
        match self.volumeHandle.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_volumeHandle(&mut self) {
        self.volumeHandle.clear();
    }

    pub fn has_volumeHandle(&self) -> bool {
        self.volumeHandle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_volumeHandle(&mut self, v: ::std::string::String) {
        self.volumeHandle = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_volumeHandle(&mut self) -> &mut ::std::string::String {
        if self.volumeHandle.is_none() {
            self.volumeHandle.set_default();
        }
        self.volumeHandle.as_mut().unwrap()
    }

    // Take field
    pub fn take_volumeHandle(&mut self) -> ::std::string::String {
        self.volumeHandle.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool readOnly = 3;


    pub fn get_readOnly(&self) -> bool {
        self.readOnly.unwrap_or(false)
    }
    pub fn clear_readOnly(&mut self) {
        self.readOnly = ::std::option::Option::None;
    }

    pub fn has_readOnly(&self) -> bool {
        self.readOnly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readOnly(&mut self, v: bool) {
        self.readOnly = ::std::option::Option::Some(v);
    }

    // optional string fsType = 4;


    pub fn get_fsType(&self) -> &str {
        match self.fsType.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_fsType(&mut self) {
        self.fsType.clear();
    }

    pub fn has_fsType(&self) -> bool {
        self.fsType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fsType(&mut self, v: ::std::string::String) {
        self.fsType = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fsType(&mut self) -> &mut ::std::string::String {
        if self.fsType.is_none() {
            self.fsType.set_default();
        }
        self.fsType.as_mut().unwrap()
    }

    // Take field
    pub fn take_fsType(&mut self) -> ::std::string::String {
        self.fsType.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .k8s.io.api.core.v1.CSIPersistentVolumeSource.VolumeAttributesEntry volumeAttributes = 5;


    pub fn get_volumeAttributes(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.volumeAttributes
    }
    pub fn clear_volumeAttributes(&mut self) {
        self.volumeAttributes.clear();
    }

    // Param is passed by value, moved
    pub fn set_volumeAttributes(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.volumeAttributes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_volumeAttributes(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.volumeAttributes
    }

    // Take field
    pub fn take_volumeAttributes(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.volumeAttributes, ::std::collections::HashMap::new())
    }

    // optional .k8s.io.api.core.v1.SecretReference controllerPublishSecretRef = 6;


    pub fn get_controllerPublishSecretRef(&self) -> &SecretReference {
        self.controllerPublishSecretRef.as_ref().unwrap_or_else(|| <SecretReference as ::protobuf::Message>::default_instance())
    }
    pub fn clear_controllerPublishSecretRef(&mut self) {
        self.controllerPublishSecretRef.clear();
    }

    pub fn has_controllerPublishSecretRef(&self) -> bool {
        self.controllerPublishSecretRef.is_some()
    }

    // Param is passed by value, moved
    pub fn set_controllerPublishSecretRef(&mut self, v: SecretReference) {
        self.controllerPublishSecretRef = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_controllerPublishSecretRef(&mut self) -> &mut SecretReference {
        if self.controllerPublishSecretRef.is_none() {
            self.controllerPublishSecretRef.set_default();
        }
        self.controllerPublishSecretRef.as_mut().unwrap()
    }

    // Take field
    pub fn take_controllerPublishSecretRef(&mut self) -> SecretReference {
        self.controllerPublishSecretRef.take().unwrap_or_else(|| SecretReference::new())
    }

    // optional .k8s.io.api.core.v1.SecretReference nodeStageSecretRef = 7;


    pub fn get_nodeStageSecretRef(&self) -> &SecretReference {
        self.nodeStageSecretRef.as_ref().unwrap_or_else(|| <SecretReference as ::protobuf::Message>::default_instance())
    }
    pub fn clear_nodeStageSecretRef(&mut self) {
        self.nodeStageSecretRef.clear();
    }

    pub fn has_nodeStageSecretRef(&self) -> bool {
        self.nodeStageSecretRef.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nodeStageSecretRef(&mut self, v: SecretReference) {
        self.nodeStageSecretRef = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nodeStageSecretRef(&mut self) -> &mut SecretReference {
        if self.nodeStageSecretRef.is_none() {
            self.nodeStageSecretRef.set_default();
        }
        self.nodeStageSecretRef.as_mut().unwrap()
    }

    // Take field
    pub fn take_nodeStageSecretRef(&mut self) -> SecretReference {
        self.nodeStageSecretRef.take().unwrap_or_else(|| SecretReference::new())
    }

    // optional .k8s.io.api.core.v1.SecretReference nodePublishSecretRef = 8;


    pub fn get_nodePublishSecretRef(&self) -> &SecretReference {
        self.nodePublishSecretRef.as_ref().unwrap_or_else(|| <SecretReference as ::protobuf::Message>::default_instance())
    }
    pub fn clear_nodePublishSecretRef(&mut self) {
        self.nodePublishSecretRef.clear();
    }

    pub fn has_nodePublishSecretRef(&self) -> bool {
        self.nodePublishSecretRef.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nodePublishSecretRef(&mut self, v: SecretReference) {
        self.nodePublishSecretRef = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nodePublishSecretRef(&mut self) -> &mut SecretReference {
        if self.nodePublishSecretRef.is_none() {
            self.nodePublishSecretRef.set_default();
        }
        self.nodePublishSecretRef.as_mut().unwrap()
    }

    // Take field
    pub fn take_nodePublishSecretRef(&mut self) -> SecretReference {
        self.nodePublishSecretRef.take().unwrap_or_else(|| SecretReference::new())
    }

    // optional .k8s.io.api.core.v1.SecretReference controllerExpandSecretRef = 9;


    pub fn get_controllerExpandSecretRef(&self) -> &SecretReference {
        self.controllerExpandSecretRef.as_ref().unwrap_or_else(|| <SecretReference as ::protobuf::Message>::default_instance())
    }
    pub fn clear_controllerExpandSecretRef(&mut self) {
        self.controllerExpandSecretRef.clear();
    }

    pub fn has_controllerExpandSecretRef(&self) -> bool {
        self.controllerExpandSecretRef.is_some()
    }

    // Param is passed by value, moved
    pub fn set_controllerExpandSecretRef(&mut self, v: SecretReference) {
        self.controllerExpandSecretRef = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_controllerExpandSecretRef(&mut self) -> &mut SecretReference {
        if self.controllerExpandSecretRef.is_none() {
            self.controllerExpandSecretRef.set_default();
        }
        self.controllerExpandSecretRef.as_mut().unwrap()
    }

    // Take field
    pub fn take_controllerExpandSecretRef(&mut self) -> SecretReference {
        self.controllerExpandSecretRef.take().unwrap_or_else(|| SecretReference::new())
    }
}

impl ::protobuf::Message for CSIPersistentVolumeSource {
    fn is_initialized(&self) -> bool {
        for v in &self.controllerPublishSecretRef {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.nodeStageSecretRef {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.nodePublishSecretRef {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.controllerExpandSecretRef {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.driver)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.volumeHandle)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.readOnly = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.fsType)?;
                },
                5 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.volumeAttributes)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.controllerPublishSecretRef)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.nodeStageSecretRef)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.nodePublishSecretRef)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.controllerExpandSecretRef)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.driver.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.volumeHandle.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.readOnly {
            my_size += 2;
        }
        if let Some(ref v) = self.fsType.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(5, &self.volumeAttributes);
        if let Some(ref v) = self.controllerPublishSecretRef.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.nodeStageSecretRef.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.nodePublishSecretRef.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.controllerExpandSecretRef.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.driver.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.volumeHandle.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.readOnly {
            os.write_bool(3, v)?;
        }
        if let Some(ref v) = self.fsType.as_ref() {
            os.write_string(4, &v)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(5, &self.volumeAttributes, os)?;
        if let Some(ref v) = self.controllerPublishSecretRef.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.nodeStageSecretRef.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.nodePublishSecretRef.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.controllerExpandSecretRef.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CSIPersistentVolumeSource {
        CSIPersistentVolumeSource::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "driver",
                |m: &CSIPersistentVolumeSource| { &m.driver },
                |m: &mut CSIPersistentVolumeSource| { &mut m.driver },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "volumeHandle",
                |m: &CSIPersistentVolumeSource| { &m.volumeHandle },
                |m: &mut CSIPersistentVolumeSource| { &mut m.volumeHandle },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "readOnly",
                |m: &CSIPersistentVolumeSource| { &m.readOnly },
                |m: &mut CSIPersistentVolumeSource| { &mut m.readOnly },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "fsType",
                |m: &CSIPersistentVolumeSource| { &m.fsType },
                |m: &mut CSIPersistentVolumeSource| { &mut m.fsType },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                "volumeAttributes",
                |m: &CSIPersistentVolumeSource| { &m.volumeAttributes },
                |m: &mut CSIPersistentVolumeSource| { &mut m.volumeAttributes },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SecretReference>>(
                "controllerPublishSecretRef",
                |m: &CSIPersistentVolumeSource| { &m.controllerPublishSecretRef },
                |m: &mut CSIPersistentVolumeSource| { &mut m.controllerPublishSecretRef },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SecretReference>>(
                "nodeStageSecretRef",
                |m: &CSIPersistentVolumeSource| { &m.nodeStageSecretRef },
                |m: &mut CSIPersistentVolumeSource| { &mut m.nodeStageSecretRef },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SecretReference>>(
                "nodePublishSecretRef",
                |m: &CSIPersistentVolumeSource| { &m.nodePublishSecretRef },
                |m: &mut CSIPersistentVolumeSource| { &mut m.nodePublishSecretRef },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SecretReference>>(
                "controllerExpandSecretRef",
                |m: &CSIPersistentVolumeSource| { &m.controllerExpandSecretRef },
                |m: &mut CSIPersistentVolumeSource| { &mut m.controllerExpandSecretRef },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CSIPersistentVolumeSource>(
                "CSIPersistentVolumeSource",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CSIPersistentVolumeSource {
        static instance: ::protobuf::rt::LazyV2<CSIPersistentVolumeSource> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CSIPersistentVolumeSource::new)
    }
}

impl ::protobuf::Clear for CSIPersistentVolumeSource {
    fn clear(&mut self) {
        self.driver.clear();
        self.volumeHandle.clear();
        self.readOnly = ::std::option::Option::None;
        self.fsType.clear();
        self.volumeAttributes.clear();
        self.controllerPublishSecretRef.clear();
        self.nodeStageSecretRef.clear();
        self.nodePublishSecretRef.clear();
        self.controllerExpandSecretRef.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CSIPersistentVolumeSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSIPersistentVolumeSource {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CSIVolumeSource {
    // message fields
    driver: ::protobuf::SingularField<::std::string::String>,
    readOnly: ::std::option::Option<bool>,
    fsType: ::protobuf::SingularField<::std::string::String>,
    pub volumeAttributes: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    pub nodePublishSecretRef: ::protobuf::SingularPtrField<LocalObjectReference>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CSIVolumeSource {
    fn default() -> &'a CSIVolumeSource {
        <CSIVolumeSource as ::protobuf::Message>::default_instance()
    }
}

impl CSIVolumeSource {
    pub fn new() -> CSIVolumeSource {
        ::std::default::Default::default()
    }

    // optional string driver = 1;


    pub fn get_driver(&self) -> &str {
        match self.driver.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_driver(&mut self) {
        self.driver.clear();
    }

    pub fn has_driver(&self) -> bool {
        self.driver.is_some()
    }

    // Param is passed by value, moved
    pub fn set_driver(&mut self, v: ::std::string::String) {
        self.driver = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_driver(&mut self) -> &mut ::std::string::String {
        if self.driver.is_none() {
            self.driver.set_default();
        }
        self.driver.as_mut().unwrap()
    }

    // Take field
    pub fn take_driver(&mut self) -> ::std::string::String {
        self.driver.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool readOnly = 2;


    pub fn get_readOnly(&self) -> bool {
        self.readOnly.unwrap_or(false)
    }
    pub fn clear_readOnly(&mut self) {
        self.readOnly = ::std::option::Option::None;
    }

    pub fn has_readOnly(&self) -> bool {
        self.readOnly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readOnly(&mut self, v: bool) {
        self.readOnly = ::std::option::Option::Some(v);
    }

    // optional string fsType = 3;


    pub fn get_fsType(&self) -> &str {
        match self.fsType.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_fsType(&mut self) {
        self.fsType.clear();
    }

    pub fn has_fsType(&self) -> bool {
        self.fsType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fsType(&mut self, v: ::std::string::String) {
        self.fsType = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fsType(&mut self) -> &mut ::std::string::String {
        if self.fsType.is_none() {
            self.fsType.set_default();
        }
        self.fsType.as_mut().unwrap()
    }

    // Take field
    pub fn take_fsType(&mut self) -> ::std::string::String {
        self.fsType.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .k8s.io.api.core.v1.CSIVolumeSource.VolumeAttributesEntry volumeAttributes = 4;


    pub fn get_volumeAttributes(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.volumeAttributes
    }
    pub fn clear_volumeAttributes(&mut self) {
        self.volumeAttributes.clear();
    }

    // Param is passed by value, moved
    pub fn set_volumeAttributes(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.volumeAttributes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_volumeAttributes(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.volumeAttributes
    }

    // Take field
    pub fn take_volumeAttributes(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.volumeAttributes, ::std::collections::HashMap::new())
    }

    // optional .k8s.io.api.core.v1.LocalObjectReference nodePublishSecretRef = 5;


    pub fn get_nodePublishSecretRef(&self) -> &LocalObjectReference {
        self.nodePublishSecretRef.as_ref().unwrap_or_else(|| <LocalObjectReference as ::protobuf::Message>::default_instance())
    }
    pub fn clear_nodePublishSecretRef(&mut self) {
        self.nodePublishSecretRef.clear();
    }

    pub fn has_nodePublishSecretRef(&self) -> bool {
        self.nodePublishSecretRef.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nodePublishSecretRef(&mut self, v: LocalObjectReference) {
        self.nodePublishSecretRef = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nodePublishSecretRef(&mut self) -> &mut LocalObjectReference {
        if self.nodePublishSecretRef.is_none() {
            self.nodePublishSecretRef.set_default();
        }
        self.nodePublishSecretRef.as_mut().unwrap()
    }

    // Take field
    pub fn take_nodePublishSecretRef(&mut self) -> LocalObjectReference {
        self.nodePublishSecretRef.take().unwrap_or_else(|| LocalObjectReference::new())
    }
}

impl ::protobuf::Message for CSIVolumeSource {
    fn is_initialized(&self) -> bool {
        for v in &self.nodePublishSecretRef {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.driver)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.readOnly = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.fsType)?;
                },
                4 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.volumeAttributes)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.nodePublishSecretRef)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.driver.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.readOnly {
            my_size += 2;
        }
        if let Some(ref v) = self.fsType.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(4, &self.volumeAttributes);
        if let Some(ref v) = self.nodePublishSecretRef.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.driver.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.readOnly {
            os.write_bool(2, v)?;
        }
        if let Some(ref v) = self.fsType.as_ref() {
            os.write_string(3, &v)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(4, &self.volumeAttributes, os)?;
        if let Some(ref v) = self.nodePublishSecretRef.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CSIVolumeSource {
        CSIVolumeSource::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "driver",
                |m: &CSIVolumeSource| { &m.driver },
                |m: &mut CSIVolumeSource| { &mut m.driver },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "readOnly",
                |m: &CSIVolumeSource| { &m.readOnly },
                |m: &mut CSIVolumeSource| { &mut m.readOnly },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "fsType",
                |m: &CSIVolumeSource| { &m.fsType },
                |m: &mut CSIVolumeSource| { &mut m.fsType },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                "volumeAttributes",
                |m: &CSIVolumeSource| { &m.volumeAttributes },
                |m: &mut CSIVolumeSource| { &mut m.volumeAttributes },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LocalObjectReference>>(
                "nodePublishSecretRef",
                |m: &CSIVolumeSource| { &m.nodePublishSecretRef },
                |m: &mut CSIVolumeSource| { &mut m.nodePublishSecretRef },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CSIVolumeSource>(
                "CSIVolumeSource",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CSIVolumeSource {
        static instance: ::protobuf::rt::LazyV2<CSIVolumeSource> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CSIVolumeSource::new)
    }
}

impl ::protobuf::Clear for CSIVolumeSource {
    fn clear(&mut self) {
        self.driver.clear();
        self.readOnly = ::std::option::Option::None;
        self.fsType.clear();
        self.volumeAttributes.clear();
        self.nodePublishSecretRef.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CSIVolumeSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CSIVolumeSource {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Capabilities {
    // message fields
    pub add: ::protobuf::RepeatedField<::std::string::String>,
    pub drop: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Capabilities {
    fn default() -> &'a Capabilities {
        <Capabilities as ::protobuf::Message>::default_instance()
    }
}

impl Capabilities {
    pub fn new() -> Capabilities {
        ::std::default::Default::default()
    }

    // repeated string add = 1;


    pub fn get_add(&self) -> &[::std::string::String] {
        &self.add
    }
    pub fn clear_add(&mut self) {
        self.add.clear();
    }

    // Param is passed by value, moved
    pub fn set_add(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.add = v;
    }

    // Mutable pointer to the field.
    pub fn mut_add(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.add
    }

    // Take field
    pub fn take_add(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.add, ::protobuf::RepeatedField::new())
    }

    // repeated string drop = 2;


    pub fn get_drop(&self) -> &[::std::string::String] {
        &self.drop
    }
    pub fn clear_drop(&mut self) {
        self.drop.clear();
    }

    // Param is passed by value, moved
    pub fn set_drop(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.drop = v;
    }

    // Mutable pointer to the field.
    pub fn mut_drop(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.drop
    }

    // Take field
    pub fn take_drop(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.drop, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Capabilities {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.add)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.drop)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.add {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in &self.drop {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.add {
            os.write_string(1, &v)?;
        };
        for v in &self.drop {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Capabilities {
        Capabilities::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "add",
                |m: &Capabilities| { &m.add },
                |m: &mut Capabilities| { &mut m.add },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "drop",
                |m: &Capabilities| { &m.drop },
                |m: &mut Capabilities| { &mut m.drop },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Capabilities>(
                "Capabilities",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Capabilities {
        static instance: ::protobuf::rt::LazyV2<Capabilities> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Capabilities::new)
    }
}

impl ::protobuf::Clear for Capabilities {
    fn clear(&mut self) {
        self.add.clear();
        self.drop.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Capabilities {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Capabilities {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CephFSPersistentVolumeSource {
    // message fields
    pub monitors: ::protobuf::RepeatedField<::std::string::String>,
    path: ::protobuf::SingularField<::std::string::String>,
    user: ::protobuf::SingularField<::std::string::String>,
    secretFile: ::protobuf::SingularField<::std::string::String>,
    pub secretRef: ::protobuf::SingularPtrField<SecretReference>,
    readOnly: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CephFSPersistentVolumeSource {
    fn default() -> &'a CephFSPersistentVolumeSource {
        <CephFSPersistentVolumeSource as ::protobuf::Message>::default_instance()
    }
}

impl CephFSPersistentVolumeSource {
    pub fn new() -> CephFSPersistentVolumeSource {
        ::std::default::Default::default()
    }

    // repeated string monitors = 1;


    pub fn get_monitors(&self) -> &[::std::string::String] {
        &self.monitors
    }
    pub fn clear_monitors(&mut self) {
        self.monitors.clear();
    }

    // Param is passed by value, moved
    pub fn set_monitors(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.monitors = v;
    }

    // Mutable pointer to the field.
    pub fn mut_monitors(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.monitors
    }

    // Take field
    pub fn take_monitors(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.monitors, ::protobuf::RepeatedField::new())
    }

    // optional string path = 2;


    pub fn get_path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path.set_default();
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string user = 3;


    pub fn get_user(&self) -> &str {
        match self.user.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_user(&mut self) {
        self.user.clear();
    }

    pub fn has_user(&self) -> bool {
        self.user.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user(&mut self, v: ::std::string::String) {
        self.user = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user(&mut self) -> &mut ::std::string::String {
        if self.user.is_none() {
            self.user.set_default();
        }
        self.user.as_mut().unwrap()
    }

    // Take field
    pub fn take_user(&mut self) -> ::std::string::String {
        self.user.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string secretFile = 4;


    pub fn get_secretFile(&self) -> &str {
        match self.secretFile.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_secretFile(&mut self) {
        self.secretFile.clear();
    }

    pub fn has_secretFile(&self) -> bool {
        self.secretFile.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secretFile(&mut self, v: ::std::string::String) {
        self.secretFile = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_secretFile(&mut self) -> &mut ::std::string::String {
        if self.secretFile.is_none() {
            self.secretFile.set_default();
        }
        self.secretFile.as_mut().unwrap()
    }

    // Take field
    pub fn take_secretFile(&mut self) -> ::std::string::String {
        self.secretFile.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .k8s.io.api.core.v1.SecretReference secretRef = 5;


    pub fn get_secretRef(&self) -> &SecretReference {
        self.secretRef.as_ref().unwrap_or_else(|| <SecretReference as ::protobuf::Message>::default_instance())
    }
    pub fn clear_secretRef(&mut self) {
        self.secretRef.clear();
    }

    pub fn has_secretRef(&self) -> bool {
        self.secretRef.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secretRef(&mut self, v: SecretReference) {
        self.secretRef = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_secretRef(&mut self) -> &mut SecretReference {
        if self.secretRef.is_none() {
            self.secretRef.set_default();
        }
        self.secretRef.as_mut().unwrap()
    }

    // Take field
    pub fn take_secretRef(&mut self) -> SecretReference {
        self.secretRef.take().unwrap_or_else(|| SecretReference::new())
    }

    // optional bool readOnly = 6;


    pub fn get_readOnly(&self) -> bool {
        self.readOnly.unwrap_or(false)
    }
    pub fn clear_readOnly(&mut self) {
        self.readOnly = ::std::option::Option::None;
    }

    pub fn has_readOnly(&self) -> bool {
        self.readOnly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readOnly(&mut self, v: bool) {
        self.readOnly = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CephFSPersistentVolumeSource {
    fn is_initialized(&self) -> bool {
        for v in &self.secretRef {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.monitors)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.path)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.user)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.secretFile)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.secretRef)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.readOnly = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.monitors {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if let Some(ref v) = self.path.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.user.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.secretFile.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.secretRef.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.readOnly {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.monitors {
            os.write_string(1, &v)?;
        };
        if let Some(ref v) = self.path.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.user.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.secretFile.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.secretRef.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.readOnly {
            os.write_bool(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CephFSPersistentVolumeSource {
        CephFSPersistentVolumeSource::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "monitors",
                |m: &CephFSPersistentVolumeSource| { &m.monitors },
                |m: &mut CephFSPersistentVolumeSource| { &mut m.monitors },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "path",
                |m: &CephFSPersistentVolumeSource| { &m.path },
                |m: &mut CephFSPersistentVolumeSource| { &mut m.path },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "user",
                |m: &CephFSPersistentVolumeSource| { &m.user },
                |m: &mut CephFSPersistentVolumeSource| { &mut m.user },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "secretFile",
                |m: &CephFSPersistentVolumeSource| { &m.secretFile },
                |m: &mut CephFSPersistentVolumeSource| { &mut m.secretFile },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SecretReference>>(
                "secretRef",
                |m: &CephFSPersistentVolumeSource| { &m.secretRef },
                |m: &mut CephFSPersistentVolumeSource| { &mut m.secretRef },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "readOnly",
                |m: &CephFSPersistentVolumeSource| { &m.readOnly },
                |m: &mut CephFSPersistentVolumeSource| { &mut m.readOnly },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CephFSPersistentVolumeSource>(
                "CephFSPersistentVolumeSource",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CephFSPersistentVolumeSource {
        static instance: ::protobuf::rt::LazyV2<CephFSPersistentVolumeSource> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CephFSPersistentVolumeSource::new)
    }
}

impl ::protobuf::Clear for CephFSPersistentVolumeSource {
    fn clear(&mut self) {
        self.monitors.clear();
        self.path.clear();
        self.user.clear();
        self.secretFile.clear();
        self.secretRef.clear();
        self.readOnly = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CephFSPersistentVolumeSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CephFSPersistentVolumeSource {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CephFSVolumeSource {
    // message fields
    pub monitors: ::protobuf::RepeatedField<::std::string::String>,
    path: ::protobuf::SingularField<::std::string::String>,
    user: ::protobuf::SingularField<::std::string::String>,
    secretFile: ::protobuf::SingularField<::std::string::String>,
    pub secretRef: ::protobuf::SingularPtrField<LocalObjectReference>,
    readOnly: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CephFSVolumeSource {
    fn default() -> &'a CephFSVolumeSource {
        <CephFSVolumeSource as ::protobuf::Message>::default_instance()
    }
}

impl CephFSVolumeSource {
    pub fn new() -> CephFSVolumeSource {
        ::std::default::Default::default()
    }

    // repeated string monitors = 1;


    pub fn get_monitors(&self) -> &[::std::string::String] {
        &self.monitors
    }
    pub fn clear_monitors(&mut self) {
        self.monitors.clear();
    }

    // Param is passed by value, moved
    pub fn set_monitors(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.monitors = v;
    }

    // Mutable pointer to the field.
    pub fn mut_monitors(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.monitors
    }

    // Take field
    pub fn take_monitors(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.monitors, ::protobuf::RepeatedField::new())
    }

    // optional string path = 2;


    pub fn get_path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path.set_default();
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string user = 3;


    pub fn get_user(&self) -> &str {
        match self.user.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_user(&mut self) {
        self.user.clear();
    }

    pub fn has_user(&self) -> bool {
        self.user.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user(&mut self, v: ::std::string::String) {
        self.user = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user(&mut self) -> &mut ::std::string::String {
        if self.user.is_none() {
            self.user.set_default();
        }
        self.user.as_mut().unwrap()
    }

    // Take field
    pub fn take_user(&mut self) -> ::std::string::String {
        self.user.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string secretFile = 4;


    pub fn get_secretFile(&self) -> &str {
        match self.secretFile.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_secretFile(&mut self) {
        self.secretFile.clear();
    }

    pub fn has_secretFile(&self) -> bool {
        self.secretFile.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secretFile(&mut self, v: ::std::string::String) {
        self.secretFile = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_secretFile(&mut self) -> &mut ::std::string::String {
        if self.secretFile.is_none() {
            self.secretFile.set_default();
        }
        self.secretFile.as_mut().unwrap()
    }

    // Take field
    pub fn take_secretFile(&mut self) -> ::std::string::String {
        self.secretFile.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .k8s.io.api.core.v1.LocalObjectReference secretRef = 5;


    pub fn get_secretRef(&self) -> &LocalObjectReference {
        self.secretRef.as_ref().unwrap_or_else(|| <LocalObjectReference as ::protobuf::Message>::default_instance())
    }
    pub fn clear_secretRef(&mut self) {
        self.secretRef.clear();
    }

    pub fn has_secretRef(&self) -> bool {
        self.secretRef.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secretRef(&mut self, v: LocalObjectReference) {
        self.secretRef = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_secretRef(&mut self) -> &mut LocalObjectReference {
        if self.secretRef.is_none() {
            self.secretRef.set_default();
        }
        self.secretRef.as_mut().unwrap()
    }

    // Take field
    pub fn take_secretRef(&mut self) -> LocalObjectReference {
        self.secretRef.take().unwrap_or_else(|| LocalObjectReference::new())
    }

    // optional bool readOnly = 6;


    pub fn get_readOnly(&self) -> bool {
        self.readOnly.unwrap_or(false)
    }
    pub fn clear_readOnly(&mut self) {
        self.readOnly = ::std::option::Option::None;
    }

    pub fn has_readOnly(&self) -> bool {
        self.readOnly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readOnly(&mut self, v: bool) {
        self.readOnly = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for CephFSVolumeSource {
    fn is_initialized(&self) -> bool {
        for v in &self.secretRef {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.monitors)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.path)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.user)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.secretFile)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.secretRef)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.readOnly = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.monitors {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if let Some(ref v) = self.path.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.user.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.secretFile.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.secretRef.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.readOnly {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.monitors {
            os.write_string(1, &v)?;
        };
        if let Some(ref v) = self.path.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.user.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.secretFile.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.secretRef.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.readOnly {
            os.write_bool(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CephFSVolumeSource {
        CephFSVolumeSource::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "monitors",
                |m: &CephFSVolumeSource| { &m.monitors },
                |m: &mut CephFSVolumeSource| { &mut m.monitors },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "path",
                |m: &CephFSVolumeSource| { &m.path },
                |m: &mut CephFSVolumeSource| { &mut m.path },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "user",
                |m: &CephFSVolumeSource| { &m.user },
                |m: &mut CephFSVolumeSource| { &mut m.user },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "secretFile",
                |m: &CephFSVolumeSource| { &m.secretFile },
                |m: &mut CephFSVolumeSource| { &mut m.secretFile },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LocalObjectReference>>(
                "secretRef",
                |m: &CephFSVolumeSource| { &m.secretRef },
                |m: &mut CephFSVolumeSource| { &mut m.secretRef },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "readOnly",
                |m: &CephFSVolumeSource| { &m.readOnly },
                |m: &mut CephFSVolumeSource| { &mut m.readOnly },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CephFSVolumeSource>(
                "CephFSVolumeSource",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CephFSVolumeSource {
        static instance: ::protobuf::rt::LazyV2<CephFSVolumeSource> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CephFSVolumeSource::new)
    }
}

impl ::protobuf::Clear for CephFSVolumeSource {
    fn clear(&mut self) {
        self.monitors.clear();
        self.path.clear();
        self.user.clear();
        self.secretFile.clear();
        self.secretRef.clear();
        self.readOnly = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CephFSVolumeSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CephFSVolumeSource {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CinderPersistentVolumeSource {
    // message fields
    volumeID: ::protobuf::SingularField<::std::string::String>,
    fsType: ::protobuf::SingularField<::std::string::String>,
    readOnly: ::std::option::Option<bool>,
    pub secretRef: ::protobuf::SingularPtrField<SecretReference>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CinderPersistentVolumeSource {
    fn default() -> &'a CinderPersistentVolumeSource {
        <CinderPersistentVolumeSource as ::protobuf::Message>::default_instance()
    }
}

impl CinderPersistentVolumeSource {
    pub fn new() -> CinderPersistentVolumeSource {
        ::std::default::Default::default()
    }

    // optional string volumeID = 1;


    pub fn get_volumeID(&self) -> &str {
        match self.volumeID.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_volumeID(&mut self) {
        self.volumeID.clear();
    }

    pub fn has_volumeID(&self) -> bool {
        self.volumeID.is_some()
    }

    // Param is passed by value, moved
    pub fn set_volumeID(&mut self, v: ::std::string::String) {
        self.volumeID = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_volumeID(&mut self) -> &mut ::std::string::String {
        if self.volumeID.is_none() {
            self.volumeID.set_default();
        }
        self.volumeID.as_mut().unwrap()
    }

    // Take field
    pub fn take_volumeID(&mut self) -> ::std::string::String {
        self.volumeID.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string fsType = 2;


    pub fn get_fsType(&self) -> &str {
        match self.fsType.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_fsType(&mut self) {
        self.fsType.clear();
    }

    pub fn has_fsType(&self) -> bool {
        self.fsType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fsType(&mut self, v: ::std::string::String) {
        self.fsType = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fsType(&mut self) -> &mut ::std::string::String {
        if self.fsType.is_none() {
            self.fsType.set_default();
        }
        self.fsType.as_mut().unwrap()
    }

    // Take field
    pub fn take_fsType(&mut self) -> ::std::string::String {
        self.fsType.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool readOnly = 3;


    pub fn get_readOnly(&self) -> bool {
        self.readOnly.unwrap_or(false)
    }
    pub fn clear_readOnly(&mut self) {
        self.readOnly = ::std::option::Option::None;
    }

    pub fn has_readOnly(&self) -> bool {
        self.readOnly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readOnly(&mut self, v: bool) {
        self.readOnly = ::std::option::Option::Some(v);
    }

    // optional .k8s.io.api.core.v1.SecretReference secretRef = 4;


    pub fn get_secretRef(&self) -> &SecretReference {
        self.secretRef.as_ref().unwrap_or_else(|| <SecretReference as ::protobuf::Message>::default_instance())
    }
    pub fn clear_secretRef(&mut self) {
        self.secretRef.clear();
    }

    pub fn has_secretRef(&self) -> bool {
        self.secretRef.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secretRef(&mut self, v: SecretReference) {
        self.secretRef = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_secretRef(&mut self) -> &mut SecretReference {
        if self.secretRef.is_none() {
            self.secretRef.set_default();
        }
        self.secretRef.as_mut().unwrap()
    }

    // Take field
    pub fn take_secretRef(&mut self) -> SecretReference {
        self.secretRef.take().unwrap_or_else(|| SecretReference::new())
    }
}

impl ::protobuf::Message for CinderPersistentVolumeSource {
    fn is_initialized(&self) -> bool {
        for v in &self.secretRef {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.volumeID)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.fsType)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.readOnly = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.secretRef)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.volumeID.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.fsType.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.readOnly {
            my_size += 2;
        }
        if let Some(ref v) = self.secretRef.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.volumeID.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.fsType.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.readOnly {
            os.write_bool(3, v)?;
        }
        if let Some(ref v) = self.secretRef.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CinderPersistentVolumeSource {
        CinderPersistentVolumeSource::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "volumeID",
                |m: &CinderPersistentVolumeSource| { &m.volumeID },
                |m: &mut CinderPersistentVolumeSource| { &mut m.volumeID },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "fsType",
                |m: &CinderPersistentVolumeSource| { &m.fsType },
                |m: &mut CinderPersistentVolumeSource| { &mut m.fsType },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "readOnly",
                |m: &CinderPersistentVolumeSource| { &m.readOnly },
                |m: &mut CinderPersistentVolumeSource| { &mut m.readOnly },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SecretReference>>(
                "secretRef",
                |m: &CinderPersistentVolumeSource| { &m.secretRef },
                |m: &mut CinderPersistentVolumeSource| { &mut m.secretRef },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CinderPersistentVolumeSource>(
                "CinderPersistentVolumeSource",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CinderPersistentVolumeSource {
        static instance: ::protobuf::rt::LazyV2<CinderPersistentVolumeSource> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CinderPersistentVolumeSource::new)
    }
}

impl ::protobuf::Clear for CinderPersistentVolumeSource {
    fn clear(&mut self) {
        self.volumeID.clear();
        self.fsType.clear();
        self.readOnly = ::std::option::Option::None;
        self.secretRef.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CinderPersistentVolumeSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CinderPersistentVolumeSource {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CinderVolumeSource {
    // message fields
    volumeID: ::protobuf::SingularField<::std::string::String>,
    fsType: ::protobuf::SingularField<::std::string::String>,
    readOnly: ::std::option::Option<bool>,
    pub secretRef: ::protobuf::SingularPtrField<LocalObjectReference>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CinderVolumeSource {
    fn default() -> &'a CinderVolumeSource {
        <CinderVolumeSource as ::protobuf::Message>::default_instance()
    }
}

impl CinderVolumeSource {
    pub fn new() -> CinderVolumeSource {
        ::std::default::Default::default()
    }

    // optional string volumeID = 1;


    pub fn get_volumeID(&self) -> &str {
        match self.volumeID.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_volumeID(&mut self) {
        self.volumeID.clear();
    }

    pub fn has_volumeID(&self) -> bool {
        self.volumeID.is_some()
    }

    // Param is passed by value, moved
    pub fn set_volumeID(&mut self, v: ::std::string::String) {
        self.volumeID = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_volumeID(&mut self) -> &mut ::std::string::String {
        if self.volumeID.is_none() {
            self.volumeID.set_default();
        }
        self.volumeID.as_mut().unwrap()
    }

    // Take field
    pub fn take_volumeID(&mut self) -> ::std::string::String {
        self.volumeID.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string fsType = 2;


    pub fn get_fsType(&self) -> &str {
        match self.fsType.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_fsType(&mut self) {
        self.fsType.clear();
    }

    pub fn has_fsType(&self) -> bool {
        self.fsType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fsType(&mut self, v: ::std::string::String) {
        self.fsType = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fsType(&mut self) -> &mut ::std::string::String {
        if self.fsType.is_none() {
            self.fsType.set_default();
        }
        self.fsType.as_mut().unwrap()
    }

    // Take field
    pub fn take_fsType(&mut self) -> ::std::string::String {
        self.fsType.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool readOnly = 3;


    pub fn get_readOnly(&self) -> bool {
        self.readOnly.unwrap_or(false)
    }
    pub fn clear_readOnly(&mut self) {
        self.readOnly = ::std::option::Option::None;
    }

    pub fn has_readOnly(&self) -> bool {
        self.readOnly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readOnly(&mut self, v: bool) {
        self.readOnly = ::std::option::Option::Some(v);
    }

    // optional .k8s.io.api.core.v1.LocalObjectReference secretRef = 4;


    pub fn get_secretRef(&self) -> &LocalObjectReference {
        self.secretRef.as_ref().unwrap_or_else(|| <LocalObjectReference as ::protobuf::Message>::default_instance())
    }
    pub fn clear_secretRef(&mut self) {
        self.secretRef.clear();
    }

    pub fn has_secretRef(&self) -> bool {
        self.secretRef.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secretRef(&mut self, v: LocalObjectReference) {
        self.secretRef = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_secretRef(&mut self) -> &mut LocalObjectReference {
        if self.secretRef.is_none() {
            self.secretRef.set_default();
        }
        self.secretRef.as_mut().unwrap()
    }

    // Take field
    pub fn take_secretRef(&mut self) -> LocalObjectReference {
        self.secretRef.take().unwrap_or_else(|| LocalObjectReference::new())
    }
}

impl ::protobuf::Message for CinderVolumeSource {
    fn is_initialized(&self) -> bool {
        for v in &self.secretRef {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.volumeID)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.fsType)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.readOnly = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.secretRef)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.volumeID.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.fsType.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.readOnly {
            my_size += 2;
        }
        if let Some(ref v) = self.secretRef.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.volumeID.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.fsType.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.readOnly {
            os.write_bool(3, v)?;
        }
        if let Some(ref v) = self.secretRef.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CinderVolumeSource {
        CinderVolumeSource::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "volumeID",
                |m: &CinderVolumeSource| { &m.volumeID },
                |m: &mut CinderVolumeSource| { &mut m.volumeID },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "fsType",
                |m: &CinderVolumeSource| { &m.fsType },
                |m: &mut CinderVolumeSource| { &mut m.fsType },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "readOnly",
                |m: &CinderVolumeSource| { &m.readOnly },
                |m: &mut CinderVolumeSource| { &mut m.readOnly },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LocalObjectReference>>(
                "secretRef",
                |m: &CinderVolumeSource| { &m.secretRef },
                |m: &mut CinderVolumeSource| { &mut m.secretRef },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CinderVolumeSource>(
                "CinderVolumeSource",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CinderVolumeSource {
        static instance: ::protobuf::rt::LazyV2<CinderVolumeSource> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CinderVolumeSource::new)
    }
}

impl ::protobuf::Clear for CinderVolumeSource {
    fn clear(&mut self) {
        self.volumeID.clear();
        self.fsType.clear();
        self.readOnly = ::std::option::Option::None;
        self.secretRef.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CinderVolumeSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CinderVolumeSource {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ClientIPConfig {
    // message fields
    timeoutSeconds: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ClientIPConfig {
    fn default() -> &'a ClientIPConfig {
        <ClientIPConfig as ::protobuf::Message>::default_instance()
    }
}

impl ClientIPConfig {
    pub fn new() -> ClientIPConfig {
        ::std::default::Default::default()
    }

    // optional int32 timeoutSeconds = 1;


    pub fn get_timeoutSeconds(&self) -> i32 {
        self.timeoutSeconds.unwrap_or(0)
    }
    pub fn clear_timeoutSeconds(&mut self) {
        self.timeoutSeconds = ::std::option::Option::None;
    }

    pub fn has_timeoutSeconds(&self) -> bool {
        self.timeoutSeconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timeoutSeconds(&mut self, v: i32) {
        self.timeoutSeconds = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ClientIPConfig {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.timeoutSeconds = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.timeoutSeconds {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.timeoutSeconds {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ClientIPConfig {
        ClientIPConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "timeoutSeconds",
                |m: &ClientIPConfig| { &m.timeoutSeconds },
                |m: &mut ClientIPConfig| { &mut m.timeoutSeconds },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ClientIPConfig>(
                "ClientIPConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ClientIPConfig {
        static instance: ::protobuf::rt::LazyV2<ClientIPConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ClientIPConfig::new)
    }
}

impl ::protobuf::Clear for ClientIPConfig {
    fn clear(&mut self) {
        self.timeoutSeconds = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ClientIPConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClientIPConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ComponentCondition {
    // message fields
    field_type: ::protobuf::SingularField<::std::string::String>,
    status: ::protobuf::SingularField<::std::string::String>,
    message: ::protobuf::SingularField<::std::string::String>,
    error: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ComponentCondition {
    fn default() -> &'a ComponentCondition {
        <ComponentCondition as ::protobuf::Message>::default_instance()
    }
}

impl ComponentCondition {
    pub fn new() -> ComponentCondition {
        ::std::default::Default::default()
    }

    // optional string type = 1;


    pub fn get_field_type(&self) -> &str {
        match self.field_type.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ::std::string::String) {
        self.field_type = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut ::std::string::String {
        if self.field_type.is_none() {
            self.field_type.set_default();
        }
        self.field_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_field_type(&mut self) -> ::std::string::String {
        self.field_type.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string status = 2;


    pub fn get_status(&self) -> &str {
        match self.status.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: ::std::string::String) {
        self.status = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut ::std::string::String {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> ::std::string::String {
        self.status.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string message = 3;


    pub fn get_message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string error = 4;


    pub fn get_error(&self) -> &str {
        match self.error.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: ::std::string::String) {
        self.error = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut ::std::string::String {
        if self.error.is_none() {
            self.error.set_default();
        }
        self.error.as_mut().unwrap()
    }

    // Take field
    pub fn take_error(&mut self) -> ::std::string::String {
        self.error.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for ComponentCondition {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.field_type)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.status)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.message)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.error)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.field_type.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.status.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.error.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.field_type.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.status.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.message.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.error.as_ref() {
            os.write_string(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ComponentCondition {
        ComponentCondition::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "type",
                |m: &ComponentCondition| { &m.field_type },
                |m: &mut ComponentCondition| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "status",
                |m: &ComponentCondition| { &m.status },
                |m: &mut ComponentCondition| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "message",
                |m: &ComponentCondition| { &m.message },
                |m: &mut ComponentCondition| { &mut m.message },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "error",
                |m: &ComponentCondition| { &m.error },
                |m: &mut ComponentCondition| { &mut m.error },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ComponentCondition>(
                "ComponentCondition",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ComponentCondition {
        static instance: ::protobuf::rt::LazyV2<ComponentCondition> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ComponentCondition::new)
    }
}

impl ::protobuf::Clear for ComponentCondition {
    fn clear(&mut self) {
        self.field_type.clear();
        self.status.clear();
        self.message.clear();
        self.error.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ComponentCondition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ComponentCondition {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ComponentStatus {
    // message fields
    pub metadata: ::protobuf::SingularPtrField<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta>,
    pub conditions: ::protobuf::RepeatedField<ComponentCondition>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ComponentStatus {
    fn default() -> &'a ComponentStatus {
        <ComponentStatus as ::protobuf::Message>::default_instance()
    }
}

impl ComponentStatus {
    pub fn new() -> ComponentStatus {
        ::std::default::Default::default()
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;


    pub fn get_metadata(&self) -> &super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta::new())
    }

    // repeated .k8s.io.api.core.v1.ComponentCondition conditions = 2;


    pub fn get_conditions(&self) -> &[ComponentCondition] {
        &self.conditions
    }
    pub fn clear_conditions(&mut self) {
        self.conditions.clear();
    }

    // Param is passed by value, moved
    pub fn set_conditions(&mut self, v: ::protobuf::RepeatedField<ComponentCondition>) {
        self.conditions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_conditions(&mut self) -> &mut ::protobuf::RepeatedField<ComponentCondition> {
        &mut self.conditions
    }

    // Take field
    pub fn take_conditions(&mut self) -> ::protobuf::RepeatedField<ComponentCondition> {
        ::std::mem::replace(&mut self.conditions, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ComponentStatus {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.conditions {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.conditions)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.conditions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.conditions {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ComponentStatus {
        ComponentStatus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta>>(
                "metadata",
                |m: &ComponentStatus| { &m.metadata },
                |m: &mut ComponentStatus| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ComponentCondition>>(
                "conditions",
                |m: &ComponentStatus| { &m.conditions },
                |m: &mut ComponentStatus| { &mut m.conditions },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ComponentStatus>(
                "ComponentStatus",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ComponentStatus {
        static instance: ::protobuf::rt::LazyV2<ComponentStatus> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ComponentStatus::new)
    }
}

impl ::protobuf::Clear for ComponentStatus {
    fn clear(&mut self) {
        self.metadata.clear();
        self.conditions.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ComponentStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ComponentStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ComponentStatusList {
    // message fields
    pub metadata: ::protobuf::SingularPtrField<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta>,
    pub items: ::protobuf::RepeatedField<ComponentStatus>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ComponentStatusList {
    fn default() -> &'a ComponentStatusList {
        <ComponentStatusList as ::protobuf::Message>::default_instance()
    }
}

impl ComponentStatusList {
    pub fn new() -> ComponentStatusList {
        ::std::default::Default::default()
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;


    pub fn get_metadata(&self) -> &super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta {
        self.metadata.take().unwrap_or_else(|| super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta::new())
    }

    // repeated .k8s.io.api.core.v1.ComponentStatus items = 2;


    pub fn get_items(&self) -> &[ComponentStatus] {
        &self.items
    }
    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::protobuf::RepeatedField<ComponentStatus>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::protobuf::RepeatedField<ComponentStatus> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::protobuf::RepeatedField<ComponentStatus> {
        ::std::mem::replace(&mut self.items, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ComponentStatusList {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.items {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.items)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.items {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ComponentStatusList {
        ComponentStatusList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta>>(
                "metadata",
                |m: &ComponentStatusList| { &m.metadata },
                |m: &mut ComponentStatusList| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ComponentStatus>>(
                "items",
                |m: &ComponentStatusList| { &m.items },
                |m: &mut ComponentStatusList| { &mut m.items },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ComponentStatusList>(
                "ComponentStatusList",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ComponentStatusList {
        static instance: ::protobuf::rt::LazyV2<ComponentStatusList> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ComponentStatusList::new)
    }
}

impl ::protobuf::Clear for ComponentStatusList {
    fn clear(&mut self) {
        self.metadata.clear();
        self.items.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ComponentStatusList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ComponentStatusList {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ConfigMap {
    // message fields
    pub metadata: ::protobuf::SingularPtrField<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta>,
    immutable: ::std::option::Option<bool>,
    pub data: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    pub binaryData: ::std::collections::HashMap<::std::string::String, ::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ConfigMap {
    fn default() -> &'a ConfigMap {
        <ConfigMap as ::protobuf::Message>::default_instance()
    }
}

impl ConfigMap {
    pub fn new() -> ConfigMap {
        ::std::default::Default::default()
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;


    pub fn get_metadata(&self) -> &super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta::new())
    }

    // optional bool immutable = 4;


    pub fn get_immutable(&self) -> bool {
        self.immutable.unwrap_or(false)
    }
    pub fn clear_immutable(&mut self) {
        self.immutable = ::std::option::Option::None;
    }

    pub fn has_immutable(&self) -> bool {
        self.immutable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_immutable(&mut self, v: bool) {
        self.immutable = ::std::option::Option::Some(v);
    }

    // repeated .k8s.io.api.core.v1.ConfigMap.DataEntry data = 2;


    pub fn get_data(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    pub fn mut_data(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.data, ::std::collections::HashMap::new())
    }

    // repeated .k8s.io.api.core.v1.ConfigMap.BinaryDataEntry binaryData = 3;


    pub fn get_binaryData(&self) -> &::std::collections::HashMap<::std::string::String, ::std::vec::Vec<u8>> {
        &self.binaryData
    }
    pub fn clear_binaryData(&mut self) {
        self.binaryData.clear();
    }

    // Param is passed by value, moved
    pub fn set_binaryData(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::vec::Vec<u8>>) {
        self.binaryData = v;
    }

    // Mutable pointer to the field.
    pub fn mut_binaryData(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::vec::Vec<u8>> {
        &mut self.binaryData
    }

    // Take field
    pub fn take_binaryData(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.binaryData, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for ConfigMap {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.immutable = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.data)?;
                },
                3 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeBytes>(wire_type, is, &mut self.binaryData)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.immutable {
            my_size += 2;
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(2, &self.data);
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeBytes>(3, &self.binaryData);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.immutable {
            os.write_bool(4, v)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(2, &self.data, os)?;
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeBytes>(3, &self.binaryData, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConfigMap {
        ConfigMap::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta>>(
                "metadata",
                |m: &ConfigMap| { &m.metadata },
                |m: &mut ConfigMap| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "immutable",
                |m: &ConfigMap| { &m.immutable },
                |m: &mut ConfigMap| { &mut m.immutable },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                "data",
                |m: &ConfigMap| { &m.data },
                |m: &mut ConfigMap| { &mut m.data },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeBytes>(
                "binaryData",
                |m: &ConfigMap| { &m.binaryData },
                |m: &mut ConfigMap| { &mut m.binaryData },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ConfigMap>(
                "ConfigMap",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ConfigMap {
        static instance: ::protobuf::rt::LazyV2<ConfigMap> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ConfigMap::new)
    }
}

impl ::protobuf::Clear for ConfigMap {
    fn clear(&mut self) {
        self.metadata.clear();
        self.immutable = ::std::option::Option::None;
        self.data.clear();
        self.binaryData.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConfigMap {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConfigMap {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ConfigMapEnvSource {
    // message fields
    pub localObjectReference: ::protobuf::SingularPtrField<LocalObjectReference>,
    optional: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ConfigMapEnvSource {
    fn default() -> &'a ConfigMapEnvSource {
        <ConfigMapEnvSource as ::protobuf::Message>::default_instance()
    }
}

impl ConfigMapEnvSource {
    pub fn new() -> ConfigMapEnvSource {
        ::std::default::Default::default()
    }

    // optional .k8s.io.api.core.v1.LocalObjectReference localObjectReference = 1;


    pub fn get_localObjectReference(&self) -> &LocalObjectReference {
        self.localObjectReference.as_ref().unwrap_or_else(|| <LocalObjectReference as ::protobuf::Message>::default_instance())
    }
    pub fn clear_localObjectReference(&mut self) {
        self.localObjectReference.clear();
    }

    pub fn has_localObjectReference(&self) -> bool {
        self.localObjectReference.is_some()
    }

    // Param is passed by value, moved
    pub fn set_localObjectReference(&mut self, v: LocalObjectReference) {
        self.localObjectReference = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_localObjectReference(&mut self) -> &mut LocalObjectReference {
        if self.localObjectReference.is_none() {
            self.localObjectReference.set_default();
        }
        self.localObjectReference.as_mut().unwrap()
    }

    // Take field
    pub fn take_localObjectReference(&mut self) -> LocalObjectReference {
        self.localObjectReference.take().unwrap_or_else(|| LocalObjectReference::new())
    }

    // optional bool optional = 2;


    pub fn get_optional(&self) -> bool {
        self.optional.unwrap_or(false)
    }
    pub fn clear_optional(&mut self) {
        self.optional = ::std::option::Option::None;
    }

    pub fn has_optional(&self) -> bool {
        self.optional.is_some()
    }

    // Param is passed by value, moved
    pub fn set_optional(&mut self, v: bool) {
        self.optional = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ConfigMapEnvSource {
    fn is_initialized(&self) -> bool {
        for v in &self.localObjectReference {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.localObjectReference)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.optional = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.localObjectReference.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.optional {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.localObjectReference.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.optional {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConfigMapEnvSource {
        ConfigMapEnvSource::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LocalObjectReference>>(
                "localObjectReference",
                |m: &ConfigMapEnvSource| { &m.localObjectReference },
                |m: &mut ConfigMapEnvSource| { &mut m.localObjectReference },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "optional",
                |m: &ConfigMapEnvSource| { &m.optional },
                |m: &mut ConfigMapEnvSource| { &mut m.optional },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ConfigMapEnvSource>(
                "ConfigMapEnvSource",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ConfigMapEnvSource {
        static instance: ::protobuf::rt::LazyV2<ConfigMapEnvSource> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ConfigMapEnvSource::new)
    }
}

impl ::protobuf::Clear for ConfigMapEnvSource {
    fn clear(&mut self) {
        self.localObjectReference.clear();
        self.optional = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConfigMapEnvSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConfigMapEnvSource {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ConfigMapKeySelector {
    // message fields
    pub localObjectReference: ::protobuf::SingularPtrField<LocalObjectReference>,
    key: ::protobuf::SingularField<::std::string::String>,
    optional: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ConfigMapKeySelector {
    fn default() -> &'a ConfigMapKeySelector {
        <ConfigMapKeySelector as ::protobuf::Message>::default_instance()
    }
}

impl ConfigMapKeySelector {
    pub fn new() -> ConfigMapKeySelector {
        ::std::default::Default::default()
    }

    // optional .k8s.io.api.core.v1.LocalObjectReference localObjectReference = 1;


    pub fn get_localObjectReference(&self) -> &LocalObjectReference {
        self.localObjectReference.as_ref().unwrap_or_else(|| <LocalObjectReference as ::protobuf::Message>::default_instance())
    }
    pub fn clear_localObjectReference(&mut self) {
        self.localObjectReference.clear();
    }

    pub fn has_localObjectReference(&self) -> bool {
        self.localObjectReference.is_some()
    }

    // Param is passed by value, moved
    pub fn set_localObjectReference(&mut self, v: LocalObjectReference) {
        self.localObjectReference = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_localObjectReference(&mut self) -> &mut LocalObjectReference {
        if self.localObjectReference.is_none() {
            self.localObjectReference.set_default();
        }
        self.localObjectReference.as_mut().unwrap()
    }

    // Take field
    pub fn take_localObjectReference(&mut self) -> LocalObjectReference {
        self.localObjectReference.take().unwrap_or_else(|| LocalObjectReference::new())
    }

    // optional string key = 2;


    pub fn get_key(&self) -> &str {
        match self.key.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        if self.key.is_none() {
            self.key.set_default();
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        self.key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool optional = 3;


    pub fn get_optional(&self) -> bool {
        self.optional.unwrap_or(false)
    }
    pub fn clear_optional(&mut self) {
        self.optional = ::std::option::Option::None;
    }

    pub fn has_optional(&self) -> bool {
        self.optional.is_some()
    }

    // Param is passed by value, moved
    pub fn set_optional(&mut self, v: bool) {
        self.optional = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ConfigMapKeySelector {
    fn is_initialized(&self) -> bool {
        for v in &self.localObjectReference {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.localObjectReference)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.key)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.optional = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.localObjectReference.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.key.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.optional {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.localObjectReference.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.key.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.optional {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConfigMapKeySelector {
        ConfigMapKeySelector::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LocalObjectReference>>(
                "localObjectReference",
                |m: &ConfigMapKeySelector| { &m.localObjectReference },
                |m: &mut ConfigMapKeySelector| { &mut m.localObjectReference },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "key",
                |m: &ConfigMapKeySelector| { &m.key },
                |m: &mut ConfigMapKeySelector| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "optional",
                |m: &ConfigMapKeySelector| { &m.optional },
                |m: &mut ConfigMapKeySelector| { &mut m.optional },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ConfigMapKeySelector>(
                "ConfigMapKeySelector",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ConfigMapKeySelector {
        static instance: ::protobuf::rt::LazyV2<ConfigMapKeySelector> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ConfigMapKeySelector::new)
    }
}

impl ::protobuf::Clear for ConfigMapKeySelector {
    fn clear(&mut self) {
        self.localObjectReference.clear();
        self.key.clear();
        self.optional = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConfigMapKeySelector {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConfigMapKeySelector {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ConfigMapList {
    // message fields
    pub metadata: ::protobuf::SingularPtrField<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta>,
    pub items: ::protobuf::RepeatedField<ConfigMap>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ConfigMapList {
    fn default() -> &'a ConfigMapList {
        <ConfigMapList as ::protobuf::Message>::default_instance()
    }
}

impl ConfigMapList {
    pub fn new() -> ConfigMapList {
        ::std::default::Default::default()
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;


    pub fn get_metadata(&self) -> &super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta {
        self.metadata.take().unwrap_or_else(|| super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta::new())
    }

    // repeated .k8s.io.api.core.v1.ConfigMap items = 2;


    pub fn get_items(&self) -> &[ConfigMap] {
        &self.items
    }
    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::protobuf::RepeatedField<ConfigMap>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::protobuf::RepeatedField<ConfigMap> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::protobuf::RepeatedField<ConfigMap> {
        ::std::mem::replace(&mut self.items, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ConfigMapList {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.items {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.items)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.items {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConfigMapList {
        ConfigMapList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta>>(
                "metadata",
                |m: &ConfigMapList| { &m.metadata },
                |m: &mut ConfigMapList| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ConfigMap>>(
                "items",
                |m: &ConfigMapList| { &m.items },
                |m: &mut ConfigMapList| { &mut m.items },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ConfigMapList>(
                "ConfigMapList",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ConfigMapList {
        static instance: ::protobuf::rt::LazyV2<ConfigMapList> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ConfigMapList::new)
    }
}

impl ::protobuf::Clear for ConfigMapList {
    fn clear(&mut self) {
        self.metadata.clear();
        self.items.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConfigMapList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConfigMapList {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ConfigMapNodeConfigSource {
    // message fields
    namespace: ::protobuf::SingularField<::std::string::String>,
    name: ::protobuf::SingularField<::std::string::String>,
    uid: ::protobuf::SingularField<::std::string::String>,
    resourceVersion: ::protobuf::SingularField<::std::string::String>,
    kubeletConfigKey: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ConfigMapNodeConfigSource {
    fn default() -> &'a ConfigMapNodeConfigSource {
        <ConfigMapNodeConfigSource as ::protobuf::Message>::default_instance()
    }
}

impl ConfigMapNodeConfigSource {
    pub fn new() -> ConfigMapNodeConfigSource {
        ::std::default::Default::default()
    }

    // optional string namespace = 1;


    pub fn get_namespace(&self) -> &str {
        match self.namespace.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_namespace(&mut self) {
        self.namespace.clear();
    }

    pub fn has_namespace(&self) -> bool {
        self.namespace.is_some()
    }

    // Param is passed by value, moved
    pub fn set_namespace(&mut self, v: ::std::string::String) {
        self.namespace = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_namespace(&mut self) -> &mut ::std::string::String {
        if self.namespace.is_none() {
            self.namespace.set_default();
        }
        self.namespace.as_mut().unwrap()
    }

    // Take field
    pub fn take_namespace(&mut self) -> ::std::string::String {
        self.namespace.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string name = 2;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string uid = 3;


    pub fn get_uid(&self) -> &str {
        match self.uid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_uid(&mut self) {
        self.uid.clear();
    }

    pub fn has_uid(&self) -> bool {
        self.uid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_uid(&mut self, v: ::std::string::String) {
        self.uid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uid(&mut self) -> &mut ::std::string::String {
        if self.uid.is_none() {
            self.uid.set_default();
        }
        self.uid.as_mut().unwrap()
    }

    // Take field
    pub fn take_uid(&mut self) -> ::std::string::String {
        self.uid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string resourceVersion = 4;


    pub fn get_resourceVersion(&self) -> &str {
        match self.resourceVersion.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_resourceVersion(&mut self) {
        self.resourceVersion.clear();
    }

    pub fn has_resourceVersion(&self) -> bool {
        self.resourceVersion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resourceVersion(&mut self, v: ::std::string::String) {
        self.resourceVersion = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_resourceVersion(&mut self) -> &mut ::std::string::String {
        if self.resourceVersion.is_none() {
            self.resourceVersion.set_default();
        }
        self.resourceVersion.as_mut().unwrap()
    }

    // Take field
    pub fn take_resourceVersion(&mut self) -> ::std::string::String {
        self.resourceVersion.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string kubeletConfigKey = 5;


    pub fn get_kubeletConfigKey(&self) -> &str {
        match self.kubeletConfigKey.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_kubeletConfigKey(&mut self) {
        self.kubeletConfigKey.clear();
    }

    pub fn has_kubeletConfigKey(&self) -> bool {
        self.kubeletConfigKey.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kubeletConfigKey(&mut self, v: ::std::string::String) {
        self.kubeletConfigKey = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kubeletConfigKey(&mut self) -> &mut ::std::string::String {
        if self.kubeletConfigKey.is_none() {
            self.kubeletConfigKey.set_default();
        }
        self.kubeletConfigKey.as_mut().unwrap()
    }

    // Take field
    pub fn take_kubeletConfigKey(&mut self) -> ::std::string::String {
        self.kubeletConfigKey.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for ConfigMapNodeConfigSource {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.namespace)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.uid)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.resourceVersion)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.kubeletConfigKey)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.namespace.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.uid.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.resourceVersion.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.kubeletConfigKey.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.namespace.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.uid.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.resourceVersion.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.kubeletConfigKey.as_ref() {
            os.write_string(5, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConfigMapNodeConfigSource {
        ConfigMapNodeConfigSource::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "namespace",
                |m: &ConfigMapNodeConfigSource| { &m.namespace },
                |m: &mut ConfigMapNodeConfigSource| { &mut m.namespace },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &ConfigMapNodeConfigSource| { &m.name },
                |m: &mut ConfigMapNodeConfigSource| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "uid",
                |m: &ConfigMapNodeConfigSource| { &m.uid },
                |m: &mut ConfigMapNodeConfigSource| { &mut m.uid },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "resourceVersion",
                |m: &ConfigMapNodeConfigSource| { &m.resourceVersion },
                |m: &mut ConfigMapNodeConfigSource| { &mut m.resourceVersion },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "kubeletConfigKey",
                |m: &ConfigMapNodeConfigSource| { &m.kubeletConfigKey },
                |m: &mut ConfigMapNodeConfigSource| { &mut m.kubeletConfigKey },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ConfigMapNodeConfigSource>(
                "ConfigMapNodeConfigSource",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ConfigMapNodeConfigSource {
        static instance: ::protobuf::rt::LazyV2<ConfigMapNodeConfigSource> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ConfigMapNodeConfigSource::new)
    }
}

impl ::protobuf::Clear for ConfigMapNodeConfigSource {
    fn clear(&mut self) {
        self.namespace.clear();
        self.name.clear();
        self.uid.clear();
        self.resourceVersion.clear();
        self.kubeletConfigKey.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConfigMapNodeConfigSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConfigMapNodeConfigSource {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ConfigMapProjection {
    // message fields
    pub localObjectReference: ::protobuf::SingularPtrField<LocalObjectReference>,
    pub items: ::protobuf::RepeatedField<KeyToPath>,
    optional: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ConfigMapProjection {
    fn default() -> &'a ConfigMapProjection {
        <ConfigMapProjection as ::protobuf::Message>::default_instance()
    }
}

impl ConfigMapProjection {
    pub fn new() -> ConfigMapProjection {
        ::std::default::Default::default()
    }

    // optional .k8s.io.api.core.v1.LocalObjectReference localObjectReference = 1;


    pub fn get_localObjectReference(&self) -> &LocalObjectReference {
        self.localObjectReference.as_ref().unwrap_or_else(|| <LocalObjectReference as ::protobuf::Message>::default_instance())
    }
    pub fn clear_localObjectReference(&mut self) {
        self.localObjectReference.clear();
    }

    pub fn has_localObjectReference(&self) -> bool {
        self.localObjectReference.is_some()
    }

    // Param is passed by value, moved
    pub fn set_localObjectReference(&mut self, v: LocalObjectReference) {
        self.localObjectReference = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_localObjectReference(&mut self) -> &mut LocalObjectReference {
        if self.localObjectReference.is_none() {
            self.localObjectReference.set_default();
        }
        self.localObjectReference.as_mut().unwrap()
    }

    // Take field
    pub fn take_localObjectReference(&mut self) -> LocalObjectReference {
        self.localObjectReference.take().unwrap_or_else(|| LocalObjectReference::new())
    }

    // repeated .k8s.io.api.core.v1.KeyToPath items = 2;


    pub fn get_items(&self) -> &[KeyToPath] {
        &self.items
    }
    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::protobuf::RepeatedField<KeyToPath>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::protobuf::RepeatedField<KeyToPath> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::protobuf::RepeatedField<KeyToPath> {
        ::std::mem::replace(&mut self.items, ::protobuf::RepeatedField::new())
    }

    // optional bool optional = 4;


    pub fn get_optional(&self) -> bool {
        self.optional.unwrap_or(false)
    }
    pub fn clear_optional(&mut self) {
        self.optional = ::std::option::Option::None;
    }

    pub fn has_optional(&self) -> bool {
        self.optional.is_some()
    }

    // Param is passed by value, moved
    pub fn set_optional(&mut self, v: bool) {
        self.optional = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ConfigMapProjection {
    fn is_initialized(&self) -> bool {
        for v in &self.localObjectReference {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.items {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.localObjectReference)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.items)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.optional = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.localObjectReference.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.optional {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.localObjectReference.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.items {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.optional {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConfigMapProjection {
        ConfigMapProjection::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LocalObjectReference>>(
                "localObjectReference",
                |m: &ConfigMapProjection| { &m.localObjectReference },
                |m: &mut ConfigMapProjection| { &mut m.localObjectReference },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<KeyToPath>>(
                "items",
                |m: &ConfigMapProjection| { &m.items },
                |m: &mut ConfigMapProjection| { &mut m.items },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "optional",
                |m: &ConfigMapProjection| { &m.optional },
                |m: &mut ConfigMapProjection| { &mut m.optional },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ConfigMapProjection>(
                "ConfigMapProjection",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ConfigMapProjection {
        static instance: ::protobuf::rt::LazyV2<ConfigMapProjection> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ConfigMapProjection::new)
    }
}

impl ::protobuf::Clear for ConfigMapProjection {
    fn clear(&mut self) {
        self.localObjectReference.clear();
        self.items.clear();
        self.optional = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConfigMapProjection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConfigMapProjection {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ConfigMapVolumeSource {
    // message fields
    pub localObjectReference: ::protobuf::SingularPtrField<LocalObjectReference>,
    pub items: ::protobuf::RepeatedField<KeyToPath>,
    defaultMode: ::std::option::Option<i32>,
    optional: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ConfigMapVolumeSource {
    fn default() -> &'a ConfigMapVolumeSource {
        <ConfigMapVolumeSource as ::protobuf::Message>::default_instance()
    }
}

impl ConfigMapVolumeSource {
    pub fn new() -> ConfigMapVolumeSource {
        ::std::default::Default::default()
    }

    // optional .k8s.io.api.core.v1.LocalObjectReference localObjectReference = 1;


    pub fn get_localObjectReference(&self) -> &LocalObjectReference {
        self.localObjectReference.as_ref().unwrap_or_else(|| <LocalObjectReference as ::protobuf::Message>::default_instance())
    }
    pub fn clear_localObjectReference(&mut self) {
        self.localObjectReference.clear();
    }

    pub fn has_localObjectReference(&self) -> bool {
        self.localObjectReference.is_some()
    }

    // Param is passed by value, moved
    pub fn set_localObjectReference(&mut self, v: LocalObjectReference) {
        self.localObjectReference = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_localObjectReference(&mut self) -> &mut LocalObjectReference {
        if self.localObjectReference.is_none() {
            self.localObjectReference.set_default();
        }
        self.localObjectReference.as_mut().unwrap()
    }

    // Take field
    pub fn take_localObjectReference(&mut self) -> LocalObjectReference {
        self.localObjectReference.take().unwrap_or_else(|| LocalObjectReference::new())
    }

    // repeated .k8s.io.api.core.v1.KeyToPath items = 2;


    pub fn get_items(&self) -> &[KeyToPath] {
        &self.items
    }
    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::protobuf::RepeatedField<KeyToPath>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::protobuf::RepeatedField<KeyToPath> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::protobuf::RepeatedField<KeyToPath> {
        ::std::mem::replace(&mut self.items, ::protobuf::RepeatedField::new())
    }

    // optional int32 defaultMode = 3;


    pub fn get_defaultMode(&self) -> i32 {
        self.defaultMode.unwrap_or(0)
    }
    pub fn clear_defaultMode(&mut self) {
        self.defaultMode = ::std::option::Option::None;
    }

    pub fn has_defaultMode(&self) -> bool {
        self.defaultMode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_defaultMode(&mut self, v: i32) {
        self.defaultMode = ::std::option::Option::Some(v);
    }

    // optional bool optional = 4;


    pub fn get_optional(&self) -> bool {
        self.optional.unwrap_or(false)
    }
    pub fn clear_optional(&mut self) {
        self.optional = ::std::option::Option::None;
    }

    pub fn has_optional(&self) -> bool {
        self.optional.is_some()
    }

    // Param is passed by value, moved
    pub fn set_optional(&mut self, v: bool) {
        self.optional = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ConfigMapVolumeSource {
    fn is_initialized(&self) -> bool {
        for v in &self.localObjectReference {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.items {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.localObjectReference)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.items)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.defaultMode = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.optional = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.localObjectReference.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.defaultMode {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.optional {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.localObjectReference.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.items {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.defaultMode {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.optional {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ConfigMapVolumeSource {
        ConfigMapVolumeSource::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LocalObjectReference>>(
                "localObjectReference",
                |m: &ConfigMapVolumeSource| { &m.localObjectReference },
                |m: &mut ConfigMapVolumeSource| { &mut m.localObjectReference },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<KeyToPath>>(
                "items",
                |m: &ConfigMapVolumeSource| { &m.items },
                |m: &mut ConfigMapVolumeSource| { &mut m.items },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "defaultMode",
                |m: &ConfigMapVolumeSource| { &m.defaultMode },
                |m: &mut ConfigMapVolumeSource| { &mut m.defaultMode },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "optional",
                |m: &ConfigMapVolumeSource| { &m.optional },
                |m: &mut ConfigMapVolumeSource| { &mut m.optional },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ConfigMapVolumeSource>(
                "ConfigMapVolumeSource",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ConfigMapVolumeSource {
        static instance: ::protobuf::rt::LazyV2<ConfigMapVolumeSource> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ConfigMapVolumeSource::new)
    }
}

impl ::protobuf::Clear for ConfigMapVolumeSource {
    fn clear(&mut self) {
        self.localObjectReference.clear();
        self.items.clear();
        self.defaultMode = ::std::option::Option::None;
        self.optional = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ConfigMapVolumeSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConfigMapVolumeSource {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Container {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    image: ::protobuf::SingularField<::std::string::String>,
    pub command: ::protobuf::RepeatedField<::std::string::String>,
    pub args: ::protobuf::RepeatedField<::std::string::String>,
    workingDir: ::protobuf::SingularField<::std::string::String>,
    pub ports: ::protobuf::RepeatedField<ContainerPort>,
    pub envFrom: ::protobuf::RepeatedField<EnvFromSource>,
    pub env: ::protobuf::RepeatedField<EnvVar>,
    pub resources: ::protobuf::SingularPtrField<ResourceRequirements>,
    pub volumeMounts: ::protobuf::RepeatedField<VolumeMount>,
    pub volumeDevices: ::protobuf::RepeatedField<VolumeDevice>,
    pub livenessProbe: ::protobuf::SingularPtrField<Probe>,
    pub readinessProbe: ::protobuf::SingularPtrField<Probe>,
    pub startupProbe: ::protobuf::SingularPtrField<Probe>,
    pub lifecycle: ::protobuf::SingularPtrField<Lifecycle>,
    terminationMessagePath: ::protobuf::SingularField<::std::string::String>,
    terminationMessagePolicy: ::protobuf::SingularField<::std::string::String>,
    imagePullPolicy: ::protobuf::SingularField<::std::string::String>,
    pub securityContext: ::protobuf::SingularPtrField<SecurityContext>,
    stdin: ::std::option::Option<bool>,
    stdinOnce: ::std::option::Option<bool>,
    tty: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Container {
    fn default() -> &'a Container {
        <Container as ::protobuf::Message>::default_instance()
    }
}

impl Container {
    pub fn new() -> Container {
        ::std::default::Default::default()
    }

    // optional string name = 1;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string image = 2;


    pub fn get_image(&self) -> &str {
        match self.image.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_image(&mut self) {
        self.image.clear();
    }

    pub fn has_image(&self) -> bool {
        self.image.is_some()
    }

    // Param is passed by value, moved
    pub fn set_image(&mut self, v: ::std::string::String) {
        self.image = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_image(&mut self) -> &mut ::std::string::String {
        if self.image.is_none() {
            self.image.set_default();
        }
        self.image.as_mut().unwrap()
    }

    // Take field
    pub fn take_image(&mut self) -> ::std::string::String {
        self.image.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated string command = 3;


    pub fn get_command(&self) -> &[::std::string::String] {
        &self.command
    }
    pub fn clear_command(&mut self) {
        self.command.clear();
    }

    // Param is passed by value, moved
    pub fn set_command(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.command = v;
    }

    // Mutable pointer to the field.
    pub fn mut_command(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.command
    }

    // Take field
    pub fn take_command(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.command, ::protobuf::RepeatedField::new())
    }

    // repeated string args = 4;


    pub fn get_args(&self) -> &[::std::string::String] {
        &self.args
    }
    pub fn clear_args(&mut self) {
        self.args.clear();
    }

    // Param is passed by value, moved
    pub fn set_args(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.args = v;
    }

    // Mutable pointer to the field.
    pub fn mut_args(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.args
    }

    // Take field
    pub fn take_args(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.args, ::protobuf::RepeatedField::new())
    }

    // optional string workingDir = 5;


    pub fn get_workingDir(&self) -> &str {
        match self.workingDir.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_workingDir(&mut self) {
        self.workingDir.clear();
    }

    pub fn has_workingDir(&self) -> bool {
        self.workingDir.is_some()
    }

    // Param is passed by value, moved
    pub fn set_workingDir(&mut self, v: ::std::string::String) {
        self.workingDir = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_workingDir(&mut self) -> &mut ::std::string::String {
        if self.workingDir.is_none() {
            self.workingDir.set_default();
        }
        self.workingDir.as_mut().unwrap()
    }

    // Take field
    pub fn take_workingDir(&mut self) -> ::std::string::String {
        self.workingDir.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .k8s.io.api.core.v1.ContainerPort ports = 6;


    pub fn get_ports(&self) -> &[ContainerPort] {
        &self.ports
    }
    pub fn clear_ports(&mut self) {
        self.ports.clear();
    }

    // Param is passed by value, moved
    pub fn set_ports(&mut self, v: ::protobuf::RepeatedField<ContainerPort>) {
        self.ports = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ports(&mut self) -> &mut ::protobuf::RepeatedField<ContainerPort> {
        &mut self.ports
    }

    // Take field
    pub fn take_ports(&mut self) -> ::protobuf::RepeatedField<ContainerPort> {
        ::std::mem::replace(&mut self.ports, ::protobuf::RepeatedField::new())
    }

    // repeated .k8s.io.api.core.v1.EnvFromSource envFrom = 19;


    pub fn get_envFrom(&self) -> &[EnvFromSource] {
        &self.envFrom
    }
    pub fn clear_envFrom(&mut self) {
        self.envFrom.clear();
    }

    // Param is passed by value, moved
    pub fn set_envFrom(&mut self, v: ::protobuf::RepeatedField<EnvFromSource>) {
        self.envFrom = v;
    }

    // Mutable pointer to the field.
    pub fn mut_envFrom(&mut self) -> &mut ::protobuf::RepeatedField<EnvFromSource> {
        &mut self.envFrom
    }

    // Take field
    pub fn take_envFrom(&mut self) -> ::protobuf::RepeatedField<EnvFromSource> {
        ::std::mem::replace(&mut self.envFrom, ::protobuf::RepeatedField::new())
    }

    // repeated .k8s.io.api.core.v1.EnvVar env = 7;


    pub fn get_env(&self) -> &[EnvVar] {
        &self.env
    }
    pub fn clear_env(&mut self) {
        self.env.clear();
    }

    // Param is passed by value, moved
    pub fn set_env(&mut self, v: ::protobuf::RepeatedField<EnvVar>) {
        self.env = v;
    }

    // Mutable pointer to the field.
    pub fn mut_env(&mut self) -> &mut ::protobuf::RepeatedField<EnvVar> {
        &mut self.env
    }

    // Take field
    pub fn take_env(&mut self) -> ::protobuf::RepeatedField<EnvVar> {
        ::std::mem::replace(&mut self.env, ::protobuf::RepeatedField::new())
    }

    // optional .k8s.io.api.core.v1.ResourceRequirements resources = 8;


    pub fn get_resources(&self) -> &ResourceRequirements {
        self.resources.as_ref().unwrap_or_else(|| <ResourceRequirements as ::protobuf::Message>::default_instance())
    }
    pub fn clear_resources(&mut self) {
        self.resources.clear();
    }

    pub fn has_resources(&self) -> bool {
        self.resources.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resources(&mut self, v: ResourceRequirements) {
        self.resources = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_resources(&mut self) -> &mut ResourceRequirements {
        if self.resources.is_none() {
            self.resources.set_default();
        }
        self.resources.as_mut().unwrap()
    }

    // Take field
    pub fn take_resources(&mut self) -> ResourceRequirements {
        self.resources.take().unwrap_or_else(|| ResourceRequirements::new())
    }

    // repeated .k8s.io.api.core.v1.VolumeMount volumeMounts = 9;


    pub fn get_volumeMounts(&self) -> &[VolumeMount] {
        &self.volumeMounts
    }
    pub fn clear_volumeMounts(&mut self) {
        self.volumeMounts.clear();
    }

    // Param is passed by value, moved
    pub fn set_volumeMounts(&mut self, v: ::protobuf::RepeatedField<VolumeMount>) {
        self.volumeMounts = v;
    }

    // Mutable pointer to the field.
    pub fn mut_volumeMounts(&mut self) -> &mut ::protobuf::RepeatedField<VolumeMount> {
        &mut self.volumeMounts
    }

    // Take field
    pub fn take_volumeMounts(&mut self) -> ::protobuf::RepeatedField<VolumeMount> {
        ::std::mem::replace(&mut self.volumeMounts, ::protobuf::RepeatedField::new())
    }

    // repeated .k8s.io.api.core.v1.VolumeDevice volumeDevices = 21;


    pub fn get_volumeDevices(&self) -> &[VolumeDevice] {
        &self.volumeDevices
    }
    pub fn clear_volumeDevices(&mut self) {
        self.volumeDevices.clear();
    }

    // Param is passed by value, moved
    pub fn set_volumeDevices(&mut self, v: ::protobuf::RepeatedField<VolumeDevice>) {
        self.volumeDevices = v;
    }

    // Mutable pointer to the field.
    pub fn mut_volumeDevices(&mut self) -> &mut ::protobuf::RepeatedField<VolumeDevice> {
        &mut self.volumeDevices
    }

    // Take field
    pub fn take_volumeDevices(&mut self) -> ::protobuf::RepeatedField<VolumeDevice> {
        ::std::mem::replace(&mut self.volumeDevices, ::protobuf::RepeatedField::new())
    }

    // optional .k8s.io.api.core.v1.Probe livenessProbe = 10;


    pub fn get_livenessProbe(&self) -> &Probe {
        self.livenessProbe.as_ref().unwrap_or_else(|| <Probe as ::protobuf::Message>::default_instance())
    }
    pub fn clear_livenessProbe(&mut self) {
        self.livenessProbe.clear();
    }

    pub fn has_livenessProbe(&self) -> bool {
        self.livenessProbe.is_some()
    }

    // Param is passed by value, moved
    pub fn set_livenessProbe(&mut self, v: Probe) {
        self.livenessProbe = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_livenessProbe(&mut self) -> &mut Probe {
        if self.livenessProbe.is_none() {
            self.livenessProbe.set_default();
        }
        self.livenessProbe.as_mut().unwrap()
    }

    // Take field
    pub fn take_livenessProbe(&mut self) -> Probe {
        self.livenessProbe.take().unwrap_or_else(|| Probe::new())
    }

    // optional .k8s.io.api.core.v1.Probe readinessProbe = 11;


    pub fn get_readinessProbe(&self) -> &Probe {
        self.readinessProbe.as_ref().unwrap_or_else(|| <Probe as ::protobuf::Message>::default_instance())
    }
    pub fn clear_readinessProbe(&mut self) {
        self.readinessProbe.clear();
    }

    pub fn has_readinessProbe(&self) -> bool {
        self.readinessProbe.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readinessProbe(&mut self, v: Probe) {
        self.readinessProbe = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_readinessProbe(&mut self) -> &mut Probe {
        if self.readinessProbe.is_none() {
            self.readinessProbe.set_default();
        }
        self.readinessProbe.as_mut().unwrap()
    }

    // Take field
    pub fn take_readinessProbe(&mut self) -> Probe {
        self.readinessProbe.take().unwrap_or_else(|| Probe::new())
    }

    // optional .k8s.io.api.core.v1.Probe startupProbe = 22;


    pub fn get_startupProbe(&self) -> &Probe {
        self.startupProbe.as_ref().unwrap_or_else(|| <Probe as ::protobuf::Message>::default_instance())
    }
    pub fn clear_startupProbe(&mut self) {
        self.startupProbe.clear();
    }

    pub fn has_startupProbe(&self) -> bool {
        self.startupProbe.is_some()
    }

    // Param is passed by value, moved
    pub fn set_startupProbe(&mut self, v: Probe) {
        self.startupProbe = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_startupProbe(&mut self) -> &mut Probe {
        if self.startupProbe.is_none() {
            self.startupProbe.set_default();
        }
        self.startupProbe.as_mut().unwrap()
    }

    // Take field
    pub fn take_startupProbe(&mut self) -> Probe {
        self.startupProbe.take().unwrap_or_else(|| Probe::new())
    }

    // optional .k8s.io.api.core.v1.Lifecycle lifecycle = 12;


    pub fn get_lifecycle(&self) -> &Lifecycle {
        self.lifecycle.as_ref().unwrap_or_else(|| <Lifecycle as ::protobuf::Message>::default_instance())
    }
    pub fn clear_lifecycle(&mut self) {
        self.lifecycle.clear();
    }

    pub fn has_lifecycle(&self) -> bool {
        self.lifecycle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lifecycle(&mut self, v: Lifecycle) {
        self.lifecycle = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lifecycle(&mut self) -> &mut Lifecycle {
        if self.lifecycle.is_none() {
            self.lifecycle.set_default();
        }
        self.lifecycle.as_mut().unwrap()
    }

    // Take field
    pub fn take_lifecycle(&mut self) -> Lifecycle {
        self.lifecycle.take().unwrap_or_else(|| Lifecycle::new())
    }

    // optional string terminationMessagePath = 13;


    pub fn get_terminationMessagePath(&self) -> &str {
        match self.terminationMessagePath.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_terminationMessagePath(&mut self) {
        self.terminationMessagePath.clear();
    }

    pub fn has_terminationMessagePath(&self) -> bool {
        self.terminationMessagePath.is_some()
    }

    // Param is passed by value, moved
    pub fn set_terminationMessagePath(&mut self, v: ::std::string::String) {
        self.terminationMessagePath = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_terminationMessagePath(&mut self) -> &mut ::std::string::String {
        if self.terminationMessagePath.is_none() {
            self.terminationMessagePath.set_default();
        }
        self.terminationMessagePath.as_mut().unwrap()
    }

    // Take field
    pub fn take_terminationMessagePath(&mut self) -> ::std::string::String {
        self.terminationMessagePath.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string terminationMessagePolicy = 20;


    pub fn get_terminationMessagePolicy(&self) -> &str {
        match self.terminationMessagePolicy.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_terminationMessagePolicy(&mut self) {
        self.terminationMessagePolicy.clear();
    }

    pub fn has_terminationMessagePolicy(&self) -> bool {
        self.terminationMessagePolicy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_terminationMessagePolicy(&mut self, v: ::std::string::String) {
        self.terminationMessagePolicy = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_terminationMessagePolicy(&mut self) -> &mut ::std::string::String {
        if self.terminationMessagePolicy.is_none() {
            self.terminationMessagePolicy.set_default();
        }
        self.terminationMessagePolicy.as_mut().unwrap()
    }

    // Take field
    pub fn take_terminationMessagePolicy(&mut self) -> ::std::string::String {
        self.terminationMessagePolicy.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string imagePullPolicy = 14;


    pub fn get_imagePullPolicy(&self) -> &str {
        match self.imagePullPolicy.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_imagePullPolicy(&mut self) {
        self.imagePullPolicy.clear();
    }

    pub fn has_imagePullPolicy(&self) -> bool {
        self.imagePullPolicy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_imagePullPolicy(&mut self, v: ::std::string::String) {
        self.imagePullPolicy = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_imagePullPolicy(&mut self) -> &mut ::std::string::String {
        if self.imagePullPolicy.is_none() {
            self.imagePullPolicy.set_default();
        }
        self.imagePullPolicy.as_mut().unwrap()
    }

    // Take field
    pub fn take_imagePullPolicy(&mut self) -> ::std::string::String {
        self.imagePullPolicy.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .k8s.io.api.core.v1.SecurityContext securityContext = 15;


    pub fn get_securityContext(&self) -> &SecurityContext {
        self.securityContext.as_ref().unwrap_or_else(|| <SecurityContext as ::protobuf::Message>::default_instance())
    }
    pub fn clear_securityContext(&mut self) {
        self.securityContext.clear();
    }

    pub fn has_securityContext(&self) -> bool {
        self.securityContext.is_some()
    }

    // Param is passed by value, moved
    pub fn set_securityContext(&mut self, v: SecurityContext) {
        self.securityContext = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_securityContext(&mut self) -> &mut SecurityContext {
        if self.securityContext.is_none() {
            self.securityContext.set_default();
        }
        self.securityContext.as_mut().unwrap()
    }

    // Take field
    pub fn take_securityContext(&mut self) -> SecurityContext {
        self.securityContext.take().unwrap_or_else(|| SecurityContext::new())
    }

    // optional bool stdin = 16;


    pub fn get_stdin(&self) -> bool {
        self.stdin.unwrap_or(false)
    }
    pub fn clear_stdin(&mut self) {
        self.stdin = ::std::option::Option::None;
    }

    pub fn has_stdin(&self) -> bool {
        self.stdin.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stdin(&mut self, v: bool) {
        self.stdin = ::std::option::Option::Some(v);
    }

    // optional bool stdinOnce = 17;


    pub fn get_stdinOnce(&self) -> bool {
        self.stdinOnce.unwrap_or(false)
    }
    pub fn clear_stdinOnce(&mut self) {
        self.stdinOnce = ::std::option::Option::None;
    }

    pub fn has_stdinOnce(&self) -> bool {
        self.stdinOnce.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stdinOnce(&mut self, v: bool) {
        self.stdinOnce = ::std::option::Option::Some(v);
    }

    // optional bool tty = 18;


    pub fn get_tty(&self) -> bool {
        self.tty.unwrap_or(false)
    }
    pub fn clear_tty(&mut self) {
        self.tty = ::std::option::Option::None;
    }

    pub fn has_tty(&self) -> bool {
        self.tty.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tty(&mut self, v: bool) {
        self.tty = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for Container {
    fn is_initialized(&self) -> bool {
        for v in &self.ports {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.envFrom {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.env {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.resources {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.volumeMounts {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.volumeDevices {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.livenessProbe {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.readinessProbe {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.startupProbe {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.lifecycle {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.securityContext {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.image)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.command)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.args)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.workingDir)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.ports)?;
                },
                19 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.envFrom)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.env)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.resources)?;
                },
                9 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.volumeMounts)?;
                },
                21 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.volumeDevices)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.livenessProbe)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.readinessProbe)?;
                },
                22 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.startupProbe)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.lifecycle)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.terminationMessagePath)?;
                },
                20 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.terminationMessagePolicy)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.imagePullPolicy)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.securityContext)?;
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.stdin = ::std::option::Option::Some(tmp);
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.stdinOnce = ::std::option::Option::Some(tmp);
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.tty = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.image.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        for value in &self.command {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in &self.args {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        if let Some(ref v) = self.workingDir.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        for value in &self.ports {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.envFrom {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.env {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.resources.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.volumeMounts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.volumeDevices {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.livenessProbe.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.readinessProbe.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.startupProbe.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.lifecycle.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.terminationMessagePath.as_ref() {
            my_size += ::protobuf::rt::string_size(13, &v);
        }
        if let Some(ref v) = self.terminationMessagePolicy.as_ref() {
            my_size += ::protobuf::rt::string_size(20, &v);
        }
        if let Some(ref v) = self.imagePullPolicy.as_ref() {
            my_size += ::protobuf::rt::string_size(14, &v);
        }
        if let Some(ref v) = self.securityContext.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.stdin {
            my_size += 3;
        }
        if let Some(v) = self.stdinOnce {
            my_size += 3;
        }
        if let Some(v) = self.tty {
            my_size += 3;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.image.as_ref() {
            os.write_string(2, &v)?;
        }
        for v in &self.command {
            os.write_string(3, &v)?;
        };
        for v in &self.args {
            os.write_string(4, &v)?;
        };
        if let Some(ref v) = self.workingDir.as_ref() {
            os.write_string(5, &v)?;
        }
        for v in &self.ports {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.envFrom {
            os.write_tag(19, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.env {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.resources.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.volumeMounts {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.volumeDevices {
            os.write_tag(21, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.livenessProbe.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.readinessProbe.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.startupProbe.as_ref() {
            os.write_tag(22, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.lifecycle.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.terminationMessagePath.as_ref() {
            os.write_string(13, &v)?;
        }
        if let Some(ref v) = self.terminationMessagePolicy.as_ref() {
            os.write_string(20, &v)?;
        }
        if let Some(ref v) = self.imagePullPolicy.as_ref() {
            os.write_string(14, &v)?;
        }
        if let Some(ref v) = self.securityContext.as_ref() {
            os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.stdin {
            os.write_bool(16, v)?;
        }
        if let Some(v) = self.stdinOnce {
            os.write_bool(17, v)?;
        }
        if let Some(v) = self.tty {
            os.write_bool(18, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Container {
        Container::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &Container| { &m.name },
                |m: &mut Container| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "image",
                |m: &Container| { &m.image },
                |m: &mut Container| { &mut m.image },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "command",
                |m: &Container| { &m.command },
                |m: &mut Container| { &mut m.command },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "args",
                |m: &Container| { &m.args },
                |m: &mut Container| { &mut m.args },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "workingDir",
                |m: &Container| { &m.workingDir },
                |m: &mut Container| { &mut m.workingDir },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ContainerPort>>(
                "ports",
                |m: &Container| { &m.ports },
                |m: &mut Container| { &mut m.ports },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EnvFromSource>>(
                "envFrom",
                |m: &Container| { &m.envFrom },
                |m: &mut Container| { &mut m.envFrom },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EnvVar>>(
                "env",
                |m: &Container| { &m.env },
                |m: &mut Container| { &mut m.env },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResourceRequirements>>(
                "resources",
                |m: &Container| { &m.resources },
                |m: &mut Container| { &mut m.resources },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<VolumeMount>>(
                "volumeMounts",
                |m: &Container| { &m.volumeMounts },
                |m: &mut Container| { &mut m.volumeMounts },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<VolumeDevice>>(
                "volumeDevices",
                |m: &Container| { &m.volumeDevices },
                |m: &mut Container| { &mut m.volumeDevices },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Probe>>(
                "livenessProbe",
                |m: &Container| { &m.livenessProbe },
                |m: &mut Container| { &mut m.livenessProbe },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Probe>>(
                "readinessProbe",
                |m: &Container| { &m.readinessProbe },
                |m: &mut Container| { &mut m.readinessProbe },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Probe>>(
                "startupProbe",
                |m: &Container| { &m.startupProbe },
                |m: &mut Container| { &mut m.startupProbe },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Lifecycle>>(
                "lifecycle",
                |m: &Container| { &m.lifecycle },
                |m: &mut Container| { &mut m.lifecycle },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "terminationMessagePath",
                |m: &Container| { &m.terminationMessagePath },
                |m: &mut Container| { &mut m.terminationMessagePath },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "terminationMessagePolicy",
                |m: &Container| { &m.terminationMessagePolicy },
                |m: &mut Container| { &mut m.terminationMessagePolicy },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "imagePullPolicy",
                |m: &Container| { &m.imagePullPolicy },
                |m: &mut Container| { &mut m.imagePullPolicy },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SecurityContext>>(
                "securityContext",
                |m: &Container| { &m.securityContext },
                |m: &mut Container| { &mut m.securityContext },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "stdin",
                |m: &Container| { &m.stdin },
                |m: &mut Container| { &mut m.stdin },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "stdinOnce",
                |m: &Container| { &m.stdinOnce },
                |m: &mut Container| { &mut m.stdinOnce },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "tty",
                |m: &Container| { &m.tty },
                |m: &mut Container| { &mut m.tty },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Container>(
                "Container",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Container {
        static instance: ::protobuf::rt::LazyV2<Container> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Container::new)
    }
}

impl ::protobuf::Clear for Container {
    fn clear(&mut self) {
        self.name.clear();
        self.image.clear();
        self.command.clear();
        self.args.clear();
        self.workingDir.clear();
        self.ports.clear();
        self.envFrom.clear();
        self.env.clear();
        self.resources.clear();
        self.volumeMounts.clear();
        self.volumeDevices.clear();
        self.livenessProbe.clear();
        self.readinessProbe.clear();
        self.startupProbe.clear();
        self.lifecycle.clear();
        self.terminationMessagePath.clear();
        self.terminationMessagePolicy.clear();
        self.imagePullPolicy.clear();
        self.securityContext.clear();
        self.stdin = ::std::option::Option::None;
        self.stdinOnce = ::std::option::Option::None;
        self.tty = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Container {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Container {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ContainerImage {
    // message fields
    pub names: ::protobuf::RepeatedField<::std::string::String>,
    sizeBytes: ::std::option::Option<i64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ContainerImage {
    fn default() -> &'a ContainerImage {
        <ContainerImage as ::protobuf::Message>::default_instance()
    }
}

impl ContainerImage {
    pub fn new() -> ContainerImage {
        ::std::default::Default::default()
    }

    // repeated string names = 1;


    pub fn get_names(&self) -> &[::std::string::String] {
        &self.names
    }
    pub fn clear_names(&mut self) {
        self.names.clear();
    }

    // Param is passed by value, moved
    pub fn set_names(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.names = v;
    }

    // Mutable pointer to the field.
    pub fn mut_names(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.names
    }

    // Take field
    pub fn take_names(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.names, ::protobuf::RepeatedField::new())
    }

    // optional int64 sizeBytes = 2;


    pub fn get_sizeBytes(&self) -> i64 {
        self.sizeBytes.unwrap_or(0)
    }
    pub fn clear_sizeBytes(&mut self) {
        self.sizeBytes = ::std::option::Option::None;
    }

    pub fn has_sizeBytes(&self) -> bool {
        self.sizeBytes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sizeBytes(&mut self, v: i64) {
        self.sizeBytes = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ContainerImage {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.names)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.sizeBytes = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.names {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if let Some(v) = self.sizeBytes {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.names {
            os.write_string(1, &v)?;
        };
        if let Some(v) = self.sizeBytes {
            os.write_int64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ContainerImage {
        ContainerImage::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "names",
                |m: &ContainerImage| { &m.names },
                |m: &mut ContainerImage| { &mut m.names },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "sizeBytes",
                |m: &ContainerImage| { &m.sizeBytes },
                |m: &mut ContainerImage| { &mut m.sizeBytes },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ContainerImage>(
                "ContainerImage",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ContainerImage {
        static instance: ::protobuf::rt::LazyV2<ContainerImage> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ContainerImage::new)
    }
}

impl ::protobuf::Clear for ContainerImage {
    fn clear(&mut self) {
        self.names.clear();
        self.sizeBytes = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ContainerImage {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContainerImage {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ContainerPort {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    hostPort: ::std::option::Option<i32>,
    containerPort: ::std::option::Option<i32>,
    protocol: ::protobuf::SingularField<::std::string::String>,
    hostIP: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ContainerPort {
    fn default() -> &'a ContainerPort {
        <ContainerPort as ::protobuf::Message>::default_instance()
    }
}

impl ContainerPort {
    pub fn new() -> ContainerPort {
        ::std::default::Default::default()
    }

    // optional string name = 1;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 hostPort = 2;


    pub fn get_hostPort(&self) -> i32 {
        self.hostPort.unwrap_or(0)
    }
    pub fn clear_hostPort(&mut self) {
        self.hostPort = ::std::option::Option::None;
    }

    pub fn has_hostPort(&self) -> bool {
        self.hostPort.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hostPort(&mut self, v: i32) {
        self.hostPort = ::std::option::Option::Some(v);
    }

    // optional int32 containerPort = 3;


    pub fn get_containerPort(&self) -> i32 {
        self.containerPort.unwrap_or(0)
    }
    pub fn clear_containerPort(&mut self) {
        self.containerPort = ::std::option::Option::None;
    }

    pub fn has_containerPort(&self) -> bool {
        self.containerPort.is_some()
    }

    // Param is passed by value, moved
    pub fn set_containerPort(&mut self, v: i32) {
        self.containerPort = ::std::option::Option::Some(v);
    }

    // optional string protocol = 4;


    pub fn get_protocol(&self) -> &str {
        match self.protocol.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_protocol(&mut self) {
        self.protocol.clear();
    }

    pub fn has_protocol(&self) -> bool {
        self.protocol.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protocol(&mut self, v: ::std::string::String) {
        self.protocol = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_protocol(&mut self) -> &mut ::std::string::String {
        if self.protocol.is_none() {
            self.protocol.set_default();
        }
        self.protocol.as_mut().unwrap()
    }

    // Take field
    pub fn take_protocol(&mut self) -> ::std::string::String {
        self.protocol.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string hostIP = 5;


    pub fn get_hostIP(&self) -> &str {
        match self.hostIP.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_hostIP(&mut self) {
        self.hostIP.clear();
    }

    pub fn has_hostIP(&self) -> bool {
        self.hostIP.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hostIP(&mut self, v: ::std::string::String) {
        self.hostIP = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hostIP(&mut self) -> &mut ::std::string::String {
        if self.hostIP.is_none() {
            self.hostIP.set_default();
        }
        self.hostIP.as_mut().unwrap()
    }

    // Take field
    pub fn take_hostIP(&mut self) -> ::std::string::String {
        self.hostIP.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for ContainerPort {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.hostPort = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.containerPort = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.protocol)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.hostIP)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.hostPort {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.containerPort {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.protocol.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.hostIP.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.hostPort {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.containerPort {
            os.write_int32(3, v)?;
        }
        if let Some(ref v) = self.protocol.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.hostIP.as_ref() {
            os.write_string(5, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ContainerPort {
        ContainerPort::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &ContainerPort| { &m.name },
                |m: &mut ContainerPort| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "hostPort",
                |m: &ContainerPort| { &m.hostPort },
                |m: &mut ContainerPort| { &mut m.hostPort },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "containerPort",
                |m: &ContainerPort| { &m.containerPort },
                |m: &mut ContainerPort| { &mut m.containerPort },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "protocol",
                |m: &ContainerPort| { &m.protocol },
                |m: &mut ContainerPort| { &mut m.protocol },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "hostIP",
                |m: &ContainerPort| { &m.hostIP },
                |m: &mut ContainerPort| { &mut m.hostIP },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ContainerPort>(
                "ContainerPort",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ContainerPort {
        static instance: ::protobuf::rt::LazyV2<ContainerPort> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ContainerPort::new)
    }
}

impl ::protobuf::Clear for ContainerPort {
    fn clear(&mut self) {
        self.name.clear();
        self.hostPort = ::std::option::Option::None;
        self.containerPort = ::std::option::Option::None;
        self.protocol.clear();
        self.hostIP.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ContainerPort {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContainerPort {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ContainerState {
    // message fields
    pub waiting: ::protobuf::SingularPtrField<ContainerStateWaiting>,
    pub running: ::protobuf::SingularPtrField<ContainerStateRunning>,
    pub terminated: ::protobuf::SingularPtrField<ContainerStateTerminated>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ContainerState {
    fn default() -> &'a ContainerState {
        <ContainerState as ::protobuf::Message>::default_instance()
    }
}

impl ContainerState {
    pub fn new() -> ContainerState {
        ::std::default::Default::default()
    }

    // optional .k8s.io.api.core.v1.ContainerStateWaiting waiting = 1;


    pub fn get_waiting(&self) -> &ContainerStateWaiting {
        self.waiting.as_ref().unwrap_or_else(|| <ContainerStateWaiting as ::protobuf::Message>::default_instance())
    }
    pub fn clear_waiting(&mut self) {
        self.waiting.clear();
    }

    pub fn has_waiting(&self) -> bool {
        self.waiting.is_some()
    }

    // Param is passed by value, moved
    pub fn set_waiting(&mut self, v: ContainerStateWaiting) {
        self.waiting = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_waiting(&mut self) -> &mut ContainerStateWaiting {
        if self.waiting.is_none() {
            self.waiting.set_default();
        }
        self.waiting.as_mut().unwrap()
    }

    // Take field
    pub fn take_waiting(&mut self) -> ContainerStateWaiting {
        self.waiting.take().unwrap_or_else(|| ContainerStateWaiting::new())
    }

    // optional .k8s.io.api.core.v1.ContainerStateRunning running = 2;


    pub fn get_running(&self) -> &ContainerStateRunning {
        self.running.as_ref().unwrap_or_else(|| <ContainerStateRunning as ::protobuf::Message>::default_instance())
    }
    pub fn clear_running(&mut self) {
        self.running.clear();
    }

    pub fn has_running(&self) -> bool {
        self.running.is_some()
    }

    // Param is passed by value, moved
    pub fn set_running(&mut self, v: ContainerStateRunning) {
        self.running = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_running(&mut self) -> &mut ContainerStateRunning {
        if self.running.is_none() {
            self.running.set_default();
        }
        self.running.as_mut().unwrap()
    }

    // Take field
    pub fn take_running(&mut self) -> ContainerStateRunning {
        self.running.take().unwrap_or_else(|| ContainerStateRunning::new())
    }

    // optional .k8s.io.api.core.v1.ContainerStateTerminated terminated = 3;


    pub fn get_terminated(&self) -> &ContainerStateTerminated {
        self.terminated.as_ref().unwrap_or_else(|| <ContainerStateTerminated as ::protobuf::Message>::default_instance())
    }
    pub fn clear_terminated(&mut self) {
        self.terminated.clear();
    }

    pub fn has_terminated(&self) -> bool {
        self.terminated.is_some()
    }

    // Param is passed by value, moved
    pub fn set_terminated(&mut self, v: ContainerStateTerminated) {
        self.terminated = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_terminated(&mut self) -> &mut ContainerStateTerminated {
        if self.terminated.is_none() {
            self.terminated.set_default();
        }
        self.terminated.as_mut().unwrap()
    }

    // Take field
    pub fn take_terminated(&mut self) -> ContainerStateTerminated {
        self.terminated.take().unwrap_or_else(|| ContainerStateTerminated::new())
    }
}

impl ::protobuf::Message for ContainerState {
    fn is_initialized(&self) -> bool {
        for v in &self.waiting {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.running {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.terminated {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.waiting)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.running)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.terminated)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.waiting.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.running.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.terminated.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.waiting.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.running.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.terminated.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ContainerState {
        ContainerState::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ContainerStateWaiting>>(
                "waiting",
                |m: &ContainerState| { &m.waiting },
                |m: &mut ContainerState| { &mut m.waiting },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ContainerStateRunning>>(
                "running",
                |m: &ContainerState| { &m.running },
                |m: &mut ContainerState| { &mut m.running },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ContainerStateTerminated>>(
                "terminated",
                |m: &ContainerState| { &m.terminated },
                |m: &mut ContainerState| { &mut m.terminated },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ContainerState>(
                "ContainerState",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ContainerState {
        static instance: ::protobuf::rt::LazyV2<ContainerState> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ContainerState::new)
    }
}

impl ::protobuf::Clear for ContainerState {
    fn clear(&mut self) {
        self.waiting.clear();
        self.running.clear();
        self.terminated.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ContainerState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContainerState {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ContainerStateRunning {
    // message fields
    pub startedAt: ::protobuf::SingularPtrField<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ContainerStateRunning {
    fn default() -> &'a ContainerStateRunning {
        <ContainerStateRunning as ::protobuf::Message>::default_instance()
    }
}

impl ContainerStateRunning {
    pub fn new() -> ContainerStateRunning {
        ::std::default::Default::default()
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time startedAt = 1;


    pub fn get_startedAt(&self) -> &super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time {
        self.startedAt.as_ref().unwrap_or_else(|| <super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time as ::protobuf::Message>::default_instance())
    }
    pub fn clear_startedAt(&mut self) {
        self.startedAt.clear();
    }

    pub fn has_startedAt(&self) -> bool {
        self.startedAt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_startedAt(&mut self, v: super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time) {
        self.startedAt = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_startedAt(&mut self) -> &mut super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time {
        if self.startedAt.is_none() {
            self.startedAt.set_default();
        }
        self.startedAt.as_mut().unwrap()
    }

    // Take field
    pub fn take_startedAt(&mut self) -> super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time {
        self.startedAt.take().unwrap_or_else(|| super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time::new())
    }
}

impl ::protobuf::Message for ContainerStateRunning {
    fn is_initialized(&self) -> bool {
        for v in &self.startedAt {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.startedAt)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.startedAt.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.startedAt.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ContainerStateRunning {
        ContainerStateRunning::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time>>(
                "startedAt",
                |m: &ContainerStateRunning| { &m.startedAt },
                |m: &mut ContainerStateRunning| { &mut m.startedAt },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ContainerStateRunning>(
                "ContainerStateRunning",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ContainerStateRunning {
        static instance: ::protobuf::rt::LazyV2<ContainerStateRunning> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ContainerStateRunning::new)
    }
}

impl ::protobuf::Clear for ContainerStateRunning {
    fn clear(&mut self) {
        self.startedAt.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ContainerStateRunning {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContainerStateRunning {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ContainerStateTerminated {
    // message fields
    exitCode: ::std::option::Option<i32>,
    signal: ::std::option::Option<i32>,
    reason: ::protobuf::SingularField<::std::string::String>,
    message: ::protobuf::SingularField<::std::string::String>,
    pub startedAt: ::protobuf::SingularPtrField<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time>,
    pub finishedAt: ::protobuf::SingularPtrField<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time>,
    containerID: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ContainerStateTerminated {
    fn default() -> &'a ContainerStateTerminated {
        <ContainerStateTerminated as ::protobuf::Message>::default_instance()
    }
}

impl ContainerStateTerminated {
    pub fn new() -> ContainerStateTerminated {
        ::std::default::Default::default()
    }

    // optional int32 exitCode = 1;


    pub fn get_exitCode(&self) -> i32 {
        self.exitCode.unwrap_or(0)
    }
    pub fn clear_exitCode(&mut self) {
        self.exitCode = ::std::option::Option::None;
    }

    pub fn has_exitCode(&self) -> bool {
        self.exitCode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_exitCode(&mut self, v: i32) {
        self.exitCode = ::std::option::Option::Some(v);
    }

    // optional int32 signal = 2;


    pub fn get_signal(&self) -> i32 {
        self.signal.unwrap_or(0)
    }
    pub fn clear_signal(&mut self) {
        self.signal = ::std::option::Option::None;
    }

    pub fn has_signal(&self) -> bool {
        self.signal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_signal(&mut self, v: i32) {
        self.signal = ::std::option::Option::Some(v);
    }

    // optional string reason = 3;


    pub fn get_reason(&self) -> &str {
        match self.reason.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_reason(&mut self) {
        self.reason.clear();
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: ::std::string::String) {
        self.reason = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reason(&mut self) -> &mut ::std::string::String {
        if self.reason.is_none() {
            self.reason.set_default();
        }
        self.reason.as_mut().unwrap()
    }

    // Take field
    pub fn take_reason(&mut self) -> ::std::string::String {
        self.reason.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string message = 4;


    pub fn get_message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time startedAt = 5;


    pub fn get_startedAt(&self) -> &super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time {
        self.startedAt.as_ref().unwrap_or_else(|| <super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time as ::protobuf::Message>::default_instance())
    }
    pub fn clear_startedAt(&mut self) {
        self.startedAt.clear();
    }

    pub fn has_startedAt(&self) -> bool {
        self.startedAt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_startedAt(&mut self, v: super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time) {
        self.startedAt = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_startedAt(&mut self) -> &mut super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time {
        if self.startedAt.is_none() {
            self.startedAt.set_default();
        }
        self.startedAt.as_mut().unwrap()
    }

    // Take field
    pub fn take_startedAt(&mut self) -> super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time {
        self.startedAt.take().unwrap_or_else(|| super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time::new())
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time finishedAt = 6;


    pub fn get_finishedAt(&self) -> &super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time {
        self.finishedAt.as_ref().unwrap_or_else(|| <super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time as ::protobuf::Message>::default_instance())
    }
    pub fn clear_finishedAt(&mut self) {
        self.finishedAt.clear();
    }

    pub fn has_finishedAt(&self) -> bool {
        self.finishedAt.is_some()
    }

    // Param is passed by value, moved
    pub fn set_finishedAt(&mut self, v: super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time) {
        self.finishedAt = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_finishedAt(&mut self) -> &mut super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time {
        if self.finishedAt.is_none() {
            self.finishedAt.set_default();
        }
        self.finishedAt.as_mut().unwrap()
    }

    // Take field
    pub fn take_finishedAt(&mut self) -> super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time {
        self.finishedAt.take().unwrap_or_else(|| super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time::new())
    }

    // optional string containerID = 7;


    pub fn get_containerID(&self) -> &str {
        match self.containerID.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_containerID(&mut self) {
        self.containerID.clear();
    }

    pub fn has_containerID(&self) -> bool {
        self.containerID.is_some()
    }

    // Param is passed by value, moved
    pub fn set_containerID(&mut self, v: ::std::string::String) {
        self.containerID = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_containerID(&mut self) -> &mut ::std::string::String {
        if self.containerID.is_none() {
            self.containerID.set_default();
        }
        self.containerID.as_mut().unwrap()
    }

    // Take field
    pub fn take_containerID(&mut self) -> ::std::string::String {
        self.containerID.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for ContainerStateTerminated {
    fn is_initialized(&self) -> bool {
        for v in &self.startedAt {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.finishedAt {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.exitCode = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.signal = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.reason)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.message)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.startedAt)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.finishedAt)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.containerID)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.exitCode {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.signal {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.reason.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.startedAt.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.finishedAt.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.containerID.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.exitCode {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.signal {
            os.write_int32(2, v)?;
        }
        if let Some(ref v) = self.reason.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.message.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.startedAt.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.finishedAt.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.containerID.as_ref() {
            os.write_string(7, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ContainerStateTerminated {
        ContainerStateTerminated::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "exitCode",
                |m: &ContainerStateTerminated| { &m.exitCode },
                |m: &mut ContainerStateTerminated| { &mut m.exitCode },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "signal",
                |m: &ContainerStateTerminated| { &m.signal },
                |m: &mut ContainerStateTerminated| { &mut m.signal },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "reason",
                |m: &ContainerStateTerminated| { &m.reason },
                |m: &mut ContainerStateTerminated| { &mut m.reason },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "message",
                |m: &ContainerStateTerminated| { &m.message },
                |m: &mut ContainerStateTerminated| { &mut m.message },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time>>(
                "startedAt",
                |m: &ContainerStateTerminated| { &m.startedAt },
                |m: &mut ContainerStateTerminated| { &mut m.startedAt },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time>>(
                "finishedAt",
                |m: &ContainerStateTerminated| { &m.finishedAt },
                |m: &mut ContainerStateTerminated| { &mut m.finishedAt },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "containerID",
                |m: &ContainerStateTerminated| { &m.containerID },
                |m: &mut ContainerStateTerminated| { &mut m.containerID },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ContainerStateTerminated>(
                "ContainerStateTerminated",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ContainerStateTerminated {
        static instance: ::protobuf::rt::LazyV2<ContainerStateTerminated> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ContainerStateTerminated::new)
    }
}

impl ::protobuf::Clear for ContainerStateTerminated {
    fn clear(&mut self) {
        self.exitCode = ::std::option::Option::None;
        self.signal = ::std::option::Option::None;
        self.reason.clear();
        self.message.clear();
        self.startedAt.clear();
        self.finishedAt.clear();
        self.containerID.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ContainerStateTerminated {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContainerStateTerminated {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ContainerStateWaiting {
    // message fields
    reason: ::protobuf::SingularField<::std::string::String>,
    message: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ContainerStateWaiting {
    fn default() -> &'a ContainerStateWaiting {
        <ContainerStateWaiting as ::protobuf::Message>::default_instance()
    }
}

impl ContainerStateWaiting {
    pub fn new() -> ContainerStateWaiting {
        ::std::default::Default::default()
    }

    // optional string reason = 1;


    pub fn get_reason(&self) -> &str {
        match self.reason.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_reason(&mut self) {
        self.reason.clear();
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: ::std::string::String) {
        self.reason = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reason(&mut self) -> &mut ::std::string::String {
        if self.reason.is_none() {
            self.reason.set_default();
        }
        self.reason.as_mut().unwrap()
    }

    // Take field
    pub fn take_reason(&mut self) -> ::std::string::String {
        self.reason.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string message = 2;


    pub fn get_message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for ContainerStateWaiting {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.reason)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.reason.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.reason.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.message.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ContainerStateWaiting {
        ContainerStateWaiting::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "reason",
                |m: &ContainerStateWaiting| { &m.reason },
                |m: &mut ContainerStateWaiting| { &mut m.reason },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "message",
                |m: &ContainerStateWaiting| { &m.message },
                |m: &mut ContainerStateWaiting| { &mut m.message },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ContainerStateWaiting>(
                "ContainerStateWaiting",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ContainerStateWaiting {
        static instance: ::protobuf::rt::LazyV2<ContainerStateWaiting> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ContainerStateWaiting::new)
    }
}

impl ::protobuf::Clear for ContainerStateWaiting {
    fn clear(&mut self) {
        self.reason.clear();
        self.message.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ContainerStateWaiting {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContainerStateWaiting {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ContainerStatus {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    pub state: ::protobuf::SingularPtrField<ContainerState>,
    pub lastState: ::protobuf::SingularPtrField<ContainerState>,
    ready: ::std::option::Option<bool>,
    restartCount: ::std::option::Option<i32>,
    image: ::protobuf::SingularField<::std::string::String>,
    imageID: ::protobuf::SingularField<::std::string::String>,
    containerID: ::protobuf::SingularField<::std::string::String>,
    started: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ContainerStatus {
    fn default() -> &'a ContainerStatus {
        <ContainerStatus as ::protobuf::Message>::default_instance()
    }
}

impl ContainerStatus {
    pub fn new() -> ContainerStatus {
        ::std::default::Default::default()
    }

    // optional string name = 1;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .k8s.io.api.core.v1.ContainerState state = 2;


    pub fn get_state(&self) -> &ContainerState {
        self.state.as_ref().unwrap_or_else(|| <ContainerState as ::protobuf::Message>::default_instance())
    }
    pub fn clear_state(&mut self) {
        self.state.clear();
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: ContainerState) {
        self.state = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_state(&mut self) -> &mut ContainerState {
        if self.state.is_none() {
            self.state.set_default();
        }
        self.state.as_mut().unwrap()
    }

    // Take field
    pub fn take_state(&mut self) -> ContainerState {
        self.state.take().unwrap_or_else(|| ContainerState::new())
    }

    // optional .k8s.io.api.core.v1.ContainerState lastState = 3;


    pub fn get_lastState(&self) -> &ContainerState {
        self.lastState.as_ref().unwrap_or_else(|| <ContainerState as ::protobuf::Message>::default_instance())
    }
    pub fn clear_lastState(&mut self) {
        self.lastState.clear();
    }

    pub fn has_lastState(&self) -> bool {
        self.lastState.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lastState(&mut self, v: ContainerState) {
        self.lastState = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lastState(&mut self) -> &mut ContainerState {
        if self.lastState.is_none() {
            self.lastState.set_default();
        }
        self.lastState.as_mut().unwrap()
    }

    // Take field
    pub fn take_lastState(&mut self) -> ContainerState {
        self.lastState.take().unwrap_or_else(|| ContainerState::new())
    }

    // optional bool ready = 4;


    pub fn get_ready(&self) -> bool {
        self.ready.unwrap_or(false)
    }
    pub fn clear_ready(&mut self) {
        self.ready = ::std::option::Option::None;
    }

    pub fn has_ready(&self) -> bool {
        self.ready.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ready(&mut self, v: bool) {
        self.ready = ::std::option::Option::Some(v);
    }

    // optional int32 restartCount = 5;


    pub fn get_restartCount(&self) -> i32 {
        self.restartCount.unwrap_or(0)
    }
    pub fn clear_restartCount(&mut self) {
        self.restartCount = ::std::option::Option::None;
    }

    pub fn has_restartCount(&self) -> bool {
        self.restartCount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_restartCount(&mut self, v: i32) {
        self.restartCount = ::std::option::Option::Some(v);
    }

    // optional string image = 6;


    pub fn get_image(&self) -> &str {
        match self.image.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_image(&mut self) {
        self.image.clear();
    }

    pub fn has_image(&self) -> bool {
        self.image.is_some()
    }

    // Param is passed by value, moved
    pub fn set_image(&mut self, v: ::std::string::String) {
        self.image = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_image(&mut self) -> &mut ::std::string::String {
        if self.image.is_none() {
            self.image.set_default();
        }
        self.image.as_mut().unwrap()
    }

    // Take field
    pub fn take_image(&mut self) -> ::std::string::String {
        self.image.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string imageID = 7;


    pub fn get_imageID(&self) -> &str {
        match self.imageID.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_imageID(&mut self) {
        self.imageID.clear();
    }

    pub fn has_imageID(&self) -> bool {
        self.imageID.is_some()
    }

    // Param is passed by value, moved
    pub fn set_imageID(&mut self, v: ::std::string::String) {
        self.imageID = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_imageID(&mut self) -> &mut ::std::string::String {
        if self.imageID.is_none() {
            self.imageID.set_default();
        }
        self.imageID.as_mut().unwrap()
    }

    // Take field
    pub fn take_imageID(&mut self) -> ::std::string::String {
        self.imageID.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string containerID = 8;


    pub fn get_containerID(&self) -> &str {
        match self.containerID.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_containerID(&mut self) {
        self.containerID.clear();
    }

    pub fn has_containerID(&self) -> bool {
        self.containerID.is_some()
    }

    // Param is passed by value, moved
    pub fn set_containerID(&mut self, v: ::std::string::String) {
        self.containerID = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_containerID(&mut self) -> &mut ::std::string::String {
        if self.containerID.is_none() {
            self.containerID.set_default();
        }
        self.containerID.as_mut().unwrap()
    }

    // Take field
    pub fn take_containerID(&mut self) -> ::std::string::String {
        self.containerID.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool started = 9;


    pub fn get_started(&self) -> bool {
        self.started.unwrap_or(false)
    }
    pub fn clear_started(&mut self) {
        self.started = ::std::option::Option::None;
    }

    pub fn has_started(&self) -> bool {
        self.started.is_some()
    }

    // Param is passed by value, moved
    pub fn set_started(&mut self, v: bool) {
        self.started = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ContainerStatus {
    fn is_initialized(&self) -> bool {
        for v in &self.state {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.lastState {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.state)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.lastState)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.ready = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.restartCount = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.image)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.imageID)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.containerID)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.started = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.state.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.lastState.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.ready {
            my_size += 2;
        }
        if let Some(v) = self.restartCount {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.image.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(ref v) = self.imageID.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(ref v) = self.containerID.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(v) = self.started {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.state.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.lastState.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.ready {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.restartCount {
            os.write_int32(5, v)?;
        }
        if let Some(ref v) = self.image.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(ref v) = self.imageID.as_ref() {
            os.write_string(7, &v)?;
        }
        if let Some(ref v) = self.containerID.as_ref() {
            os.write_string(8, &v)?;
        }
        if let Some(v) = self.started {
            os.write_bool(9, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ContainerStatus {
        ContainerStatus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &ContainerStatus| { &m.name },
                |m: &mut ContainerStatus| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ContainerState>>(
                "state",
                |m: &ContainerStatus| { &m.state },
                |m: &mut ContainerStatus| { &mut m.state },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ContainerState>>(
                "lastState",
                |m: &ContainerStatus| { &m.lastState },
                |m: &mut ContainerStatus| { &mut m.lastState },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "ready",
                |m: &ContainerStatus| { &m.ready },
                |m: &mut ContainerStatus| { &mut m.ready },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "restartCount",
                |m: &ContainerStatus| { &m.restartCount },
                |m: &mut ContainerStatus| { &mut m.restartCount },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "image",
                |m: &ContainerStatus| { &m.image },
                |m: &mut ContainerStatus| { &mut m.image },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "imageID",
                |m: &ContainerStatus| { &m.imageID },
                |m: &mut ContainerStatus| { &mut m.imageID },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "containerID",
                |m: &ContainerStatus| { &m.containerID },
                |m: &mut ContainerStatus| { &mut m.containerID },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "started",
                |m: &ContainerStatus| { &m.started },
                |m: &mut ContainerStatus| { &mut m.started },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ContainerStatus>(
                "ContainerStatus",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ContainerStatus {
        static instance: ::protobuf::rt::LazyV2<ContainerStatus> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ContainerStatus::new)
    }
}

impl ::protobuf::Clear for ContainerStatus {
    fn clear(&mut self) {
        self.name.clear();
        self.state.clear();
        self.lastState.clear();
        self.ready = ::std::option::Option::None;
        self.restartCount = ::std::option::Option::None;
        self.image.clear();
        self.imageID.clear();
        self.containerID.clear();
        self.started = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ContainerStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContainerStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DaemonEndpoint {
    // message fields
    Port: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DaemonEndpoint {
    fn default() -> &'a DaemonEndpoint {
        <DaemonEndpoint as ::protobuf::Message>::default_instance()
    }
}

impl DaemonEndpoint {
    pub fn new() -> DaemonEndpoint {
        ::std::default::Default::default()
    }

    // optional int32 Port = 1;


    pub fn get_Port(&self) -> i32 {
        self.Port.unwrap_or(0)
    }
    pub fn clear_Port(&mut self) {
        self.Port = ::std::option::Option::None;
    }

    pub fn has_Port(&self) -> bool {
        self.Port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Port(&mut self, v: i32) {
        self.Port = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for DaemonEndpoint {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.Port = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.Port {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.Port {
            os.write_int32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DaemonEndpoint {
        DaemonEndpoint::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "Port",
                |m: &DaemonEndpoint| { &m.Port },
                |m: &mut DaemonEndpoint| { &mut m.Port },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DaemonEndpoint>(
                "DaemonEndpoint",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DaemonEndpoint {
        static instance: ::protobuf::rt::LazyV2<DaemonEndpoint> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DaemonEndpoint::new)
    }
}

impl ::protobuf::Clear for DaemonEndpoint {
    fn clear(&mut self) {
        self.Port = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DaemonEndpoint {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DaemonEndpoint {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DownwardAPIProjection {
    // message fields
    pub items: ::protobuf::RepeatedField<DownwardAPIVolumeFile>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DownwardAPIProjection {
    fn default() -> &'a DownwardAPIProjection {
        <DownwardAPIProjection as ::protobuf::Message>::default_instance()
    }
}

impl DownwardAPIProjection {
    pub fn new() -> DownwardAPIProjection {
        ::std::default::Default::default()
    }

    // repeated .k8s.io.api.core.v1.DownwardAPIVolumeFile items = 1;


    pub fn get_items(&self) -> &[DownwardAPIVolumeFile] {
        &self.items
    }
    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::protobuf::RepeatedField<DownwardAPIVolumeFile>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::protobuf::RepeatedField<DownwardAPIVolumeFile> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::protobuf::RepeatedField<DownwardAPIVolumeFile> {
        ::std::mem::replace(&mut self.items, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for DownwardAPIProjection {
    fn is_initialized(&self) -> bool {
        for v in &self.items {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.items)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.items {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DownwardAPIProjection {
        DownwardAPIProjection::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DownwardAPIVolumeFile>>(
                "items",
                |m: &DownwardAPIProjection| { &m.items },
                |m: &mut DownwardAPIProjection| { &mut m.items },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DownwardAPIProjection>(
                "DownwardAPIProjection",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DownwardAPIProjection {
        static instance: ::protobuf::rt::LazyV2<DownwardAPIProjection> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DownwardAPIProjection::new)
    }
}

impl ::protobuf::Clear for DownwardAPIProjection {
    fn clear(&mut self) {
        self.items.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DownwardAPIProjection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DownwardAPIProjection {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DownwardAPIVolumeFile {
    // message fields
    path: ::protobuf::SingularField<::std::string::String>,
    pub fieldRef: ::protobuf::SingularPtrField<ObjectFieldSelector>,
    pub resourceFieldRef: ::protobuf::SingularPtrField<ResourceFieldSelector>,
    mode: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DownwardAPIVolumeFile {
    fn default() -> &'a DownwardAPIVolumeFile {
        <DownwardAPIVolumeFile as ::protobuf::Message>::default_instance()
    }
}

impl DownwardAPIVolumeFile {
    pub fn new() -> DownwardAPIVolumeFile {
        ::std::default::Default::default()
    }

    // optional string path = 1;


    pub fn get_path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path.set_default();
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .k8s.io.api.core.v1.ObjectFieldSelector fieldRef = 2;


    pub fn get_fieldRef(&self) -> &ObjectFieldSelector {
        self.fieldRef.as_ref().unwrap_or_else(|| <ObjectFieldSelector as ::protobuf::Message>::default_instance())
    }
    pub fn clear_fieldRef(&mut self) {
        self.fieldRef.clear();
    }

    pub fn has_fieldRef(&self) -> bool {
        self.fieldRef.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fieldRef(&mut self, v: ObjectFieldSelector) {
        self.fieldRef = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fieldRef(&mut self) -> &mut ObjectFieldSelector {
        if self.fieldRef.is_none() {
            self.fieldRef.set_default();
        }
        self.fieldRef.as_mut().unwrap()
    }

    // Take field
    pub fn take_fieldRef(&mut self) -> ObjectFieldSelector {
        self.fieldRef.take().unwrap_or_else(|| ObjectFieldSelector::new())
    }

    // optional .k8s.io.api.core.v1.ResourceFieldSelector resourceFieldRef = 3;


    pub fn get_resourceFieldRef(&self) -> &ResourceFieldSelector {
        self.resourceFieldRef.as_ref().unwrap_or_else(|| <ResourceFieldSelector as ::protobuf::Message>::default_instance())
    }
    pub fn clear_resourceFieldRef(&mut self) {
        self.resourceFieldRef.clear();
    }

    pub fn has_resourceFieldRef(&self) -> bool {
        self.resourceFieldRef.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resourceFieldRef(&mut self, v: ResourceFieldSelector) {
        self.resourceFieldRef = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_resourceFieldRef(&mut self) -> &mut ResourceFieldSelector {
        if self.resourceFieldRef.is_none() {
            self.resourceFieldRef.set_default();
        }
        self.resourceFieldRef.as_mut().unwrap()
    }

    // Take field
    pub fn take_resourceFieldRef(&mut self) -> ResourceFieldSelector {
        self.resourceFieldRef.take().unwrap_or_else(|| ResourceFieldSelector::new())
    }

    // optional int32 mode = 4;


    pub fn get_mode(&self) -> i32 {
        self.mode.unwrap_or(0)
    }
    pub fn clear_mode(&mut self) {
        self.mode = ::std::option::Option::None;
    }

    pub fn has_mode(&self) -> bool {
        self.mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mode(&mut self, v: i32) {
        self.mode = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for DownwardAPIVolumeFile {
    fn is_initialized(&self) -> bool {
        for v in &self.fieldRef {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.resourceFieldRef {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.path)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.fieldRef)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.resourceFieldRef)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.mode = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.path.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.fieldRef.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.resourceFieldRef.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.mode {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.path.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.fieldRef.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.resourceFieldRef.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.mode {
            os.write_int32(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DownwardAPIVolumeFile {
        DownwardAPIVolumeFile::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "path",
                |m: &DownwardAPIVolumeFile| { &m.path },
                |m: &mut DownwardAPIVolumeFile| { &mut m.path },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ObjectFieldSelector>>(
                "fieldRef",
                |m: &DownwardAPIVolumeFile| { &m.fieldRef },
                |m: &mut DownwardAPIVolumeFile| { &mut m.fieldRef },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResourceFieldSelector>>(
                "resourceFieldRef",
                |m: &DownwardAPIVolumeFile| { &m.resourceFieldRef },
                |m: &mut DownwardAPIVolumeFile| { &mut m.resourceFieldRef },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "mode",
                |m: &DownwardAPIVolumeFile| { &m.mode },
                |m: &mut DownwardAPIVolumeFile| { &mut m.mode },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DownwardAPIVolumeFile>(
                "DownwardAPIVolumeFile",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DownwardAPIVolumeFile {
        static instance: ::protobuf::rt::LazyV2<DownwardAPIVolumeFile> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DownwardAPIVolumeFile::new)
    }
}

impl ::protobuf::Clear for DownwardAPIVolumeFile {
    fn clear(&mut self) {
        self.path.clear();
        self.fieldRef.clear();
        self.resourceFieldRef.clear();
        self.mode = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DownwardAPIVolumeFile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DownwardAPIVolumeFile {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DownwardAPIVolumeSource {
    // message fields
    pub items: ::protobuf::RepeatedField<DownwardAPIVolumeFile>,
    defaultMode: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DownwardAPIVolumeSource {
    fn default() -> &'a DownwardAPIVolumeSource {
        <DownwardAPIVolumeSource as ::protobuf::Message>::default_instance()
    }
}

impl DownwardAPIVolumeSource {
    pub fn new() -> DownwardAPIVolumeSource {
        ::std::default::Default::default()
    }

    // repeated .k8s.io.api.core.v1.DownwardAPIVolumeFile items = 1;


    pub fn get_items(&self) -> &[DownwardAPIVolumeFile] {
        &self.items
    }
    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::protobuf::RepeatedField<DownwardAPIVolumeFile>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::protobuf::RepeatedField<DownwardAPIVolumeFile> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::protobuf::RepeatedField<DownwardAPIVolumeFile> {
        ::std::mem::replace(&mut self.items, ::protobuf::RepeatedField::new())
    }

    // optional int32 defaultMode = 2;


    pub fn get_defaultMode(&self) -> i32 {
        self.defaultMode.unwrap_or(0)
    }
    pub fn clear_defaultMode(&mut self) {
        self.defaultMode = ::std::option::Option::None;
    }

    pub fn has_defaultMode(&self) -> bool {
        self.defaultMode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_defaultMode(&mut self, v: i32) {
        self.defaultMode = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for DownwardAPIVolumeSource {
    fn is_initialized(&self) -> bool {
        for v in &self.items {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.items)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.defaultMode = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.defaultMode {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.items {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.defaultMode {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DownwardAPIVolumeSource {
        DownwardAPIVolumeSource::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DownwardAPIVolumeFile>>(
                "items",
                |m: &DownwardAPIVolumeSource| { &m.items },
                |m: &mut DownwardAPIVolumeSource| { &mut m.items },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "defaultMode",
                |m: &DownwardAPIVolumeSource| { &m.defaultMode },
                |m: &mut DownwardAPIVolumeSource| { &mut m.defaultMode },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DownwardAPIVolumeSource>(
                "DownwardAPIVolumeSource",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DownwardAPIVolumeSource {
        static instance: ::protobuf::rt::LazyV2<DownwardAPIVolumeSource> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DownwardAPIVolumeSource::new)
    }
}

impl ::protobuf::Clear for DownwardAPIVolumeSource {
    fn clear(&mut self) {
        self.items.clear();
        self.defaultMode = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DownwardAPIVolumeSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DownwardAPIVolumeSource {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EmptyDirVolumeSource {
    // message fields
    medium: ::protobuf::SingularField<::std::string::String>,
    pub sizeLimit: ::protobuf::SingularPtrField<super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EmptyDirVolumeSource {
    fn default() -> &'a EmptyDirVolumeSource {
        <EmptyDirVolumeSource as ::protobuf::Message>::default_instance()
    }
}

impl EmptyDirVolumeSource {
    pub fn new() -> EmptyDirVolumeSource {
        ::std::default::Default::default()
    }

    // optional string medium = 1;


    pub fn get_medium(&self) -> &str {
        match self.medium.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_medium(&mut self) {
        self.medium.clear();
    }

    pub fn has_medium(&self) -> bool {
        self.medium.is_some()
    }

    // Param is passed by value, moved
    pub fn set_medium(&mut self, v: ::std::string::String) {
        self.medium = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_medium(&mut self) -> &mut ::std::string::String {
        if self.medium.is_none() {
            self.medium.set_default();
        }
        self.medium.as_mut().unwrap()
    }

    // Take field
    pub fn take_medium(&mut self) -> ::std::string::String {
        self.medium.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .k8s.io.apimachinery.pkg.api.resource.Quantity sizeLimit = 2;


    pub fn get_sizeLimit(&self) -> &super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity {
        self.sizeLimit.as_ref().unwrap_or_else(|| <super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity as ::protobuf::Message>::default_instance())
    }
    pub fn clear_sizeLimit(&mut self) {
        self.sizeLimit.clear();
    }

    pub fn has_sizeLimit(&self) -> bool {
        self.sizeLimit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sizeLimit(&mut self, v: super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity) {
        self.sizeLimit = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sizeLimit(&mut self) -> &mut super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity {
        if self.sizeLimit.is_none() {
            self.sizeLimit.set_default();
        }
        self.sizeLimit.as_mut().unwrap()
    }

    // Take field
    pub fn take_sizeLimit(&mut self) -> super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity {
        self.sizeLimit.take().unwrap_or_else(|| super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity::new())
    }
}

impl ::protobuf::Message for EmptyDirVolumeSource {
    fn is_initialized(&self) -> bool {
        for v in &self.sizeLimit {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.medium)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.sizeLimit)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.medium.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.sizeLimit.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.medium.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.sizeLimit.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EmptyDirVolumeSource {
        EmptyDirVolumeSource::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "medium",
                |m: &EmptyDirVolumeSource| { &m.medium },
                |m: &mut EmptyDirVolumeSource| { &mut m.medium },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity>>(
                "sizeLimit",
                |m: &EmptyDirVolumeSource| { &m.sizeLimit },
                |m: &mut EmptyDirVolumeSource| { &mut m.sizeLimit },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EmptyDirVolumeSource>(
                "EmptyDirVolumeSource",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EmptyDirVolumeSource {
        static instance: ::protobuf::rt::LazyV2<EmptyDirVolumeSource> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EmptyDirVolumeSource::new)
    }
}

impl ::protobuf::Clear for EmptyDirVolumeSource {
    fn clear(&mut self) {
        self.medium.clear();
        self.sizeLimit.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EmptyDirVolumeSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EmptyDirVolumeSource {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EndpointAddress {
    // message fields
    ip: ::protobuf::SingularField<::std::string::String>,
    hostname: ::protobuf::SingularField<::std::string::String>,
    nodeName: ::protobuf::SingularField<::std::string::String>,
    pub targetRef: ::protobuf::SingularPtrField<ObjectReference>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EndpointAddress {
    fn default() -> &'a EndpointAddress {
        <EndpointAddress as ::protobuf::Message>::default_instance()
    }
}

impl EndpointAddress {
    pub fn new() -> EndpointAddress {
        ::std::default::Default::default()
    }

    // optional string ip = 1;


    pub fn get_ip(&self) -> &str {
        match self.ip.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_ip(&mut self) {
        self.ip.clear();
    }

    pub fn has_ip(&self) -> bool {
        self.ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ip(&mut self, v: ::std::string::String) {
        self.ip = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ip(&mut self) -> &mut ::std::string::String {
        if self.ip.is_none() {
            self.ip.set_default();
        }
        self.ip.as_mut().unwrap()
    }

    // Take field
    pub fn take_ip(&mut self) -> ::std::string::String {
        self.ip.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string hostname = 3;


    pub fn get_hostname(&self) -> &str {
        match self.hostname.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_hostname(&mut self) {
        self.hostname.clear();
    }

    pub fn has_hostname(&self) -> bool {
        self.hostname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hostname(&mut self, v: ::std::string::String) {
        self.hostname = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hostname(&mut self) -> &mut ::std::string::String {
        if self.hostname.is_none() {
            self.hostname.set_default();
        }
        self.hostname.as_mut().unwrap()
    }

    // Take field
    pub fn take_hostname(&mut self) -> ::std::string::String {
        self.hostname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string nodeName = 4;


    pub fn get_nodeName(&self) -> &str {
        match self.nodeName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_nodeName(&mut self) {
        self.nodeName.clear();
    }

    pub fn has_nodeName(&self) -> bool {
        self.nodeName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nodeName(&mut self, v: ::std::string::String) {
        self.nodeName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nodeName(&mut self) -> &mut ::std::string::String {
        if self.nodeName.is_none() {
            self.nodeName.set_default();
        }
        self.nodeName.as_mut().unwrap()
    }

    // Take field
    pub fn take_nodeName(&mut self) -> ::std::string::String {
        self.nodeName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .k8s.io.api.core.v1.ObjectReference targetRef = 2;


    pub fn get_targetRef(&self) -> &ObjectReference {
        self.targetRef.as_ref().unwrap_or_else(|| <ObjectReference as ::protobuf::Message>::default_instance())
    }
    pub fn clear_targetRef(&mut self) {
        self.targetRef.clear();
    }

    pub fn has_targetRef(&self) -> bool {
        self.targetRef.is_some()
    }

    // Param is passed by value, moved
    pub fn set_targetRef(&mut self, v: ObjectReference) {
        self.targetRef = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_targetRef(&mut self) -> &mut ObjectReference {
        if self.targetRef.is_none() {
            self.targetRef.set_default();
        }
        self.targetRef.as_mut().unwrap()
    }

    // Take field
    pub fn take_targetRef(&mut self) -> ObjectReference {
        self.targetRef.take().unwrap_or_else(|| ObjectReference::new())
    }
}

impl ::protobuf::Message for EndpointAddress {
    fn is_initialized(&self) -> bool {
        for v in &self.targetRef {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.ip)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.hostname)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.nodeName)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.targetRef)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.ip.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.hostname.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.nodeName.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.targetRef.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.ip.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.hostname.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.nodeName.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.targetRef.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EndpointAddress {
        EndpointAddress::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "ip",
                |m: &EndpointAddress| { &m.ip },
                |m: &mut EndpointAddress| { &mut m.ip },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "hostname",
                |m: &EndpointAddress| { &m.hostname },
                |m: &mut EndpointAddress| { &mut m.hostname },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "nodeName",
                |m: &EndpointAddress| { &m.nodeName },
                |m: &mut EndpointAddress| { &mut m.nodeName },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ObjectReference>>(
                "targetRef",
                |m: &EndpointAddress| { &m.targetRef },
                |m: &mut EndpointAddress| { &mut m.targetRef },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EndpointAddress>(
                "EndpointAddress",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EndpointAddress {
        static instance: ::protobuf::rt::LazyV2<EndpointAddress> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EndpointAddress::new)
    }
}

impl ::protobuf::Clear for EndpointAddress {
    fn clear(&mut self) {
        self.ip.clear();
        self.hostname.clear();
        self.nodeName.clear();
        self.targetRef.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EndpointAddress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EndpointAddress {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EndpointPort {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    port: ::std::option::Option<i32>,
    protocol: ::protobuf::SingularField<::std::string::String>,
    appProtocol: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EndpointPort {
    fn default() -> &'a EndpointPort {
        <EndpointPort as ::protobuf::Message>::default_instance()
    }
}

impl EndpointPort {
    pub fn new() -> EndpointPort {
        ::std::default::Default::default()
    }

    // optional string name = 1;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 port = 2;


    pub fn get_port(&self) -> i32 {
        self.port.unwrap_or(0)
    }
    pub fn clear_port(&mut self) {
        self.port = ::std::option::Option::None;
    }

    pub fn has_port(&self) -> bool {
        self.port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_port(&mut self, v: i32) {
        self.port = ::std::option::Option::Some(v);
    }

    // optional string protocol = 3;


    pub fn get_protocol(&self) -> &str {
        match self.protocol.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_protocol(&mut self) {
        self.protocol.clear();
    }

    pub fn has_protocol(&self) -> bool {
        self.protocol.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protocol(&mut self, v: ::std::string::String) {
        self.protocol = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_protocol(&mut self) -> &mut ::std::string::String {
        if self.protocol.is_none() {
            self.protocol.set_default();
        }
        self.protocol.as_mut().unwrap()
    }

    // Take field
    pub fn take_protocol(&mut self) -> ::std::string::String {
        self.protocol.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string appProtocol = 4;


    pub fn get_appProtocol(&self) -> &str {
        match self.appProtocol.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_appProtocol(&mut self) {
        self.appProtocol.clear();
    }

    pub fn has_appProtocol(&self) -> bool {
        self.appProtocol.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appProtocol(&mut self, v: ::std::string::String) {
        self.appProtocol = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_appProtocol(&mut self) -> &mut ::std::string::String {
        if self.appProtocol.is_none() {
            self.appProtocol.set_default();
        }
        self.appProtocol.as_mut().unwrap()
    }

    // Take field
    pub fn take_appProtocol(&mut self) -> ::std::string::String {
        self.appProtocol.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for EndpointPort {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.port = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.protocol)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.appProtocol)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.port {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.protocol.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.appProtocol.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.port {
            os.write_int32(2, v)?;
        }
        if let Some(ref v) = self.protocol.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.appProtocol.as_ref() {
            os.write_string(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EndpointPort {
        EndpointPort::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &EndpointPort| { &m.name },
                |m: &mut EndpointPort| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "port",
                |m: &EndpointPort| { &m.port },
                |m: &mut EndpointPort| { &mut m.port },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "protocol",
                |m: &EndpointPort| { &m.protocol },
                |m: &mut EndpointPort| { &mut m.protocol },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "appProtocol",
                |m: &EndpointPort| { &m.appProtocol },
                |m: &mut EndpointPort| { &mut m.appProtocol },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EndpointPort>(
                "EndpointPort",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EndpointPort {
        static instance: ::protobuf::rt::LazyV2<EndpointPort> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EndpointPort::new)
    }
}

impl ::protobuf::Clear for EndpointPort {
    fn clear(&mut self) {
        self.name.clear();
        self.port = ::std::option::Option::None;
        self.protocol.clear();
        self.appProtocol.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EndpointPort {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EndpointPort {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EndpointSubset {
    // message fields
    pub addresses: ::protobuf::RepeatedField<EndpointAddress>,
    pub notReadyAddresses: ::protobuf::RepeatedField<EndpointAddress>,
    pub ports: ::protobuf::RepeatedField<EndpointPort>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EndpointSubset {
    fn default() -> &'a EndpointSubset {
        <EndpointSubset as ::protobuf::Message>::default_instance()
    }
}

impl EndpointSubset {
    pub fn new() -> EndpointSubset {
        ::std::default::Default::default()
    }

    // repeated .k8s.io.api.core.v1.EndpointAddress addresses = 1;


    pub fn get_addresses(&self) -> &[EndpointAddress] {
        &self.addresses
    }
    pub fn clear_addresses(&mut self) {
        self.addresses.clear();
    }

    // Param is passed by value, moved
    pub fn set_addresses(&mut self, v: ::protobuf::RepeatedField<EndpointAddress>) {
        self.addresses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_addresses(&mut self) -> &mut ::protobuf::RepeatedField<EndpointAddress> {
        &mut self.addresses
    }

    // Take field
    pub fn take_addresses(&mut self) -> ::protobuf::RepeatedField<EndpointAddress> {
        ::std::mem::replace(&mut self.addresses, ::protobuf::RepeatedField::new())
    }

    // repeated .k8s.io.api.core.v1.EndpointAddress notReadyAddresses = 2;


    pub fn get_notReadyAddresses(&self) -> &[EndpointAddress] {
        &self.notReadyAddresses
    }
    pub fn clear_notReadyAddresses(&mut self) {
        self.notReadyAddresses.clear();
    }

    // Param is passed by value, moved
    pub fn set_notReadyAddresses(&mut self, v: ::protobuf::RepeatedField<EndpointAddress>) {
        self.notReadyAddresses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_notReadyAddresses(&mut self) -> &mut ::protobuf::RepeatedField<EndpointAddress> {
        &mut self.notReadyAddresses
    }

    // Take field
    pub fn take_notReadyAddresses(&mut self) -> ::protobuf::RepeatedField<EndpointAddress> {
        ::std::mem::replace(&mut self.notReadyAddresses, ::protobuf::RepeatedField::new())
    }

    // repeated .k8s.io.api.core.v1.EndpointPort ports = 3;


    pub fn get_ports(&self) -> &[EndpointPort] {
        &self.ports
    }
    pub fn clear_ports(&mut self) {
        self.ports.clear();
    }

    // Param is passed by value, moved
    pub fn set_ports(&mut self, v: ::protobuf::RepeatedField<EndpointPort>) {
        self.ports = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ports(&mut self) -> &mut ::protobuf::RepeatedField<EndpointPort> {
        &mut self.ports
    }

    // Take field
    pub fn take_ports(&mut self) -> ::protobuf::RepeatedField<EndpointPort> {
        ::std::mem::replace(&mut self.ports, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for EndpointSubset {
    fn is_initialized(&self) -> bool {
        for v in &self.addresses {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.notReadyAddresses {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ports {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.addresses)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.notReadyAddresses)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.ports)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.addresses {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.notReadyAddresses {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.ports {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.addresses {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.notReadyAddresses {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.ports {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EndpointSubset {
        EndpointSubset::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EndpointAddress>>(
                "addresses",
                |m: &EndpointSubset| { &m.addresses },
                |m: &mut EndpointSubset| { &mut m.addresses },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EndpointAddress>>(
                "notReadyAddresses",
                |m: &EndpointSubset| { &m.notReadyAddresses },
                |m: &mut EndpointSubset| { &mut m.notReadyAddresses },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EndpointPort>>(
                "ports",
                |m: &EndpointSubset| { &m.ports },
                |m: &mut EndpointSubset| { &mut m.ports },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EndpointSubset>(
                "EndpointSubset",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EndpointSubset {
        static instance: ::protobuf::rt::LazyV2<EndpointSubset> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EndpointSubset::new)
    }
}

impl ::protobuf::Clear for EndpointSubset {
    fn clear(&mut self) {
        self.addresses.clear();
        self.notReadyAddresses.clear();
        self.ports.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EndpointSubset {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EndpointSubset {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Endpoints {
    // message fields
    pub metadata: ::protobuf::SingularPtrField<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta>,
    pub subsets: ::protobuf::RepeatedField<EndpointSubset>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Endpoints {
    fn default() -> &'a Endpoints {
        <Endpoints as ::protobuf::Message>::default_instance()
    }
}

impl Endpoints {
    pub fn new() -> Endpoints {
        ::std::default::Default::default()
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;


    pub fn get_metadata(&self) -> &super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta::new())
    }

    // repeated .k8s.io.api.core.v1.EndpointSubset subsets = 2;


    pub fn get_subsets(&self) -> &[EndpointSubset] {
        &self.subsets
    }
    pub fn clear_subsets(&mut self) {
        self.subsets.clear();
    }

    // Param is passed by value, moved
    pub fn set_subsets(&mut self, v: ::protobuf::RepeatedField<EndpointSubset>) {
        self.subsets = v;
    }

    // Mutable pointer to the field.
    pub fn mut_subsets(&mut self) -> &mut ::protobuf::RepeatedField<EndpointSubset> {
        &mut self.subsets
    }

    // Take field
    pub fn take_subsets(&mut self) -> ::protobuf::RepeatedField<EndpointSubset> {
        ::std::mem::replace(&mut self.subsets, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Endpoints {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.subsets {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.subsets)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.subsets {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.subsets {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Endpoints {
        Endpoints::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta>>(
                "metadata",
                |m: &Endpoints| { &m.metadata },
                |m: &mut Endpoints| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EndpointSubset>>(
                "subsets",
                |m: &Endpoints| { &m.subsets },
                |m: &mut Endpoints| { &mut m.subsets },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Endpoints>(
                "Endpoints",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Endpoints {
        static instance: ::protobuf::rt::LazyV2<Endpoints> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Endpoints::new)
    }
}

impl ::protobuf::Clear for Endpoints {
    fn clear(&mut self) {
        self.metadata.clear();
        self.subsets.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Endpoints {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Endpoints {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EndpointsList {
    // message fields
    pub metadata: ::protobuf::SingularPtrField<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta>,
    pub items: ::protobuf::RepeatedField<Endpoints>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EndpointsList {
    fn default() -> &'a EndpointsList {
        <EndpointsList as ::protobuf::Message>::default_instance()
    }
}

impl EndpointsList {
    pub fn new() -> EndpointsList {
        ::std::default::Default::default()
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;


    pub fn get_metadata(&self) -> &super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta {
        self.metadata.take().unwrap_or_else(|| super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta::new())
    }

    // repeated .k8s.io.api.core.v1.Endpoints items = 2;


    pub fn get_items(&self) -> &[Endpoints] {
        &self.items
    }
    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::protobuf::RepeatedField<Endpoints>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::protobuf::RepeatedField<Endpoints> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::protobuf::RepeatedField<Endpoints> {
        ::std::mem::replace(&mut self.items, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for EndpointsList {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.items {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.items)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.items {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EndpointsList {
        EndpointsList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta>>(
                "metadata",
                |m: &EndpointsList| { &m.metadata },
                |m: &mut EndpointsList| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Endpoints>>(
                "items",
                |m: &EndpointsList| { &m.items },
                |m: &mut EndpointsList| { &mut m.items },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EndpointsList>(
                "EndpointsList",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EndpointsList {
        static instance: ::protobuf::rt::LazyV2<EndpointsList> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EndpointsList::new)
    }
}

impl ::protobuf::Clear for EndpointsList {
    fn clear(&mut self) {
        self.metadata.clear();
        self.items.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EndpointsList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EndpointsList {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EnvFromSource {
    // message fields
    prefix: ::protobuf::SingularField<::std::string::String>,
    pub configMapRef: ::protobuf::SingularPtrField<ConfigMapEnvSource>,
    pub secretRef: ::protobuf::SingularPtrField<SecretEnvSource>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EnvFromSource {
    fn default() -> &'a EnvFromSource {
        <EnvFromSource as ::protobuf::Message>::default_instance()
    }
}

impl EnvFromSource {
    pub fn new() -> EnvFromSource {
        ::std::default::Default::default()
    }

    // optional string prefix = 1;


    pub fn get_prefix(&self) -> &str {
        match self.prefix.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_prefix(&mut self) {
        self.prefix.clear();
    }

    pub fn has_prefix(&self) -> bool {
        self.prefix.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prefix(&mut self, v: ::std::string::String) {
        self.prefix = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_prefix(&mut self) -> &mut ::std::string::String {
        if self.prefix.is_none() {
            self.prefix.set_default();
        }
        self.prefix.as_mut().unwrap()
    }

    // Take field
    pub fn take_prefix(&mut self) -> ::std::string::String {
        self.prefix.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .k8s.io.api.core.v1.ConfigMapEnvSource configMapRef = 2;


    pub fn get_configMapRef(&self) -> &ConfigMapEnvSource {
        self.configMapRef.as_ref().unwrap_or_else(|| <ConfigMapEnvSource as ::protobuf::Message>::default_instance())
    }
    pub fn clear_configMapRef(&mut self) {
        self.configMapRef.clear();
    }

    pub fn has_configMapRef(&self) -> bool {
        self.configMapRef.is_some()
    }

    // Param is passed by value, moved
    pub fn set_configMapRef(&mut self, v: ConfigMapEnvSource) {
        self.configMapRef = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_configMapRef(&mut self) -> &mut ConfigMapEnvSource {
        if self.configMapRef.is_none() {
            self.configMapRef.set_default();
        }
        self.configMapRef.as_mut().unwrap()
    }

    // Take field
    pub fn take_configMapRef(&mut self) -> ConfigMapEnvSource {
        self.configMapRef.take().unwrap_or_else(|| ConfigMapEnvSource::new())
    }

    // optional .k8s.io.api.core.v1.SecretEnvSource secretRef = 3;


    pub fn get_secretRef(&self) -> &SecretEnvSource {
        self.secretRef.as_ref().unwrap_or_else(|| <SecretEnvSource as ::protobuf::Message>::default_instance())
    }
    pub fn clear_secretRef(&mut self) {
        self.secretRef.clear();
    }

    pub fn has_secretRef(&self) -> bool {
        self.secretRef.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secretRef(&mut self, v: SecretEnvSource) {
        self.secretRef = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_secretRef(&mut self) -> &mut SecretEnvSource {
        if self.secretRef.is_none() {
            self.secretRef.set_default();
        }
        self.secretRef.as_mut().unwrap()
    }

    // Take field
    pub fn take_secretRef(&mut self) -> SecretEnvSource {
        self.secretRef.take().unwrap_or_else(|| SecretEnvSource::new())
    }
}

impl ::protobuf::Message for EnvFromSource {
    fn is_initialized(&self) -> bool {
        for v in &self.configMapRef {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.secretRef {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.prefix)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.configMapRef)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.secretRef)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.prefix.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.configMapRef.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.secretRef.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.prefix.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.configMapRef.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.secretRef.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EnvFromSource {
        EnvFromSource::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "prefix",
                |m: &EnvFromSource| { &m.prefix },
                |m: &mut EnvFromSource| { &mut m.prefix },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ConfigMapEnvSource>>(
                "configMapRef",
                |m: &EnvFromSource| { &m.configMapRef },
                |m: &mut EnvFromSource| { &mut m.configMapRef },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SecretEnvSource>>(
                "secretRef",
                |m: &EnvFromSource| { &m.secretRef },
                |m: &mut EnvFromSource| { &mut m.secretRef },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EnvFromSource>(
                "EnvFromSource",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EnvFromSource {
        static instance: ::protobuf::rt::LazyV2<EnvFromSource> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EnvFromSource::new)
    }
}

impl ::protobuf::Clear for EnvFromSource {
    fn clear(&mut self) {
        self.prefix.clear();
        self.configMapRef.clear();
        self.secretRef.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EnvFromSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EnvFromSource {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EnvVar {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    value: ::protobuf::SingularField<::std::string::String>,
    pub valueFrom: ::protobuf::SingularPtrField<EnvVarSource>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EnvVar {
    fn default() -> &'a EnvVar {
        <EnvVar as ::protobuf::Message>::default_instance()
    }
}

impl EnvVar {
    pub fn new() -> EnvVar {
        ::std::default::Default::default()
    }

    // optional string name = 1;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string value = 2;


    pub fn get_value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        if self.value.is_none() {
            self.value.set_default();
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .k8s.io.api.core.v1.EnvVarSource valueFrom = 3;


    pub fn get_valueFrom(&self) -> &EnvVarSource {
        self.valueFrom.as_ref().unwrap_or_else(|| <EnvVarSource as ::protobuf::Message>::default_instance())
    }
    pub fn clear_valueFrom(&mut self) {
        self.valueFrom.clear();
    }

    pub fn has_valueFrom(&self) -> bool {
        self.valueFrom.is_some()
    }

    // Param is passed by value, moved
    pub fn set_valueFrom(&mut self, v: EnvVarSource) {
        self.valueFrom = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_valueFrom(&mut self) -> &mut EnvVarSource {
        if self.valueFrom.is_none() {
            self.valueFrom.set_default();
        }
        self.valueFrom.as_mut().unwrap()
    }

    // Take field
    pub fn take_valueFrom(&mut self) -> EnvVarSource {
        self.valueFrom.take().unwrap_or_else(|| EnvVarSource::new())
    }
}

impl ::protobuf::Message for EnvVar {
    fn is_initialized(&self) -> bool {
        for v in &self.valueFrom {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.value)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.valueFrom)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.value.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.valueFrom.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.value.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.valueFrom.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EnvVar {
        EnvVar::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &EnvVar| { &m.name },
                |m: &mut EnvVar| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "value",
                |m: &EnvVar| { &m.value },
                |m: &mut EnvVar| { &mut m.value },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EnvVarSource>>(
                "valueFrom",
                |m: &EnvVar| { &m.valueFrom },
                |m: &mut EnvVar| { &mut m.valueFrom },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EnvVar>(
                "EnvVar",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EnvVar {
        static instance: ::protobuf::rt::LazyV2<EnvVar> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EnvVar::new)
    }
}

impl ::protobuf::Clear for EnvVar {
    fn clear(&mut self) {
        self.name.clear();
        self.value.clear();
        self.valueFrom.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EnvVar {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EnvVar {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EnvVarSource {
    // message fields
    pub fieldRef: ::protobuf::SingularPtrField<ObjectFieldSelector>,
    pub resourceFieldRef: ::protobuf::SingularPtrField<ResourceFieldSelector>,
    pub configMapKeyRef: ::protobuf::SingularPtrField<ConfigMapKeySelector>,
    pub secretKeyRef: ::protobuf::SingularPtrField<SecretKeySelector>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EnvVarSource {
    fn default() -> &'a EnvVarSource {
        <EnvVarSource as ::protobuf::Message>::default_instance()
    }
}

impl EnvVarSource {
    pub fn new() -> EnvVarSource {
        ::std::default::Default::default()
    }

    // optional .k8s.io.api.core.v1.ObjectFieldSelector fieldRef = 1;


    pub fn get_fieldRef(&self) -> &ObjectFieldSelector {
        self.fieldRef.as_ref().unwrap_or_else(|| <ObjectFieldSelector as ::protobuf::Message>::default_instance())
    }
    pub fn clear_fieldRef(&mut self) {
        self.fieldRef.clear();
    }

    pub fn has_fieldRef(&self) -> bool {
        self.fieldRef.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fieldRef(&mut self, v: ObjectFieldSelector) {
        self.fieldRef = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fieldRef(&mut self) -> &mut ObjectFieldSelector {
        if self.fieldRef.is_none() {
            self.fieldRef.set_default();
        }
        self.fieldRef.as_mut().unwrap()
    }

    // Take field
    pub fn take_fieldRef(&mut self) -> ObjectFieldSelector {
        self.fieldRef.take().unwrap_or_else(|| ObjectFieldSelector::new())
    }

    // optional .k8s.io.api.core.v1.ResourceFieldSelector resourceFieldRef = 2;


    pub fn get_resourceFieldRef(&self) -> &ResourceFieldSelector {
        self.resourceFieldRef.as_ref().unwrap_or_else(|| <ResourceFieldSelector as ::protobuf::Message>::default_instance())
    }
    pub fn clear_resourceFieldRef(&mut self) {
        self.resourceFieldRef.clear();
    }

    pub fn has_resourceFieldRef(&self) -> bool {
        self.resourceFieldRef.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resourceFieldRef(&mut self, v: ResourceFieldSelector) {
        self.resourceFieldRef = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_resourceFieldRef(&mut self) -> &mut ResourceFieldSelector {
        if self.resourceFieldRef.is_none() {
            self.resourceFieldRef.set_default();
        }
        self.resourceFieldRef.as_mut().unwrap()
    }

    // Take field
    pub fn take_resourceFieldRef(&mut self) -> ResourceFieldSelector {
        self.resourceFieldRef.take().unwrap_or_else(|| ResourceFieldSelector::new())
    }

    // optional .k8s.io.api.core.v1.ConfigMapKeySelector configMapKeyRef = 3;


    pub fn get_configMapKeyRef(&self) -> &ConfigMapKeySelector {
        self.configMapKeyRef.as_ref().unwrap_or_else(|| <ConfigMapKeySelector as ::protobuf::Message>::default_instance())
    }
    pub fn clear_configMapKeyRef(&mut self) {
        self.configMapKeyRef.clear();
    }

    pub fn has_configMapKeyRef(&self) -> bool {
        self.configMapKeyRef.is_some()
    }

    // Param is passed by value, moved
    pub fn set_configMapKeyRef(&mut self, v: ConfigMapKeySelector) {
        self.configMapKeyRef = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_configMapKeyRef(&mut self) -> &mut ConfigMapKeySelector {
        if self.configMapKeyRef.is_none() {
            self.configMapKeyRef.set_default();
        }
        self.configMapKeyRef.as_mut().unwrap()
    }

    // Take field
    pub fn take_configMapKeyRef(&mut self) -> ConfigMapKeySelector {
        self.configMapKeyRef.take().unwrap_or_else(|| ConfigMapKeySelector::new())
    }

    // optional .k8s.io.api.core.v1.SecretKeySelector secretKeyRef = 4;


    pub fn get_secretKeyRef(&self) -> &SecretKeySelector {
        self.secretKeyRef.as_ref().unwrap_or_else(|| <SecretKeySelector as ::protobuf::Message>::default_instance())
    }
    pub fn clear_secretKeyRef(&mut self) {
        self.secretKeyRef.clear();
    }

    pub fn has_secretKeyRef(&self) -> bool {
        self.secretKeyRef.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secretKeyRef(&mut self, v: SecretKeySelector) {
        self.secretKeyRef = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_secretKeyRef(&mut self) -> &mut SecretKeySelector {
        if self.secretKeyRef.is_none() {
            self.secretKeyRef.set_default();
        }
        self.secretKeyRef.as_mut().unwrap()
    }

    // Take field
    pub fn take_secretKeyRef(&mut self) -> SecretKeySelector {
        self.secretKeyRef.take().unwrap_or_else(|| SecretKeySelector::new())
    }
}

impl ::protobuf::Message for EnvVarSource {
    fn is_initialized(&self) -> bool {
        for v in &self.fieldRef {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.resourceFieldRef {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.configMapKeyRef {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.secretKeyRef {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.fieldRef)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.resourceFieldRef)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.configMapKeyRef)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.secretKeyRef)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.fieldRef.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.resourceFieldRef.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.configMapKeyRef.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.secretKeyRef.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.fieldRef.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.resourceFieldRef.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.configMapKeyRef.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.secretKeyRef.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EnvVarSource {
        EnvVarSource::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ObjectFieldSelector>>(
                "fieldRef",
                |m: &EnvVarSource| { &m.fieldRef },
                |m: &mut EnvVarSource| { &mut m.fieldRef },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResourceFieldSelector>>(
                "resourceFieldRef",
                |m: &EnvVarSource| { &m.resourceFieldRef },
                |m: &mut EnvVarSource| { &mut m.resourceFieldRef },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ConfigMapKeySelector>>(
                "configMapKeyRef",
                |m: &EnvVarSource| { &m.configMapKeyRef },
                |m: &mut EnvVarSource| { &mut m.configMapKeyRef },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SecretKeySelector>>(
                "secretKeyRef",
                |m: &EnvVarSource| { &m.secretKeyRef },
                |m: &mut EnvVarSource| { &mut m.secretKeyRef },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EnvVarSource>(
                "EnvVarSource",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EnvVarSource {
        static instance: ::protobuf::rt::LazyV2<EnvVarSource> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EnvVarSource::new)
    }
}

impl ::protobuf::Clear for EnvVarSource {
    fn clear(&mut self) {
        self.fieldRef.clear();
        self.resourceFieldRef.clear();
        self.configMapKeyRef.clear();
        self.secretKeyRef.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EnvVarSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EnvVarSource {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EphemeralContainer {
    // message fields
    pub ephemeralContainerCommon: ::protobuf::SingularPtrField<EphemeralContainerCommon>,
    targetContainerName: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EphemeralContainer {
    fn default() -> &'a EphemeralContainer {
        <EphemeralContainer as ::protobuf::Message>::default_instance()
    }
}

impl EphemeralContainer {
    pub fn new() -> EphemeralContainer {
        ::std::default::Default::default()
    }

    // optional .k8s.io.api.core.v1.EphemeralContainerCommon ephemeralContainerCommon = 1;


    pub fn get_ephemeralContainerCommon(&self) -> &EphemeralContainerCommon {
        self.ephemeralContainerCommon.as_ref().unwrap_or_else(|| <EphemeralContainerCommon as ::protobuf::Message>::default_instance())
    }
    pub fn clear_ephemeralContainerCommon(&mut self) {
        self.ephemeralContainerCommon.clear();
    }

    pub fn has_ephemeralContainerCommon(&self) -> bool {
        self.ephemeralContainerCommon.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ephemeralContainerCommon(&mut self, v: EphemeralContainerCommon) {
        self.ephemeralContainerCommon = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ephemeralContainerCommon(&mut self) -> &mut EphemeralContainerCommon {
        if self.ephemeralContainerCommon.is_none() {
            self.ephemeralContainerCommon.set_default();
        }
        self.ephemeralContainerCommon.as_mut().unwrap()
    }

    // Take field
    pub fn take_ephemeralContainerCommon(&mut self) -> EphemeralContainerCommon {
        self.ephemeralContainerCommon.take().unwrap_or_else(|| EphemeralContainerCommon::new())
    }

    // optional string targetContainerName = 2;


    pub fn get_targetContainerName(&self) -> &str {
        match self.targetContainerName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_targetContainerName(&mut self) {
        self.targetContainerName.clear();
    }

    pub fn has_targetContainerName(&self) -> bool {
        self.targetContainerName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_targetContainerName(&mut self, v: ::std::string::String) {
        self.targetContainerName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_targetContainerName(&mut self) -> &mut ::std::string::String {
        if self.targetContainerName.is_none() {
            self.targetContainerName.set_default();
        }
        self.targetContainerName.as_mut().unwrap()
    }

    // Take field
    pub fn take_targetContainerName(&mut self) -> ::std::string::String {
        self.targetContainerName.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for EphemeralContainer {
    fn is_initialized(&self) -> bool {
        for v in &self.ephemeralContainerCommon {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ephemeralContainerCommon)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.targetContainerName)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.ephemeralContainerCommon.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.targetContainerName.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.ephemeralContainerCommon.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.targetContainerName.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EphemeralContainer {
        EphemeralContainer::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EphemeralContainerCommon>>(
                "ephemeralContainerCommon",
                |m: &EphemeralContainer| { &m.ephemeralContainerCommon },
                |m: &mut EphemeralContainer| { &mut m.ephemeralContainerCommon },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "targetContainerName",
                |m: &EphemeralContainer| { &m.targetContainerName },
                |m: &mut EphemeralContainer| { &mut m.targetContainerName },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EphemeralContainer>(
                "EphemeralContainer",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EphemeralContainer {
        static instance: ::protobuf::rt::LazyV2<EphemeralContainer> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EphemeralContainer::new)
    }
}

impl ::protobuf::Clear for EphemeralContainer {
    fn clear(&mut self) {
        self.ephemeralContainerCommon.clear();
        self.targetContainerName.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EphemeralContainer {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EphemeralContainer {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EphemeralContainerCommon {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    image: ::protobuf::SingularField<::std::string::String>,
    pub command: ::protobuf::RepeatedField<::std::string::String>,
    pub args: ::protobuf::RepeatedField<::std::string::String>,
    workingDir: ::protobuf::SingularField<::std::string::String>,
    pub ports: ::protobuf::RepeatedField<ContainerPort>,
    pub envFrom: ::protobuf::RepeatedField<EnvFromSource>,
    pub env: ::protobuf::RepeatedField<EnvVar>,
    pub resources: ::protobuf::SingularPtrField<ResourceRequirements>,
    pub volumeMounts: ::protobuf::RepeatedField<VolumeMount>,
    pub volumeDevices: ::protobuf::RepeatedField<VolumeDevice>,
    pub livenessProbe: ::protobuf::SingularPtrField<Probe>,
    pub readinessProbe: ::protobuf::SingularPtrField<Probe>,
    pub startupProbe: ::protobuf::SingularPtrField<Probe>,
    pub lifecycle: ::protobuf::SingularPtrField<Lifecycle>,
    terminationMessagePath: ::protobuf::SingularField<::std::string::String>,
    terminationMessagePolicy: ::protobuf::SingularField<::std::string::String>,
    imagePullPolicy: ::protobuf::SingularField<::std::string::String>,
    pub securityContext: ::protobuf::SingularPtrField<SecurityContext>,
    stdin: ::std::option::Option<bool>,
    stdinOnce: ::std::option::Option<bool>,
    tty: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EphemeralContainerCommon {
    fn default() -> &'a EphemeralContainerCommon {
        <EphemeralContainerCommon as ::protobuf::Message>::default_instance()
    }
}

impl EphemeralContainerCommon {
    pub fn new() -> EphemeralContainerCommon {
        ::std::default::Default::default()
    }

    // optional string name = 1;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string image = 2;


    pub fn get_image(&self) -> &str {
        match self.image.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_image(&mut self) {
        self.image.clear();
    }

    pub fn has_image(&self) -> bool {
        self.image.is_some()
    }

    // Param is passed by value, moved
    pub fn set_image(&mut self, v: ::std::string::String) {
        self.image = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_image(&mut self) -> &mut ::std::string::String {
        if self.image.is_none() {
            self.image.set_default();
        }
        self.image.as_mut().unwrap()
    }

    // Take field
    pub fn take_image(&mut self) -> ::std::string::String {
        self.image.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated string command = 3;


    pub fn get_command(&self) -> &[::std::string::String] {
        &self.command
    }
    pub fn clear_command(&mut self) {
        self.command.clear();
    }

    // Param is passed by value, moved
    pub fn set_command(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.command = v;
    }

    // Mutable pointer to the field.
    pub fn mut_command(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.command
    }

    // Take field
    pub fn take_command(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.command, ::protobuf::RepeatedField::new())
    }

    // repeated string args = 4;


    pub fn get_args(&self) -> &[::std::string::String] {
        &self.args
    }
    pub fn clear_args(&mut self) {
        self.args.clear();
    }

    // Param is passed by value, moved
    pub fn set_args(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.args = v;
    }

    // Mutable pointer to the field.
    pub fn mut_args(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.args
    }

    // Take field
    pub fn take_args(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.args, ::protobuf::RepeatedField::new())
    }

    // optional string workingDir = 5;


    pub fn get_workingDir(&self) -> &str {
        match self.workingDir.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_workingDir(&mut self) {
        self.workingDir.clear();
    }

    pub fn has_workingDir(&self) -> bool {
        self.workingDir.is_some()
    }

    // Param is passed by value, moved
    pub fn set_workingDir(&mut self, v: ::std::string::String) {
        self.workingDir = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_workingDir(&mut self) -> &mut ::std::string::String {
        if self.workingDir.is_none() {
            self.workingDir.set_default();
        }
        self.workingDir.as_mut().unwrap()
    }

    // Take field
    pub fn take_workingDir(&mut self) -> ::std::string::String {
        self.workingDir.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .k8s.io.api.core.v1.ContainerPort ports = 6;


    pub fn get_ports(&self) -> &[ContainerPort] {
        &self.ports
    }
    pub fn clear_ports(&mut self) {
        self.ports.clear();
    }

    // Param is passed by value, moved
    pub fn set_ports(&mut self, v: ::protobuf::RepeatedField<ContainerPort>) {
        self.ports = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ports(&mut self) -> &mut ::protobuf::RepeatedField<ContainerPort> {
        &mut self.ports
    }

    // Take field
    pub fn take_ports(&mut self) -> ::protobuf::RepeatedField<ContainerPort> {
        ::std::mem::replace(&mut self.ports, ::protobuf::RepeatedField::new())
    }

    // repeated .k8s.io.api.core.v1.EnvFromSource envFrom = 19;


    pub fn get_envFrom(&self) -> &[EnvFromSource] {
        &self.envFrom
    }
    pub fn clear_envFrom(&mut self) {
        self.envFrom.clear();
    }

    // Param is passed by value, moved
    pub fn set_envFrom(&mut self, v: ::protobuf::RepeatedField<EnvFromSource>) {
        self.envFrom = v;
    }

    // Mutable pointer to the field.
    pub fn mut_envFrom(&mut self) -> &mut ::protobuf::RepeatedField<EnvFromSource> {
        &mut self.envFrom
    }

    // Take field
    pub fn take_envFrom(&mut self) -> ::protobuf::RepeatedField<EnvFromSource> {
        ::std::mem::replace(&mut self.envFrom, ::protobuf::RepeatedField::new())
    }

    // repeated .k8s.io.api.core.v1.EnvVar env = 7;


    pub fn get_env(&self) -> &[EnvVar] {
        &self.env
    }
    pub fn clear_env(&mut self) {
        self.env.clear();
    }

    // Param is passed by value, moved
    pub fn set_env(&mut self, v: ::protobuf::RepeatedField<EnvVar>) {
        self.env = v;
    }

    // Mutable pointer to the field.
    pub fn mut_env(&mut self) -> &mut ::protobuf::RepeatedField<EnvVar> {
        &mut self.env
    }

    // Take field
    pub fn take_env(&mut self) -> ::protobuf::RepeatedField<EnvVar> {
        ::std::mem::replace(&mut self.env, ::protobuf::RepeatedField::new())
    }

    // optional .k8s.io.api.core.v1.ResourceRequirements resources = 8;


    pub fn get_resources(&self) -> &ResourceRequirements {
        self.resources.as_ref().unwrap_or_else(|| <ResourceRequirements as ::protobuf::Message>::default_instance())
    }
    pub fn clear_resources(&mut self) {
        self.resources.clear();
    }

    pub fn has_resources(&self) -> bool {
        self.resources.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resources(&mut self, v: ResourceRequirements) {
        self.resources = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_resources(&mut self) -> &mut ResourceRequirements {
        if self.resources.is_none() {
            self.resources.set_default();
        }
        self.resources.as_mut().unwrap()
    }

    // Take field
    pub fn take_resources(&mut self) -> ResourceRequirements {
        self.resources.take().unwrap_or_else(|| ResourceRequirements::new())
    }

    // repeated .k8s.io.api.core.v1.VolumeMount volumeMounts = 9;


    pub fn get_volumeMounts(&self) -> &[VolumeMount] {
        &self.volumeMounts
    }
    pub fn clear_volumeMounts(&mut self) {
        self.volumeMounts.clear();
    }

    // Param is passed by value, moved
    pub fn set_volumeMounts(&mut self, v: ::protobuf::RepeatedField<VolumeMount>) {
        self.volumeMounts = v;
    }

    // Mutable pointer to the field.
    pub fn mut_volumeMounts(&mut self) -> &mut ::protobuf::RepeatedField<VolumeMount> {
        &mut self.volumeMounts
    }

    // Take field
    pub fn take_volumeMounts(&mut self) -> ::protobuf::RepeatedField<VolumeMount> {
        ::std::mem::replace(&mut self.volumeMounts, ::protobuf::RepeatedField::new())
    }

    // repeated .k8s.io.api.core.v1.VolumeDevice volumeDevices = 21;


    pub fn get_volumeDevices(&self) -> &[VolumeDevice] {
        &self.volumeDevices
    }
    pub fn clear_volumeDevices(&mut self) {
        self.volumeDevices.clear();
    }

    // Param is passed by value, moved
    pub fn set_volumeDevices(&mut self, v: ::protobuf::RepeatedField<VolumeDevice>) {
        self.volumeDevices = v;
    }

    // Mutable pointer to the field.
    pub fn mut_volumeDevices(&mut self) -> &mut ::protobuf::RepeatedField<VolumeDevice> {
        &mut self.volumeDevices
    }

    // Take field
    pub fn take_volumeDevices(&mut self) -> ::protobuf::RepeatedField<VolumeDevice> {
        ::std::mem::replace(&mut self.volumeDevices, ::protobuf::RepeatedField::new())
    }

    // optional .k8s.io.api.core.v1.Probe livenessProbe = 10;


    pub fn get_livenessProbe(&self) -> &Probe {
        self.livenessProbe.as_ref().unwrap_or_else(|| <Probe as ::protobuf::Message>::default_instance())
    }
    pub fn clear_livenessProbe(&mut self) {
        self.livenessProbe.clear();
    }

    pub fn has_livenessProbe(&self) -> bool {
        self.livenessProbe.is_some()
    }

    // Param is passed by value, moved
    pub fn set_livenessProbe(&mut self, v: Probe) {
        self.livenessProbe = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_livenessProbe(&mut self) -> &mut Probe {
        if self.livenessProbe.is_none() {
            self.livenessProbe.set_default();
        }
        self.livenessProbe.as_mut().unwrap()
    }

    // Take field
    pub fn take_livenessProbe(&mut self) -> Probe {
        self.livenessProbe.take().unwrap_or_else(|| Probe::new())
    }

    // optional .k8s.io.api.core.v1.Probe readinessProbe = 11;


    pub fn get_readinessProbe(&self) -> &Probe {
        self.readinessProbe.as_ref().unwrap_or_else(|| <Probe as ::protobuf::Message>::default_instance())
    }
    pub fn clear_readinessProbe(&mut self) {
        self.readinessProbe.clear();
    }

    pub fn has_readinessProbe(&self) -> bool {
        self.readinessProbe.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readinessProbe(&mut self, v: Probe) {
        self.readinessProbe = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_readinessProbe(&mut self) -> &mut Probe {
        if self.readinessProbe.is_none() {
            self.readinessProbe.set_default();
        }
        self.readinessProbe.as_mut().unwrap()
    }

    // Take field
    pub fn take_readinessProbe(&mut self) -> Probe {
        self.readinessProbe.take().unwrap_or_else(|| Probe::new())
    }

    // optional .k8s.io.api.core.v1.Probe startupProbe = 22;


    pub fn get_startupProbe(&self) -> &Probe {
        self.startupProbe.as_ref().unwrap_or_else(|| <Probe as ::protobuf::Message>::default_instance())
    }
    pub fn clear_startupProbe(&mut self) {
        self.startupProbe.clear();
    }

    pub fn has_startupProbe(&self) -> bool {
        self.startupProbe.is_some()
    }

    // Param is passed by value, moved
    pub fn set_startupProbe(&mut self, v: Probe) {
        self.startupProbe = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_startupProbe(&mut self) -> &mut Probe {
        if self.startupProbe.is_none() {
            self.startupProbe.set_default();
        }
        self.startupProbe.as_mut().unwrap()
    }

    // Take field
    pub fn take_startupProbe(&mut self) -> Probe {
        self.startupProbe.take().unwrap_or_else(|| Probe::new())
    }

    // optional .k8s.io.api.core.v1.Lifecycle lifecycle = 12;


    pub fn get_lifecycle(&self) -> &Lifecycle {
        self.lifecycle.as_ref().unwrap_or_else(|| <Lifecycle as ::protobuf::Message>::default_instance())
    }
    pub fn clear_lifecycle(&mut self) {
        self.lifecycle.clear();
    }

    pub fn has_lifecycle(&self) -> bool {
        self.lifecycle.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lifecycle(&mut self, v: Lifecycle) {
        self.lifecycle = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lifecycle(&mut self) -> &mut Lifecycle {
        if self.lifecycle.is_none() {
            self.lifecycle.set_default();
        }
        self.lifecycle.as_mut().unwrap()
    }

    // Take field
    pub fn take_lifecycle(&mut self) -> Lifecycle {
        self.lifecycle.take().unwrap_or_else(|| Lifecycle::new())
    }

    // optional string terminationMessagePath = 13;


    pub fn get_terminationMessagePath(&self) -> &str {
        match self.terminationMessagePath.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_terminationMessagePath(&mut self) {
        self.terminationMessagePath.clear();
    }

    pub fn has_terminationMessagePath(&self) -> bool {
        self.terminationMessagePath.is_some()
    }

    // Param is passed by value, moved
    pub fn set_terminationMessagePath(&mut self, v: ::std::string::String) {
        self.terminationMessagePath = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_terminationMessagePath(&mut self) -> &mut ::std::string::String {
        if self.terminationMessagePath.is_none() {
            self.terminationMessagePath.set_default();
        }
        self.terminationMessagePath.as_mut().unwrap()
    }

    // Take field
    pub fn take_terminationMessagePath(&mut self) -> ::std::string::String {
        self.terminationMessagePath.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string terminationMessagePolicy = 20;


    pub fn get_terminationMessagePolicy(&self) -> &str {
        match self.terminationMessagePolicy.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_terminationMessagePolicy(&mut self) {
        self.terminationMessagePolicy.clear();
    }

    pub fn has_terminationMessagePolicy(&self) -> bool {
        self.terminationMessagePolicy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_terminationMessagePolicy(&mut self, v: ::std::string::String) {
        self.terminationMessagePolicy = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_terminationMessagePolicy(&mut self) -> &mut ::std::string::String {
        if self.terminationMessagePolicy.is_none() {
            self.terminationMessagePolicy.set_default();
        }
        self.terminationMessagePolicy.as_mut().unwrap()
    }

    // Take field
    pub fn take_terminationMessagePolicy(&mut self) -> ::std::string::String {
        self.terminationMessagePolicy.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string imagePullPolicy = 14;


    pub fn get_imagePullPolicy(&self) -> &str {
        match self.imagePullPolicy.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_imagePullPolicy(&mut self) {
        self.imagePullPolicy.clear();
    }

    pub fn has_imagePullPolicy(&self) -> bool {
        self.imagePullPolicy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_imagePullPolicy(&mut self, v: ::std::string::String) {
        self.imagePullPolicy = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_imagePullPolicy(&mut self) -> &mut ::std::string::String {
        if self.imagePullPolicy.is_none() {
            self.imagePullPolicy.set_default();
        }
        self.imagePullPolicy.as_mut().unwrap()
    }

    // Take field
    pub fn take_imagePullPolicy(&mut self) -> ::std::string::String {
        self.imagePullPolicy.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .k8s.io.api.core.v1.SecurityContext securityContext = 15;


    pub fn get_securityContext(&self) -> &SecurityContext {
        self.securityContext.as_ref().unwrap_or_else(|| <SecurityContext as ::protobuf::Message>::default_instance())
    }
    pub fn clear_securityContext(&mut self) {
        self.securityContext.clear();
    }

    pub fn has_securityContext(&self) -> bool {
        self.securityContext.is_some()
    }

    // Param is passed by value, moved
    pub fn set_securityContext(&mut self, v: SecurityContext) {
        self.securityContext = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_securityContext(&mut self) -> &mut SecurityContext {
        if self.securityContext.is_none() {
            self.securityContext.set_default();
        }
        self.securityContext.as_mut().unwrap()
    }

    // Take field
    pub fn take_securityContext(&mut self) -> SecurityContext {
        self.securityContext.take().unwrap_or_else(|| SecurityContext::new())
    }

    // optional bool stdin = 16;


    pub fn get_stdin(&self) -> bool {
        self.stdin.unwrap_or(false)
    }
    pub fn clear_stdin(&mut self) {
        self.stdin = ::std::option::Option::None;
    }

    pub fn has_stdin(&self) -> bool {
        self.stdin.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stdin(&mut self, v: bool) {
        self.stdin = ::std::option::Option::Some(v);
    }

    // optional bool stdinOnce = 17;


    pub fn get_stdinOnce(&self) -> bool {
        self.stdinOnce.unwrap_or(false)
    }
    pub fn clear_stdinOnce(&mut self) {
        self.stdinOnce = ::std::option::Option::None;
    }

    pub fn has_stdinOnce(&self) -> bool {
        self.stdinOnce.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stdinOnce(&mut self, v: bool) {
        self.stdinOnce = ::std::option::Option::Some(v);
    }

    // optional bool tty = 18;


    pub fn get_tty(&self) -> bool {
        self.tty.unwrap_or(false)
    }
    pub fn clear_tty(&mut self) {
        self.tty = ::std::option::Option::None;
    }

    pub fn has_tty(&self) -> bool {
        self.tty.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tty(&mut self, v: bool) {
        self.tty = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for EphemeralContainerCommon {
    fn is_initialized(&self) -> bool {
        for v in &self.ports {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.envFrom {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.env {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.resources {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.volumeMounts {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.volumeDevices {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.livenessProbe {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.readinessProbe {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.startupProbe {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.lifecycle {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.securityContext {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.image)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.command)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.args)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.workingDir)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.ports)?;
                },
                19 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.envFrom)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.env)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.resources)?;
                },
                9 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.volumeMounts)?;
                },
                21 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.volumeDevices)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.livenessProbe)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.readinessProbe)?;
                },
                22 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.startupProbe)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.lifecycle)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.terminationMessagePath)?;
                },
                20 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.terminationMessagePolicy)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.imagePullPolicy)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.securityContext)?;
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.stdin = ::std::option::Option::Some(tmp);
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.stdinOnce = ::std::option::Option::Some(tmp);
                },
                18 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.tty = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.image.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        for value in &self.command {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        for value in &self.args {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        if let Some(ref v) = self.workingDir.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        for value in &self.ports {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.envFrom {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.env {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.resources.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.volumeMounts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.volumeDevices {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.livenessProbe.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.readinessProbe.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.startupProbe.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.lifecycle.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.terminationMessagePath.as_ref() {
            my_size += ::protobuf::rt::string_size(13, &v);
        }
        if let Some(ref v) = self.terminationMessagePolicy.as_ref() {
            my_size += ::protobuf::rt::string_size(20, &v);
        }
        if let Some(ref v) = self.imagePullPolicy.as_ref() {
            my_size += ::protobuf::rt::string_size(14, &v);
        }
        if let Some(ref v) = self.securityContext.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.stdin {
            my_size += 3;
        }
        if let Some(v) = self.stdinOnce {
            my_size += 3;
        }
        if let Some(v) = self.tty {
            my_size += 3;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.image.as_ref() {
            os.write_string(2, &v)?;
        }
        for v in &self.command {
            os.write_string(3, &v)?;
        };
        for v in &self.args {
            os.write_string(4, &v)?;
        };
        if let Some(ref v) = self.workingDir.as_ref() {
            os.write_string(5, &v)?;
        }
        for v in &self.ports {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.envFrom {
            os.write_tag(19, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.env {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.resources.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.volumeMounts {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.volumeDevices {
            os.write_tag(21, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.livenessProbe.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.readinessProbe.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.startupProbe.as_ref() {
            os.write_tag(22, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.lifecycle.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.terminationMessagePath.as_ref() {
            os.write_string(13, &v)?;
        }
        if let Some(ref v) = self.terminationMessagePolicy.as_ref() {
            os.write_string(20, &v)?;
        }
        if let Some(ref v) = self.imagePullPolicy.as_ref() {
            os.write_string(14, &v)?;
        }
        if let Some(ref v) = self.securityContext.as_ref() {
            os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.stdin {
            os.write_bool(16, v)?;
        }
        if let Some(v) = self.stdinOnce {
            os.write_bool(17, v)?;
        }
        if let Some(v) = self.tty {
            os.write_bool(18, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EphemeralContainerCommon {
        EphemeralContainerCommon::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &EphemeralContainerCommon| { &m.name },
                |m: &mut EphemeralContainerCommon| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "image",
                |m: &EphemeralContainerCommon| { &m.image },
                |m: &mut EphemeralContainerCommon| { &mut m.image },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "command",
                |m: &EphemeralContainerCommon| { &m.command },
                |m: &mut EphemeralContainerCommon| { &mut m.command },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "args",
                |m: &EphemeralContainerCommon| { &m.args },
                |m: &mut EphemeralContainerCommon| { &mut m.args },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "workingDir",
                |m: &EphemeralContainerCommon| { &m.workingDir },
                |m: &mut EphemeralContainerCommon| { &mut m.workingDir },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ContainerPort>>(
                "ports",
                |m: &EphemeralContainerCommon| { &m.ports },
                |m: &mut EphemeralContainerCommon| { &mut m.ports },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EnvFromSource>>(
                "envFrom",
                |m: &EphemeralContainerCommon| { &m.envFrom },
                |m: &mut EphemeralContainerCommon| { &mut m.envFrom },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EnvVar>>(
                "env",
                |m: &EphemeralContainerCommon| { &m.env },
                |m: &mut EphemeralContainerCommon| { &mut m.env },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResourceRequirements>>(
                "resources",
                |m: &EphemeralContainerCommon| { &m.resources },
                |m: &mut EphemeralContainerCommon| { &mut m.resources },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<VolumeMount>>(
                "volumeMounts",
                |m: &EphemeralContainerCommon| { &m.volumeMounts },
                |m: &mut EphemeralContainerCommon| { &mut m.volumeMounts },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<VolumeDevice>>(
                "volumeDevices",
                |m: &EphemeralContainerCommon| { &m.volumeDevices },
                |m: &mut EphemeralContainerCommon| { &mut m.volumeDevices },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Probe>>(
                "livenessProbe",
                |m: &EphemeralContainerCommon| { &m.livenessProbe },
                |m: &mut EphemeralContainerCommon| { &mut m.livenessProbe },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Probe>>(
                "readinessProbe",
                |m: &EphemeralContainerCommon| { &m.readinessProbe },
                |m: &mut EphemeralContainerCommon| { &mut m.readinessProbe },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Probe>>(
                "startupProbe",
                |m: &EphemeralContainerCommon| { &m.startupProbe },
                |m: &mut EphemeralContainerCommon| { &mut m.startupProbe },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Lifecycle>>(
                "lifecycle",
                |m: &EphemeralContainerCommon| { &m.lifecycle },
                |m: &mut EphemeralContainerCommon| { &mut m.lifecycle },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "terminationMessagePath",
                |m: &EphemeralContainerCommon| { &m.terminationMessagePath },
                |m: &mut EphemeralContainerCommon| { &mut m.terminationMessagePath },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "terminationMessagePolicy",
                |m: &EphemeralContainerCommon| { &m.terminationMessagePolicy },
                |m: &mut EphemeralContainerCommon| { &mut m.terminationMessagePolicy },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "imagePullPolicy",
                |m: &EphemeralContainerCommon| { &m.imagePullPolicy },
                |m: &mut EphemeralContainerCommon| { &mut m.imagePullPolicy },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SecurityContext>>(
                "securityContext",
                |m: &EphemeralContainerCommon| { &m.securityContext },
                |m: &mut EphemeralContainerCommon| { &mut m.securityContext },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "stdin",
                |m: &EphemeralContainerCommon| { &m.stdin },
                |m: &mut EphemeralContainerCommon| { &mut m.stdin },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "stdinOnce",
                |m: &EphemeralContainerCommon| { &m.stdinOnce },
                |m: &mut EphemeralContainerCommon| { &mut m.stdinOnce },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "tty",
                |m: &EphemeralContainerCommon| { &m.tty },
                |m: &mut EphemeralContainerCommon| { &mut m.tty },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EphemeralContainerCommon>(
                "EphemeralContainerCommon",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EphemeralContainerCommon {
        static instance: ::protobuf::rt::LazyV2<EphemeralContainerCommon> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EphemeralContainerCommon::new)
    }
}

impl ::protobuf::Clear for EphemeralContainerCommon {
    fn clear(&mut self) {
        self.name.clear();
        self.image.clear();
        self.command.clear();
        self.args.clear();
        self.workingDir.clear();
        self.ports.clear();
        self.envFrom.clear();
        self.env.clear();
        self.resources.clear();
        self.volumeMounts.clear();
        self.volumeDevices.clear();
        self.livenessProbe.clear();
        self.readinessProbe.clear();
        self.startupProbe.clear();
        self.lifecycle.clear();
        self.terminationMessagePath.clear();
        self.terminationMessagePolicy.clear();
        self.imagePullPolicy.clear();
        self.securityContext.clear();
        self.stdin = ::std::option::Option::None;
        self.stdinOnce = ::std::option::Option::None;
        self.tty = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EphemeralContainerCommon {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EphemeralContainerCommon {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EphemeralContainers {
    // message fields
    pub metadata: ::protobuf::SingularPtrField<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta>,
    pub ephemeralContainers: ::protobuf::RepeatedField<EphemeralContainer>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EphemeralContainers {
    fn default() -> &'a EphemeralContainers {
        <EphemeralContainers as ::protobuf::Message>::default_instance()
    }
}

impl EphemeralContainers {
    pub fn new() -> EphemeralContainers {
        ::std::default::Default::default()
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;


    pub fn get_metadata(&self) -> &super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta::new())
    }

    // repeated .k8s.io.api.core.v1.EphemeralContainer ephemeralContainers = 2;


    pub fn get_ephemeralContainers(&self) -> &[EphemeralContainer] {
        &self.ephemeralContainers
    }
    pub fn clear_ephemeralContainers(&mut self) {
        self.ephemeralContainers.clear();
    }

    // Param is passed by value, moved
    pub fn set_ephemeralContainers(&mut self, v: ::protobuf::RepeatedField<EphemeralContainer>) {
        self.ephemeralContainers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ephemeralContainers(&mut self) -> &mut ::protobuf::RepeatedField<EphemeralContainer> {
        &mut self.ephemeralContainers
    }

    // Take field
    pub fn take_ephemeralContainers(&mut self) -> ::protobuf::RepeatedField<EphemeralContainer> {
        ::std::mem::replace(&mut self.ephemeralContainers, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for EphemeralContainers {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ephemeralContainers {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.ephemeralContainers)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.ephemeralContainers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.ephemeralContainers {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EphemeralContainers {
        EphemeralContainers::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta>>(
                "metadata",
                |m: &EphemeralContainers| { &m.metadata },
                |m: &mut EphemeralContainers| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EphemeralContainer>>(
                "ephemeralContainers",
                |m: &EphemeralContainers| { &m.ephemeralContainers },
                |m: &mut EphemeralContainers| { &mut m.ephemeralContainers },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EphemeralContainers>(
                "EphemeralContainers",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EphemeralContainers {
        static instance: ::protobuf::rt::LazyV2<EphemeralContainers> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EphemeralContainers::new)
    }
}

impl ::protobuf::Clear for EphemeralContainers {
    fn clear(&mut self) {
        self.metadata.clear();
        self.ephemeralContainers.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EphemeralContainers {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EphemeralContainers {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EphemeralVolumeSource {
    // message fields
    pub volumeClaimTemplate: ::protobuf::SingularPtrField<PersistentVolumeClaimTemplate>,
    readOnly: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EphemeralVolumeSource {
    fn default() -> &'a EphemeralVolumeSource {
        <EphemeralVolumeSource as ::protobuf::Message>::default_instance()
    }
}

impl EphemeralVolumeSource {
    pub fn new() -> EphemeralVolumeSource {
        ::std::default::Default::default()
    }

    // optional .k8s.io.api.core.v1.PersistentVolumeClaimTemplate volumeClaimTemplate = 1;


    pub fn get_volumeClaimTemplate(&self) -> &PersistentVolumeClaimTemplate {
        self.volumeClaimTemplate.as_ref().unwrap_or_else(|| <PersistentVolumeClaimTemplate as ::protobuf::Message>::default_instance())
    }
    pub fn clear_volumeClaimTemplate(&mut self) {
        self.volumeClaimTemplate.clear();
    }

    pub fn has_volumeClaimTemplate(&self) -> bool {
        self.volumeClaimTemplate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_volumeClaimTemplate(&mut self, v: PersistentVolumeClaimTemplate) {
        self.volumeClaimTemplate = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_volumeClaimTemplate(&mut self) -> &mut PersistentVolumeClaimTemplate {
        if self.volumeClaimTemplate.is_none() {
            self.volumeClaimTemplate.set_default();
        }
        self.volumeClaimTemplate.as_mut().unwrap()
    }

    // Take field
    pub fn take_volumeClaimTemplate(&mut self) -> PersistentVolumeClaimTemplate {
        self.volumeClaimTemplate.take().unwrap_or_else(|| PersistentVolumeClaimTemplate::new())
    }

    // optional bool readOnly = 2;


    pub fn get_readOnly(&self) -> bool {
        self.readOnly.unwrap_or(false)
    }
    pub fn clear_readOnly(&mut self) {
        self.readOnly = ::std::option::Option::None;
    }

    pub fn has_readOnly(&self) -> bool {
        self.readOnly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readOnly(&mut self, v: bool) {
        self.readOnly = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for EphemeralVolumeSource {
    fn is_initialized(&self) -> bool {
        for v in &self.volumeClaimTemplate {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.volumeClaimTemplate)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.readOnly = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.volumeClaimTemplate.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.readOnly {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.volumeClaimTemplate.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.readOnly {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EphemeralVolumeSource {
        EphemeralVolumeSource::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PersistentVolumeClaimTemplate>>(
                "volumeClaimTemplate",
                |m: &EphemeralVolumeSource| { &m.volumeClaimTemplate },
                |m: &mut EphemeralVolumeSource| { &mut m.volumeClaimTemplate },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "readOnly",
                |m: &EphemeralVolumeSource| { &m.readOnly },
                |m: &mut EphemeralVolumeSource| { &mut m.readOnly },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EphemeralVolumeSource>(
                "EphemeralVolumeSource",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EphemeralVolumeSource {
        static instance: ::protobuf::rt::LazyV2<EphemeralVolumeSource> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EphemeralVolumeSource::new)
    }
}

impl ::protobuf::Clear for EphemeralVolumeSource {
    fn clear(&mut self) {
        self.volumeClaimTemplate.clear();
        self.readOnly = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EphemeralVolumeSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EphemeralVolumeSource {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Event {
    // message fields
    pub metadata: ::protobuf::SingularPtrField<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta>,
    pub involvedObject: ::protobuf::SingularPtrField<ObjectReference>,
    reason: ::protobuf::SingularField<::std::string::String>,
    message: ::protobuf::SingularField<::std::string::String>,
    pub source: ::protobuf::SingularPtrField<EventSource>,
    pub firstTimestamp: ::protobuf::SingularPtrField<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time>,
    pub lastTimestamp: ::protobuf::SingularPtrField<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time>,
    count: ::std::option::Option<i32>,
    field_type: ::protobuf::SingularField<::std::string::String>,
    pub eventTime: ::protobuf::SingularPtrField<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::MicroTime>,
    pub series: ::protobuf::SingularPtrField<EventSeries>,
    action: ::protobuf::SingularField<::std::string::String>,
    pub related: ::protobuf::SingularPtrField<ObjectReference>,
    reportingComponent: ::protobuf::SingularField<::std::string::String>,
    reportingInstance: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Event {
    fn default() -> &'a Event {
        <Event as ::protobuf::Message>::default_instance()
    }
}

impl Event {
    pub fn new() -> Event {
        ::std::default::Default::default()
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;


    pub fn get_metadata(&self) -> &super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta::new())
    }

    // optional .k8s.io.api.core.v1.ObjectReference involvedObject = 2;


    pub fn get_involvedObject(&self) -> &ObjectReference {
        self.involvedObject.as_ref().unwrap_or_else(|| <ObjectReference as ::protobuf::Message>::default_instance())
    }
    pub fn clear_involvedObject(&mut self) {
        self.involvedObject.clear();
    }

    pub fn has_involvedObject(&self) -> bool {
        self.involvedObject.is_some()
    }

    // Param is passed by value, moved
    pub fn set_involvedObject(&mut self, v: ObjectReference) {
        self.involvedObject = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_involvedObject(&mut self) -> &mut ObjectReference {
        if self.involvedObject.is_none() {
            self.involvedObject.set_default();
        }
        self.involvedObject.as_mut().unwrap()
    }

    // Take field
    pub fn take_involvedObject(&mut self) -> ObjectReference {
        self.involvedObject.take().unwrap_or_else(|| ObjectReference::new())
    }

    // optional string reason = 3;


    pub fn get_reason(&self) -> &str {
        match self.reason.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_reason(&mut self) {
        self.reason.clear();
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: ::std::string::String) {
        self.reason = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reason(&mut self) -> &mut ::std::string::String {
        if self.reason.is_none() {
            self.reason.set_default();
        }
        self.reason.as_mut().unwrap()
    }

    // Take field
    pub fn take_reason(&mut self) -> ::std::string::String {
        self.reason.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string message = 4;


    pub fn get_message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .k8s.io.api.core.v1.EventSource source = 5;


    pub fn get_source(&self) -> &EventSource {
        self.source.as_ref().unwrap_or_else(|| <EventSource as ::protobuf::Message>::default_instance())
    }
    pub fn clear_source(&mut self) {
        self.source.clear();
    }

    pub fn has_source(&self) -> bool {
        self.source.is_some()
    }

    // Param is passed by value, moved
    pub fn set_source(&mut self, v: EventSource) {
        self.source = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_source(&mut self) -> &mut EventSource {
        if self.source.is_none() {
            self.source.set_default();
        }
        self.source.as_mut().unwrap()
    }

    // Take field
    pub fn take_source(&mut self) -> EventSource {
        self.source.take().unwrap_or_else(|| EventSource::new())
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time firstTimestamp = 6;


    pub fn get_firstTimestamp(&self) -> &super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time {
        self.firstTimestamp.as_ref().unwrap_or_else(|| <super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time as ::protobuf::Message>::default_instance())
    }
    pub fn clear_firstTimestamp(&mut self) {
        self.firstTimestamp.clear();
    }

    pub fn has_firstTimestamp(&self) -> bool {
        self.firstTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_firstTimestamp(&mut self, v: super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time) {
        self.firstTimestamp = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_firstTimestamp(&mut self) -> &mut super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time {
        if self.firstTimestamp.is_none() {
            self.firstTimestamp.set_default();
        }
        self.firstTimestamp.as_mut().unwrap()
    }

    // Take field
    pub fn take_firstTimestamp(&mut self) -> super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time {
        self.firstTimestamp.take().unwrap_or_else(|| super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time::new())
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTimestamp = 7;


    pub fn get_lastTimestamp(&self) -> &super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time {
        self.lastTimestamp.as_ref().unwrap_or_else(|| <super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time as ::protobuf::Message>::default_instance())
    }
    pub fn clear_lastTimestamp(&mut self) {
        self.lastTimestamp.clear();
    }

    pub fn has_lastTimestamp(&self) -> bool {
        self.lastTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lastTimestamp(&mut self, v: super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time) {
        self.lastTimestamp = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lastTimestamp(&mut self) -> &mut super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time {
        if self.lastTimestamp.is_none() {
            self.lastTimestamp.set_default();
        }
        self.lastTimestamp.as_mut().unwrap()
    }

    // Take field
    pub fn take_lastTimestamp(&mut self) -> super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time {
        self.lastTimestamp.take().unwrap_or_else(|| super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time::new())
    }

    // optional int32 count = 8;


    pub fn get_count(&self) -> i32 {
        self.count.unwrap_or(0)
    }
    pub fn clear_count(&mut self) {
        self.count = ::std::option::Option::None;
    }

    pub fn has_count(&self) -> bool {
        self.count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: i32) {
        self.count = ::std::option::Option::Some(v);
    }

    // optional string type = 9;


    pub fn get_field_type(&self) -> &str {
        match self.field_type.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ::std::string::String) {
        self.field_type = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut ::std::string::String {
        if self.field_type.is_none() {
            self.field_type.set_default();
        }
        self.field_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_field_type(&mut self) -> ::std::string::String {
        self.field_type.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.MicroTime eventTime = 10;


    pub fn get_eventTime(&self) -> &super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::MicroTime {
        self.eventTime.as_ref().unwrap_or_else(|| <super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::MicroTime as ::protobuf::Message>::default_instance())
    }
    pub fn clear_eventTime(&mut self) {
        self.eventTime.clear();
    }

    pub fn has_eventTime(&self) -> bool {
        self.eventTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_eventTime(&mut self, v: super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::MicroTime) {
        self.eventTime = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_eventTime(&mut self) -> &mut super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::MicroTime {
        if self.eventTime.is_none() {
            self.eventTime.set_default();
        }
        self.eventTime.as_mut().unwrap()
    }

    // Take field
    pub fn take_eventTime(&mut self) -> super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::MicroTime {
        self.eventTime.take().unwrap_or_else(|| super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::MicroTime::new())
    }

    // optional .k8s.io.api.core.v1.EventSeries series = 11;


    pub fn get_series(&self) -> &EventSeries {
        self.series.as_ref().unwrap_or_else(|| <EventSeries as ::protobuf::Message>::default_instance())
    }
    pub fn clear_series(&mut self) {
        self.series.clear();
    }

    pub fn has_series(&self) -> bool {
        self.series.is_some()
    }

    // Param is passed by value, moved
    pub fn set_series(&mut self, v: EventSeries) {
        self.series = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_series(&mut self) -> &mut EventSeries {
        if self.series.is_none() {
            self.series.set_default();
        }
        self.series.as_mut().unwrap()
    }

    // Take field
    pub fn take_series(&mut self) -> EventSeries {
        self.series.take().unwrap_or_else(|| EventSeries::new())
    }

    // optional string action = 12;


    pub fn get_action(&self) -> &str {
        match self.action.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_action(&mut self) {
        self.action.clear();
    }

    pub fn has_action(&self) -> bool {
        self.action.is_some()
    }

    // Param is passed by value, moved
    pub fn set_action(&mut self, v: ::std::string::String) {
        self.action = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_action(&mut self) -> &mut ::std::string::String {
        if self.action.is_none() {
            self.action.set_default();
        }
        self.action.as_mut().unwrap()
    }

    // Take field
    pub fn take_action(&mut self) -> ::std::string::String {
        self.action.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .k8s.io.api.core.v1.ObjectReference related = 13;


    pub fn get_related(&self) -> &ObjectReference {
        self.related.as_ref().unwrap_or_else(|| <ObjectReference as ::protobuf::Message>::default_instance())
    }
    pub fn clear_related(&mut self) {
        self.related.clear();
    }

    pub fn has_related(&self) -> bool {
        self.related.is_some()
    }

    // Param is passed by value, moved
    pub fn set_related(&mut self, v: ObjectReference) {
        self.related = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_related(&mut self) -> &mut ObjectReference {
        if self.related.is_none() {
            self.related.set_default();
        }
        self.related.as_mut().unwrap()
    }

    // Take field
    pub fn take_related(&mut self) -> ObjectReference {
        self.related.take().unwrap_or_else(|| ObjectReference::new())
    }

    // optional string reportingComponent = 14;


    pub fn get_reportingComponent(&self) -> &str {
        match self.reportingComponent.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_reportingComponent(&mut self) {
        self.reportingComponent.clear();
    }

    pub fn has_reportingComponent(&self) -> bool {
        self.reportingComponent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reportingComponent(&mut self, v: ::std::string::String) {
        self.reportingComponent = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reportingComponent(&mut self) -> &mut ::std::string::String {
        if self.reportingComponent.is_none() {
            self.reportingComponent.set_default();
        }
        self.reportingComponent.as_mut().unwrap()
    }

    // Take field
    pub fn take_reportingComponent(&mut self) -> ::std::string::String {
        self.reportingComponent.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string reportingInstance = 15;


    pub fn get_reportingInstance(&self) -> &str {
        match self.reportingInstance.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_reportingInstance(&mut self) {
        self.reportingInstance.clear();
    }

    pub fn has_reportingInstance(&self) -> bool {
        self.reportingInstance.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reportingInstance(&mut self, v: ::std::string::String) {
        self.reportingInstance = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reportingInstance(&mut self) -> &mut ::std::string::String {
        if self.reportingInstance.is_none() {
            self.reportingInstance.set_default();
        }
        self.reportingInstance.as_mut().unwrap()
    }

    // Take field
    pub fn take_reportingInstance(&mut self) -> ::std::string::String {
        self.reportingInstance.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for Event {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.involvedObject {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.source {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.firstTimestamp {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.lastTimestamp {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.eventTime {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.series {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.related {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.involvedObject)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.reason)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.message)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.source)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.firstTimestamp)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.lastTimestamp)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.count = ::std::option::Option::Some(tmp);
                },
                9 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.field_type)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.eventTime)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.series)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.action)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.related)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.reportingComponent)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.reportingInstance)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.involvedObject.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.reason.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.source.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.firstTimestamp.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.lastTimestamp.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.count {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.field_type.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(ref v) = self.eventTime.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.series.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.action.as_ref() {
            my_size += ::protobuf::rt::string_size(12, &v);
        }
        if let Some(ref v) = self.related.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.reportingComponent.as_ref() {
            my_size += ::protobuf::rt::string_size(14, &v);
        }
        if let Some(ref v) = self.reportingInstance.as_ref() {
            my_size += ::protobuf::rt::string_size(15, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.involvedObject.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.reason.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.message.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.source.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.firstTimestamp.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.lastTimestamp.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.count {
            os.write_int32(8, v)?;
        }
        if let Some(ref v) = self.field_type.as_ref() {
            os.write_string(9, &v)?;
        }
        if let Some(ref v) = self.eventTime.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.series.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.action.as_ref() {
            os.write_string(12, &v)?;
        }
        if let Some(ref v) = self.related.as_ref() {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.reportingComponent.as_ref() {
            os.write_string(14, &v)?;
        }
        if let Some(ref v) = self.reportingInstance.as_ref() {
            os.write_string(15, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Event {
        Event::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta>>(
                "metadata",
                |m: &Event| { &m.metadata },
                |m: &mut Event| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ObjectReference>>(
                "involvedObject",
                |m: &Event| { &m.involvedObject },
                |m: &mut Event| { &mut m.involvedObject },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "reason",
                |m: &Event| { &m.reason },
                |m: &mut Event| { &mut m.reason },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "message",
                |m: &Event| { &m.message },
                |m: &mut Event| { &mut m.message },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EventSource>>(
                "source",
                |m: &Event| { &m.source },
                |m: &mut Event| { &mut m.source },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time>>(
                "firstTimestamp",
                |m: &Event| { &m.firstTimestamp },
                |m: &mut Event| { &mut m.firstTimestamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time>>(
                "lastTimestamp",
                |m: &Event| { &m.lastTimestamp },
                |m: &mut Event| { &mut m.lastTimestamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "count",
                |m: &Event| { &m.count },
                |m: &mut Event| { &mut m.count },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "type",
                |m: &Event| { &m.field_type },
                |m: &mut Event| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::MicroTime>>(
                "eventTime",
                |m: &Event| { &m.eventTime },
                |m: &mut Event| { &mut m.eventTime },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EventSeries>>(
                "series",
                |m: &Event| { &m.series },
                |m: &mut Event| { &mut m.series },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "action",
                |m: &Event| { &m.action },
                |m: &mut Event| { &mut m.action },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ObjectReference>>(
                "related",
                |m: &Event| { &m.related },
                |m: &mut Event| { &mut m.related },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "reportingComponent",
                |m: &Event| { &m.reportingComponent },
                |m: &mut Event| { &mut m.reportingComponent },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "reportingInstance",
                |m: &Event| { &m.reportingInstance },
                |m: &mut Event| { &mut m.reportingInstance },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Event>(
                "Event",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Event {
        static instance: ::protobuf::rt::LazyV2<Event> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Event::new)
    }
}

impl ::protobuf::Clear for Event {
    fn clear(&mut self) {
        self.metadata.clear();
        self.involvedObject.clear();
        self.reason.clear();
        self.message.clear();
        self.source.clear();
        self.firstTimestamp.clear();
        self.lastTimestamp.clear();
        self.count = ::std::option::Option::None;
        self.field_type.clear();
        self.eventTime.clear();
        self.series.clear();
        self.action.clear();
        self.related.clear();
        self.reportingComponent.clear();
        self.reportingInstance.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Event {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Event {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EventList {
    // message fields
    pub metadata: ::protobuf::SingularPtrField<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta>,
    pub items: ::protobuf::RepeatedField<Event>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EventList {
    fn default() -> &'a EventList {
        <EventList as ::protobuf::Message>::default_instance()
    }
}

impl EventList {
    pub fn new() -> EventList {
        ::std::default::Default::default()
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;


    pub fn get_metadata(&self) -> &super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta {
        self.metadata.take().unwrap_or_else(|| super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta::new())
    }

    // repeated .k8s.io.api.core.v1.Event items = 2;


    pub fn get_items(&self) -> &[Event] {
        &self.items
    }
    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::protobuf::RepeatedField<Event>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::protobuf::RepeatedField<Event> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::protobuf::RepeatedField<Event> {
        ::std::mem::replace(&mut self.items, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for EventList {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.items {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.items)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.items {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EventList {
        EventList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta>>(
                "metadata",
                |m: &EventList| { &m.metadata },
                |m: &mut EventList| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Event>>(
                "items",
                |m: &EventList| { &m.items },
                |m: &mut EventList| { &mut m.items },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EventList>(
                "EventList",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EventList {
        static instance: ::protobuf::rt::LazyV2<EventList> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EventList::new)
    }
}

impl ::protobuf::Clear for EventList {
    fn clear(&mut self) {
        self.metadata.clear();
        self.items.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EventList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EventList {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EventSeries {
    // message fields
    count: ::std::option::Option<i32>,
    pub lastObservedTime: ::protobuf::SingularPtrField<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::MicroTime>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EventSeries {
    fn default() -> &'a EventSeries {
        <EventSeries as ::protobuf::Message>::default_instance()
    }
}

impl EventSeries {
    pub fn new() -> EventSeries {
        ::std::default::Default::default()
    }

    // optional int32 count = 1;


    pub fn get_count(&self) -> i32 {
        self.count.unwrap_or(0)
    }
    pub fn clear_count(&mut self) {
        self.count = ::std::option::Option::None;
    }

    pub fn has_count(&self) -> bool {
        self.count.is_some()
    }

    // Param is passed by value, moved
    pub fn set_count(&mut self, v: i32) {
        self.count = ::std::option::Option::Some(v);
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.MicroTime lastObservedTime = 2;


    pub fn get_lastObservedTime(&self) -> &super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::MicroTime {
        self.lastObservedTime.as_ref().unwrap_or_else(|| <super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::MicroTime as ::protobuf::Message>::default_instance())
    }
    pub fn clear_lastObservedTime(&mut self) {
        self.lastObservedTime.clear();
    }

    pub fn has_lastObservedTime(&self) -> bool {
        self.lastObservedTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lastObservedTime(&mut self, v: super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::MicroTime) {
        self.lastObservedTime = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lastObservedTime(&mut self) -> &mut super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::MicroTime {
        if self.lastObservedTime.is_none() {
            self.lastObservedTime.set_default();
        }
        self.lastObservedTime.as_mut().unwrap()
    }

    // Take field
    pub fn take_lastObservedTime(&mut self) -> super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::MicroTime {
        self.lastObservedTime.take().unwrap_or_else(|| super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::MicroTime::new())
    }
}

impl ::protobuf::Message for EventSeries {
    fn is_initialized(&self) -> bool {
        for v in &self.lastObservedTime {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.count = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.lastObservedTime)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.count {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.lastObservedTime.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.count {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.lastObservedTime.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EventSeries {
        EventSeries::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "count",
                |m: &EventSeries| { &m.count },
                |m: &mut EventSeries| { &mut m.count },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::MicroTime>>(
                "lastObservedTime",
                |m: &EventSeries| { &m.lastObservedTime },
                |m: &mut EventSeries| { &mut m.lastObservedTime },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EventSeries>(
                "EventSeries",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EventSeries {
        static instance: ::protobuf::rt::LazyV2<EventSeries> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EventSeries::new)
    }
}

impl ::protobuf::Clear for EventSeries {
    fn clear(&mut self) {
        self.count = ::std::option::Option::None;
        self.lastObservedTime.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EventSeries {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EventSeries {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EventSource {
    // message fields
    component: ::protobuf::SingularField<::std::string::String>,
    host: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EventSource {
    fn default() -> &'a EventSource {
        <EventSource as ::protobuf::Message>::default_instance()
    }
}

impl EventSource {
    pub fn new() -> EventSource {
        ::std::default::Default::default()
    }

    // optional string component = 1;


    pub fn get_component(&self) -> &str {
        match self.component.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_component(&mut self) {
        self.component.clear();
    }

    pub fn has_component(&self) -> bool {
        self.component.is_some()
    }

    // Param is passed by value, moved
    pub fn set_component(&mut self, v: ::std::string::String) {
        self.component = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_component(&mut self) -> &mut ::std::string::String {
        if self.component.is_none() {
            self.component.set_default();
        }
        self.component.as_mut().unwrap()
    }

    // Take field
    pub fn take_component(&mut self) -> ::std::string::String {
        self.component.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string host = 2;


    pub fn get_host(&self) -> &str {
        match self.host.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_host(&mut self) {
        self.host.clear();
    }

    pub fn has_host(&self) -> bool {
        self.host.is_some()
    }

    // Param is passed by value, moved
    pub fn set_host(&mut self, v: ::std::string::String) {
        self.host = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_host(&mut self) -> &mut ::std::string::String {
        if self.host.is_none() {
            self.host.set_default();
        }
        self.host.as_mut().unwrap()
    }

    // Take field
    pub fn take_host(&mut self) -> ::std::string::String {
        self.host.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for EventSource {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.component)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.host)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.component.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.host.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.component.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.host.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EventSource {
        EventSource::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "component",
                |m: &EventSource| { &m.component },
                |m: &mut EventSource| { &mut m.component },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "host",
                |m: &EventSource| { &m.host },
                |m: &mut EventSource| { &mut m.host },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EventSource>(
                "EventSource",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EventSource {
        static instance: ::protobuf::rt::LazyV2<EventSource> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EventSource::new)
    }
}

impl ::protobuf::Clear for EventSource {
    fn clear(&mut self) {
        self.component.clear();
        self.host.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EventSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EventSource {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ExecAction {
    // message fields
    pub command: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExecAction {
    fn default() -> &'a ExecAction {
        <ExecAction as ::protobuf::Message>::default_instance()
    }
}

impl ExecAction {
    pub fn new() -> ExecAction {
        ::std::default::Default::default()
    }

    // repeated string command = 1;


    pub fn get_command(&self) -> &[::std::string::String] {
        &self.command
    }
    pub fn clear_command(&mut self) {
        self.command.clear();
    }

    // Param is passed by value, moved
    pub fn set_command(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.command = v;
    }

    // Mutable pointer to the field.
    pub fn mut_command(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.command
    }

    // Take field
    pub fn take_command(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.command, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ExecAction {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.command)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.command {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.command {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExecAction {
        ExecAction::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "command",
                |m: &ExecAction| { &m.command },
                |m: &mut ExecAction| { &mut m.command },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ExecAction>(
                "ExecAction",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ExecAction {
        static instance: ::protobuf::rt::LazyV2<ExecAction> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ExecAction::new)
    }
}

impl ::protobuf::Clear for ExecAction {
    fn clear(&mut self) {
        self.command.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExecAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExecAction {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FCVolumeSource {
    // message fields
    pub targetWWNs: ::protobuf::RepeatedField<::std::string::String>,
    lun: ::std::option::Option<i32>,
    fsType: ::protobuf::SingularField<::std::string::String>,
    readOnly: ::std::option::Option<bool>,
    pub wwids: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FCVolumeSource {
    fn default() -> &'a FCVolumeSource {
        <FCVolumeSource as ::protobuf::Message>::default_instance()
    }
}

impl FCVolumeSource {
    pub fn new() -> FCVolumeSource {
        ::std::default::Default::default()
    }

    // repeated string targetWWNs = 1;


    pub fn get_targetWWNs(&self) -> &[::std::string::String] {
        &self.targetWWNs
    }
    pub fn clear_targetWWNs(&mut self) {
        self.targetWWNs.clear();
    }

    // Param is passed by value, moved
    pub fn set_targetWWNs(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.targetWWNs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_targetWWNs(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.targetWWNs
    }

    // Take field
    pub fn take_targetWWNs(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.targetWWNs, ::protobuf::RepeatedField::new())
    }

    // optional int32 lun = 2;


    pub fn get_lun(&self) -> i32 {
        self.lun.unwrap_or(0)
    }
    pub fn clear_lun(&mut self) {
        self.lun = ::std::option::Option::None;
    }

    pub fn has_lun(&self) -> bool {
        self.lun.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lun(&mut self, v: i32) {
        self.lun = ::std::option::Option::Some(v);
    }

    // optional string fsType = 3;


    pub fn get_fsType(&self) -> &str {
        match self.fsType.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_fsType(&mut self) {
        self.fsType.clear();
    }

    pub fn has_fsType(&self) -> bool {
        self.fsType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fsType(&mut self, v: ::std::string::String) {
        self.fsType = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fsType(&mut self) -> &mut ::std::string::String {
        if self.fsType.is_none() {
            self.fsType.set_default();
        }
        self.fsType.as_mut().unwrap()
    }

    // Take field
    pub fn take_fsType(&mut self) -> ::std::string::String {
        self.fsType.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool readOnly = 4;


    pub fn get_readOnly(&self) -> bool {
        self.readOnly.unwrap_or(false)
    }
    pub fn clear_readOnly(&mut self) {
        self.readOnly = ::std::option::Option::None;
    }

    pub fn has_readOnly(&self) -> bool {
        self.readOnly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readOnly(&mut self, v: bool) {
        self.readOnly = ::std::option::Option::Some(v);
    }

    // repeated string wwids = 5;


    pub fn get_wwids(&self) -> &[::std::string::String] {
        &self.wwids
    }
    pub fn clear_wwids(&mut self) {
        self.wwids.clear();
    }

    // Param is passed by value, moved
    pub fn set_wwids(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.wwids = v;
    }

    // Mutable pointer to the field.
    pub fn mut_wwids(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.wwids
    }

    // Take field
    pub fn take_wwids(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.wwids, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for FCVolumeSource {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.targetWWNs)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.lun = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.fsType)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.readOnly = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.wwids)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.targetWWNs {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if let Some(v) = self.lun {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.fsType.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.readOnly {
            my_size += 2;
        }
        for value in &self.wwids {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.targetWWNs {
            os.write_string(1, &v)?;
        };
        if let Some(v) = self.lun {
            os.write_int32(2, v)?;
        }
        if let Some(ref v) = self.fsType.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.readOnly {
            os.write_bool(4, v)?;
        }
        for v in &self.wwids {
            os.write_string(5, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FCVolumeSource {
        FCVolumeSource::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "targetWWNs",
                |m: &FCVolumeSource| { &m.targetWWNs },
                |m: &mut FCVolumeSource| { &mut m.targetWWNs },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "lun",
                |m: &FCVolumeSource| { &m.lun },
                |m: &mut FCVolumeSource| { &mut m.lun },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "fsType",
                |m: &FCVolumeSource| { &m.fsType },
                |m: &mut FCVolumeSource| { &mut m.fsType },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "readOnly",
                |m: &FCVolumeSource| { &m.readOnly },
                |m: &mut FCVolumeSource| { &mut m.readOnly },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "wwids",
                |m: &FCVolumeSource| { &m.wwids },
                |m: &mut FCVolumeSource| { &mut m.wwids },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FCVolumeSource>(
                "FCVolumeSource",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FCVolumeSource {
        static instance: ::protobuf::rt::LazyV2<FCVolumeSource> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FCVolumeSource::new)
    }
}

impl ::protobuf::Clear for FCVolumeSource {
    fn clear(&mut self) {
        self.targetWWNs.clear();
        self.lun = ::std::option::Option::None;
        self.fsType.clear();
        self.readOnly = ::std::option::Option::None;
        self.wwids.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FCVolumeSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FCVolumeSource {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FlexPersistentVolumeSource {
    // message fields
    driver: ::protobuf::SingularField<::std::string::String>,
    fsType: ::protobuf::SingularField<::std::string::String>,
    pub secretRef: ::protobuf::SingularPtrField<SecretReference>,
    readOnly: ::std::option::Option<bool>,
    pub options: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FlexPersistentVolumeSource {
    fn default() -> &'a FlexPersistentVolumeSource {
        <FlexPersistentVolumeSource as ::protobuf::Message>::default_instance()
    }
}

impl FlexPersistentVolumeSource {
    pub fn new() -> FlexPersistentVolumeSource {
        ::std::default::Default::default()
    }

    // optional string driver = 1;


    pub fn get_driver(&self) -> &str {
        match self.driver.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_driver(&mut self) {
        self.driver.clear();
    }

    pub fn has_driver(&self) -> bool {
        self.driver.is_some()
    }

    // Param is passed by value, moved
    pub fn set_driver(&mut self, v: ::std::string::String) {
        self.driver = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_driver(&mut self) -> &mut ::std::string::String {
        if self.driver.is_none() {
            self.driver.set_default();
        }
        self.driver.as_mut().unwrap()
    }

    // Take field
    pub fn take_driver(&mut self) -> ::std::string::String {
        self.driver.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string fsType = 2;


    pub fn get_fsType(&self) -> &str {
        match self.fsType.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_fsType(&mut self) {
        self.fsType.clear();
    }

    pub fn has_fsType(&self) -> bool {
        self.fsType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fsType(&mut self, v: ::std::string::String) {
        self.fsType = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fsType(&mut self) -> &mut ::std::string::String {
        if self.fsType.is_none() {
            self.fsType.set_default();
        }
        self.fsType.as_mut().unwrap()
    }

    // Take field
    pub fn take_fsType(&mut self) -> ::std::string::String {
        self.fsType.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .k8s.io.api.core.v1.SecretReference secretRef = 3;


    pub fn get_secretRef(&self) -> &SecretReference {
        self.secretRef.as_ref().unwrap_or_else(|| <SecretReference as ::protobuf::Message>::default_instance())
    }
    pub fn clear_secretRef(&mut self) {
        self.secretRef.clear();
    }

    pub fn has_secretRef(&self) -> bool {
        self.secretRef.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secretRef(&mut self, v: SecretReference) {
        self.secretRef = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_secretRef(&mut self) -> &mut SecretReference {
        if self.secretRef.is_none() {
            self.secretRef.set_default();
        }
        self.secretRef.as_mut().unwrap()
    }

    // Take field
    pub fn take_secretRef(&mut self) -> SecretReference {
        self.secretRef.take().unwrap_or_else(|| SecretReference::new())
    }

    // optional bool readOnly = 4;


    pub fn get_readOnly(&self) -> bool {
        self.readOnly.unwrap_or(false)
    }
    pub fn clear_readOnly(&mut self) {
        self.readOnly = ::std::option::Option::None;
    }

    pub fn has_readOnly(&self) -> bool {
        self.readOnly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readOnly(&mut self, v: bool) {
        self.readOnly = ::std::option::Option::Some(v);
    }

    // repeated .k8s.io.api.core.v1.FlexPersistentVolumeSource.OptionsEntry options = 5;


    pub fn get_options(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.options
    }
    pub fn clear_options(&mut self) {
        self.options.clear();
    }

    // Param is passed by value, moved
    pub fn set_options(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.options = v;
    }

    // Mutable pointer to the field.
    pub fn mut_options(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.options
    }

    // Take field
    pub fn take_options(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.options, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for FlexPersistentVolumeSource {
    fn is_initialized(&self) -> bool {
        for v in &self.secretRef {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.driver)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.fsType)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.secretRef)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.readOnly = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.options)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.driver.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.fsType.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.secretRef.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.readOnly {
            my_size += 2;
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(5, &self.options);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.driver.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.fsType.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.secretRef.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.readOnly {
            os.write_bool(4, v)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(5, &self.options, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FlexPersistentVolumeSource {
        FlexPersistentVolumeSource::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "driver",
                |m: &FlexPersistentVolumeSource| { &m.driver },
                |m: &mut FlexPersistentVolumeSource| { &mut m.driver },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "fsType",
                |m: &FlexPersistentVolumeSource| { &m.fsType },
                |m: &mut FlexPersistentVolumeSource| { &mut m.fsType },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SecretReference>>(
                "secretRef",
                |m: &FlexPersistentVolumeSource| { &m.secretRef },
                |m: &mut FlexPersistentVolumeSource| { &mut m.secretRef },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "readOnly",
                |m: &FlexPersistentVolumeSource| { &m.readOnly },
                |m: &mut FlexPersistentVolumeSource| { &mut m.readOnly },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                "options",
                |m: &FlexPersistentVolumeSource| { &m.options },
                |m: &mut FlexPersistentVolumeSource| { &mut m.options },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FlexPersistentVolumeSource>(
                "FlexPersistentVolumeSource",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FlexPersistentVolumeSource {
        static instance: ::protobuf::rt::LazyV2<FlexPersistentVolumeSource> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FlexPersistentVolumeSource::new)
    }
}

impl ::protobuf::Clear for FlexPersistentVolumeSource {
    fn clear(&mut self) {
        self.driver.clear();
        self.fsType.clear();
        self.secretRef.clear();
        self.readOnly = ::std::option::Option::None;
        self.options.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FlexPersistentVolumeSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FlexPersistentVolumeSource {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FlexVolumeSource {
    // message fields
    driver: ::protobuf::SingularField<::std::string::String>,
    fsType: ::protobuf::SingularField<::std::string::String>,
    pub secretRef: ::protobuf::SingularPtrField<LocalObjectReference>,
    readOnly: ::std::option::Option<bool>,
    pub options: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FlexVolumeSource {
    fn default() -> &'a FlexVolumeSource {
        <FlexVolumeSource as ::protobuf::Message>::default_instance()
    }
}

impl FlexVolumeSource {
    pub fn new() -> FlexVolumeSource {
        ::std::default::Default::default()
    }

    // optional string driver = 1;


    pub fn get_driver(&self) -> &str {
        match self.driver.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_driver(&mut self) {
        self.driver.clear();
    }

    pub fn has_driver(&self) -> bool {
        self.driver.is_some()
    }

    // Param is passed by value, moved
    pub fn set_driver(&mut self, v: ::std::string::String) {
        self.driver = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_driver(&mut self) -> &mut ::std::string::String {
        if self.driver.is_none() {
            self.driver.set_default();
        }
        self.driver.as_mut().unwrap()
    }

    // Take field
    pub fn take_driver(&mut self) -> ::std::string::String {
        self.driver.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string fsType = 2;


    pub fn get_fsType(&self) -> &str {
        match self.fsType.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_fsType(&mut self) {
        self.fsType.clear();
    }

    pub fn has_fsType(&self) -> bool {
        self.fsType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fsType(&mut self, v: ::std::string::String) {
        self.fsType = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fsType(&mut self) -> &mut ::std::string::String {
        if self.fsType.is_none() {
            self.fsType.set_default();
        }
        self.fsType.as_mut().unwrap()
    }

    // Take field
    pub fn take_fsType(&mut self) -> ::std::string::String {
        self.fsType.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .k8s.io.api.core.v1.LocalObjectReference secretRef = 3;


    pub fn get_secretRef(&self) -> &LocalObjectReference {
        self.secretRef.as_ref().unwrap_or_else(|| <LocalObjectReference as ::protobuf::Message>::default_instance())
    }
    pub fn clear_secretRef(&mut self) {
        self.secretRef.clear();
    }

    pub fn has_secretRef(&self) -> bool {
        self.secretRef.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secretRef(&mut self, v: LocalObjectReference) {
        self.secretRef = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_secretRef(&mut self) -> &mut LocalObjectReference {
        if self.secretRef.is_none() {
            self.secretRef.set_default();
        }
        self.secretRef.as_mut().unwrap()
    }

    // Take field
    pub fn take_secretRef(&mut self) -> LocalObjectReference {
        self.secretRef.take().unwrap_or_else(|| LocalObjectReference::new())
    }

    // optional bool readOnly = 4;


    pub fn get_readOnly(&self) -> bool {
        self.readOnly.unwrap_or(false)
    }
    pub fn clear_readOnly(&mut self) {
        self.readOnly = ::std::option::Option::None;
    }

    pub fn has_readOnly(&self) -> bool {
        self.readOnly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readOnly(&mut self, v: bool) {
        self.readOnly = ::std::option::Option::Some(v);
    }

    // repeated .k8s.io.api.core.v1.FlexVolumeSource.OptionsEntry options = 5;


    pub fn get_options(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.options
    }
    pub fn clear_options(&mut self) {
        self.options.clear();
    }

    // Param is passed by value, moved
    pub fn set_options(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.options = v;
    }

    // Mutable pointer to the field.
    pub fn mut_options(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.options
    }

    // Take field
    pub fn take_options(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.options, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for FlexVolumeSource {
    fn is_initialized(&self) -> bool {
        for v in &self.secretRef {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.driver)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.fsType)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.secretRef)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.readOnly = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.options)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.driver.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.fsType.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.secretRef.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.readOnly {
            my_size += 2;
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(5, &self.options);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.driver.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.fsType.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.secretRef.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.readOnly {
            os.write_bool(4, v)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(5, &self.options, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FlexVolumeSource {
        FlexVolumeSource::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "driver",
                |m: &FlexVolumeSource| { &m.driver },
                |m: &mut FlexVolumeSource| { &mut m.driver },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "fsType",
                |m: &FlexVolumeSource| { &m.fsType },
                |m: &mut FlexVolumeSource| { &mut m.fsType },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LocalObjectReference>>(
                "secretRef",
                |m: &FlexVolumeSource| { &m.secretRef },
                |m: &mut FlexVolumeSource| { &mut m.secretRef },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "readOnly",
                |m: &FlexVolumeSource| { &m.readOnly },
                |m: &mut FlexVolumeSource| { &mut m.readOnly },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                "options",
                |m: &FlexVolumeSource| { &m.options },
                |m: &mut FlexVolumeSource| { &mut m.options },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FlexVolumeSource>(
                "FlexVolumeSource",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FlexVolumeSource {
        static instance: ::protobuf::rt::LazyV2<FlexVolumeSource> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FlexVolumeSource::new)
    }
}

impl ::protobuf::Clear for FlexVolumeSource {
    fn clear(&mut self) {
        self.driver.clear();
        self.fsType.clear();
        self.secretRef.clear();
        self.readOnly = ::std::option::Option::None;
        self.options.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FlexVolumeSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FlexVolumeSource {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FlockerVolumeSource {
    // message fields
    datasetName: ::protobuf::SingularField<::std::string::String>,
    datasetUUID: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FlockerVolumeSource {
    fn default() -> &'a FlockerVolumeSource {
        <FlockerVolumeSource as ::protobuf::Message>::default_instance()
    }
}

impl FlockerVolumeSource {
    pub fn new() -> FlockerVolumeSource {
        ::std::default::Default::default()
    }

    // optional string datasetName = 1;


    pub fn get_datasetName(&self) -> &str {
        match self.datasetName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_datasetName(&mut self) {
        self.datasetName.clear();
    }

    pub fn has_datasetName(&self) -> bool {
        self.datasetName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_datasetName(&mut self, v: ::std::string::String) {
        self.datasetName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_datasetName(&mut self) -> &mut ::std::string::String {
        if self.datasetName.is_none() {
            self.datasetName.set_default();
        }
        self.datasetName.as_mut().unwrap()
    }

    // Take field
    pub fn take_datasetName(&mut self) -> ::std::string::String {
        self.datasetName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string datasetUUID = 2;


    pub fn get_datasetUUID(&self) -> &str {
        match self.datasetUUID.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_datasetUUID(&mut self) {
        self.datasetUUID.clear();
    }

    pub fn has_datasetUUID(&self) -> bool {
        self.datasetUUID.is_some()
    }

    // Param is passed by value, moved
    pub fn set_datasetUUID(&mut self, v: ::std::string::String) {
        self.datasetUUID = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_datasetUUID(&mut self) -> &mut ::std::string::String {
        if self.datasetUUID.is_none() {
            self.datasetUUID.set_default();
        }
        self.datasetUUID.as_mut().unwrap()
    }

    // Take field
    pub fn take_datasetUUID(&mut self) -> ::std::string::String {
        self.datasetUUID.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for FlockerVolumeSource {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.datasetName)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.datasetUUID)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.datasetName.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.datasetUUID.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.datasetName.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.datasetUUID.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FlockerVolumeSource {
        FlockerVolumeSource::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "datasetName",
                |m: &FlockerVolumeSource| { &m.datasetName },
                |m: &mut FlockerVolumeSource| { &mut m.datasetName },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "datasetUUID",
                |m: &FlockerVolumeSource| { &m.datasetUUID },
                |m: &mut FlockerVolumeSource| { &mut m.datasetUUID },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FlockerVolumeSource>(
                "FlockerVolumeSource",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FlockerVolumeSource {
        static instance: ::protobuf::rt::LazyV2<FlockerVolumeSource> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FlockerVolumeSource::new)
    }
}

impl ::protobuf::Clear for FlockerVolumeSource {
    fn clear(&mut self) {
        self.datasetName.clear();
        self.datasetUUID.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FlockerVolumeSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FlockerVolumeSource {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GCEPersistentDiskVolumeSource {
    // message fields
    pdName: ::protobuf::SingularField<::std::string::String>,
    fsType: ::protobuf::SingularField<::std::string::String>,
    partition: ::std::option::Option<i32>,
    readOnly: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GCEPersistentDiskVolumeSource {
    fn default() -> &'a GCEPersistentDiskVolumeSource {
        <GCEPersistentDiskVolumeSource as ::protobuf::Message>::default_instance()
    }
}

impl GCEPersistentDiskVolumeSource {
    pub fn new() -> GCEPersistentDiskVolumeSource {
        ::std::default::Default::default()
    }

    // optional string pdName = 1;


    pub fn get_pdName(&self) -> &str {
        match self.pdName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_pdName(&mut self) {
        self.pdName.clear();
    }

    pub fn has_pdName(&self) -> bool {
        self.pdName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pdName(&mut self, v: ::std::string::String) {
        self.pdName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pdName(&mut self) -> &mut ::std::string::String {
        if self.pdName.is_none() {
            self.pdName.set_default();
        }
        self.pdName.as_mut().unwrap()
    }

    // Take field
    pub fn take_pdName(&mut self) -> ::std::string::String {
        self.pdName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string fsType = 2;


    pub fn get_fsType(&self) -> &str {
        match self.fsType.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_fsType(&mut self) {
        self.fsType.clear();
    }

    pub fn has_fsType(&self) -> bool {
        self.fsType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fsType(&mut self, v: ::std::string::String) {
        self.fsType = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fsType(&mut self) -> &mut ::std::string::String {
        if self.fsType.is_none() {
            self.fsType.set_default();
        }
        self.fsType.as_mut().unwrap()
    }

    // Take field
    pub fn take_fsType(&mut self) -> ::std::string::String {
        self.fsType.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 partition = 3;


    pub fn get_partition(&self) -> i32 {
        self.partition.unwrap_or(0)
    }
    pub fn clear_partition(&mut self) {
        self.partition = ::std::option::Option::None;
    }

    pub fn has_partition(&self) -> bool {
        self.partition.is_some()
    }

    // Param is passed by value, moved
    pub fn set_partition(&mut self, v: i32) {
        self.partition = ::std::option::Option::Some(v);
    }

    // optional bool readOnly = 4;


    pub fn get_readOnly(&self) -> bool {
        self.readOnly.unwrap_or(false)
    }
    pub fn clear_readOnly(&mut self) {
        self.readOnly = ::std::option::Option::None;
    }

    pub fn has_readOnly(&self) -> bool {
        self.readOnly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readOnly(&mut self, v: bool) {
        self.readOnly = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for GCEPersistentDiskVolumeSource {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.pdName)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.fsType)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.partition = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.readOnly = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.pdName.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.fsType.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.partition {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.readOnly {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.pdName.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.fsType.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.partition {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.readOnly {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GCEPersistentDiskVolumeSource {
        GCEPersistentDiskVolumeSource::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "pdName",
                |m: &GCEPersistentDiskVolumeSource| { &m.pdName },
                |m: &mut GCEPersistentDiskVolumeSource| { &mut m.pdName },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "fsType",
                |m: &GCEPersistentDiskVolumeSource| { &m.fsType },
                |m: &mut GCEPersistentDiskVolumeSource| { &mut m.fsType },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "partition",
                |m: &GCEPersistentDiskVolumeSource| { &m.partition },
                |m: &mut GCEPersistentDiskVolumeSource| { &mut m.partition },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "readOnly",
                |m: &GCEPersistentDiskVolumeSource| { &m.readOnly },
                |m: &mut GCEPersistentDiskVolumeSource| { &mut m.readOnly },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GCEPersistentDiskVolumeSource>(
                "GCEPersistentDiskVolumeSource",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GCEPersistentDiskVolumeSource {
        static instance: ::protobuf::rt::LazyV2<GCEPersistentDiskVolumeSource> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GCEPersistentDiskVolumeSource::new)
    }
}

impl ::protobuf::Clear for GCEPersistentDiskVolumeSource {
    fn clear(&mut self) {
        self.pdName.clear();
        self.fsType.clear();
        self.partition = ::std::option::Option::None;
        self.readOnly = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GCEPersistentDiskVolumeSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GCEPersistentDiskVolumeSource {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GitRepoVolumeSource {
    // message fields
    repository: ::protobuf::SingularField<::std::string::String>,
    revision: ::protobuf::SingularField<::std::string::String>,
    directory: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GitRepoVolumeSource {
    fn default() -> &'a GitRepoVolumeSource {
        <GitRepoVolumeSource as ::protobuf::Message>::default_instance()
    }
}

impl GitRepoVolumeSource {
    pub fn new() -> GitRepoVolumeSource {
        ::std::default::Default::default()
    }

    // optional string repository = 1;


    pub fn get_repository(&self) -> &str {
        match self.repository.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_repository(&mut self) {
        self.repository.clear();
    }

    pub fn has_repository(&self) -> bool {
        self.repository.is_some()
    }

    // Param is passed by value, moved
    pub fn set_repository(&mut self, v: ::std::string::String) {
        self.repository = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_repository(&mut self) -> &mut ::std::string::String {
        if self.repository.is_none() {
            self.repository.set_default();
        }
        self.repository.as_mut().unwrap()
    }

    // Take field
    pub fn take_repository(&mut self) -> ::std::string::String {
        self.repository.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string revision = 2;


    pub fn get_revision(&self) -> &str {
        match self.revision.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_revision(&mut self) {
        self.revision.clear();
    }

    pub fn has_revision(&self) -> bool {
        self.revision.is_some()
    }

    // Param is passed by value, moved
    pub fn set_revision(&mut self, v: ::std::string::String) {
        self.revision = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_revision(&mut self) -> &mut ::std::string::String {
        if self.revision.is_none() {
            self.revision.set_default();
        }
        self.revision.as_mut().unwrap()
    }

    // Take field
    pub fn take_revision(&mut self) -> ::std::string::String {
        self.revision.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string directory = 3;


    pub fn get_directory(&self) -> &str {
        match self.directory.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_directory(&mut self) {
        self.directory.clear();
    }

    pub fn has_directory(&self) -> bool {
        self.directory.is_some()
    }

    // Param is passed by value, moved
    pub fn set_directory(&mut self, v: ::std::string::String) {
        self.directory = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_directory(&mut self) -> &mut ::std::string::String {
        if self.directory.is_none() {
            self.directory.set_default();
        }
        self.directory.as_mut().unwrap()
    }

    // Take field
    pub fn take_directory(&mut self) -> ::std::string::String {
        self.directory.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for GitRepoVolumeSource {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.repository)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.revision)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.directory)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.repository.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.revision.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.directory.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.repository.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.revision.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.directory.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GitRepoVolumeSource {
        GitRepoVolumeSource::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "repository",
                |m: &GitRepoVolumeSource| { &m.repository },
                |m: &mut GitRepoVolumeSource| { &mut m.repository },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "revision",
                |m: &GitRepoVolumeSource| { &m.revision },
                |m: &mut GitRepoVolumeSource| { &mut m.revision },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "directory",
                |m: &GitRepoVolumeSource| { &m.directory },
                |m: &mut GitRepoVolumeSource| { &mut m.directory },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GitRepoVolumeSource>(
                "GitRepoVolumeSource",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GitRepoVolumeSource {
        static instance: ::protobuf::rt::LazyV2<GitRepoVolumeSource> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GitRepoVolumeSource::new)
    }
}

impl ::protobuf::Clear for GitRepoVolumeSource {
    fn clear(&mut self) {
        self.repository.clear();
        self.revision.clear();
        self.directory.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GitRepoVolumeSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GitRepoVolumeSource {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GlusterfsPersistentVolumeSource {
    // message fields
    endpoints: ::protobuf::SingularField<::std::string::String>,
    path: ::protobuf::SingularField<::std::string::String>,
    readOnly: ::std::option::Option<bool>,
    endpointsNamespace: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GlusterfsPersistentVolumeSource {
    fn default() -> &'a GlusterfsPersistentVolumeSource {
        <GlusterfsPersistentVolumeSource as ::protobuf::Message>::default_instance()
    }
}

impl GlusterfsPersistentVolumeSource {
    pub fn new() -> GlusterfsPersistentVolumeSource {
        ::std::default::Default::default()
    }

    // optional string endpoints = 1;


    pub fn get_endpoints(&self) -> &str {
        match self.endpoints.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_endpoints(&mut self) {
        self.endpoints.clear();
    }

    pub fn has_endpoints(&self) -> bool {
        self.endpoints.is_some()
    }

    // Param is passed by value, moved
    pub fn set_endpoints(&mut self, v: ::std::string::String) {
        self.endpoints = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_endpoints(&mut self) -> &mut ::std::string::String {
        if self.endpoints.is_none() {
            self.endpoints.set_default();
        }
        self.endpoints.as_mut().unwrap()
    }

    // Take field
    pub fn take_endpoints(&mut self) -> ::std::string::String {
        self.endpoints.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string path = 2;


    pub fn get_path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path.set_default();
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool readOnly = 3;


    pub fn get_readOnly(&self) -> bool {
        self.readOnly.unwrap_or(false)
    }
    pub fn clear_readOnly(&mut self) {
        self.readOnly = ::std::option::Option::None;
    }

    pub fn has_readOnly(&self) -> bool {
        self.readOnly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readOnly(&mut self, v: bool) {
        self.readOnly = ::std::option::Option::Some(v);
    }

    // optional string endpointsNamespace = 4;


    pub fn get_endpointsNamespace(&self) -> &str {
        match self.endpointsNamespace.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_endpointsNamespace(&mut self) {
        self.endpointsNamespace.clear();
    }

    pub fn has_endpointsNamespace(&self) -> bool {
        self.endpointsNamespace.is_some()
    }

    // Param is passed by value, moved
    pub fn set_endpointsNamespace(&mut self, v: ::std::string::String) {
        self.endpointsNamespace = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_endpointsNamespace(&mut self) -> &mut ::std::string::String {
        if self.endpointsNamespace.is_none() {
            self.endpointsNamespace.set_default();
        }
        self.endpointsNamespace.as_mut().unwrap()
    }

    // Take field
    pub fn take_endpointsNamespace(&mut self) -> ::std::string::String {
        self.endpointsNamespace.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for GlusterfsPersistentVolumeSource {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.endpoints)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.path)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.readOnly = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.endpointsNamespace)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.endpoints.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.path.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.readOnly {
            my_size += 2;
        }
        if let Some(ref v) = self.endpointsNamespace.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.endpoints.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.path.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.readOnly {
            os.write_bool(3, v)?;
        }
        if let Some(ref v) = self.endpointsNamespace.as_ref() {
            os.write_string(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GlusterfsPersistentVolumeSource {
        GlusterfsPersistentVolumeSource::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "endpoints",
                |m: &GlusterfsPersistentVolumeSource| { &m.endpoints },
                |m: &mut GlusterfsPersistentVolumeSource| { &mut m.endpoints },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "path",
                |m: &GlusterfsPersistentVolumeSource| { &m.path },
                |m: &mut GlusterfsPersistentVolumeSource| { &mut m.path },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "readOnly",
                |m: &GlusterfsPersistentVolumeSource| { &m.readOnly },
                |m: &mut GlusterfsPersistentVolumeSource| { &mut m.readOnly },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "endpointsNamespace",
                |m: &GlusterfsPersistentVolumeSource| { &m.endpointsNamespace },
                |m: &mut GlusterfsPersistentVolumeSource| { &mut m.endpointsNamespace },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GlusterfsPersistentVolumeSource>(
                "GlusterfsPersistentVolumeSource",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GlusterfsPersistentVolumeSource {
        static instance: ::protobuf::rt::LazyV2<GlusterfsPersistentVolumeSource> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GlusterfsPersistentVolumeSource::new)
    }
}

impl ::protobuf::Clear for GlusterfsPersistentVolumeSource {
    fn clear(&mut self) {
        self.endpoints.clear();
        self.path.clear();
        self.readOnly = ::std::option::Option::None;
        self.endpointsNamespace.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GlusterfsPersistentVolumeSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GlusterfsPersistentVolumeSource {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GlusterfsVolumeSource {
    // message fields
    endpoints: ::protobuf::SingularField<::std::string::String>,
    path: ::protobuf::SingularField<::std::string::String>,
    readOnly: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GlusterfsVolumeSource {
    fn default() -> &'a GlusterfsVolumeSource {
        <GlusterfsVolumeSource as ::protobuf::Message>::default_instance()
    }
}

impl GlusterfsVolumeSource {
    pub fn new() -> GlusterfsVolumeSource {
        ::std::default::Default::default()
    }

    // optional string endpoints = 1;


    pub fn get_endpoints(&self) -> &str {
        match self.endpoints.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_endpoints(&mut self) {
        self.endpoints.clear();
    }

    pub fn has_endpoints(&self) -> bool {
        self.endpoints.is_some()
    }

    // Param is passed by value, moved
    pub fn set_endpoints(&mut self, v: ::std::string::String) {
        self.endpoints = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_endpoints(&mut self) -> &mut ::std::string::String {
        if self.endpoints.is_none() {
            self.endpoints.set_default();
        }
        self.endpoints.as_mut().unwrap()
    }

    // Take field
    pub fn take_endpoints(&mut self) -> ::std::string::String {
        self.endpoints.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string path = 2;


    pub fn get_path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path.set_default();
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool readOnly = 3;


    pub fn get_readOnly(&self) -> bool {
        self.readOnly.unwrap_or(false)
    }
    pub fn clear_readOnly(&mut self) {
        self.readOnly = ::std::option::Option::None;
    }

    pub fn has_readOnly(&self) -> bool {
        self.readOnly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readOnly(&mut self, v: bool) {
        self.readOnly = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for GlusterfsVolumeSource {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.endpoints)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.path)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.readOnly = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.endpoints.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.path.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.readOnly {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.endpoints.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.path.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.readOnly {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GlusterfsVolumeSource {
        GlusterfsVolumeSource::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "endpoints",
                |m: &GlusterfsVolumeSource| { &m.endpoints },
                |m: &mut GlusterfsVolumeSource| { &mut m.endpoints },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "path",
                |m: &GlusterfsVolumeSource| { &m.path },
                |m: &mut GlusterfsVolumeSource| { &mut m.path },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "readOnly",
                |m: &GlusterfsVolumeSource| { &m.readOnly },
                |m: &mut GlusterfsVolumeSource| { &mut m.readOnly },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GlusterfsVolumeSource>(
                "GlusterfsVolumeSource",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GlusterfsVolumeSource {
        static instance: ::protobuf::rt::LazyV2<GlusterfsVolumeSource> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GlusterfsVolumeSource::new)
    }
}

impl ::protobuf::Clear for GlusterfsVolumeSource {
    fn clear(&mut self) {
        self.endpoints.clear();
        self.path.clear();
        self.readOnly = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GlusterfsVolumeSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GlusterfsVolumeSource {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HTTPGetAction {
    // message fields
    path: ::protobuf::SingularField<::std::string::String>,
    pub port: ::protobuf::SingularPtrField<super::k8s_io_apimachinery_pkg_util_intstr_generated::IntOrString>,
    host: ::protobuf::SingularField<::std::string::String>,
    scheme: ::protobuf::SingularField<::std::string::String>,
    pub httpHeaders: ::protobuf::RepeatedField<HTTPHeader>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HTTPGetAction {
    fn default() -> &'a HTTPGetAction {
        <HTTPGetAction as ::protobuf::Message>::default_instance()
    }
}

impl HTTPGetAction {
    pub fn new() -> HTTPGetAction {
        ::std::default::Default::default()
    }

    // optional string path = 1;


    pub fn get_path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path.set_default();
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString port = 2;


    pub fn get_port(&self) -> &super::k8s_io_apimachinery_pkg_util_intstr_generated::IntOrString {
        self.port.as_ref().unwrap_or_else(|| <super::k8s_io_apimachinery_pkg_util_intstr_generated::IntOrString as ::protobuf::Message>::default_instance())
    }
    pub fn clear_port(&mut self) {
        self.port.clear();
    }

    pub fn has_port(&self) -> bool {
        self.port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_port(&mut self, v: super::k8s_io_apimachinery_pkg_util_intstr_generated::IntOrString) {
        self.port = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_port(&mut self) -> &mut super::k8s_io_apimachinery_pkg_util_intstr_generated::IntOrString {
        if self.port.is_none() {
            self.port.set_default();
        }
        self.port.as_mut().unwrap()
    }

    // Take field
    pub fn take_port(&mut self) -> super::k8s_io_apimachinery_pkg_util_intstr_generated::IntOrString {
        self.port.take().unwrap_or_else(|| super::k8s_io_apimachinery_pkg_util_intstr_generated::IntOrString::new())
    }

    // optional string host = 3;


    pub fn get_host(&self) -> &str {
        match self.host.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_host(&mut self) {
        self.host.clear();
    }

    pub fn has_host(&self) -> bool {
        self.host.is_some()
    }

    // Param is passed by value, moved
    pub fn set_host(&mut self, v: ::std::string::String) {
        self.host = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_host(&mut self) -> &mut ::std::string::String {
        if self.host.is_none() {
            self.host.set_default();
        }
        self.host.as_mut().unwrap()
    }

    // Take field
    pub fn take_host(&mut self) -> ::std::string::String {
        self.host.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string scheme = 4;


    pub fn get_scheme(&self) -> &str {
        match self.scheme.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_scheme(&mut self) {
        self.scheme.clear();
    }

    pub fn has_scheme(&self) -> bool {
        self.scheme.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scheme(&mut self, v: ::std::string::String) {
        self.scheme = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_scheme(&mut self) -> &mut ::std::string::String {
        if self.scheme.is_none() {
            self.scheme.set_default();
        }
        self.scheme.as_mut().unwrap()
    }

    // Take field
    pub fn take_scheme(&mut self) -> ::std::string::String {
        self.scheme.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .k8s.io.api.core.v1.HTTPHeader httpHeaders = 5;


    pub fn get_httpHeaders(&self) -> &[HTTPHeader] {
        &self.httpHeaders
    }
    pub fn clear_httpHeaders(&mut self) {
        self.httpHeaders.clear();
    }

    // Param is passed by value, moved
    pub fn set_httpHeaders(&mut self, v: ::protobuf::RepeatedField<HTTPHeader>) {
        self.httpHeaders = v;
    }

    // Mutable pointer to the field.
    pub fn mut_httpHeaders(&mut self) -> &mut ::protobuf::RepeatedField<HTTPHeader> {
        &mut self.httpHeaders
    }

    // Take field
    pub fn take_httpHeaders(&mut self) -> ::protobuf::RepeatedField<HTTPHeader> {
        ::std::mem::replace(&mut self.httpHeaders, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for HTTPGetAction {
    fn is_initialized(&self) -> bool {
        for v in &self.port {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.httpHeaders {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.path)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.port)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.host)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.scheme)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.httpHeaders)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.path.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.port.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.host.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.scheme.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        for value in &self.httpHeaders {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.path.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.port.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.host.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.scheme.as_ref() {
            os.write_string(4, &v)?;
        }
        for v in &self.httpHeaders {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HTTPGetAction {
        HTTPGetAction::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "path",
                |m: &HTTPGetAction| { &m.path },
                |m: &mut HTTPGetAction| { &mut m.path },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_util_intstr_generated::IntOrString>>(
                "port",
                |m: &HTTPGetAction| { &m.port },
                |m: &mut HTTPGetAction| { &mut m.port },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "host",
                |m: &HTTPGetAction| { &m.host },
                |m: &mut HTTPGetAction| { &mut m.host },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "scheme",
                |m: &HTTPGetAction| { &m.scheme },
                |m: &mut HTTPGetAction| { &mut m.scheme },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<HTTPHeader>>(
                "httpHeaders",
                |m: &HTTPGetAction| { &m.httpHeaders },
                |m: &mut HTTPGetAction| { &mut m.httpHeaders },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HTTPGetAction>(
                "HTTPGetAction",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static HTTPGetAction {
        static instance: ::protobuf::rt::LazyV2<HTTPGetAction> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HTTPGetAction::new)
    }
}

impl ::protobuf::Clear for HTTPGetAction {
    fn clear(&mut self) {
        self.path.clear();
        self.port.clear();
        self.host.clear();
        self.scheme.clear();
        self.httpHeaders.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HTTPGetAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HTTPGetAction {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HTTPHeader {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    value: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HTTPHeader {
    fn default() -> &'a HTTPHeader {
        <HTTPHeader as ::protobuf::Message>::default_instance()
    }
}

impl HTTPHeader {
    pub fn new() -> HTTPHeader {
        ::std::default::Default::default()
    }

    // optional string name = 1;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string value = 2;


    pub fn get_value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        if self.value.is_none() {
            self.value.set_default();
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for HTTPHeader {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.value.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.value.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HTTPHeader {
        HTTPHeader::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &HTTPHeader| { &m.name },
                |m: &mut HTTPHeader| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "value",
                |m: &HTTPHeader| { &m.value },
                |m: &mut HTTPHeader| { &mut m.value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HTTPHeader>(
                "HTTPHeader",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static HTTPHeader {
        static instance: ::protobuf::rt::LazyV2<HTTPHeader> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HTTPHeader::new)
    }
}

impl ::protobuf::Clear for HTTPHeader {
    fn clear(&mut self) {
        self.name.clear();
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HTTPHeader {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HTTPHeader {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Handler {
    // message fields
    pub exec: ::protobuf::SingularPtrField<ExecAction>,
    pub httpGet: ::protobuf::SingularPtrField<HTTPGetAction>,
    pub tcpSocket: ::protobuf::SingularPtrField<TCPSocketAction>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Handler {
    fn default() -> &'a Handler {
        <Handler as ::protobuf::Message>::default_instance()
    }
}

impl Handler {
    pub fn new() -> Handler {
        ::std::default::Default::default()
    }

    // optional .k8s.io.api.core.v1.ExecAction exec = 1;


    pub fn get_exec(&self) -> &ExecAction {
        self.exec.as_ref().unwrap_or_else(|| <ExecAction as ::protobuf::Message>::default_instance())
    }
    pub fn clear_exec(&mut self) {
        self.exec.clear();
    }

    pub fn has_exec(&self) -> bool {
        self.exec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_exec(&mut self, v: ExecAction) {
        self.exec = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_exec(&mut self) -> &mut ExecAction {
        if self.exec.is_none() {
            self.exec.set_default();
        }
        self.exec.as_mut().unwrap()
    }

    // Take field
    pub fn take_exec(&mut self) -> ExecAction {
        self.exec.take().unwrap_or_else(|| ExecAction::new())
    }

    // optional .k8s.io.api.core.v1.HTTPGetAction httpGet = 2;


    pub fn get_httpGet(&self) -> &HTTPGetAction {
        self.httpGet.as_ref().unwrap_or_else(|| <HTTPGetAction as ::protobuf::Message>::default_instance())
    }
    pub fn clear_httpGet(&mut self) {
        self.httpGet.clear();
    }

    pub fn has_httpGet(&self) -> bool {
        self.httpGet.is_some()
    }

    // Param is passed by value, moved
    pub fn set_httpGet(&mut self, v: HTTPGetAction) {
        self.httpGet = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_httpGet(&mut self) -> &mut HTTPGetAction {
        if self.httpGet.is_none() {
            self.httpGet.set_default();
        }
        self.httpGet.as_mut().unwrap()
    }

    // Take field
    pub fn take_httpGet(&mut self) -> HTTPGetAction {
        self.httpGet.take().unwrap_or_else(|| HTTPGetAction::new())
    }

    // optional .k8s.io.api.core.v1.TCPSocketAction tcpSocket = 3;


    pub fn get_tcpSocket(&self) -> &TCPSocketAction {
        self.tcpSocket.as_ref().unwrap_or_else(|| <TCPSocketAction as ::protobuf::Message>::default_instance())
    }
    pub fn clear_tcpSocket(&mut self) {
        self.tcpSocket.clear();
    }

    pub fn has_tcpSocket(&self) -> bool {
        self.tcpSocket.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tcpSocket(&mut self, v: TCPSocketAction) {
        self.tcpSocket = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tcpSocket(&mut self) -> &mut TCPSocketAction {
        if self.tcpSocket.is_none() {
            self.tcpSocket.set_default();
        }
        self.tcpSocket.as_mut().unwrap()
    }

    // Take field
    pub fn take_tcpSocket(&mut self) -> TCPSocketAction {
        self.tcpSocket.take().unwrap_or_else(|| TCPSocketAction::new())
    }
}

impl ::protobuf::Message for Handler {
    fn is_initialized(&self) -> bool {
        for v in &self.exec {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.httpGet {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tcpSocket {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.exec)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.httpGet)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.tcpSocket)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.exec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.httpGet.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.tcpSocket.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.exec.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.httpGet.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.tcpSocket.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Handler {
        Handler::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ExecAction>>(
                "exec",
                |m: &Handler| { &m.exec },
                |m: &mut Handler| { &mut m.exec },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<HTTPGetAction>>(
                "httpGet",
                |m: &Handler| { &m.httpGet },
                |m: &mut Handler| { &mut m.httpGet },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TCPSocketAction>>(
                "tcpSocket",
                |m: &Handler| { &m.tcpSocket },
                |m: &mut Handler| { &mut m.tcpSocket },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Handler>(
                "Handler",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Handler {
        static instance: ::protobuf::rt::LazyV2<Handler> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Handler::new)
    }
}

impl ::protobuf::Clear for Handler {
    fn clear(&mut self) {
        self.exec.clear();
        self.httpGet.clear();
        self.tcpSocket.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Handler {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Handler {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HostAlias {
    // message fields
    ip: ::protobuf::SingularField<::std::string::String>,
    pub hostnames: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HostAlias {
    fn default() -> &'a HostAlias {
        <HostAlias as ::protobuf::Message>::default_instance()
    }
}

impl HostAlias {
    pub fn new() -> HostAlias {
        ::std::default::Default::default()
    }

    // optional string ip = 1;


    pub fn get_ip(&self) -> &str {
        match self.ip.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_ip(&mut self) {
        self.ip.clear();
    }

    pub fn has_ip(&self) -> bool {
        self.ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ip(&mut self, v: ::std::string::String) {
        self.ip = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ip(&mut self) -> &mut ::std::string::String {
        if self.ip.is_none() {
            self.ip.set_default();
        }
        self.ip.as_mut().unwrap()
    }

    // Take field
    pub fn take_ip(&mut self) -> ::std::string::String {
        self.ip.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated string hostnames = 2;


    pub fn get_hostnames(&self) -> &[::std::string::String] {
        &self.hostnames
    }
    pub fn clear_hostnames(&mut self) {
        self.hostnames.clear();
    }

    // Param is passed by value, moved
    pub fn set_hostnames(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.hostnames = v;
    }

    // Mutable pointer to the field.
    pub fn mut_hostnames(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.hostnames
    }

    // Take field
    pub fn take_hostnames(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.hostnames, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for HostAlias {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.ip)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.hostnames)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.ip.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.hostnames {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.ip.as_ref() {
            os.write_string(1, &v)?;
        }
        for v in &self.hostnames {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HostAlias {
        HostAlias::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "ip",
                |m: &HostAlias| { &m.ip },
                |m: &mut HostAlias| { &mut m.ip },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "hostnames",
                |m: &HostAlias| { &m.hostnames },
                |m: &mut HostAlias| { &mut m.hostnames },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HostAlias>(
                "HostAlias",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static HostAlias {
        static instance: ::protobuf::rt::LazyV2<HostAlias> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HostAlias::new)
    }
}

impl ::protobuf::Clear for HostAlias {
    fn clear(&mut self) {
        self.ip.clear();
        self.hostnames.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HostAlias {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HostAlias {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct HostPathVolumeSource {
    // message fields
    path: ::protobuf::SingularField<::std::string::String>,
    field_type: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HostPathVolumeSource {
    fn default() -> &'a HostPathVolumeSource {
        <HostPathVolumeSource as ::protobuf::Message>::default_instance()
    }
}

impl HostPathVolumeSource {
    pub fn new() -> HostPathVolumeSource {
        ::std::default::Default::default()
    }

    // optional string path = 1;


    pub fn get_path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path.set_default();
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string type = 2;


    pub fn get_field_type(&self) -> &str {
        match self.field_type.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ::std::string::String) {
        self.field_type = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut ::std::string::String {
        if self.field_type.is_none() {
            self.field_type.set_default();
        }
        self.field_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_field_type(&mut self) -> ::std::string::String {
        self.field_type.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for HostPathVolumeSource {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.path)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.field_type)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.path.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.field_type.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.path.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.field_type.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HostPathVolumeSource {
        HostPathVolumeSource::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "path",
                |m: &HostPathVolumeSource| { &m.path },
                |m: &mut HostPathVolumeSource| { &mut m.path },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "type",
                |m: &HostPathVolumeSource| { &m.field_type },
                |m: &mut HostPathVolumeSource| { &mut m.field_type },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<HostPathVolumeSource>(
                "HostPathVolumeSource",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static HostPathVolumeSource {
        static instance: ::protobuf::rt::LazyV2<HostPathVolumeSource> = ::protobuf::rt::LazyV2::INIT;
        instance.get(HostPathVolumeSource::new)
    }
}

impl ::protobuf::Clear for HostPathVolumeSource {
    fn clear(&mut self) {
        self.path.clear();
        self.field_type.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HostPathVolumeSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HostPathVolumeSource {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ISCSIPersistentVolumeSource {
    // message fields
    targetPortal: ::protobuf::SingularField<::std::string::String>,
    iqn: ::protobuf::SingularField<::std::string::String>,
    lun: ::std::option::Option<i32>,
    iscsiInterface: ::protobuf::SingularField<::std::string::String>,
    fsType: ::protobuf::SingularField<::std::string::String>,
    readOnly: ::std::option::Option<bool>,
    pub portals: ::protobuf::RepeatedField<::std::string::String>,
    chapAuthDiscovery: ::std::option::Option<bool>,
    chapAuthSession: ::std::option::Option<bool>,
    pub secretRef: ::protobuf::SingularPtrField<SecretReference>,
    initiatorName: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ISCSIPersistentVolumeSource {
    fn default() -> &'a ISCSIPersistentVolumeSource {
        <ISCSIPersistentVolumeSource as ::protobuf::Message>::default_instance()
    }
}

impl ISCSIPersistentVolumeSource {
    pub fn new() -> ISCSIPersistentVolumeSource {
        ::std::default::Default::default()
    }

    // optional string targetPortal = 1;


    pub fn get_targetPortal(&self) -> &str {
        match self.targetPortal.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_targetPortal(&mut self) {
        self.targetPortal.clear();
    }

    pub fn has_targetPortal(&self) -> bool {
        self.targetPortal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_targetPortal(&mut self, v: ::std::string::String) {
        self.targetPortal = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_targetPortal(&mut self) -> &mut ::std::string::String {
        if self.targetPortal.is_none() {
            self.targetPortal.set_default();
        }
        self.targetPortal.as_mut().unwrap()
    }

    // Take field
    pub fn take_targetPortal(&mut self) -> ::std::string::String {
        self.targetPortal.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string iqn = 2;


    pub fn get_iqn(&self) -> &str {
        match self.iqn.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_iqn(&mut self) {
        self.iqn.clear();
    }

    pub fn has_iqn(&self) -> bool {
        self.iqn.is_some()
    }

    // Param is passed by value, moved
    pub fn set_iqn(&mut self, v: ::std::string::String) {
        self.iqn = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_iqn(&mut self) -> &mut ::std::string::String {
        if self.iqn.is_none() {
            self.iqn.set_default();
        }
        self.iqn.as_mut().unwrap()
    }

    // Take field
    pub fn take_iqn(&mut self) -> ::std::string::String {
        self.iqn.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 lun = 3;


    pub fn get_lun(&self) -> i32 {
        self.lun.unwrap_or(0)
    }
    pub fn clear_lun(&mut self) {
        self.lun = ::std::option::Option::None;
    }

    pub fn has_lun(&self) -> bool {
        self.lun.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lun(&mut self, v: i32) {
        self.lun = ::std::option::Option::Some(v);
    }

    // optional string iscsiInterface = 4;


    pub fn get_iscsiInterface(&self) -> &str {
        match self.iscsiInterface.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_iscsiInterface(&mut self) {
        self.iscsiInterface.clear();
    }

    pub fn has_iscsiInterface(&self) -> bool {
        self.iscsiInterface.is_some()
    }

    // Param is passed by value, moved
    pub fn set_iscsiInterface(&mut self, v: ::std::string::String) {
        self.iscsiInterface = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_iscsiInterface(&mut self) -> &mut ::std::string::String {
        if self.iscsiInterface.is_none() {
            self.iscsiInterface.set_default();
        }
        self.iscsiInterface.as_mut().unwrap()
    }

    // Take field
    pub fn take_iscsiInterface(&mut self) -> ::std::string::String {
        self.iscsiInterface.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string fsType = 5;


    pub fn get_fsType(&self) -> &str {
        match self.fsType.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_fsType(&mut self) {
        self.fsType.clear();
    }

    pub fn has_fsType(&self) -> bool {
        self.fsType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fsType(&mut self, v: ::std::string::String) {
        self.fsType = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fsType(&mut self) -> &mut ::std::string::String {
        if self.fsType.is_none() {
            self.fsType.set_default();
        }
        self.fsType.as_mut().unwrap()
    }

    // Take field
    pub fn take_fsType(&mut self) -> ::std::string::String {
        self.fsType.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool readOnly = 6;


    pub fn get_readOnly(&self) -> bool {
        self.readOnly.unwrap_or(false)
    }
    pub fn clear_readOnly(&mut self) {
        self.readOnly = ::std::option::Option::None;
    }

    pub fn has_readOnly(&self) -> bool {
        self.readOnly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readOnly(&mut self, v: bool) {
        self.readOnly = ::std::option::Option::Some(v);
    }

    // repeated string portals = 7;


    pub fn get_portals(&self) -> &[::std::string::String] {
        &self.portals
    }
    pub fn clear_portals(&mut self) {
        self.portals.clear();
    }

    // Param is passed by value, moved
    pub fn set_portals(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.portals = v;
    }

    // Mutable pointer to the field.
    pub fn mut_portals(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.portals
    }

    // Take field
    pub fn take_portals(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.portals, ::protobuf::RepeatedField::new())
    }

    // optional bool chapAuthDiscovery = 8;


    pub fn get_chapAuthDiscovery(&self) -> bool {
        self.chapAuthDiscovery.unwrap_or(false)
    }
    pub fn clear_chapAuthDiscovery(&mut self) {
        self.chapAuthDiscovery = ::std::option::Option::None;
    }

    pub fn has_chapAuthDiscovery(&self) -> bool {
        self.chapAuthDiscovery.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chapAuthDiscovery(&mut self, v: bool) {
        self.chapAuthDiscovery = ::std::option::Option::Some(v);
    }

    // optional bool chapAuthSession = 11;


    pub fn get_chapAuthSession(&self) -> bool {
        self.chapAuthSession.unwrap_or(false)
    }
    pub fn clear_chapAuthSession(&mut self) {
        self.chapAuthSession = ::std::option::Option::None;
    }

    pub fn has_chapAuthSession(&self) -> bool {
        self.chapAuthSession.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chapAuthSession(&mut self, v: bool) {
        self.chapAuthSession = ::std::option::Option::Some(v);
    }

    // optional .k8s.io.api.core.v1.SecretReference secretRef = 10;


    pub fn get_secretRef(&self) -> &SecretReference {
        self.secretRef.as_ref().unwrap_or_else(|| <SecretReference as ::protobuf::Message>::default_instance())
    }
    pub fn clear_secretRef(&mut self) {
        self.secretRef.clear();
    }

    pub fn has_secretRef(&self) -> bool {
        self.secretRef.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secretRef(&mut self, v: SecretReference) {
        self.secretRef = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_secretRef(&mut self) -> &mut SecretReference {
        if self.secretRef.is_none() {
            self.secretRef.set_default();
        }
        self.secretRef.as_mut().unwrap()
    }

    // Take field
    pub fn take_secretRef(&mut self) -> SecretReference {
        self.secretRef.take().unwrap_or_else(|| SecretReference::new())
    }

    // optional string initiatorName = 12;


    pub fn get_initiatorName(&self) -> &str {
        match self.initiatorName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_initiatorName(&mut self) {
        self.initiatorName.clear();
    }

    pub fn has_initiatorName(&self) -> bool {
        self.initiatorName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_initiatorName(&mut self, v: ::std::string::String) {
        self.initiatorName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_initiatorName(&mut self) -> &mut ::std::string::String {
        if self.initiatorName.is_none() {
            self.initiatorName.set_default();
        }
        self.initiatorName.as_mut().unwrap()
    }

    // Take field
    pub fn take_initiatorName(&mut self) -> ::std::string::String {
        self.initiatorName.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for ISCSIPersistentVolumeSource {
    fn is_initialized(&self) -> bool {
        for v in &self.secretRef {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.targetPortal)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.iqn)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.lun = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.iscsiInterface)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.fsType)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.readOnly = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.portals)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.chapAuthDiscovery = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.chapAuthSession = ::std::option::Option::Some(tmp);
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.secretRef)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.initiatorName)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.targetPortal.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.iqn.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.lun {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.iscsiInterface.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.fsType.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.readOnly {
            my_size += 2;
        }
        for value in &self.portals {
            my_size += ::protobuf::rt::string_size(7, &value);
        };
        if let Some(v) = self.chapAuthDiscovery {
            my_size += 2;
        }
        if let Some(v) = self.chapAuthSession {
            my_size += 2;
        }
        if let Some(ref v) = self.secretRef.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.initiatorName.as_ref() {
            my_size += ::protobuf::rt::string_size(12, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.targetPortal.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.iqn.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.lun {
            os.write_int32(3, v)?;
        }
        if let Some(ref v) = self.iscsiInterface.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.fsType.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(v) = self.readOnly {
            os.write_bool(6, v)?;
        }
        for v in &self.portals {
            os.write_string(7, &v)?;
        };
        if let Some(v) = self.chapAuthDiscovery {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.chapAuthSession {
            os.write_bool(11, v)?;
        }
        if let Some(ref v) = self.secretRef.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.initiatorName.as_ref() {
            os.write_string(12, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ISCSIPersistentVolumeSource {
        ISCSIPersistentVolumeSource::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "targetPortal",
                |m: &ISCSIPersistentVolumeSource| { &m.targetPortal },
                |m: &mut ISCSIPersistentVolumeSource| { &mut m.targetPortal },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "iqn",
                |m: &ISCSIPersistentVolumeSource| { &m.iqn },
                |m: &mut ISCSIPersistentVolumeSource| { &mut m.iqn },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "lun",
                |m: &ISCSIPersistentVolumeSource| { &m.lun },
                |m: &mut ISCSIPersistentVolumeSource| { &mut m.lun },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "iscsiInterface",
                |m: &ISCSIPersistentVolumeSource| { &m.iscsiInterface },
                |m: &mut ISCSIPersistentVolumeSource| { &mut m.iscsiInterface },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "fsType",
                |m: &ISCSIPersistentVolumeSource| { &m.fsType },
                |m: &mut ISCSIPersistentVolumeSource| { &mut m.fsType },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "readOnly",
                |m: &ISCSIPersistentVolumeSource| { &m.readOnly },
                |m: &mut ISCSIPersistentVolumeSource| { &mut m.readOnly },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "portals",
                |m: &ISCSIPersistentVolumeSource| { &m.portals },
                |m: &mut ISCSIPersistentVolumeSource| { &mut m.portals },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "chapAuthDiscovery",
                |m: &ISCSIPersistentVolumeSource| { &m.chapAuthDiscovery },
                |m: &mut ISCSIPersistentVolumeSource| { &mut m.chapAuthDiscovery },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "chapAuthSession",
                |m: &ISCSIPersistentVolumeSource| { &m.chapAuthSession },
                |m: &mut ISCSIPersistentVolumeSource| { &mut m.chapAuthSession },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SecretReference>>(
                "secretRef",
                |m: &ISCSIPersistentVolumeSource| { &m.secretRef },
                |m: &mut ISCSIPersistentVolumeSource| { &mut m.secretRef },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "initiatorName",
                |m: &ISCSIPersistentVolumeSource| { &m.initiatorName },
                |m: &mut ISCSIPersistentVolumeSource| { &mut m.initiatorName },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ISCSIPersistentVolumeSource>(
                "ISCSIPersistentVolumeSource",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ISCSIPersistentVolumeSource {
        static instance: ::protobuf::rt::LazyV2<ISCSIPersistentVolumeSource> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ISCSIPersistentVolumeSource::new)
    }
}

impl ::protobuf::Clear for ISCSIPersistentVolumeSource {
    fn clear(&mut self) {
        self.targetPortal.clear();
        self.iqn.clear();
        self.lun = ::std::option::Option::None;
        self.iscsiInterface.clear();
        self.fsType.clear();
        self.readOnly = ::std::option::Option::None;
        self.portals.clear();
        self.chapAuthDiscovery = ::std::option::Option::None;
        self.chapAuthSession = ::std::option::Option::None;
        self.secretRef.clear();
        self.initiatorName.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ISCSIPersistentVolumeSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ISCSIPersistentVolumeSource {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ISCSIVolumeSource {
    // message fields
    targetPortal: ::protobuf::SingularField<::std::string::String>,
    iqn: ::protobuf::SingularField<::std::string::String>,
    lun: ::std::option::Option<i32>,
    iscsiInterface: ::protobuf::SingularField<::std::string::String>,
    fsType: ::protobuf::SingularField<::std::string::String>,
    readOnly: ::std::option::Option<bool>,
    pub portals: ::protobuf::RepeatedField<::std::string::String>,
    chapAuthDiscovery: ::std::option::Option<bool>,
    chapAuthSession: ::std::option::Option<bool>,
    pub secretRef: ::protobuf::SingularPtrField<LocalObjectReference>,
    initiatorName: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ISCSIVolumeSource {
    fn default() -> &'a ISCSIVolumeSource {
        <ISCSIVolumeSource as ::protobuf::Message>::default_instance()
    }
}

impl ISCSIVolumeSource {
    pub fn new() -> ISCSIVolumeSource {
        ::std::default::Default::default()
    }

    // optional string targetPortal = 1;


    pub fn get_targetPortal(&self) -> &str {
        match self.targetPortal.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_targetPortal(&mut self) {
        self.targetPortal.clear();
    }

    pub fn has_targetPortal(&self) -> bool {
        self.targetPortal.is_some()
    }

    // Param is passed by value, moved
    pub fn set_targetPortal(&mut self, v: ::std::string::String) {
        self.targetPortal = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_targetPortal(&mut self) -> &mut ::std::string::String {
        if self.targetPortal.is_none() {
            self.targetPortal.set_default();
        }
        self.targetPortal.as_mut().unwrap()
    }

    // Take field
    pub fn take_targetPortal(&mut self) -> ::std::string::String {
        self.targetPortal.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string iqn = 2;


    pub fn get_iqn(&self) -> &str {
        match self.iqn.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_iqn(&mut self) {
        self.iqn.clear();
    }

    pub fn has_iqn(&self) -> bool {
        self.iqn.is_some()
    }

    // Param is passed by value, moved
    pub fn set_iqn(&mut self, v: ::std::string::String) {
        self.iqn = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_iqn(&mut self) -> &mut ::std::string::String {
        if self.iqn.is_none() {
            self.iqn.set_default();
        }
        self.iqn.as_mut().unwrap()
    }

    // Take field
    pub fn take_iqn(&mut self) -> ::std::string::String {
        self.iqn.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 lun = 3;


    pub fn get_lun(&self) -> i32 {
        self.lun.unwrap_or(0)
    }
    pub fn clear_lun(&mut self) {
        self.lun = ::std::option::Option::None;
    }

    pub fn has_lun(&self) -> bool {
        self.lun.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lun(&mut self, v: i32) {
        self.lun = ::std::option::Option::Some(v);
    }

    // optional string iscsiInterface = 4;


    pub fn get_iscsiInterface(&self) -> &str {
        match self.iscsiInterface.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_iscsiInterface(&mut self) {
        self.iscsiInterface.clear();
    }

    pub fn has_iscsiInterface(&self) -> bool {
        self.iscsiInterface.is_some()
    }

    // Param is passed by value, moved
    pub fn set_iscsiInterface(&mut self, v: ::std::string::String) {
        self.iscsiInterface = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_iscsiInterface(&mut self) -> &mut ::std::string::String {
        if self.iscsiInterface.is_none() {
            self.iscsiInterface.set_default();
        }
        self.iscsiInterface.as_mut().unwrap()
    }

    // Take field
    pub fn take_iscsiInterface(&mut self) -> ::std::string::String {
        self.iscsiInterface.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string fsType = 5;


    pub fn get_fsType(&self) -> &str {
        match self.fsType.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_fsType(&mut self) {
        self.fsType.clear();
    }

    pub fn has_fsType(&self) -> bool {
        self.fsType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fsType(&mut self, v: ::std::string::String) {
        self.fsType = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fsType(&mut self) -> &mut ::std::string::String {
        if self.fsType.is_none() {
            self.fsType.set_default();
        }
        self.fsType.as_mut().unwrap()
    }

    // Take field
    pub fn take_fsType(&mut self) -> ::std::string::String {
        self.fsType.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool readOnly = 6;


    pub fn get_readOnly(&self) -> bool {
        self.readOnly.unwrap_or(false)
    }
    pub fn clear_readOnly(&mut self) {
        self.readOnly = ::std::option::Option::None;
    }

    pub fn has_readOnly(&self) -> bool {
        self.readOnly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readOnly(&mut self, v: bool) {
        self.readOnly = ::std::option::Option::Some(v);
    }

    // repeated string portals = 7;


    pub fn get_portals(&self) -> &[::std::string::String] {
        &self.portals
    }
    pub fn clear_portals(&mut self) {
        self.portals.clear();
    }

    // Param is passed by value, moved
    pub fn set_portals(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.portals = v;
    }

    // Mutable pointer to the field.
    pub fn mut_portals(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.portals
    }

    // Take field
    pub fn take_portals(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.portals, ::protobuf::RepeatedField::new())
    }

    // optional bool chapAuthDiscovery = 8;


    pub fn get_chapAuthDiscovery(&self) -> bool {
        self.chapAuthDiscovery.unwrap_or(false)
    }
    pub fn clear_chapAuthDiscovery(&mut self) {
        self.chapAuthDiscovery = ::std::option::Option::None;
    }

    pub fn has_chapAuthDiscovery(&self) -> bool {
        self.chapAuthDiscovery.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chapAuthDiscovery(&mut self, v: bool) {
        self.chapAuthDiscovery = ::std::option::Option::Some(v);
    }

    // optional bool chapAuthSession = 11;


    pub fn get_chapAuthSession(&self) -> bool {
        self.chapAuthSession.unwrap_or(false)
    }
    pub fn clear_chapAuthSession(&mut self) {
        self.chapAuthSession = ::std::option::Option::None;
    }

    pub fn has_chapAuthSession(&self) -> bool {
        self.chapAuthSession.is_some()
    }

    // Param is passed by value, moved
    pub fn set_chapAuthSession(&mut self, v: bool) {
        self.chapAuthSession = ::std::option::Option::Some(v);
    }

    // optional .k8s.io.api.core.v1.LocalObjectReference secretRef = 10;


    pub fn get_secretRef(&self) -> &LocalObjectReference {
        self.secretRef.as_ref().unwrap_or_else(|| <LocalObjectReference as ::protobuf::Message>::default_instance())
    }
    pub fn clear_secretRef(&mut self) {
        self.secretRef.clear();
    }

    pub fn has_secretRef(&self) -> bool {
        self.secretRef.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secretRef(&mut self, v: LocalObjectReference) {
        self.secretRef = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_secretRef(&mut self) -> &mut LocalObjectReference {
        if self.secretRef.is_none() {
            self.secretRef.set_default();
        }
        self.secretRef.as_mut().unwrap()
    }

    // Take field
    pub fn take_secretRef(&mut self) -> LocalObjectReference {
        self.secretRef.take().unwrap_or_else(|| LocalObjectReference::new())
    }

    // optional string initiatorName = 12;


    pub fn get_initiatorName(&self) -> &str {
        match self.initiatorName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_initiatorName(&mut self) {
        self.initiatorName.clear();
    }

    pub fn has_initiatorName(&self) -> bool {
        self.initiatorName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_initiatorName(&mut self, v: ::std::string::String) {
        self.initiatorName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_initiatorName(&mut self) -> &mut ::std::string::String {
        if self.initiatorName.is_none() {
            self.initiatorName.set_default();
        }
        self.initiatorName.as_mut().unwrap()
    }

    // Take field
    pub fn take_initiatorName(&mut self) -> ::std::string::String {
        self.initiatorName.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for ISCSIVolumeSource {
    fn is_initialized(&self) -> bool {
        for v in &self.secretRef {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.targetPortal)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.iqn)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.lun = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.iscsiInterface)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.fsType)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.readOnly = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.portals)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.chapAuthDiscovery = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.chapAuthSession = ::std::option::Option::Some(tmp);
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.secretRef)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.initiatorName)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.targetPortal.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.iqn.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.lun {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.iscsiInterface.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.fsType.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.readOnly {
            my_size += 2;
        }
        for value in &self.portals {
            my_size += ::protobuf::rt::string_size(7, &value);
        };
        if let Some(v) = self.chapAuthDiscovery {
            my_size += 2;
        }
        if let Some(v) = self.chapAuthSession {
            my_size += 2;
        }
        if let Some(ref v) = self.secretRef.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.initiatorName.as_ref() {
            my_size += ::protobuf::rt::string_size(12, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.targetPortal.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.iqn.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.lun {
            os.write_int32(3, v)?;
        }
        if let Some(ref v) = self.iscsiInterface.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.fsType.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(v) = self.readOnly {
            os.write_bool(6, v)?;
        }
        for v in &self.portals {
            os.write_string(7, &v)?;
        };
        if let Some(v) = self.chapAuthDiscovery {
            os.write_bool(8, v)?;
        }
        if let Some(v) = self.chapAuthSession {
            os.write_bool(11, v)?;
        }
        if let Some(ref v) = self.secretRef.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.initiatorName.as_ref() {
            os.write_string(12, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ISCSIVolumeSource {
        ISCSIVolumeSource::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "targetPortal",
                |m: &ISCSIVolumeSource| { &m.targetPortal },
                |m: &mut ISCSIVolumeSource| { &mut m.targetPortal },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "iqn",
                |m: &ISCSIVolumeSource| { &m.iqn },
                |m: &mut ISCSIVolumeSource| { &mut m.iqn },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "lun",
                |m: &ISCSIVolumeSource| { &m.lun },
                |m: &mut ISCSIVolumeSource| { &mut m.lun },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "iscsiInterface",
                |m: &ISCSIVolumeSource| { &m.iscsiInterface },
                |m: &mut ISCSIVolumeSource| { &mut m.iscsiInterface },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "fsType",
                |m: &ISCSIVolumeSource| { &m.fsType },
                |m: &mut ISCSIVolumeSource| { &mut m.fsType },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "readOnly",
                |m: &ISCSIVolumeSource| { &m.readOnly },
                |m: &mut ISCSIVolumeSource| { &mut m.readOnly },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "portals",
                |m: &ISCSIVolumeSource| { &m.portals },
                |m: &mut ISCSIVolumeSource| { &mut m.portals },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "chapAuthDiscovery",
                |m: &ISCSIVolumeSource| { &m.chapAuthDiscovery },
                |m: &mut ISCSIVolumeSource| { &mut m.chapAuthDiscovery },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "chapAuthSession",
                |m: &ISCSIVolumeSource| { &m.chapAuthSession },
                |m: &mut ISCSIVolumeSource| { &mut m.chapAuthSession },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LocalObjectReference>>(
                "secretRef",
                |m: &ISCSIVolumeSource| { &m.secretRef },
                |m: &mut ISCSIVolumeSource| { &mut m.secretRef },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "initiatorName",
                |m: &ISCSIVolumeSource| { &m.initiatorName },
                |m: &mut ISCSIVolumeSource| { &mut m.initiatorName },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ISCSIVolumeSource>(
                "ISCSIVolumeSource",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ISCSIVolumeSource {
        static instance: ::protobuf::rt::LazyV2<ISCSIVolumeSource> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ISCSIVolumeSource::new)
    }
}

impl ::protobuf::Clear for ISCSIVolumeSource {
    fn clear(&mut self) {
        self.targetPortal.clear();
        self.iqn.clear();
        self.lun = ::std::option::Option::None;
        self.iscsiInterface.clear();
        self.fsType.clear();
        self.readOnly = ::std::option::Option::None;
        self.portals.clear();
        self.chapAuthDiscovery = ::std::option::Option::None;
        self.chapAuthSession = ::std::option::Option::None;
        self.secretRef.clear();
        self.initiatorName.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ISCSIVolumeSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ISCSIVolumeSource {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct KeyToPath {
    // message fields
    key: ::protobuf::SingularField<::std::string::String>,
    path: ::protobuf::SingularField<::std::string::String>,
    mode: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a KeyToPath {
    fn default() -> &'a KeyToPath {
        <KeyToPath as ::protobuf::Message>::default_instance()
    }
}

impl KeyToPath {
    pub fn new() -> KeyToPath {
        ::std::default::Default::default()
    }

    // optional string key = 1;


    pub fn get_key(&self) -> &str {
        match self.key.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        if self.key.is_none() {
            self.key.set_default();
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        self.key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string path = 2;


    pub fn get_path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path.set_default();
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 mode = 3;


    pub fn get_mode(&self) -> i32 {
        self.mode.unwrap_or(0)
    }
    pub fn clear_mode(&mut self) {
        self.mode = ::std::option::Option::None;
    }

    pub fn has_mode(&self) -> bool {
        self.mode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mode(&mut self, v: i32) {
        self.mode = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for KeyToPath {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.path)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.mode = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.key.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.path.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.mode {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.key.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.path.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.mode {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> KeyToPath {
        KeyToPath::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "key",
                |m: &KeyToPath| { &m.key },
                |m: &mut KeyToPath| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "path",
                |m: &KeyToPath| { &m.path },
                |m: &mut KeyToPath| { &mut m.path },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "mode",
                |m: &KeyToPath| { &m.mode },
                |m: &mut KeyToPath| { &mut m.mode },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<KeyToPath>(
                "KeyToPath",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static KeyToPath {
        static instance: ::protobuf::rt::LazyV2<KeyToPath> = ::protobuf::rt::LazyV2::INIT;
        instance.get(KeyToPath::new)
    }
}

impl ::protobuf::Clear for KeyToPath {
    fn clear(&mut self) {
        self.key.clear();
        self.path.clear();
        self.mode = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for KeyToPath {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for KeyToPath {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Lifecycle {
    // message fields
    pub postStart: ::protobuf::SingularPtrField<Handler>,
    pub preStop: ::protobuf::SingularPtrField<Handler>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Lifecycle {
    fn default() -> &'a Lifecycle {
        <Lifecycle as ::protobuf::Message>::default_instance()
    }
}

impl Lifecycle {
    pub fn new() -> Lifecycle {
        ::std::default::Default::default()
    }

    // optional .k8s.io.api.core.v1.Handler postStart = 1;


    pub fn get_postStart(&self) -> &Handler {
        self.postStart.as_ref().unwrap_or_else(|| <Handler as ::protobuf::Message>::default_instance())
    }
    pub fn clear_postStart(&mut self) {
        self.postStart.clear();
    }

    pub fn has_postStart(&self) -> bool {
        self.postStart.is_some()
    }

    // Param is passed by value, moved
    pub fn set_postStart(&mut self, v: Handler) {
        self.postStart = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_postStart(&mut self) -> &mut Handler {
        if self.postStart.is_none() {
            self.postStart.set_default();
        }
        self.postStart.as_mut().unwrap()
    }

    // Take field
    pub fn take_postStart(&mut self) -> Handler {
        self.postStart.take().unwrap_or_else(|| Handler::new())
    }

    // optional .k8s.io.api.core.v1.Handler preStop = 2;


    pub fn get_preStop(&self) -> &Handler {
        self.preStop.as_ref().unwrap_or_else(|| <Handler as ::protobuf::Message>::default_instance())
    }
    pub fn clear_preStop(&mut self) {
        self.preStop.clear();
    }

    pub fn has_preStop(&self) -> bool {
        self.preStop.is_some()
    }

    // Param is passed by value, moved
    pub fn set_preStop(&mut self, v: Handler) {
        self.preStop = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_preStop(&mut self) -> &mut Handler {
        if self.preStop.is_none() {
            self.preStop.set_default();
        }
        self.preStop.as_mut().unwrap()
    }

    // Take field
    pub fn take_preStop(&mut self) -> Handler {
        self.preStop.take().unwrap_or_else(|| Handler::new())
    }
}

impl ::protobuf::Message for Lifecycle {
    fn is_initialized(&self) -> bool {
        for v in &self.postStart {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.preStop {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.postStart)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.preStop)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.postStart.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.preStop.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.postStart.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.preStop.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Lifecycle {
        Lifecycle::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Handler>>(
                "postStart",
                |m: &Lifecycle| { &m.postStart },
                |m: &mut Lifecycle| { &mut m.postStart },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Handler>>(
                "preStop",
                |m: &Lifecycle| { &m.preStop },
                |m: &mut Lifecycle| { &mut m.preStop },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Lifecycle>(
                "Lifecycle",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Lifecycle {
        static instance: ::protobuf::rt::LazyV2<Lifecycle> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Lifecycle::new)
    }
}

impl ::protobuf::Clear for Lifecycle {
    fn clear(&mut self) {
        self.postStart.clear();
        self.preStop.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Lifecycle {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Lifecycle {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LimitRange {
    // message fields
    pub metadata: ::protobuf::SingularPtrField<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta>,
    pub spec: ::protobuf::SingularPtrField<LimitRangeSpec>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LimitRange {
    fn default() -> &'a LimitRange {
        <LimitRange as ::protobuf::Message>::default_instance()
    }
}

impl LimitRange {
    pub fn new() -> LimitRange {
        ::std::default::Default::default()
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;


    pub fn get_metadata(&self) -> &super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta::new())
    }

    // optional .k8s.io.api.core.v1.LimitRangeSpec spec = 2;


    pub fn get_spec(&self) -> &LimitRangeSpec {
        self.spec.as_ref().unwrap_or_else(|| <LimitRangeSpec as ::protobuf::Message>::default_instance())
    }
    pub fn clear_spec(&mut self) {
        self.spec.clear();
    }

    pub fn has_spec(&self) -> bool {
        self.spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spec(&mut self, v: LimitRangeSpec) {
        self.spec = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spec(&mut self) -> &mut LimitRangeSpec {
        if self.spec.is_none() {
            self.spec.set_default();
        }
        self.spec.as_mut().unwrap()
    }

    // Take field
    pub fn take_spec(&mut self) -> LimitRangeSpec {
        self.spec.take().unwrap_or_else(|| LimitRangeSpec::new())
    }
}

impl ::protobuf::Message for LimitRange {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.spec {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.spec)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.spec.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LimitRange {
        LimitRange::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta>>(
                "metadata",
                |m: &LimitRange| { &m.metadata },
                |m: &mut LimitRange| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LimitRangeSpec>>(
                "spec",
                |m: &LimitRange| { &m.spec },
                |m: &mut LimitRange| { &mut m.spec },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LimitRange>(
                "LimitRange",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LimitRange {
        static instance: ::protobuf::rt::LazyV2<LimitRange> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LimitRange::new)
    }
}

impl ::protobuf::Clear for LimitRange {
    fn clear(&mut self) {
        self.metadata.clear();
        self.spec.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LimitRange {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LimitRange {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LimitRangeItem {
    // message fields
    field_type: ::protobuf::SingularField<::std::string::String>,
    pub max: ::std::collections::HashMap<::std::string::String, super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity>,
    pub min: ::std::collections::HashMap<::std::string::String, super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity>,
    pub default: ::std::collections::HashMap<::std::string::String, super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity>,
    pub defaultRequest: ::std::collections::HashMap<::std::string::String, super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity>,
    pub maxLimitRequestRatio: ::std::collections::HashMap<::std::string::String, super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LimitRangeItem {
    fn default() -> &'a LimitRangeItem {
        <LimitRangeItem as ::protobuf::Message>::default_instance()
    }
}

impl LimitRangeItem {
    pub fn new() -> LimitRangeItem {
        ::std::default::Default::default()
    }

    // optional string type = 1;


    pub fn get_field_type(&self) -> &str {
        match self.field_type.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ::std::string::String) {
        self.field_type = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut ::std::string::String {
        if self.field_type.is_none() {
            self.field_type.set_default();
        }
        self.field_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_field_type(&mut self) -> ::std::string::String {
        self.field_type.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .k8s.io.api.core.v1.LimitRangeItem.MaxEntry max = 2;


    pub fn get_max(&self) -> &::std::collections::HashMap<::std::string::String, super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity> {
        &self.max
    }
    pub fn clear_max(&mut self) {
        self.max.clear();
    }

    // Param is passed by value, moved
    pub fn set_max(&mut self, v: ::std::collections::HashMap<::std::string::String, super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity>) {
        self.max = v;
    }

    // Mutable pointer to the field.
    pub fn mut_max(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity> {
        &mut self.max
    }

    // Take field
    pub fn take_max(&mut self) -> ::std::collections::HashMap<::std::string::String, super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity> {
        ::std::mem::replace(&mut self.max, ::std::collections::HashMap::new())
    }

    // repeated .k8s.io.api.core.v1.LimitRangeItem.MinEntry min = 3;


    pub fn get_min(&self) -> &::std::collections::HashMap<::std::string::String, super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity> {
        &self.min
    }
    pub fn clear_min(&mut self) {
        self.min.clear();
    }

    // Param is passed by value, moved
    pub fn set_min(&mut self, v: ::std::collections::HashMap<::std::string::String, super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity>) {
        self.min = v;
    }

    // Mutable pointer to the field.
    pub fn mut_min(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity> {
        &mut self.min
    }

    // Take field
    pub fn take_min(&mut self) -> ::std::collections::HashMap<::std::string::String, super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity> {
        ::std::mem::replace(&mut self.min, ::std::collections::HashMap::new())
    }

    // repeated .k8s.io.api.core.v1.LimitRangeItem.DefaultEntry default = 4;


    pub fn get_default(&self) -> &::std::collections::HashMap<::std::string::String, super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity> {
        &self.default
    }
    pub fn clear_default(&mut self) {
        self.default.clear();
    }

    // Param is passed by value, moved
    pub fn set_default(&mut self, v: ::std::collections::HashMap<::std::string::String, super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity>) {
        self.default = v;
    }

    // Mutable pointer to the field.
    pub fn mut_default(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity> {
        &mut self.default
    }

    // Take field
    pub fn take_default(&mut self) -> ::std::collections::HashMap<::std::string::String, super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity> {
        ::std::mem::replace(&mut self.default, ::std::collections::HashMap::new())
    }

    // repeated .k8s.io.api.core.v1.LimitRangeItem.DefaultRequestEntry defaultRequest = 5;


    pub fn get_defaultRequest(&self) -> &::std::collections::HashMap<::std::string::String, super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity> {
        &self.defaultRequest
    }
    pub fn clear_defaultRequest(&mut self) {
        self.defaultRequest.clear();
    }

    // Param is passed by value, moved
    pub fn set_defaultRequest(&mut self, v: ::std::collections::HashMap<::std::string::String, super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity>) {
        self.defaultRequest = v;
    }

    // Mutable pointer to the field.
    pub fn mut_defaultRequest(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity> {
        &mut self.defaultRequest
    }

    // Take field
    pub fn take_defaultRequest(&mut self) -> ::std::collections::HashMap<::std::string::String, super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity> {
        ::std::mem::replace(&mut self.defaultRequest, ::std::collections::HashMap::new())
    }

    // repeated .k8s.io.api.core.v1.LimitRangeItem.MaxLimitRequestRatioEntry maxLimitRequestRatio = 6;


    pub fn get_maxLimitRequestRatio(&self) -> &::std::collections::HashMap<::std::string::String, super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity> {
        &self.maxLimitRequestRatio
    }
    pub fn clear_maxLimitRequestRatio(&mut self) {
        self.maxLimitRequestRatio.clear();
    }

    // Param is passed by value, moved
    pub fn set_maxLimitRequestRatio(&mut self, v: ::std::collections::HashMap<::std::string::String, super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity>) {
        self.maxLimitRequestRatio = v;
    }

    // Mutable pointer to the field.
    pub fn mut_maxLimitRequestRatio(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity> {
        &mut self.maxLimitRequestRatio
    }

    // Take field
    pub fn take_maxLimitRequestRatio(&mut self) -> ::std::collections::HashMap<::std::string::String, super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity> {
        ::std::mem::replace(&mut self.maxLimitRequestRatio, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for LimitRangeItem {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.field_type)?;
                },
                2 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity>>(wire_type, is, &mut self.max)?;
                },
                3 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity>>(wire_type, is, &mut self.min)?;
                },
                4 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity>>(wire_type, is, &mut self.default)?;
                },
                5 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity>>(wire_type, is, &mut self.defaultRequest)?;
                },
                6 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity>>(wire_type, is, &mut self.maxLimitRequestRatio)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.field_type.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity>>(2, &self.max);
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity>>(3, &self.min);
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity>>(4, &self.default);
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity>>(5, &self.defaultRequest);
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity>>(6, &self.maxLimitRequestRatio);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.field_type.as_ref() {
            os.write_string(1, &v)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity>>(2, &self.max, os)?;
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity>>(3, &self.min, os)?;
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity>>(4, &self.default, os)?;
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity>>(5, &self.defaultRequest, os)?;
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity>>(6, &self.maxLimitRequestRatio, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LimitRangeItem {
        LimitRangeItem::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "type",
                |m: &LimitRangeItem| { &m.field_type },
                |m: &mut LimitRangeItem| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity>>(
                "max",
                |m: &LimitRangeItem| { &m.max },
                |m: &mut LimitRangeItem| { &mut m.max },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity>>(
                "min",
                |m: &LimitRangeItem| { &m.min },
                |m: &mut LimitRangeItem| { &mut m.min },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity>>(
                "default",
                |m: &LimitRangeItem| { &m.default },
                |m: &mut LimitRangeItem| { &mut m.default },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity>>(
                "defaultRequest",
                |m: &LimitRangeItem| { &m.defaultRequest },
                |m: &mut LimitRangeItem| { &mut m.defaultRequest },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity>>(
                "maxLimitRequestRatio",
                |m: &LimitRangeItem| { &m.maxLimitRequestRatio },
                |m: &mut LimitRangeItem| { &mut m.maxLimitRequestRatio },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LimitRangeItem>(
                "LimitRangeItem",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LimitRangeItem {
        static instance: ::protobuf::rt::LazyV2<LimitRangeItem> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LimitRangeItem::new)
    }
}

impl ::protobuf::Clear for LimitRangeItem {
    fn clear(&mut self) {
        self.field_type.clear();
        self.max.clear();
        self.min.clear();
        self.default.clear();
        self.defaultRequest.clear();
        self.maxLimitRequestRatio.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LimitRangeItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LimitRangeItem {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LimitRangeList {
    // message fields
    pub metadata: ::protobuf::SingularPtrField<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta>,
    pub items: ::protobuf::RepeatedField<LimitRange>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LimitRangeList {
    fn default() -> &'a LimitRangeList {
        <LimitRangeList as ::protobuf::Message>::default_instance()
    }
}

impl LimitRangeList {
    pub fn new() -> LimitRangeList {
        ::std::default::Default::default()
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;


    pub fn get_metadata(&self) -> &super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta {
        self.metadata.take().unwrap_or_else(|| super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta::new())
    }

    // repeated .k8s.io.api.core.v1.LimitRange items = 2;


    pub fn get_items(&self) -> &[LimitRange] {
        &self.items
    }
    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::protobuf::RepeatedField<LimitRange>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::protobuf::RepeatedField<LimitRange> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::protobuf::RepeatedField<LimitRange> {
        ::std::mem::replace(&mut self.items, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for LimitRangeList {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.items {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.items)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.items {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LimitRangeList {
        LimitRangeList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta>>(
                "metadata",
                |m: &LimitRangeList| { &m.metadata },
                |m: &mut LimitRangeList| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LimitRange>>(
                "items",
                |m: &LimitRangeList| { &m.items },
                |m: &mut LimitRangeList| { &mut m.items },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LimitRangeList>(
                "LimitRangeList",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LimitRangeList {
        static instance: ::protobuf::rt::LazyV2<LimitRangeList> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LimitRangeList::new)
    }
}

impl ::protobuf::Clear for LimitRangeList {
    fn clear(&mut self) {
        self.metadata.clear();
        self.items.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LimitRangeList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LimitRangeList {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LimitRangeSpec {
    // message fields
    pub limits: ::protobuf::RepeatedField<LimitRangeItem>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LimitRangeSpec {
    fn default() -> &'a LimitRangeSpec {
        <LimitRangeSpec as ::protobuf::Message>::default_instance()
    }
}

impl LimitRangeSpec {
    pub fn new() -> LimitRangeSpec {
        ::std::default::Default::default()
    }

    // repeated .k8s.io.api.core.v1.LimitRangeItem limits = 1;


    pub fn get_limits(&self) -> &[LimitRangeItem] {
        &self.limits
    }
    pub fn clear_limits(&mut self) {
        self.limits.clear();
    }

    // Param is passed by value, moved
    pub fn set_limits(&mut self, v: ::protobuf::RepeatedField<LimitRangeItem>) {
        self.limits = v;
    }

    // Mutable pointer to the field.
    pub fn mut_limits(&mut self) -> &mut ::protobuf::RepeatedField<LimitRangeItem> {
        &mut self.limits
    }

    // Take field
    pub fn take_limits(&mut self) -> ::protobuf::RepeatedField<LimitRangeItem> {
        ::std::mem::replace(&mut self.limits, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for LimitRangeSpec {
    fn is_initialized(&self) -> bool {
        for v in &self.limits {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.limits)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.limits {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.limits {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LimitRangeSpec {
        LimitRangeSpec::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LimitRangeItem>>(
                "limits",
                |m: &LimitRangeSpec| { &m.limits },
                |m: &mut LimitRangeSpec| { &mut m.limits },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LimitRangeSpec>(
                "LimitRangeSpec",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LimitRangeSpec {
        static instance: ::protobuf::rt::LazyV2<LimitRangeSpec> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LimitRangeSpec::new)
    }
}

impl ::protobuf::Clear for LimitRangeSpec {
    fn clear(&mut self) {
        self.limits.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LimitRangeSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LimitRangeSpec {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct List {
    // message fields
    pub metadata: ::protobuf::SingularPtrField<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta>,
    pub items: ::protobuf::RepeatedField<super::k8s_io_apimachinery_pkg_runtime_generated::RawExtension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a List {
    fn default() -> &'a List {
        <List as ::protobuf::Message>::default_instance()
    }
}

impl List {
    pub fn new() -> List {
        ::std::default::Default::default()
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;


    pub fn get_metadata(&self) -> &super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta {
        self.metadata.take().unwrap_or_else(|| super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta::new())
    }

    // repeated .k8s.io.apimachinery.pkg.runtime.RawExtension items = 2;


    pub fn get_items(&self) -> &[super::k8s_io_apimachinery_pkg_runtime_generated::RawExtension] {
        &self.items
    }
    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::protobuf::RepeatedField<super::k8s_io_apimachinery_pkg_runtime_generated::RawExtension>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::protobuf::RepeatedField<super::k8s_io_apimachinery_pkg_runtime_generated::RawExtension> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::protobuf::RepeatedField<super::k8s_io_apimachinery_pkg_runtime_generated::RawExtension> {
        ::std::mem::replace(&mut self.items, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for List {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.items {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.items)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.items {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> List {
        List::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta>>(
                "metadata",
                |m: &List| { &m.metadata },
                |m: &mut List| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_runtime_generated::RawExtension>>(
                "items",
                |m: &List| { &m.items },
                |m: &mut List| { &mut m.items },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<List>(
                "List",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static List {
        static instance: ::protobuf::rt::LazyV2<List> = ::protobuf::rt::LazyV2::INIT;
        instance.get(List::new)
    }
}

impl ::protobuf::Clear for List {
    fn clear(&mut self) {
        self.metadata.clear();
        self.items.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for List {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for List {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LoadBalancerIngress {
    // message fields
    ip: ::protobuf::SingularField<::std::string::String>,
    hostname: ::protobuf::SingularField<::std::string::String>,
    pub ports: ::protobuf::RepeatedField<PortStatus>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LoadBalancerIngress {
    fn default() -> &'a LoadBalancerIngress {
        <LoadBalancerIngress as ::protobuf::Message>::default_instance()
    }
}

impl LoadBalancerIngress {
    pub fn new() -> LoadBalancerIngress {
        ::std::default::Default::default()
    }

    // optional string ip = 1;


    pub fn get_ip(&self) -> &str {
        match self.ip.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_ip(&mut self) {
        self.ip.clear();
    }

    pub fn has_ip(&self) -> bool {
        self.ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ip(&mut self, v: ::std::string::String) {
        self.ip = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ip(&mut self) -> &mut ::std::string::String {
        if self.ip.is_none() {
            self.ip.set_default();
        }
        self.ip.as_mut().unwrap()
    }

    // Take field
    pub fn take_ip(&mut self) -> ::std::string::String {
        self.ip.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string hostname = 2;


    pub fn get_hostname(&self) -> &str {
        match self.hostname.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_hostname(&mut self) {
        self.hostname.clear();
    }

    pub fn has_hostname(&self) -> bool {
        self.hostname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hostname(&mut self, v: ::std::string::String) {
        self.hostname = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hostname(&mut self) -> &mut ::std::string::String {
        if self.hostname.is_none() {
            self.hostname.set_default();
        }
        self.hostname.as_mut().unwrap()
    }

    // Take field
    pub fn take_hostname(&mut self) -> ::std::string::String {
        self.hostname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .k8s.io.api.core.v1.PortStatus ports = 4;


    pub fn get_ports(&self) -> &[PortStatus] {
        &self.ports
    }
    pub fn clear_ports(&mut self) {
        self.ports.clear();
    }

    // Param is passed by value, moved
    pub fn set_ports(&mut self, v: ::protobuf::RepeatedField<PortStatus>) {
        self.ports = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ports(&mut self) -> &mut ::protobuf::RepeatedField<PortStatus> {
        &mut self.ports
    }

    // Take field
    pub fn take_ports(&mut self) -> ::protobuf::RepeatedField<PortStatus> {
        ::std::mem::replace(&mut self.ports, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for LoadBalancerIngress {
    fn is_initialized(&self) -> bool {
        for v in &self.ports {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.ip)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.hostname)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.ports)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.ip.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.hostname.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        for value in &self.ports {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.ip.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.hostname.as_ref() {
            os.write_string(2, &v)?;
        }
        for v in &self.ports {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LoadBalancerIngress {
        LoadBalancerIngress::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "ip",
                |m: &LoadBalancerIngress| { &m.ip },
                |m: &mut LoadBalancerIngress| { &mut m.ip },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "hostname",
                |m: &LoadBalancerIngress| { &m.hostname },
                |m: &mut LoadBalancerIngress| { &mut m.hostname },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PortStatus>>(
                "ports",
                |m: &LoadBalancerIngress| { &m.ports },
                |m: &mut LoadBalancerIngress| { &mut m.ports },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LoadBalancerIngress>(
                "LoadBalancerIngress",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LoadBalancerIngress {
        static instance: ::protobuf::rt::LazyV2<LoadBalancerIngress> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LoadBalancerIngress::new)
    }
}

impl ::protobuf::Clear for LoadBalancerIngress {
    fn clear(&mut self) {
        self.ip.clear();
        self.hostname.clear();
        self.ports.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LoadBalancerIngress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LoadBalancerIngress {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LoadBalancerStatus {
    // message fields
    pub ingress: ::protobuf::RepeatedField<LoadBalancerIngress>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LoadBalancerStatus {
    fn default() -> &'a LoadBalancerStatus {
        <LoadBalancerStatus as ::protobuf::Message>::default_instance()
    }
}

impl LoadBalancerStatus {
    pub fn new() -> LoadBalancerStatus {
        ::std::default::Default::default()
    }

    // repeated .k8s.io.api.core.v1.LoadBalancerIngress ingress = 1;


    pub fn get_ingress(&self) -> &[LoadBalancerIngress] {
        &self.ingress
    }
    pub fn clear_ingress(&mut self) {
        self.ingress.clear();
    }

    // Param is passed by value, moved
    pub fn set_ingress(&mut self, v: ::protobuf::RepeatedField<LoadBalancerIngress>) {
        self.ingress = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ingress(&mut self) -> &mut ::protobuf::RepeatedField<LoadBalancerIngress> {
        &mut self.ingress
    }

    // Take field
    pub fn take_ingress(&mut self) -> ::protobuf::RepeatedField<LoadBalancerIngress> {
        ::std::mem::replace(&mut self.ingress, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for LoadBalancerStatus {
    fn is_initialized(&self) -> bool {
        for v in &self.ingress {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.ingress)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.ingress {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.ingress {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LoadBalancerStatus {
        LoadBalancerStatus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LoadBalancerIngress>>(
                "ingress",
                |m: &LoadBalancerStatus| { &m.ingress },
                |m: &mut LoadBalancerStatus| { &mut m.ingress },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LoadBalancerStatus>(
                "LoadBalancerStatus",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LoadBalancerStatus {
        static instance: ::protobuf::rt::LazyV2<LoadBalancerStatus> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LoadBalancerStatus::new)
    }
}

impl ::protobuf::Clear for LoadBalancerStatus {
    fn clear(&mut self) {
        self.ingress.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LoadBalancerStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LoadBalancerStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LocalObjectReference {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LocalObjectReference {
    fn default() -> &'a LocalObjectReference {
        <LocalObjectReference as ::protobuf::Message>::default_instance()
    }
}

impl LocalObjectReference {
    pub fn new() -> LocalObjectReference {
        ::std::default::Default::default()
    }

    // optional string name = 1;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for LocalObjectReference {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LocalObjectReference {
        LocalObjectReference::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &LocalObjectReference| { &m.name },
                |m: &mut LocalObjectReference| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LocalObjectReference>(
                "LocalObjectReference",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LocalObjectReference {
        static instance: ::protobuf::rt::LazyV2<LocalObjectReference> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LocalObjectReference::new)
    }
}

impl ::protobuf::Clear for LocalObjectReference {
    fn clear(&mut self) {
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LocalObjectReference {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LocalObjectReference {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LocalVolumeSource {
    // message fields
    path: ::protobuf::SingularField<::std::string::String>,
    fsType: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LocalVolumeSource {
    fn default() -> &'a LocalVolumeSource {
        <LocalVolumeSource as ::protobuf::Message>::default_instance()
    }
}

impl LocalVolumeSource {
    pub fn new() -> LocalVolumeSource {
        ::std::default::Default::default()
    }

    // optional string path = 1;


    pub fn get_path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path.set_default();
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string fsType = 2;


    pub fn get_fsType(&self) -> &str {
        match self.fsType.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_fsType(&mut self) {
        self.fsType.clear();
    }

    pub fn has_fsType(&self) -> bool {
        self.fsType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fsType(&mut self, v: ::std::string::String) {
        self.fsType = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fsType(&mut self) -> &mut ::std::string::String {
        if self.fsType.is_none() {
            self.fsType.set_default();
        }
        self.fsType.as_mut().unwrap()
    }

    // Take field
    pub fn take_fsType(&mut self) -> ::std::string::String {
        self.fsType.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for LocalVolumeSource {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.path)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.fsType)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.path.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.fsType.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.path.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.fsType.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LocalVolumeSource {
        LocalVolumeSource::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "path",
                |m: &LocalVolumeSource| { &m.path },
                |m: &mut LocalVolumeSource| { &mut m.path },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "fsType",
                |m: &LocalVolumeSource| { &m.fsType },
                |m: &mut LocalVolumeSource| { &mut m.fsType },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LocalVolumeSource>(
                "LocalVolumeSource",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LocalVolumeSource {
        static instance: ::protobuf::rt::LazyV2<LocalVolumeSource> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LocalVolumeSource::new)
    }
}

impl ::protobuf::Clear for LocalVolumeSource {
    fn clear(&mut self) {
        self.path.clear();
        self.fsType.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LocalVolumeSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LocalVolumeSource {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NFSVolumeSource {
    // message fields
    server: ::protobuf::SingularField<::std::string::String>,
    path: ::protobuf::SingularField<::std::string::String>,
    readOnly: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NFSVolumeSource {
    fn default() -> &'a NFSVolumeSource {
        <NFSVolumeSource as ::protobuf::Message>::default_instance()
    }
}

impl NFSVolumeSource {
    pub fn new() -> NFSVolumeSource {
        ::std::default::Default::default()
    }

    // optional string server = 1;


    pub fn get_server(&self) -> &str {
        match self.server.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_server(&mut self) {
        self.server.clear();
    }

    pub fn has_server(&self) -> bool {
        self.server.is_some()
    }

    // Param is passed by value, moved
    pub fn set_server(&mut self, v: ::std::string::String) {
        self.server = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_server(&mut self) -> &mut ::std::string::String {
        if self.server.is_none() {
            self.server.set_default();
        }
        self.server.as_mut().unwrap()
    }

    // Take field
    pub fn take_server(&mut self) -> ::std::string::String {
        self.server.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string path = 2;


    pub fn get_path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path.set_default();
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool readOnly = 3;


    pub fn get_readOnly(&self) -> bool {
        self.readOnly.unwrap_or(false)
    }
    pub fn clear_readOnly(&mut self) {
        self.readOnly = ::std::option::Option::None;
    }

    pub fn has_readOnly(&self) -> bool {
        self.readOnly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readOnly(&mut self, v: bool) {
        self.readOnly = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for NFSVolumeSource {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.server)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.path)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.readOnly = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.server.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.path.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.readOnly {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.server.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.path.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.readOnly {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NFSVolumeSource {
        NFSVolumeSource::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "server",
                |m: &NFSVolumeSource| { &m.server },
                |m: &mut NFSVolumeSource| { &mut m.server },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "path",
                |m: &NFSVolumeSource| { &m.path },
                |m: &mut NFSVolumeSource| { &mut m.path },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "readOnly",
                |m: &NFSVolumeSource| { &m.readOnly },
                |m: &mut NFSVolumeSource| { &mut m.readOnly },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<NFSVolumeSource>(
                "NFSVolumeSource",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static NFSVolumeSource {
        static instance: ::protobuf::rt::LazyV2<NFSVolumeSource> = ::protobuf::rt::LazyV2::INIT;
        instance.get(NFSVolumeSource::new)
    }
}

impl ::protobuf::Clear for NFSVolumeSource {
    fn clear(&mut self) {
        self.server.clear();
        self.path.clear();
        self.readOnly = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NFSVolumeSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NFSVolumeSource {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Namespace {
    // message fields
    pub metadata: ::protobuf::SingularPtrField<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta>,
    pub spec: ::protobuf::SingularPtrField<NamespaceSpec>,
    pub status: ::protobuf::SingularPtrField<NamespaceStatus>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Namespace {
    fn default() -> &'a Namespace {
        <Namespace as ::protobuf::Message>::default_instance()
    }
}

impl Namespace {
    pub fn new() -> Namespace {
        ::std::default::Default::default()
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;


    pub fn get_metadata(&self) -> &super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta::new())
    }

    // optional .k8s.io.api.core.v1.NamespaceSpec spec = 2;


    pub fn get_spec(&self) -> &NamespaceSpec {
        self.spec.as_ref().unwrap_or_else(|| <NamespaceSpec as ::protobuf::Message>::default_instance())
    }
    pub fn clear_spec(&mut self) {
        self.spec.clear();
    }

    pub fn has_spec(&self) -> bool {
        self.spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spec(&mut self, v: NamespaceSpec) {
        self.spec = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spec(&mut self) -> &mut NamespaceSpec {
        if self.spec.is_none() {
            self.spec.set_default();
        }
        self.spec.as_mut().unwrap()
    }

    // Take field
    pub fn take_spec(&mut self) -> NamespaceSpec {
        self.spec.take().unwrap_or_else(|| NamespaceSpec::new())
    }

    // optional .k8s.io.api.core.v1.NamespaceStatus status = 3;


    pub fn get_status(&self) -> &NamespaceStatus {
        self.status.as_ref().unwrap_or_else(|| <NamespaceStatus as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: NamespaceStatus) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut NamespaceStatus {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> NamespaceStatus {
        self.status.take().unwrap_or_else(|| NamespaceStatus::new())
    }
}

impl ::protobuf::Message for Namespace {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.spec {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.spec)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.spec.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Namespace {
        Namespace::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta>>(
                "metadata",
                |m: &Namespace| { &m.metadata },
                |m: &mut Namespace| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NamespaceSpec>>(
                "spec",
                |m: &Namespace| { &m.spec },
                |m: &mut Namespace| { &mut m.spec },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NamespaceStatus>>(
                "status",
                |m: &Namespace| { &m.status },
                |m: &mut Namespace| { &mut m.status },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Namespace>(
                "Namespace",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Namespace {
        static instance: ::protobuf::rt::LazyV2<Namespace> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Namespace::new)
    }
}

impl ::protobuf::Clear for Namespace {
    fn clear(&mut self) {
        self.metadata.clear();
        self.spec.clear();
        self.status.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Namespace {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Namespace {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NamespaceCondition {
    // message fields
    field_type: ::protobuf::SingularField<::std::string::String>,
    status: ::protobuf::SingularField<::std::string::String>,
    pub lastTransitionTime: ::protobuf::SingularPtrField<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time>,
    reason: ::protobuf::SingularField<::std::string::String>,
    message: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NamespaceCondition {
    fn default() -> &'a NamespaceCondition {
        <NamespaceCondition as ::protobuf::Message>::default_instance()
    }
}

impl NamespaceCondition {
    pub fn new() -> NamespaceCondition {
        ::std::default::Default::default()
    }

    // optional string type = 1;


    pub fn get_field_type(&self) -> &str {
        match self.field_type.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ::std::string::String) {
        self.field_type = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut ::std::string::String {
        if self.field_type.is_none() {
            self.field_type.set_default();
        }
        self.field_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_field_type(&mut self) -> ::std::string::String {
        self.field_type.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string status = 2;


    pub fn get_status(&self) -> &str {
        match self.status.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: ::std::string::String) {
        self.status = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut ::std::string::String {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> ::std::string::String {
        self.status.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 4;


    pub fn get_lastTransitionTime(&self) -> &super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time {
        self.lastTransitionTime.as_ref().unwrap_or_else(|| <super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time as ::protobuf::Message>::default_instance())
    }
    pub fn clear_lastTransitionTime(&mut self) {
        self.lastTransitionTime.clear();
    }

    pub fn has_lastTransitionTime(&self) -> bool {
        self.lastTransitionTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lastTransitionTime(&mut self, v: super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time) {
        self.lastTransitionTime = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lastTransitionTime(&mut self) -> &mut super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time {
        if self.lastTransitionTime.is_none() {
            self.lastTransitionTime.set_default();
        }
        self.lastTransitionTime.as_mut().unwrap()
    }

    // Take field
    pub fn take_lastTransitionTime(&mut self) -> super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time {
        self.lastTransitionTime.take().unwrap_or_else(|| super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time::new())
    }

    // optional string reason = 5;


    pub fn get_reason(&self) -> &str {
        match self.reason.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_reason(&mut self) {
        self.reason.clear();
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: ::std::string::String) {
        self.reason = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reason(&mut self) -> &mut ::std::string::String {
        if self.reason.is_none() {
            self.reason.set_default();
        }
        self.reason.as_mut().unwrap()
    }

    // Take field
    pub fn take_reason(&mut self) -> ::std::string::String {
        self.reason.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string message = 6;


    pub fn get_message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for NamespaceCondition {
    fn is_initialized(&self) -> bool {
        for v in &self.lastTransitionTime {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.field_type)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.status)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.lastTransitionTime)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.reason)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.field_type.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.status.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.lastTransitionTime.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.reason.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.field_type.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.status.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.lastTransitionTime.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.reason.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.message.as_ref() {
            os.write_string(6, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NamespaceCondition {
        NamespaceCondition::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "type",
                |m: &NamespaceCondition| { &m.field_type },
                |m: &mut NamespaceCondition| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "status",
                |m: &NamespaceCondition| { &m.status },
                |m: &mut NamespaceCondition| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time>>(
                "lastTransitionTime",
                |m: &NamespaceCondition| { &m.lastTransitionTime },
                |m: &mut NamespaceCondition| { &mut m.lastTransitionTime },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "reason",
                |m: &NamespaceCondition| { &m.reason },
                |m: &mut NamespaceCondition| { &mut m.reason },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "message",
                |m: &NamespaceCondition| { &m.message },
                |m: &mut NamespaceCondition| { &mut m.message },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<NamespaceCondition>(
                "NamespaceCondition",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static NamespaceCondition {
        static instance: ::protobuf::rt::LazyV2<NamespaceCondition> = ::protobuf::rt::LazyV2::INIT;
        instance.get(NamespaceCondition::new)
    }
}

impl ::protobuf::Clear for NamespaceCondition {
    fn clear(&mut self) {
        self.field_type.clear();
        self.status.clear();
        self.lastTransitionTime.clear();
        self.reason.clear();
        self.message.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NamespaceCondition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NamespaceCondition {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NamespaceList {
    // message fields
    pub metadata: ::protobuf::SingularPtrField<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta>,
    pub items: ::protobuf::RepeatedField<Namespace>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NamespaceList {
    fn default() -> &'a NamespaceList {
        <NamespaceList as ::protobuf::Message>::default_instance()
    }
}

impl NamespaceList {
    pub fn new() -> NamespaceList {
        ::std::default::Default::default()
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;


    pub fn get_metadata(&self) -> &super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta {
        self.metadata.take().unwrap_or_else(|| super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta::new())
    }

    // repeated .k8s.io.api.core.v1.Namespace items = 2;


    pub fn get_items(&self) -> &[Namespace] {
        &self.items
    }
    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::protobuf::RepeatedField<Namespace>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::protobuf::RepeatedField<Namespace> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::protobuf::RepeatedField<Namespace> {
        ::std::mem::replace(&mut self.items, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for NamespaceList {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.items {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.items)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.items {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NamespaceList {
        NamespaceList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta>>(
                "metadata",
                |m: &NamespaceList| { &m.metadata },
                |m: &mut NamespaceList| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Namespace>>(
                "items",
                |m: &NamespaceList| { &m.items },
                |m: &mut NamespaceList| { &mut m.items },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<NamespaceList>(
                "NamespaceList",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static NamespaceList {
        static instance: ::protobuf::rt::LazyV2<NamespaceList> = ::protobuf::rt::LazyV2::INIT;
        instance.get(NamespaceList::new)
    }
}

impl ::protobuf::Clear for NamespaceList {
    fn clear(&mut self) {
        self.metadata.clear();
        self.items.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NamespaceList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NamespaceList {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NamespaceSpec {
    // message fields
    pub finalizers: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NamespaceSpec {
    fn default() -> &'a NamespaceSpec {
        <NamespaceSpec as ::protobuf::Message>::default_instance()
    }
}

impl NamespaceSpec {
    pub fn new() -> NamespaceSpec {
        ::std::default::Default::default()
    }

    // repeated string finalizers = 1;


    pub fn get_finalizers(&self) -> &[::std::string::String] {
        &self.finalizers
    }
    pub fn clear_finalizers(&mut self) {
        self.finalizers.clear();
    }

    // Param is passed by value, moved
    pub fn set_finalizers(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.finalizers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_finalizers(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.finalizers
    }

    // Take field
    pub fn take_finalizers(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.finalizers, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for NamespaceSpec {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.finalizers)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.finalizers {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.finalizers {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NamespaceSpec {
        NamespaceSpec::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "finalizers",
                |m: &NamespaceSpec| { &m.finalizers },
                |m: &mut NamespaceSpec| { &mut m.finalizers },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<NamespaceSpec>(
                "NamespaceSpec",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static NamespaceSpec {
        static instance: ::protobuf::rt::LazyV2<NamespaceSpec> = ::protobuf::rt::LazyV2::INIT;
        instance.get(NamespaceSpec::new)
    }
}

impl ::protobuf::Clear for NamespaceSpec {
    fn clear(&mut self) {
        self.finalizers.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NamespaceSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NamespaceSpec {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NamespaceStatus {
    // message fields
    phase: ::protobuf::SingularField<::std::string::String>,
    pub conditions: ::protobuf::RepeatedField<NamespaceCondition>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NamespaceStatus {
    fn default() -> &'a NamespaceStatus {
        <NamespaceStatus as ::protobuf::Message>::default_instance()
    }
}

impl NamespaceStatus {
    pub fn new() -> NamespaceStatus {
        ::std::default::Default::default()
    }

    // optional string phase = 1;


    pub fn get_phase(&self) -> &str {
        match self.phase.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_phase(&mut self) {
        self.phase.clear();
    }

    pub fn has_phase(&self) -> bool {
        self.phase.is_some()
    }

    // Param is passed by value, moved
    pub fn set_phase(&mut self, v: ::std::string::String) {
        self.phase = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_phase(&mut self) -> &mut ::std::string::String {
        if self.phase.is_none() {
            self.phase.set_default();
        }
        self.phase.as_mut().unwrap()
    }

    // Take field
    pub fn take_phase(&mut self) -> ::std::string::String {
        self.phase.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .k8s.io.api.core.v1.NamespaceCondition conditions = 2;


    pub fn get_conditions(&self) -> &[NamespaceCondition] {
        &self.conditions
    }
    pub fn clear_conditions(&mut self) {
        self.conditions.clear();
    }

    // Param is passed by value, moved
    pub fn set_conditions(&mut self, v: ::protobuf::RepeatedField<NamespaceCondition>) {
        self.conditions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_conditions(&mut self) -> &mut ::protobuf::RepeatedField<NamespaceCondition> {
        &mut self.conditions
    }

    // Take field
    pub fn take_conditions(&mut self) -> ::protobuf::RepeatedField<NamespaceCondition> {
        ::std::mem::replace(&mut self.conditions, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for NamespaceStatus {
    fn is_initialized(&self) -> bool {
        for v in &self.conditions {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.phase)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.conditions)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.phase.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.conditions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.phase.as_ref() {
            os.write_string(1, &v)?;
        }
        for v in &self.conditions {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NamespaceStatus {
        NamespaceStatus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "phase",
                |m: &NamespaceStatus| { &m.phase },
                |m: &mut NamespaceStatus| { &mut m.phase },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NamespaceCondition>>(
                "conditions",
                |m: &NamespaceStatus| { &m.conditions },
                |m: &mut NamespaceStatus| { &mut m.conditions },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<NamespaceStatus>(
                "NamespaceStatus",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static NamespaceStatus {
        static instance: ::protobuf::rt::LazyV2<NamespaceStatus> = ::protobuf::rt::LazyV2::INIT;
        instance.get(NamespaceStatus::new)
    }
}

impl ::protobuf::Clear for NamespaceStatus {
    fn clear(&mut self) {
        self.phase.clear();
        self.conditions.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NamespaceStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NamespaceStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Node {
    // message fields
    pub metadata: ::protobuf::SingularPtrField<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta>,
    pub spec: ::protobuf::SingularPtrField<NodeSpec>,
    pub status: ::protobuf::SingularPtrField<NodeStatus>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Node {
    fn default() -> &'a Node {
        <Node as ::protobuf::Message>::default_instance()
    }
}

impl Node {
    pub fn new() -> Node {
        ::std::default::Default::default()
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;


    pub fn get_metadata(&self) -> &super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta::new())
    }

    // optional .k8s.io.api.core.v1.NodeSpec spec = 2;


    pub fn get_spec(&self) -> &NodeSpec {
        self.spec.as_ref().unwrap_or_else(|| <NodeSpec as ::protobuf::Message>::default_instance())
    }
    pub fn clear_spec(&mut self) {
        self.spec.clear();
    }

    pub fn has_spec(&self) -> bool {
        self.spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spec(&mut self, v: NodeSpec) {
        self.spec = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spec(&mut self) -> &mut NodeSpec {
        if self.spec.is_none() {
            self.spec.set_default();
        }
        self.spec.as_mut().unwrap()
    }

    // Take field
    pub fn take_spec(&mut self) -> NodeSpec {
        self.spec.take().unwrap_or_else(|| NodeSpec::new())
    }

    // optional .k8s.io.api.core.v1.NodeStatus status = 3;


    pub fn get_status(&self) -> &NodeStatus {
        self.status.as_ref().unwrap_or_else(|| <NodeStatus as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: NodeStatus) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut NodeStatus {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> NodeStatus {
        self.status.take().unwrap_or_else(|| NodeStatus::new())
    }
}

impl ::protobuf::Message for Node {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.spec {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.spec)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.spec.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Node {
        Node::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta>>(
                "metadata",
                |m: &Node| { &m.metadata },
                |m: &mut Node| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NodeSpec>>(
                "spec",
                |m: &Node| { &m.spec },
                |m: &mut Node| { &mut m.spec },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NodeStatus>>(
                "status",
                |m: &Node| { &m.status },
                |m: &mut Node| { &mut m.status },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Node>(
                "Node",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Node {
        static instance: ::protobuf::rt::LazyV2<Node> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Node::new)
    }
}

impl ::protobuf::Clear for Node {
    fn clear(&mut self) {
        self.metadata.clear();
        self.spec.clear();
        self.status.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Node {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Node {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NodeAddress {
    // message fields
    field_type: ::protobuf::SingularField<::std::string::String>,
    address: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NodeAddress {
    fn default() -> &'a NodeAddress {
        <NodeAddress as ::protobuf::Message>::default_instance()
    }
}

impl NodeAddress {
    pub fn new() -> NodeAddress {
        ::std::default::Default::default()
    }

    // optional string type = 1;


    pub fn get_field_type(&self) -> &str {
        match self.field_type.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ::std::string::String) {
        self.field_type = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut ::std::string::String {
        if self.field_type.is_none() {
            self.field_type.set_default();
        }
        self.field_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_field_type(&mut self) -> ::std::string::String {
        self.field_type.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string address = 2;


    pub fn get_address(&self) -> &str {
        match self.address.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    pub fn has_address(&self) -> bool {
        self.address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::string::String) {
        self.address = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::string::String {
        if self.address.is_none() {
            self.address.set_default();
        }
        self.address.as_mut().unwrap()
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::string::String {
        self.address.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for NodeAddress {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.field_type)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.address)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.field_type.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.address.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.field_type.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.address.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NodeAddress {
        NodeAddress::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "type",
                |m: &NodeAddress| { &m.field_type },
                |m: &mut NodeAddress| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "address",
                |m: &NodeAddress| { &m.address },
                |m: &mut NodeAddress| { &mut m.address },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<NodeAddress>(
                "NodeAddress",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static NodeAddress {
        static instance: ::protobuf::rt::LazyV2<NodeAddress> = ::protobuf::rt::LazyV2::INIT;
        instance.get(NodeAddress::new)
    }
}

impl ::protobuf::Clear for NodeAddress {
    fn clear(&mut self) {
        self.field_type.clear();
        self.address.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NodeAddress {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NodeAddress {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NodeAffinity {
    // message fields
    pub requiredDuringSchedulingIgnoredDuringExecution: ::protobuf::SingularPtrField<NodeSelector>,
    pub preferredDuringSchedulingIgnoredDuringExecution: ::protobuf::RepeatedField<PreferredSchedulingTerm>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NodeAffinity {
    fn default() -> &'a NodeAffinity {
        <NodeAffinity as ::protobuf::Message>::default_instance()
    }
}

impl NodeAffinity {
    pub fn new() -> NodeAffinity {
        ::std::default::Default::default()
    }

    // optional .k8s.io.api.core.v1.NodeSelector requiredDuringSchedulingIgnoredDuringExecution = 1;


    pub fn get_requiredDuringSchedulingIgnoredDuringExecution(&self) -> &NodeSelector {
        self.requiredDuringSchedulingIgnoredDuringExecution.as_ref().unwrap_or_else(|| <NodeSelector as ::protobuf::Message>::default_instance())
    }
    pub fn clear_requiredDuringSchedulingIgnoredDuringExecution(&mut self) {
        self.requiredDuringSchedulingIgnoredDuringExecution.clear();
    }

    pub fn has_requiredDuringSchedulingIgnoredDuringExecution(&self) -> bool {
        self.requiredDuringSchedulingIgnoredDuringExecution.is_some()
    }

    // Param is passed by value, moved
    pub fn set_requiredDuringSchedulingIgnoredDuringExecution(&mut self, v: NodeSelector) {
        self.requiredDuringSchedulingIgnoredDuringExecution = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_requiredDuringSchedulingIgnoredDuringExecution(&mut self) -> &mut NodeSelector {
        if self.requiredDuringSchedulingIgnoredDuringExecution.is_none() {
            self.requiredDuringSchedulingIgnoredDuringExecution.set_default();
        }
        self.requiredDuringSchedulingIgnoredDuringExecution.as_mut().unwrap()
    }

    // Take field
    pub fn take_requiredDuringSchedulingIgnoredDuringExecution(&mut self) -> NodeSelector {
        self.requiredDuringSchedulingIgnoredDuringExecution.take().unwrap_or_else(|| NodeSelector::new())
    }

    // repeated .k8s.io.api.core.v1.PreferredSchedulingTerm preferredDuringSchedulingIgnoredDuringExecution = 2;


    pub fn get_preferredDuringSchedulingIgnoredDuringExecution(&self) -> &[PreferredSchedulingTerm] {
        &self.preferredDuringSchedulingIgnoredDuringExecution
    }
    pub fn clear_preferredDuringSchedulingIgnoredDuringExecution(&mut self) {
        self.preferredDuringSchedulingIgnoredDuringExecution.clear();
    }

    // Param is passed by value, moved
    pub fn set_preferredDuringSchedulingIgnoredDuringExecution(&mut self, v: ::protobuf::RepeatedField<PreferredSchedulingTerm>) {
        self.preferredDuringSchedulingIgnoredDuringExecution = v;
    }

    // Mutable pointer to the field.
    pub fn mut_preferredDuringSchedulingIgnoredDuringExecution(&mut self) -> &mut ::protobuf::RepeatedField<PreferredSchedulingTerm> {
        &mut self.preferredDuringSchedulingIgnoredDuringExecution
    }

    // Take field
    pub fn take_preferredDuringSchedulingIgnoredDuringExecution(&mut self) -> ::protobuf::RepeatedField<PreferredSchedulingTerm> {
        ::std::mem::replace(&mut self.preferredDuringSchedulingIgnoredDuringExecution, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for NodeAffinity {
    fn is_initialized(&self) -> bool {
        for v in &self.requiredDuringSchedulingIgnoredDuringExecution {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.preferredDuringSchedulingIgnoredDuringExecution {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.requiredDuringSchedulingIgnoredDuringExecution)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.preferredDuringSchedulingIgnoredDuringExecution)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.requiredDuringSchedulingIgnoredDuringExecution.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.preferredDuringSchedulingIgnoredDuringExecution {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.requiredDuringSchedulingIgnoredDuringExecution.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.preferredDuringSchedulingIgnoredDuringExecution {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NodeAffinity {
        NodeAffinity::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NodeSelector>>(
                "requiredDuringSchedulingIgnoredDuringExecution",
                |m: &NodeAffinity| { &m.requiredDuringSchedulingIgnoredDuringExecution },
                |m: &mut NodeAffinity| { &mut m.requiredDuringSchedulingIgnoredDuringExecution },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PreferredSchedulingTerm>>(
                "preferredDuringSchedulingIgnoredDuringExecution",
                |m: &NodeAffinity| { &m.preferredDuringSchedulingIgnoredDuringExecution },
                |m: &mut NodeAffinity| { &mut m.preferredDuringSchedulingIgnoredDuringExecution },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<NodeAffinity>(
                "NodeAffinity",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static NodeAffinity {
        static instance: ::protobuf::rt::LazyV2<NodeAffinity> = ::protobuf::rt::LazyV2::INIT;
        instance.get(NodeAffinity::new)
    }
}

impl ::protobuf::Clear for NodeAffinity {
    fn clear(&mut self) {
        self.requiredDuringSchedulingIgnoredDuringExecution.clear();
        self.preferredDuringSchedulingIgnoredDuringExecution.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NodeAffinity {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NodeAffinity {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NodeCondition {
    // message fields
    field_type: ::protobuf::SingularField<::std::string::String>,
    status: ::protobuf::SingularField<::std::string::String>,
    pub lastHeartbeatTime: ::protobuf::SingularPtrField<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time>,
    pub lastTransitionTime: ::protobuf::SingularPtrField<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time>,
    reason: ::protobuf::SingularField<::std::string::String>,
    message: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NodeCondition {
    fn default() -> &'a NodeCondition {
        <NodeCondition as ::protobuf::Message>::default_instance()
    }
}

impl NodeCondition {
    pub fn new() -> NodeCondition {
        ::std::default::Default::default()
    }

    // optional string type = 1;


    pub fn get_field_type(&self) -> &str {
        match self.field_type.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ::std::string::String) {
        self.field_type = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut ::std::string::String {
        if self.field_type.is_none() {
            self.field_type.set_default();
        }
        self.field_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_field_type(&mut self) -> ::std::string::String {
        self.field_type.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string status = 2;


    pub fn get_status(&self) -> &str {
        match self.status.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: ::std::string::String) {
        self.status = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut ::std::string::String {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> ::std::string::String {
        self.status.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastHeartbeatTime = 3;


    pub fn get_lastHeartbeatTime(&self) -> &super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time {
        self.lastHeartbeatTime.as_ref().unwrap_or_else(|| <super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time as ::protobuf::Message>::default_instance())
    }
    pub fn clear_lastHeartbeatTime(&mut self) {
        self.lastHeartbeatTime.clear();
    }

    pub fn has_lastHeartbeatTime(&self) -> bool {
        self.lastHeartbeatTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lastHeartbeatTime(&mut self, v: super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time) {
        self.lastHeartbeatTime = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lastHeartbeatTime(&mut self) -> &mut super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time {
        if self.lastHeartbeatTime.is_none() {
            self.lastHeartbeatTime.set_default();
        }
        self.lastHeartbeatTime.as_mut().unwrap()
    }

    // Take field
    pub fn take_lastHeartbeatTime(&mut self) -> super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time {
        self.lastHeartbeatTime.take().unwrap_or_else(|| super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time::new())
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 4;


    pub fn get_lastTransitionTime(&self) -> &super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time {
        self.lastTransitionTime.as_ref().unwrap_or_else(|| <super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time as ::protobuf::Message>::default_instance())
    }
    pub fn clear_lastTransitionTime(&mut self) {
        self.lastTransitionTime.clear();
    }

    pub fn has_lastTransitionTime(&self) -> bool {
        self.lastTransitionTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lastTransitionTime(&mut self, v: super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time) {
        self.lastTransitionTime = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lastTransitionTime(&mut self) -> &mut super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time {
        if self.lastTransitionTime.is_none() {
            self.lastTransitionTime.set_default();
        }
        self.lastTransitionTime.as_mut().unwrap()
    }

    // Take field
    pub fn take_lastTransitionTime(&mut self) -> super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time {
        self.lastTransitionTime.take().unwrap_or_else(|| super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time::new())
    }

    // optional string reason = 5;


    pub fn get_reason(&self) -> &str {
        match self.reason.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_reason(&mut self) {
        self.reason.clear();
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: ::std::string::String) {
        self.reason = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reason(&mut self) -> &mut ::std::string::String {
        if self.reason.is_none() {
            self.reason.set_default();
        }
        self.reason.as_mut().unwrap()
    }

    // Take field
    pub fn take_reason(&mut self) -> ::std::string::String {
        self.reason.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string message = 6;


    pub fn get_message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for NodeCondition {
    fn is_initialized(&self) -> bool {
        for v in &self.lastHeartbeatTime {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.lastTransitionTime {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.field_type)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.status)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.lastHeartbeatTime)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.lastTransitionTime)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.reason)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.field_type.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.status.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.lastHeartbeatTime.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.lastTransitionTime.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.reason.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.field_type.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.status.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.lastHeartbeatTime.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.lastTransitionTime.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.reason.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.message.as_ref() {
            os.write_string(6, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NodeCondition {
        NodeCondition::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "type",
                |m: &NodeCondition| { &m.field_type },
                |m: &mut NodeCondition| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "status",
                |m: &NodeCondition| { &m.status },
                |m: &mut NodeCondition| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time>>(
                "lastHeartbeatTime",
                |m: &NodeCondition| { &m.lastHeartbeatTime },
                |m: &mut NodeCondition| { &mut m.lastHeartbeatTime },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time>>(
                "lastTransitionTime",
                |m: &NodeCondition| { &m.lastTransitionTime },
                |m: &mut NodeCondition| { &mut m.lastTransitionTime },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "reason",
                |m: &NodeCondition| { &m.reason },
                |m: &mut NodeCondition| { &mut m.reason },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "message",
                |m: &NodeCondition| { &m.message },
                |m: &mut NodeCondition| { &mut m.message },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<NodeCondition>(
                "NodeCondition",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static NodeCondition {
        static instance: ::protobuf::rt::LazyV2<NodeCondition> = ::protobuf::rt::LazyV2::INIT;
        instance.get(NodeCondition::new)
    }
}

impl ::protobuf::Clear for NodeCondition {
    fn clear(&mut self) {
        self.field_type.clear();
        self.status.clear();
        self.lastHeartbeatTime.clear();
        self.lastTransitionTime.clear();
        self.reason.clear();
        self.message.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NodeCondition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NodeCondition {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NodeConfigSource {
    // message fields
    pub configMap: ::protobuf::SingularPtrField<ConfigMapNodeConfigSource>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NodeConfigSource {
    fn default() -> &'a NodeConfigSource {
        <NodeConfigSource as ::protobuf::Message>::default_instance()
    }
}

impl NodeConfigSource {
    pub fn new() -> NodeConfigSource {
        ::std::default::Default::default()
    }

    // optional .k8s.io.api.core.v1.ConfigMapNodeConfigSource configMap = 2;


    pub fn get_configMap(&self) -> &ConfigMapNodeConfigSource {
        self.configMap.as_ref().unwrap_or_else(|| <ConfigMapNodeConfigSource as ::protobuf::Message>::default_instance())
    }
    pub fn clear_configMap(&mut self) {
        self.configMap.clear();
    }

    pub fn has_configMap(&self) -> bool {
        self.configMap.is_some()
    }

    // Param is passed by value, moved
    pub fn set_configMap(&mut self, v: ConfigMapNodeConfigSource) {
        self.configMap = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_configMap(&mut self) -> &mut ConfigMapNodeConfigSource {
        if self.configMap.is_none() {
            self.configMap.set_default();
        }
        self.configMap.as_mut().unwrap()
    }

    // Take field
    pub fn take_configMap(&mut self) -> ConfigMapNodeConfigSource {
        self.configMap.take().unwrap_or_else(|| ConfigMapNodeConfigSource::new())
    }
}

impl ::protobuf::Message for NodeConfigSource {
    fn is_initialized(&self) -> bool {
        for v in &self.configMap {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.configMap)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.configMap.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.configMap.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NodeConfigSource {
        NodeConfigSource::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ConfigMapNodeConfigSource>>(
                "configMap",
                |m: &NodeConfigSource| { &m.configMap },
                |m: &mut NodeConfigSource| { &mut m.configMap },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<NodeConfigSource>(
                "NodeConfigSource",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static NodeConfigSource {
        static instance: ::protobuf::rt::LazyV2<NodeConfigSource> = ::protobuf::rt::LazyV2::INIT;
        instance.get(NodeConfigSource::new)
    }
}

impl ::protobuf::Clear for NodeConfigSource {
    fn clear(&mut self) {
        self.configMap.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NodeConfigSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NodeConfigSource {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NodeConfigStatus {
    // message fields
    pub assigned: ::protobuf::SingularPtrField<NodeConfigSource>,
    pub active: ::protobuf::SingularPtrField<NodeConfigSource>,
    pub lastKnownGood: ::protobuf::SingularPtrField<NodeConfigSource>,
    error: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NodeConfigStatus {
    fn default() -> &'a NodeConfigStatus {
        <NodeConfigStatus as ::protobuf::Message>::default_instance()
    }
}

impl NodeConfigStatus {
    pub fn new() -> NodeConfigStatus {
        ::std::default::Default::default()
    }

    // optional .k8s.io.api.core.v1.NodeConfigSource assigned = 1;


    pub fn get_assigned(&self) -> &NodeConfigSource {
        self.assigned.as_ref().unwrap_or_else(|| <NodeConfigSource as ::protobuf::Message>::default_instance())
    }
    pub fn clear_assigned(&mut self) {
        self.assigned.clear();
    }

    pub fn has_assigned(&self) -> bool {
        self.assigned.is_some()
    }

    // Param is passed by value, moved
    pub fn set_assigned(&mut self, v: NodeConfigSource) {
        self.assigned = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_assigned(&mut self) -> &mut NodeConfigSource {
        if self.assigned.is_none() {
            self.assigned.set_default();
        }
        self.assigned.as_mut().unwrap()
    }

    // Take field
    pub fn take_assigned(&mut self) -> NodeConfigSource {
        self.assigned.take().unwrap_or_else(|| NodeConfigSource::new())
    }

    // optional .k8s.io.api.core.v1.NodeConfigSource active = 2;


    pub fn get_active(&self) -> &NodeConfigSource {
        self.active.as_ref().unwrap_or_else(|| <NodeConfigSource as ::protobuf::Message>::default_instance())
    }
    pub fn clear_active(&mut self) {
        self.active.clear();
    }

    pub fn has_active(&self) -> bool {
        self.active.is_some()
    }

    // Param is passed by value, moved
    pub fn set_active(&mut self, v: NodeConfigSource) {
        self.active = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_active(&mut self) -> &mut NodeConfigSource {
        if self.active.is_none() {
            self.active.set_default();
        }
        self.active.as_mut().unwrap()
    }

    // Take field
    pub fn take_active(&mut self) -> NodeConfigSource {
        self.active.take().unwrap_or_else(|| NodeConfigSource::new())
    }

    // optional .k8s.io.api.core.v1.NodeConfigSource lastKnownGood = 3;


    pub fn get_lastKnownGood(&self) -> &NodeConfigSource {
        self.lastKnownGood.as_ref().unwrap_or_else(|| <NodeConfigSource as ::protobuf::Message>::default_instance())
    }
    pub fn clear_lastKnownGood(&mut self) {
        self.lastKnownGood.clear();
    }

    pub fn has_lastKnownGood(&self) -> bool {
        self.lastKnownGood.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lastKnownGood(&mut self, v: NodeConfigSource) {
        self.lastKnownGood = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lastKnownGood(&mut self) -> &mut NodeConfigSource {
        if self.lastKnownGood.is_none() {
            self.lastKnownGood.set_default();
        }
        self.lastKnownGood.as_mut().unwrap()
    }

    // Take field
    pub fn take_lastKnownGood(&mut self) -> NodeConfigSource {
        self.lastKnownGood.take().unwrap_or_else(|| NodeConfigSource::new())
    }

    // optional string error = 4;


    pub fn get_error(&self) -> &str {
        match self.error.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: ::std::string::String) {
        self.error = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut ::std::string::String {
        if self.error.is_none() {
            self.error.set_default();
        }
        self.error.as_mut().unwrap()
    }

    // Take field
    pub fn take_error(&mut self) -> ::std::string::String {
        self.error.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for NodeConfigStatus {
    fn is_initialized(&self) -> bool {
        for v in &self.assigned {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.active {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.lastKnownGood {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.assigned)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.active)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.lastKnownGood)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.error)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.assigned.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.active.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.lastKnownGood.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.error.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.assigned.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.active.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.lastKnownGood.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.error.as_ref() {
            os.write_string(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NodeConfigStatus {
        NodeConfigStatus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NodeConfigSource>>(
                "assigned",
                |m: &NodeConfigStatus| { &m.assigned },
                |m: &mut NodeConfigStatus| { &mut m.assigned },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NodeConfigSource>>(
                "active",
                |m: &NodeConfigStatus| { &m.active },
                |m: &mut NodeConfigStatus| { &mut m.active },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NodeConfigSource>>(
                "lastKnownGood",
                |m: &NodeConfigStatus| { &m.lastKnownGood },
                |m: &mut NodeConfigStatus| { &mut m.lastKnownGood },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "error",
                |m: &NodeConfigStatus| { &m.error },
                |m: &mut NodeConfigStatus| { &mut m.error },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<NodeConfigStatus>(
                "NodeConfigStatus",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static NodeConfigStatus {
        static instance: ::protobuf::rt::LazyV2<NodeConfigStatus> = ::protobuf::rt::LazyV2::INIT;
        instance.get(NodeConfigStatus::new)
    }
}

impl ::protobuf::Clear for NodeConfigStatus {
    fn clear(&mut self) {
        self.assigned.clear();
        self.active.clear();
        self.lastKnownGood.clear();
        self.error.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NodeConfigStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NodeConfigStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NodeDaemonEndpoints {
    // message fields
    pub kubeletEndpoint: ::protobuf::SingularPtrField<DaemonEndpoint>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NodeDaemonEndpoints {
    fn default() -> &'a NodeDaemonEndpoints {
        <NodeDaemonEndpoints as ::protobuf::Message>::default_instance()
    }
}

impl NodeDaemonEndpoints {
    pub fn new() -> NodeDaemonEndpoints {
        ::std::default::Default::default()
    }

    // optional .k8s.io.api.core.v1.DaemonEndpoint kubeletEndpoint = 1;


    pub fn get_kubeletEndpoint(&self) -> &DaemonEndpoint {
        self.kubeletEndpoint.as_ref().unwrap_or_else(|| <DaemonEndpoint as ::protobuf::Message>::default_instance())
    }
    pub fn clear_kubeletEndpoint(&mut self) {
        self.kubeletEndpoint.clear();
    }

    pub fn has_kubeletEndpoint(&self) -> bool {
        self.kubeletEndpoint.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kubeletEndpoint(&mut self, v: DaemonEndpoint) {
        self.kubeletEndpoint = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kubeletEndpoint(&mut self) -> &mut DaemonEndpoint {
        if self.kubeletEndpoint.is_none() {
            self.kubeletEndpoint.set_default();
        }
        self.kubeletEndpoint.as_mut().unwrap()
    }

    // Take field
    pub fn take_kubeletEndpoint(&mut self) -> DaemonEndpoint {
        self.kubeletEndpoint.take().unwrap_or_else(|| DaemonEndpoint::new())
    }
}

impl ::protobuf::Message for NodeDaemonEndpoints {
    fn is_initialized(&self) -> bool {
        for v in &self.kubeletEndpoint {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.kubeletEndpoint)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.kubeletEndpoint.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.kubeletEndpoint.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NodeDaemonEndpoints {
        NodeDaemonEndpoints::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DaemonEndpoint>>(
                "kubeletEndpoint",
                |m: &NodeDaemonEndpoints| { &m.kubeletEndpoint },
                |m: &mut NodeDaemonEndpoints| { &mut m.kubeletEndpoint },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<NodeDaemonEndpoints>(
                "NodeDaemonEndpoints",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static NodeDaemonEndpoints {
        static instance: ::protobuf::rt::LazyV2<NodeDaemonEndpoints> = ::protobuf::rt::LazyV2::INIT;
        instance.get(NodeDaemonEndpoints::new)
    }
}

impl ::protobuf::Clear for NodeDaemonEndpoints {
    fn clear(&mut self) {
        self.kubeletEndpoint.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NodeDaemonEndpoints {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NodeDaemonEndpoints {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NodeList {
    // message fields
    pub metadata: ::protobuf::SingularPtrField<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta>,
    pub items: ::protobuf::RepeatedField<Node>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NodeList {
    fn default() -> &'a NodeList {
        <NodeList as ::protobuf::Message>::default_instance()
    }
}

impl NodeList {
    pub fn new() -> NodeList {
        ::std::default::Default::default()
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;


    pub fn get_metadata(&self) -> &super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta {
        self.metadata.take().unwrap_or_else(|| super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta::new())
    }

    // repeated .k8s.io.api.core.v1.Node items = 2;


    pub fn get_items(&self) -> &[Node] {
        &self.items
    }
    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::protobuf::RepeatedField<Node>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::protobuf::RepeatedField<Node> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::protobuf::RepeatedField<Node> {
        ::std::mem::replace(&mut self.items, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for NodeList {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.items {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.items)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.items {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NodeList {
        NodeList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta>>(
                "metadata",
                |m: &NodeList| { &m.metadata },
                |m: &mut NodeList| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Node>>(
                "items",
                |m: &NodeList| { &m.items },
                |m: &mut NodeList| { &mut m.items },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<NodeList>(
                "NodeList",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static NodeList {
        static instance: ::protobuf::rt::LazyV2<NodeList> = ::protobuf::rt::LazyV2::INIT;
        instance.get(NodeList::new)
    }
}

impl ::protobuf::Clear for NodeList {
    fn clear(&mut self) {
        self.metadata.clear();
        self.items.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NodeList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NodeList {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NodeProxyOptions {
    // message fields
    path: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NodeProxyOptions {
    fn default() -> &'a NodeProxyOptions {
        <NodeProxyOptions as ::protobuf::Message>::default_instance()
    }
}

impl NodeProxyOptions {
    pub fn new() -> NodeProxyOptions {
        ::std::default::Default::default()
    }

    // optional string path = 1;


    pub fn get_path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path.set_default();
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for NodeProxyOptions {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.path)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.path.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.path.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NodeProxyOptions {
        NodeProxyOptions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "path",
                |m: &NodeProxyOptions| { &m.path },
                |m: &mut NodeProxyOptions| { &mut m.path },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<NodeProxyOptions>(
                "NodeProxyOptions",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static NodeProxyOptions {
        static instance: ::protobuf::rt::LazyV2<NodeProxyOptions> = ::protobuf::rt::LazyV2::INIT;
        instance.get(NodeProxyOptions::new)
    }
}

impl ::protobuf::Clear for NodeProxyOptions {
    fn clear(&mut self) {
        self.path.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NodeProxyOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NodeProxyOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NodeResources {
    // message fields
    pub capacity: ::std::collections::HashMap<::std::string::String, super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NodeResources {
    fn default() -> &'a NodeResources {
        <NodeResources as ::protobuf::Message>::default_instance()
    }
}

impl NodeResources {
    pub fn new() -> NodeResources {
        ::std::default::Default::default()
    }

    // repeated .k8s.io.api.core.v1.NodeResources.CapacityEntry capacity = 1;


    pub fn get_capacity(&self) -> &::std::collections::HashMap<::std::string::String, super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity> {
        &self.capacity
    }
    pub fn clear_capacity(&mut self) {
        self.capacity.clear();
    }

    // Param is passed by value, moved
    pub fn set_capacity(&mut self, v: ::std::collections::HashMap<::std::string::String, super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity>) {
        self.capacity = v;
    }

    // Mutable pointer to the field.
    pub fn mut_capacity(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity> {
        &mut self.capacity
    }

    // Take field
    pub fn take_capacity(&mut self) -> ::std::collections::HashMap<::std::string::String, super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity> {
        ::std::mem::replace(&mut self.capacity, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for NodeResources {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity>>(wire_type, is, &mut self.capacity)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity>>(1, &self.capacity);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity>>(1, &self.capacity, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NodeResources {
        NodeResources::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity>>(
                "capacity",
                |m: &NodeResources| { &m.capacity },
                |m: &mut NodeResources| { &mut m.capacity },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<NodeResources>(
                "NodeResources",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static NodeResources {
        static instance: ::protobuf::rt::LazyV2<NodeResources> = ::protobuf::rt::LazyV2::INIT;
        instance.get(NodeResources::new)
    }
}

impl ::protobuf::Clear for NodeResources {
    fn clear(&mut self) {
        self.capacity.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NodeResources {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NodeResources {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NodeSelector {
    // message fields
    pub nodeSelectorTerms: ::protobuf::RepeatedField<NodeSelectorTerm>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NodeSelector {
    fn default() -> &'a NodeSelector {
        <NodeSelector as ::protobuf::Message>::default_instance()
    }
}

impl NodeSelector {
    pub fn new() -> NodeSelector {
        ::std::default::Default::default()
    }

    // repeated .k8s.io.api.core.v1.NodeSelectorTerm nodeSelectorTerms = 1;


    pub fn get_nodeSelectorTerms(&self) -> &[NodeSelectorTerm] {
        &self.nodeSelectorTerms
    }
    pub fn clear_nodeSelectorTerms(&mut self) {
        self.nodeSelectorTerms.clear();
    }

    // Param is passed by value, moved
    pub fn set_nodeSelectorTerms(&mut self, v: ::protobuf::RepeatedField<NodeSelectorTerm>) {
        self.nodeSelectorTerms = v;
    }

    // Mutable pointer to the field.
    pub fn mut_nodeSelectorTerms(&mut self) -> &mut ::protobuf::RepeatedField<NodeSelectorTerm> {
        &mut self.nodeSelectorTerms
    }

    // Take field
    pub fn take_nodeSelectorTerms(&mut self) -> ::protobuf::RepeatedField<NodeSelectorTerm> {
        ::std::mem::replace(&mut self.nodeSelectorTerms, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for NodeSelector {
    fn is_initialized(&self) -> bool {
        for v in &self.nodeSelectorTerms {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.nodeSelectorTerms)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.nodeSelectorTerms {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.nodeSelectorTerms {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NodeSelector {
        NodeSelector::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NodeSelectorTerm>>(
                "nodeSelectorTerms",
                |m: &NodeSelector| { &m.nodeSelectorTerms },
                |m: &mut NodeSelector| { &mut m.nodeSelectorTerms },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<NodeSelector>(
                "NodeSelector",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static NodeSelector {
        static instance: ::protobuf::rt::LazyV2<NodeSelector> = ::protobuf::rt::LazyV2::INIT;
        instance.get(NodeSelector::new)
    }
}

impl ::protobuf::Clear for NodeSelector {
    fn clear(&mut self) {
        self.nodeSelectorTerms.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NodeSelector {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NodeSelector {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NodeSelectorRequirement {
    // message fields
    key: ::protobuf::SingularField<::std::string::String>,
    operator: ::protobuf::SingularField<::std::string::String>,
    pub values: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NodeSelectorRequirement {
    fn default() -> &'a NodeSelectorRequirement {
        <NodeSelectorRequirement as ::protobuf::Message>::default_instance()
    }
}

impl NodeSelectorRequirement {
    pub fn new() -> NodeSelectorRequirement {
        ::std::default::Default::default()
    }

    // optional string key = 1;


    pub fn get_key(&self) -> &str {
        match self.key.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        if self.key.is_none() {
            self.key.set_default();
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        self.key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string operator = 2;


    pub fn get_operator(&self) -> &str {
        match self.operator.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_operator(&mut self) {
        self.operator.clear();
    }

    pub fn has_operator(&self) -> bool {
        self.operator.is_some()
    }

    // Param is passed by value, moved
    pub fn set_operator(&mut self, v: ::std::string::String) {
        self.operator = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_operator(&mut self) -> &mut ::std::string::String {
        if self.operator.is_none() {
            self.operator.set_default();
        }
        self.operator.as_mut().unwrap()
    }

    // Take field
    pub fn take_operator(&mut self) -> ::std::string::String {
        self.operator.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated string values = 3;


    pub fn get_values(&self) -> &[::std::string::String] {
        &self.values
    }
    pub fn clear_values(&mut self) {
        self.values.clear();
    }

    // Param is passed by value, moved
    pub fn set_values(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.values = v;
    }

    // Mutable pointer to the field.
    pub fn mut_values(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.values
    }

    // Take field
    pub fn take_values(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.values, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for NodeSelectorRequirement {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.operator)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.values)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.key.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.operator.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        for value in &self.values {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.key.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.operator.as_ref() {
            os.write_string(2, &v)?;
        }
        for v in &self.values {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NodeSelectorRequirement {
        NodeSelectorRequirement::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "key",
                |m: &NodeSelectorRequirement| { &m.key },
                |m: &mut NodeSelectorRequirement| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "operator",
                |m: &NodeSelectorRequirement| { &m.operator },
                |m: &mut NodeSelectorRequirement| { &mut m.operator },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "values",
                |m: &NodeSelectorRequirement| { &m.values },
                |m: &mut NodeSelectorRequirement| { &mut m.values },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<NodeSelectorRequirement>(
                "NodeSelectorRequirement",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static NodeSelectorRequirement {
        static instance: ::protobuf::rt::LazyV2<NodeSelectorRequirement> = ::protobuf::rt::LazyV2::INIT;
        instance.get(NodeSelectorRequirement::new)
    }
}

impl ::protobuf::Clear for NodeSelectorRequirement {
    fn clear(&mut self) {
        self.key.clear();
        self.operator.clear();
        self.values.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NodeSelectorRequirement {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NodeSelectorRequirement {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NodeSelectorTerm {
    // message fields
    pub matchExpressions: ::protobuf::RepeatedField<NodeSelectorRequirement>,
    pub matchFields: ::protobuf::RepeatedField<NodeSelectorRequirement>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NodeSelectorTerm {
    fn default() -> &'a NodeSelectorTerm {
        <NodeSelectorTerm as ::protobuf::Message>::default_instance()
    }
}

impl NodeSelectorTerm {
    pub fn new() -> NodeSelectorTerm {
        ::std::default::Default::default()
    }

    // repeated .k8s.io.api.core.v1.NodeSelectorRequirement matchExpressions = 1;


    pub fn get_matchExpressions(&self) -> &[NodeSelectorRequirement] {
        &self.matchExpressions
    }
    pub fn clear_matchExpressions(&mut self) {
        self.matchExpressions.clear();
    }

    // Param is passed by value, moved
    pub fn set_matchExpressions(&mut self, v: ::protobuf::RepeatedField<NodeSelectorRequirement>) {
        self.matchExpressions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_matchExpressions(&mut self) -> &mut ::protobuf::RepeatedField<NodeSelectorRequirement> {
        &mut self.matchExpressions
    }

    // Take field
    pub fn take_matchExpressions(&mut self) -> ::protobuf::RepeatedField<NodeSelectorRequirement> {
        ::std::mem::replace(&mut self.matchExpressions, ::protobuf::RepeatedField::new())
    }

    // repeated .k8s.io.api.core.v1.NodeSelectorRequirement matchFields = 2;


    pub fn get_matchFields(&self) -> &[NodeSelectorRequirement] {
        &self.matchFields
    }
    pub fn clear_matchFields(&mut self) {
        self.matchFields.clear();
    }

    // Param is passed by value, moved
    pub fn set_matchFields(&mut self, v: ::protobuf::RepeatedField<NodeSelectorRequirement>) {
        self.matchFields = v;
    }

    // Mutable pointer to the field.
    pub fn mut_matchFields(&mut self) -> &mut ::protobuf::RepeatedField<NodeSelectorRequirement> {
        &mut self.matchFields
    }

    // Take field
    pub fn take_matchFields(&mut self) -> ::protobuf::RepeatedField<NodeSelectorRequirement> {
        ::std::mem::replace(&mut self.matchFields, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for NodeSelectorTerm {
    fn is_initialized(&self) -> bool {
        for v in &self.matchExpressions {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.matchFields {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.matchExpressions)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.matchFields)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.matchExpressions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.matchFields {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.matchExpressions {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.matchFields {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NodeSelectorTerm {
        NodeSelectorTerm::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NodeSelectorRequirement>>(
                "matchExpressions",
                |m: &NodeSelectorTerm| { &m.matchExpressions },
                |m: &mut NodeSelectorTerm| { &mut m.matchExpressions },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NodeSelectorRequirement>>(
                "matchFields",
                |m: &NodeSelectorTerm| { &m.matchFields },
                |m: &mut NodeSelectorTerm| { &mut m.matchFields },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<NodeSelectorTerm>(
                "NodeSelectorTerm",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static NodeSelectorTerm {
        static instance: ::protobuf::rt::LazyV2<NodeSelectorTerm> = ::protobuf::rt::LazyV2::INIT;
        instance.get(NodeSelectorTerm::new)
    }
}

impl ::protobuf::Clear for NodeSelectorTerm {
    fn clear(&mut self) {
        self.matchExpressions.clear();
        self.matchFields.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NodeSelectorTerm {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NodeSelectorTerm {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NodeSpec {
    // message fields
    podCIDR: ::protobuf::SingularField<::std::string::String>,
    pub podCIDRs: ::protobuf::RepeatedField<::std::string::String>,
    providerID: ::protobuf::SingularField<::std::string::String>,
    unschedulable: ::std::option::Option<bool>,
    pub taints: ::protobuf::RepeatedField<Taint>,
    pub configSource: ::protobuf::SingularPtrField<NodeConfigSource>,
    externalID: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NodeSpec {
    fn default() -> &'a NodeSpec {
        <NodeSpec as ::protobuf::Message>::default_instance()
    }
}

impl NodeSpec {
    pub fn new() -> NodeSpec {
        ::std::default::Default::default()
    }

    // optional string podCIDR = 1;


    pub fn get_podCIDR(&self) -> &str {
        match self.podCIDR.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_podCIDR(&mut self) {
        self.podCIDR.clear();
    }

    pub fn has_podCIDR(&self) -> bool {
        self.podCIDR.is_some()
    }

    // Param is passed by value, moved
    pub fn set_podCIDR(&mut self, v: ::std::string::String) {
        self.podCIDR = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_podCIDR(&mut self) -> &mut ::std::string::String {
        if self.podCIDR.is_none() {
            self.podCIDR.set_default();
        }
        self.podCIDR.as_mut().unwrap()
    }

    // Take field
    pub fn take_podCIDR(&mut self) -> ::std::string::String {
        self.podCIDR.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated string podCIDRs = 7;


    pub fn get_podCIDRs(&self) -> &[::std::string::String] {
        &self.podCIDRs
    }
    pub fn clear_podCIDRs(&mut self) {
        self.podCIDRs.clear();
    }

    // Param is passed by value, moved
    pub fn set_podCIDRs(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.podCIDRs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_podCIDRs(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.podCIDRs
    }

    // Take field
    pub fn take_podCIDRs(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.podCIDRs, ::protobuf::RepeatedField::new())
    }

    // optional string providerID = 3;


    pub fn get_providerID(&self) -> &str {
        match self.providerID.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_providerID(&mut self) {
        self.providerID.clear();
    }

    pub fn has_providerID(&self) -> bool {
        self.providerID.is_some()
    }

    // Param is passed by value, moved
    pub fn set_providerID(&mut self, v: ::std::string::String) {
        self.providerID = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_providerID(&mut self) -> &mut ::std::string::String {
        if self.providerID.is_none() {
            self.providerID.set_default();
        }
        self.providerID.as_mut().unwrap()
    }

    // Take field
    pub fn take_providerID(&mut self) -> ::std::string::String {
        self.providerID.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool unschedulable = 4;


    pub fn get_unschedulable(&self) -> bool {
        self.unschedulable.unwrap_or(false)
    }
    pub fn clear_unschedulable(&mut self) {
        self.unschedulable = ::std::option::Option::None;
    }

    pub fn has_unschedulable(&self) -> bool {
        self.unschedulable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_unschedulable(&mut self, v: bool) {
        self.unschedulable = ::std::option::Option::Some(v);
    }

    // repeated .k8s.io.api.core.v1.Taint taints = 5;


    pub fn get_taints(&self) -> &[Taint] {
        &self.taints
    }
    pub fn clear_taints(&mut self) {
        self.taints.clear();
    }

    // Param is passed by value, moved
    pub fn set_taints(&mut self, v: ::protobuf::RepeatedField<Taint>) {
        self.taints = v;
    }

    // Mutable pointer to the field.
    pub fn mut_taints(&mut self) -> &mut ::protobuf::RepeatedField<Taint> {
        &mut self.taints
    }

    // Take field
    pub fn take_taints(&mut self) -> ::protobuf::RepeatedField<Taint> {
        ::std::mem::replace(&mut self.taints, ::protobuf::RepeatedField::new())
    }

    // optional .k8s.io.api.core.v1.NodeConfigSource configSource = 6;


    pub fn get_configSource(&self) -> &NodeConfigSource {
        self.configSource.as_ref().unwrap_or_else(|| <NodeConfigSource as ::protobuf::Message>::default_instance())
    }
    pub fn clear_configSource(&mut self) {
        self.configSource.clear();
    }

    pub fn has_configSource(&self) -> bool {
        self.configSource.is_some()
    }

    // Param is passed by value, moved
    pub fn set_configSource(&mut self, v: NodeConfigSource) {
        self.configSource = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_configSource(&mut self) -> &mut NodeConfigSource {
        if self.configSource.is_none() {
            self.configSource.set_default();
        }
        self.configSource.as_mut().unwrap()
    }

    // Take field
    pub fn take_configSource(&mut self) -> NodeConfigSource {
        self.configSource.take().unwrap_or_else(|| NodeConfigSource::new())
    }

    // optional string externalID = 2;


    pub fn get_externalID(&self) -> &str {
        match self.externalID.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_externalID(&mut self) {
        self.externalID.clear();
    }

    pub fn has_externalID(&self) -> bool {
        self.externalID.is_some()
    }

    // Param is passed by value, moved
    pub fn set_externalID(&mut self, v: ::std::string::String) {
        self.externalID = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_externalID(&mut self) -> &mut ::std::string::String {
        if self.externalID.is_none() {
            self.externalID.set_default();
        }
        self.externalID.as_mut().unwrap()
    }

    // Take field
    pub fn take_externalID(&mut self) -> ::std::string::String {
        self.externalID.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for NodeSpec {
    fn is_initialized(&self) -> bool {
        for v in &self.taints {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.configSource {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.podCIDR)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.podCIDRs)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.providerID)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.unschedulable = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.taints)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.configSource)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.externalID)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.podCIDR.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.podCIDRs {
            my_size += ::protobuf::rt::string_size(7, &value);
        };
        if let Some(ref v) = self.providerID.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.unschedulable {
            my_size += 2;
        }
        for value in &self.taints {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.configSource.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.externalID.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.podCIDR.as_ref() {
            os.write_string(1, &v)?;
        }
        for v in &self.podCIDRs {
            os.write_string(7, &v)?;
        };
        if let Some(ref v) = self.providerID.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.unschedulable {
            os.write_bool(4, v)?;
        }
        for v in &self.taints {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.configSource.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.externalID.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NodeSpec {
        NodeSpec::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "podCIDR",
                |m: &NodeSpec| { &m.podCIDR },
                |m: &mut NodeSpec| { &mut m.podCIDR },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "podCIDRs",
                |m: &NodeSpec| { &m.podCIDRs },
                |m: &mut NodeSpec| { &mut m.podCIDRs },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "providerID",
                |m: &NodeSpec| { &m.providerID },
                |m: &mut NodeSpec| { &mut m.providerID },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "unschedulable",
                |m: &NodeSpec| { &m.unschedulable },
                |m: &mut NodeSpec| { &mut m.unschedulable },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Taint>>(
                "taints",
                |m: &NodeSpec| { &m.taints },
                |m: &mut NodeSpec| { &mut m.taints },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NodeConfigSource>>(
                "configSource",
                |m: &NodeSpec| { &m.configSource },
                |m: &mut NodeSpec| { &mut m.configSource },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "externalID",
                |m: &NodeSpec| { &m.externalID },
                |m: &mut NodeSpec| { &mut m.externalID },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<NodeSpec>(
                "NodeSpec",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static NodeSpec {
        static instance: ::protobuf::rt::LazyV2<NodeSpec> = ::protobuf::rt::LazyV2::INIT;
        instance.get(NodeSpec::new)
    }
}

impl ::protobuf::Clear for NodeSpec {
    fn clear(&mut self) {
        self.podCIDR.clear();
        self.podCIDRs.clear();
        self.providerID.clear();
        self.unschedulable = ::std::option::Option::None;
        self.taints.clear();
        self.configSource.clear();
        self.externalID.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NodeSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NodeSpec {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NodeStatus {
    // message fields
    pub capacity: ::std::collections::HashMap<::std::string::String, super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity>,
    pub allocatable: ::std::collections::HashMap<::std::string::String, super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity>,
    phase: ::protobuf::SingularField<::std::string::String>,
    pub conditions: ::protobuf::RepeatedField<NodeCondition>,
    pub addresses: ::protobuf::RepeatedField<NodeAddress>,
    pub daemonEndpoints: ::protobuf::SingularPtrField<NodeDaemonEndpoints>,
    pub nodeInfo: ::protobuf::SingularPtrField<NodeSystemInfo>,
    pub images: ::protobuf::RepeatedField<ContainerImage>,
    pub volumesInUse: ::protobuf::RepeatedField<::std::string::String>,
    pub volumesAttached: ::protobuf::RepeatedField<AttachedVolume>,
    pub config: ::protobuf::SingularPtrField<NodeConfigStatus>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NodeStatus {
    fn default() -> &'a NodeStatus {
        <NodeStatus as ::protobuf::Message>::default_instance()
    }
}

impl NodeStatus {
    pub fn new() -> NodeStatus {
        ::std::default::Default::default()
    }

    // repeated .k8s.io.api.core.v1.NodeStatus.CapacityEntry capacity = 1;


    pub fn get_capacity(&self) -> &::std::collections::HashMap<::std::string::String, super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity> {
        &self.capacity
    }
    pub fn clear_capacity(&mut self) {
        self.capacity.clear();
    }

    // Param is passed by value, moved
    pub fn set_capacity(&mut self, v: ::std::collections::HashMap<::std::string::String, super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity>) {
        self.capacity = v;
    }

    // Mutable pointer to the field.
    pub fn mut_capacity(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity> {
        &mut self.capacity
    }

    // Take field
    pub fn take_capacity(&mut self) -> ::std::collections::HashMap<::std::string::String, super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity> {
        ::std::mem::replace(&mut self.capacity, ::std::collections::HashMap::new())
    }

    // repeated .k8s.io.api.core.v1.NodeStatus.AllocatableEntry allocatable = 2;


    pub fn get_allocatable(&self) -> &::std::collections::HashMap<::std::string::String, super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity> {
        &self.allocatable
    }
    pub fn clear_allocatable(&mut self) {
        self.allocatable.clear();
    }

    // Param is passed by value, moved
    pub fn set_allocatable(&mut self, v: ::std::collections::HashMap<::std::string::String, super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity>) {
        self.allocatable = v;
    }

    // Mutable pointer to the field.
    pub fn mut_allocatable(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity> {
        &mut self.allocatable
    }

    // Take field
    pub fn take_allocatable(&mut self) -> ::std::collections::HashMap<::std::string::String, super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity> {
        ::std::mem::replace(&mut self.allocatable, ::std::collections::HashMap::new())
    }

    // optional string phase = 3;


    pub fn get_phase(&self) -> &str {
        match self.phase.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_phase(&mut self) {
        self.phase.clear();
    }

    pub fn has_phase(&self) -> bool {
        self.phase.is_some()
    }

    // Param is passed by value, moved
    pub fn set_phase(&mut self, v: ::std::string::String) {
        self.phase = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_phase(&mut self) -> &mut ::std::string::String {
        if self.phase.is_none() {
            self.phase.set_default();
        }
        self.phase.as_mut().unwrap()
    }

    // Take field
    pub fn take_phase(&mut self) -> ::std::string::String {
        self.phase.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .k8s.io.api.core.v1.NodeCondition conditions = 4;


    pub fn get_conditions(&self) -> &[NodeCondition] {
        &self.conditions
    }
    pub fn clear_conditions(&mut self) {
        self.conditions.clear();
    }

    // Param is passed by value, moved
    pub fn set_conditions(&mut self, v: ::protobuf::RepeatedField<NodeCondition>) {
        self.conditions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_conditions(&mut self) -> &mut ::protobuf::RepeatedField<NodeCondition> {
        &mut self.conditions
    }

    // Take field
    pub fn take_conditions(&mut self) -> ::protobuf::RepeatedField<NodeCondition> {
        ::std::mem::replace(&mut self.conditions, ::protobuf::RepeatedField::new())
    }

    // repeated .k8s.io.api.core.v1.NodeAddress addresses = 5;


    pub fn get_addresses(&self) -> &[NodeAddress] {
        &self.addresses
    }
    pub fn clear_addresses(&mut self) {
        self.addresses.clear();
    }

    // Param is passed by value, moved
    pub fn set_addresses(&mut self, v: ::protobuf::RepeatedField<NodeAddress>) {
        self.addresses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_addresses(&mut self) -> &mut ::protobuf::RepeatedField<NodeAddress> {
        &mut self.addresses
    }

    // Take field
    pub fn take_addresses(&mut self) -> ::protobuf::RepeatedField<NodeAddress> {
        ::std::mem::replace(&mut self.addresses, ::protobuf::RepeatedField::new())
    }

    // optional .k8s.io.api.core.v1.NodeDaemonEndpoints daemonEndpoints = 6;


    pub fn get_daemonEndpoints(&self) -> &NodeDaemonEndpoints {
        self.daemonEndpoints.as_ref().unwrap_or_else(|| <NodeDaemonEndpoints as ::protobuf::Message>::default_instance())
    }
    pub fn clear_daemonEndpoints(&mut self) {
        self.daemonEndpoints.clear();
    }

    pub fn has_daemonEndpoints(&self) -> bool {
        self.daemonEndpoints.is_some()
    }

    // Param is passed by value, moved
    pub fn set_daemonEndpoints(&mut self, v: NodeDaemonEndpoints) {
        self.daemonEndpoints = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_daemonEndpoints(&mut self) -> &mut NodeDaemonEndpoints {
        if self.daemonEndpoints.is_none() {
            self.daemonEndpoints.set_default();
        }
        self.daemonEndpoints.as_mut().unwrap()
    }

    // Take field
    pub fn take_daemonEndpoints(&mut self) -> NodeDaemonEndpoints {
        self.daemonEndpoints.take().unwrap_or_else(|| NodeDaemonEndpoints::new())
    }

    // optional .k8s.io.api.core.v1.NodeSystemInfo nodeInfo = 7;


    pub fn get_nodeInfo(&self) -> &NodeSystemInfo {
        self.nodeInfo.as_ref().unwrap_or_else(|| <NodeSystemInfo as ::protobuf::Message>::default_instance())
    }
    pub fn clear_nodeInfo(&mut self) {
        self.nodeInfo.clear();
    }

    pub fn has_nodeInfo(&self) -> bool {
        self.nodeInfo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nodeInfo(&mut self, v: NodeSystemInfo) {
        self.nodeInfo = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nodeInfo(&mut self) -> &mut NodeSystemInfo {
        if self.nodeInfo.is_none() {
            self.nodeInfo.set_default();
        }
        self.nodeInfo.as_mut().unwrap()
    }

    // Take field
    pub fn take_nodeInfo(&mut self) -> NodeSystemInfo {
        self.nodeInfo.take().unwrap_or_else(|| NodeSystemInfo::new())
    }

    // repeated .k8s.io.api.core.v1.ContainerImage images = 8;


    pub fn get_images(&self) -> &[ContainerImage] {
        &self.images
    }
    pub fn clear_images(&mut self) {
        self.images.clear();
    }

    // Param is passed by value, moved
    pub fn set_images(&mut self, v: ::protobuf::RepeatedField<ContainerImage>) {
        self.images = v;
    }

    // Mutable pointer to the field.
    pub fn mut_images(&mut self) -> &mut ::protobuf::RepeatedField<ContainerImage> {
        &mut self.images
    }

    // Take field
    pub fn take_images(&mut self) -> ::protobuf::RepeatedField<ContainerImage> {
        ::std::mem::replace(&mut self.images, ::protobuf::RepeatedField::new())
    }

    // repeated string volumesInUse = 9;


    pub fn get_volumesInUse(&self) -> &[::std::string::String] {
        &self.volumesInUse
    }
    pub fn clear_volumesInUse(&mut self) {
        self.volumesInUse.clear();
    }

    // Param is passed by value, moved
    pub fn set_volumesInUse(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.volumesInUse = v;
    }

    // Mutable pointer to the field.
    pub fn mut_volumesInUse(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.volumesInUse
    }

    // Take field
    pub fn take_volumesInUse(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.volumesInUse, ::protobuf::RepeatedField::new())
    }

    // repeated .k8s.io.api.core.v1.AttachedVolume volumesAttached = 10;


    pub fn get_volumesAttached(&self) -> &[AttachedVolume] {
        &self.volumesAttached
    }
    pub fn clear_volumesAttached(&mut self) {
        self.volumesAttached.clear();
    }

    // Param is passed by value, moved
    pub fn set_volumesAttached(&mut self, v: ::protobuf::RepeatedField<AttachedVolume>) {
        self.volumesAttached = v;
    }

    // Mutable pointer to the field.
    pub fn mut_volumesAttached(&mut self) -> &mut ::protobuf::RepeatedField<AttachedVolume> {
        &mut self.volumesAttached
    }

    // Take field
    pub fn take_volumesAttached(&mut self) -> ::protobuf::RepeatedField<AttachedVolume> {
        ::std::mem::replace(&mut self.volumesAttached, ::protobuf::RepeatedField::new())
    }

    // optional .k8s.io.api.core.v1.NodeConfigStatus config = 11;


    pub fn get_config(&self) -> &NodeConfigStatus {
        self.config.as_ref().unwrap_or_else(|| <NodeConfigStatus as ::protobuf::Message>::default_instance())
    }
    pub fn clear_config(&mut self) {
        self.config.clear();
    }

    pub fn has_config(&self) -> bool {
        self.config.is_some()
    }

    // Param is passed by value, moved
    pub fn set_config(&mut self, v: NodeConfigStatus) {
        self.config = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_config(&mut self) -> &mut NodeConfigStatus {
        if self.config.is_none() {
            self.config.set_default();
        }
        self.config.as_mut().unwrap()
    }

    // Take field
    pub fn take_config(&mut self) -> NodeConfigStatus {
        self.config.take().unwrap_or_else(|| NodeConfigStatus::new())
    }
}

impl ::protobuf::Message for NodeStatus {
    fn is_initialized(&self) -> bool {
        for v in &self.conditions {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.addresses {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.daemonEndpoints {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.nodeInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.images {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.volumesAttached {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.config {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity>>(wire_type, is, &mut self.capacity)?;
                },
                2 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity>>(wire_type, is, &mut self.allocatable)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.phase)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.conditions)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.addresses)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.daemonEndpoints)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.nodeInfo)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.images)?;
                },
                9 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.volumesInUse)?;
                },
                10 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.volumesAttached)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.config)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity>>(1, &self.capacity);
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity>>(2, &self.allocatable);
        if let Some(ref v) = self.phase.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        for value in &self.conditions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.addresses {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.daemonEndpoints.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.nodeInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.images {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.volumesInUse {
            my_size += ::protobuf::rt::string_size(9, &value);
        };
        for value in &self.volumesAttached {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.config.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity>>(1, &self.capacity, os)?;
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity>>(2, &self.allocatable, os)?;
        if let Some(ref v) = self.phase.as_ref() {
            os.write_string(3, &v)?;
        }
        for v in &self.conditions {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.addresses {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.daemonEndpoints.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.nodeInfo.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.images {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.volumesInUse {
            os.write_string(9, &v)?;
        };
        for v in &self.volumesAttached {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.config.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NodeStatus {
        NodeStatus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity>>(
                "capacity",
                |m: &NodeStatus| { &m.capacity },
                |m: &mut NodeStatus| { &mut m.capacity },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity>>(
                "allocatable",
                |m: &NodeStatus| { &m.allocatable },
                |m: &mut NodeStatus| { &mut m.allocatable },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "phase",
                |m: &NodeStatus| { &m.phase },
                |m: &mut NodeStatus| { &mut m.phase },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NodeCondition>>(
                "conditions",
                |m: &NodeStatus| { &m.conditions },
                |m: &mut NodeStatus| { &mut m.conditions },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NodeAddress>>(
                "addresses",
                |m: &NodeStatus| { &m.addresses },
                |m: &mut NodeStatus| { &mut m.addresses },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NodeDaemonEndpoints>>(
                "daemonEndpoints",
                |m: &NodeStatus| { &m.daemonEndpoints },
                |m: &mut NodeStatus| { &mut m.daemonEndpoints },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NodeSystemInfo>>(
                "nodeInfo",
                |m: &NodeStatus| { &m.nodeInfo },
                |m: &mut NodeStatus| { &mut m.nodeInfo },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ContainerImage>>(
                "images",
                |m: &NodeStatus| { &m.images },
                |m: &mut NodeStatus| { &mut m.images },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "volumesInUse",
                |m: &NodeStatus| { &m.volumesInUse },
                |m: &mut NodeStatus| { &mut m.volumesInUse },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AttachedVolume>>(
                "volumesAttached",
                |m: &NodeStatus| { &m.volumesAttached },
                |m: &mut NodeStatus| { &mut m.volumesAttached },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NodeConfigStatus>>(
                "config",
                |m: &NodeStatus| { &m.config },
                |m: &mut NodeStatus| { &mut m.config },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<NodeStatus>(
                "NodeStatus",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static NodeStatus {
        static instance: ::protobuf::rt::LazyV2<NodeStatus> = ::protobuf::rt::LazyV2::INIT;
        instance.get(NodeStatus::new)
    }
}

impl ::protobuf::Clear for NodeStatus {
    fn clear(&mut self) {
        self.capacity.clear();
        self.allocatable.clear();
        self.phase.clear();
        self.conditions.clear();
        self.addresses.clear();
        self.daemonEndpoints.clear();
        self.nodeInfo.clear();
        self.images.clear();
        self.volumesInUse.clear();
        self.volumesAttached.clear();
        self.config.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NodeStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NodeStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct NodeSystemInfo {
    // message fields
    machineID: ::protobuf::SingularField<::std::string::String>,
    systemUUID: ::protobuf::SingularField<::std::string::String>,
    bootID: ::protobuf::SingularField<::std::string::String>,
    kernelVersion: ::protobuf::SingularField<::std::string::String>,
    osImage: ::protobuf::SingularField<::std::string::String>,
    containerRuntimeVersion: ::protobuf::SingularField<::std::string::String>,
    kubeletVersion: ::protobuf::SingularField<::std::string::String>,
    kubeProxyVersion: ::protobuf::SingularField<::std::string::String>,
    operatingSystem: ::protobuf::SingularField<::std::string::String>,
    architecture: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NodeSystemInfo {
    fn default() -> &'a NodeSystemInfo {
        <NodeSystemInfo as ::protobuf::Message>::default_instance()
    }
}

impl NodeSystemInfo {
    pub fn new() -> NodeSystemInfo {
        ::std::default::Default::default()
    }

    // optional string machineID = 1;


    pub fn get_machineID(&self) -> &str {
        match self.machineID.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_machineID(&mut self) {
        self.machineID.clear();
    }

    pub fn has_machineID(&self) -> bool {
        self.machineID.is_some()
    }

    // Param is passed by value, moved
    pub fn set_machineID(&mut self, v: ::std::string::String) {
        self.machineID = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_machineID(&mut self) -> &mut ::std::string::String {
        if self.machineID.is_none() {
            self.machineID.set_default();
        }
        self.machineID.as_mut().unwrap()
    }

    // Take field
    pub fn take_machineID(&mut self) -> ::std::string::String {
        self.machineID.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string systemUUID = 2;


    pub fn get_systemUUID(&self) -> &str {
        match self.systemUUID.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_systemUUID(&mut self) {
        self.systemUUID.clear();
    }

    pub fn has_systemUUID(&self) -> bool {
        self.systemUUID.is_some()
    }

    // Param is passed by value, moved
    pub fn set_systemUUID(&mut self, v: ::std::string::String) {
        self.systemUUID = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_systemUUID(&mut self) -> &mut ::std::string::String {
        if self.systemUUID.is_none() {
            self.systemUUID.set_default();
        }
        self.systemUUID.as_mut().unwrap()
    }

    // Take field
    pub fn take_systemUUID(&mut self) -> ::std::string::String {
        self.systemUUID.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string bootID = 3;


    pub fn get_bootID(&self) -> &str {
        match self.bootID.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_bootID(&mut self) {
        self.bootID.clear();
    }

    pub fn has_bootID(&self) -> bool {
        self.bootID.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bootID(&mut self, v: ::std::string::String) {
        self.bootID = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bootID(&mut self) -> &mut ::std::string::String {
        if self.bootID.is_none() {
            self.bootID.set_default();
        }
        self.bootID.as_mut().unwrap()
    }

    // Take field
    pub fn take_bootID(&mut self) -> ::std::string::String {
        self.bootID.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string kernelVersion = 4;


    pub fn get_kernelVersion(&self) -> &str {
        match self.kernelVersion.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_kernelVersion(&mut self) {
        self.kernelVersion.clear();
    }

    pub fn has_kernelVersion(&self) -> bool {
        self.kernelVersion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kernelVersion(&mut self, v: ::std::string::String) {
        self.kernelVersion = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kernelVersion(&mut self) -> &mut ::std::string::String {
        if self.kernelVersion.is_none() {
            self.kernelVersion.set_default();
        }
        self.kernelVersion.as_mut().unwrap()
    }

    // Take field
    pub fn take_kernelVersion(&mut self) -> ::std::string::String {
        self.kernelVersion.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string osImage = 5;


    pub fn get_osImage(&self) -> &str {
        match self.osImage.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_osImage(&mut self) {
        self.osImage.clear();
    }

    pub fn has_osImage(&self) -> bool {
        self.osImage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_osImage(&mut self, v: ::std::string::String) {
        self.osImage = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_osImage(&mut self) -> &mut ::std::string::String {
        if self.osImage.is_none() {
            self.osImage.set_default();
        }
        self.osImage.as_mut().unwrap()
    }

    // Take field
    pub fn take_osImage(&mut self) -> ::std::string::String {
        self.osImage.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string containerRuntimeVersion = 6;


    pub fn get_containerRuntimeVersion(&self) -> &str {
        match self.containerRuntimeVersion.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_containerRuntimeVersion(&mut self) {
        self.containerRuntimeVersion.clear();
    }

    pub fn has_containerRuntimeVersion(&self) -> bool {
        self.containerRuntimeVersion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_containerRuntimeVersion(&mut self, v: ::std::string::String) {
        self.containerRuntimeVersion = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_containerRuntimeVersion(&mut self) -> &mut ::std::string::String {
        if self.containerRuntimeVersion.is_none() {
            self.containerRuntimeVersion.set_default();
        }
        self.containerRuntimeVersion.as_mut().unwrap()
    }

    // Take field
    pub fn take_containerRuntimeVersion(&mut self) -> ::std::string::String {
        self.containerRuntimeVersion.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string kubeletVersion = 7;


    pub fn get_kubeletVersion(&self) -> &str {
        match self.kubeletVersion.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_kubeletVersion(&mut self) {
        self.kubeletVersion.clear();
    }

    pub fn has_kubeletVersion(&self) -> bool {
        self.kubeletVersion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kubeletVersion(&mut self, v: ::std::string::String) {
        self.kubeletVersion = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kubeletVersion(&mut self) -> &mut ::std::string::String {
        if self.kubeletVersion.is_none() {
            self.kubeletVersion.set_default();
        }
        self.kubeletVersion.as_mut().unwrap()
    }

    // Take field
    pub fn take_kubeletVersion(&mut self) -> ::std::string::String {
        self.kubeletVersion.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string kubeProxyVersion = 8;


    pub fn get_kubeProxyVersion(&self) -> &str {
        match self.kubeProxyVersion.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_kubeProxyVersion(&mut self) {
        self.kubeProxyVersion.clear();
    }

    pub fn has_kubeProxyVersion(&self) -> bool {
        self.kubeProxyVersion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kubeProxyVersion(&mut self, v: ::std::string::String) {
        self.kubeProxyVersion = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kubeProxyVersion(&mut self) -> &mut ::std::string::String {
        if self.kubeProxyVersion.is_none() {
            self.kubeProxyVersion.set_default();
        }
        self.kubeProxyVersion.as_mut().unwrap()
    }

    // Take field
    pub fn take_kubeProxyVersion(&mut self) -> ::std::string::String {
        self.kubeProxyVersion.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string operatingSystem = 9;


    pub fn get_operatingSystem(&self) -> &str {
        match self.operatingSystem.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_operatingSystem(&mut self) {
        self.operatingSystem.clear();
    }

    pub fn has_operatingSystem(&self) -> bool {
        self.operatingSystem.is_some()
    }

    // Param is passed by value, moved
    pub fn set_operatingSystem(&mut self, v: ::std::string::String) {
        self.operatingSystem = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_operatingSystem(&mut self) -> &mut ::std::string::String {
        if self.operatingSystem.is_none() {
            self.operatingSystem.set_default();
        }
        self.operatingSystem.as_mut().unwrap()
    }

    // Take field
    pub fn take_operatingSystem(&mut self) -> ::std::string::String {
        self.operatingSystem.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string architecture = 10;


    pub fn get_architecture(&self) -> &str {
        match self.architecture.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_architecture(&mut self) {
        self.architecture.clear();
    }

    pub fn has_architecture(&self) -> bool {
        self.architecture.is_some()
    }

    // Param is passed by value, moved
    pub fn set_architecture(&mut self, v: ::std::string::String) {
        self.architecture = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_architecture(&mut self) -> &mut ::std::string::String {
        if self.architecture.is_none() {
            self.architecture.set_default();
        }
        self.architecture.as_mut().unwrap()
    }

    // Take field
    pub fn take_architecture(&mut self) -> ::std::string::String {
        self.architecture.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for NodeSystemInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.machineID)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.systemUUID)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.bootID)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.kernelVersion)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.osImage)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.containerRuntimeVersion)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.kubeletVersion)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.kubeProxyVersion)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.operatingSystem)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.architecture)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.machineID.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.systemUUID.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.bootID.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.kernelVersion.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.osImage.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.containerRuntimeVersion.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(ref v) = self.kubeletVersion.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(ref v) = self.kubeProxyVersion.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(ref v) = self.operatingSystem.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(ref v) = self.architecture.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.machineID.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.systemUUID.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.bootID.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.kernelVersion.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.osImage.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.containerRuntimeVersion.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(ref v) = self.kubeletVersion.as_ref() {
            os.write_string(7, &v)?;
        }
        if let Some(ref v) = self.kubeProxyVersion.as_ref() {
            os.write_string(8, &v)?;
        }
        if let Some(ref v) = self.operatingSystem.as_ref() {
            os.write_string(9, &v)?;
        }
        if let Some(ref v) = self.architecture.as_ref() {
            os.write_string(10, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NodeSystemInfo {
        NodeSystemInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "machineID",
                |m: &NodeSystemInfo| { &m.machineID },
                |m: &mut NodeSystemInfo| { &mut m.machineID },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "systemUUID",
                |m: &NodeSystemInfo| { &m.systemUUID },
                |m: &mut NodeSystemInfo| { &mut m.systemUUID },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "bootID",
                |m: &NodeSystemInfo| { &m.bootID },
                |m: &mut NodeSystemInfo| { &mut m.bootID },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "kernelVersion",
                |m: &NodeSystemInfo| { &m.kernelVersion },
                |m: &mut NodeSystemInfo| { &mut m.kernelVersion },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "osImage",
                |m: &NodeSystemInfo| { &m.osImage },
                |m: &mut NodeSystemInfo| { &mut m.osImage },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "containerRuntimeVersion",
                |m: &NodeSystemInfo| { &m.containerRuntimeVersion },
                |m: &mut NodeSystemInfo| { &mut m.containerRuntimeVersion },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "kubeletVersion",
                |m: &NodeSystemInfo| { &m.kubeletVersion },
                |m: &mut NodeSystemInfo| { &mut m.kubeletVersion },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "kubeProxyVersion",
                |m: &NodeSystemInfo| { &m.kubeProxyVersion },
                |m: &mut NodeSystemInfo| { &mut m.kubeProxyVersion },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "operatingSystem",
                |m: &NodeSystemInfo| { &m.operatingSystem },
                |m: &mut NodeSystemInfo| { &mut m.operatingSystem },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "architecture",
                |m: &NodeSystemInfo| { &m.architecture },
                |m: &mut NodeSystemInfo| { &mut m.architecture },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<NodeSystemInfo>(
                "NodeSystemInfo",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static NodeSystemInfo {
        static instance: ::protobuf::rt::LazyV2<NodeSystemInfo> = ::protobuf::rt::LazyV2::INIT;
        instance.get(NodeSystemInfo::new)
    }
}

impl ::protobuf::Clear for NodeSystemInfo {
    fn clear(&mut self) {
        self.machineID.clear();
        self.systemUUID.clear();
        self.bootID.clear();
        self.kernelVersion.clear();
        self.osImage.clear();
        self.containerRuntimeVersion.clear();
        self.kubeletVersion.clear();
        self.kubeProxyVersion.clear();
        self.operatingSystem.clear();
        self.architecture.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NodeSystemInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NodeSystemInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ObjectFieldSelector {
    // message fields
    apiVersion: ::protobuf::SingularField<::std::string::String>,
    fieldPath: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ObjectFieldSelector {
    fn default() -> &'a ObjectFieldSelector {
        <ObjectFieldSelector as ::protobuf::Message>::default_instance()
    }
}

impl ObjectFieldSelector {
    pub fn new() -> ObjectFieldSelector {
        ::std::default::Default::default()
    }

    // optional string apiVersion = 1;


    pub fn get_apiVersion(&self) -> &str {
        match self.apiVersion.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_apiVersion(&mut self) {
        self.apiVersion.clear();
    }

    pub fn has_apiVersion(&self) -> bool {
        self.apiVersion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_apiVersion(&mut self, v: ::std::string::String) {
        self.apiVersion = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_apiVersion(&mut self) -> &mut ::std::string::String {
        if self.apiVersion.is_none() {
            self.apiVersion.set_default();
        }
        self.apiVersion.as_mut().unwrap()
    }

    // Take field
    pub fn take_apiVersion(&mut self) -> ::std::string::String {
        self.apiVersion.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string fieldPath = 2;


    pub fn get_fieldPath(&self) -> &str {
        match self.fieldPath.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_fieldPath(&mut self) {
        self.fieldPath.clear();
    }

    pub fn has_fieldPath(&self) -> bool {
        self.fieldPath.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fieldPath(&mut self, v: ::std::string::String) {
        self.fieldPath = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fieldPath(&mut self) -> &mut ::std::string::String {
        if self.fieldPath.is_none() {
            self.fieldPath.set_default();
        }
        self.fieldPath.as_mut().unwrap()
    }

    // Take field
    pub fn take_fieldPath(&mut self) -> ::std::string::String {
        self.fieldPath.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for ObjectFieldSelector {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.apiVersion)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.fieldPath)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.apiVersion.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.fieldPath.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.apiVersion.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.fieldPath.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ObjectFieldSelector {
        ObjectFieldSelector::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "apiVersion",
                |m: &ObjectFieldSelector| { &m.apiVersion },
                |m: &mut ObjectFieldSelector| { &mut m.apiVersion },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "fieldPath",
                |m: &ObjectFieldSelector| { &m.fieldPath },
                |m: &mut ObjectFieldSelector| { &mut m.fieldPath },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ObjectFieldSelector>(
                "ObjectFieldSelector",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ObjectFieldSelector {
        static instance: ::protobuf::rt::LazyV2<ObjectFieldSelector> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ObjectFieldSelector::new)
    }
}

impl ::protobuf::Clear for ObjectFieldSelector {
    fn clear(&mut self) {
        self.apiVersion.clear();
        self.fieldPath.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ObjectFieldSelector {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ObjectFieldSelector {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ObjectReference {
    // message fields
    kind: ::protobuf::SingularField<::std::string::String>,
    namespace: ::protobuf::SingularField<::std::string::String>,
    name: ::protobuf::SingularField<::std::string::String>,
    uid: ::protobuf::SingularField<::std::string::String>,
    apiVersion: ::protobuf::SingularField<::std::string::String>,
    resourceVersion: ::protobuf::SingularField<::std::string::String>,
    fieldPath: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ObjectReference {
    fn default() -> &'a ObjectReference {
        <ObjectReference as ::protobuf::Message>::default_instance()
    }
}

impl ObjectReference {
    pub fn new() -> ObjectReference {
        ::std::default::Default::default()
    }

    // optional string kind = 1;


    pub fn get_kind(&self) -> &str {
        match self.kind.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_kind(&mut self) {
        self.kind.clear();
    }

    pub fn has_kind(&self) -> bool {
        self.kind.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kind(&mut self, v: ::std::string::String) {
        self.kind = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kind(&mut self) -> &mut ::std::string::String {
        if self.kind.is_none() {
            self.kind.set_default();
        }
        self.kind.as_mut().unwrap()
    }

    // Take field
    pub fn take_kind(&mut self) -> ::std::string::String {
        self.kind.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string namespace = 2;


    pub fn get_namespace(&self) -> &str {
        match self.namespace.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_namespace(&mut self) {
        self.namespace.clear();
    }

    pub fn has_namespace(&self) -> bool {
        self.namespace.is_some()
    }

    // Param is passed by value, moved
    pub fn set_namespace(&mut self, v: ::std::string::String) {
        self.namespace = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_namespace(&mut self) -> &mut ::std::string::String {
        if self.namespace.is_none() {
            self.namespace.set_default();
        }
        self.namespace.as_mut().unwrap()
    }

    // Take field
    pub fn take_namespace(&mut self) -> ::std::string::String {
        self.namespace.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string name = 3;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string uid = 4;


    pub fn get_uid(&self) -> &str {
        match self.uid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_uid(&mut self) {
        self.uid.clear();
    }

    pub fn has_uid(&self) -> bool {
        self.uid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_uid(&mut self, v: ::std::string::String) {
        self.uid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uid(&mut self) -> &mut ::std::string::String {
        if self.uid.is_none() {
            self.uid.set_default();
        }
        self.uid.as_mut().unwrap()
    }

    // Take field
    pub fn take_uid(&mut self) -> ::std::string::String {
        self.uid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string apiVersion = 5;


    pub fn get_apiVersion(&self) -> &str {
        match self.apiVersion.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_apiVersion(&mut self) {
        self.apiVersion.clear();
    }

    pub fn has_apiVersion(&self) -> bool {
        self.apiVersion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_apiVersion(&mut self, v: ::std::string::String) {
        self.apiVersion = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_apiVersion(&mut self) -> &mut ::std::string::String {
        if self.apiVersion.is_none() {
            self.apiVersion.set_default();
        }
        self.apiVersion.as_mut().unwrap()
    }

    // Take field
    pub fn take_apiVersion(&mut self) -> ::std::string::String {
        self.apiVersion.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string resourceVersion = 6;


    pub fn get_resourceVersion(&self) -> &str {
        match self.resourceVersion.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_resourceVersion(&mut self) {
        self.resourceVersion.clear();
    }

    pub fn has_resourceVersion(&self) -> bool {
        self.resourceVersion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resourceVersion(&mut self, v: ::std::string::String) {
        self.resourceVersion = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_resourceVersion(&mut self) -> &mut ::std::string::String {
        if self.resourceVersion.is_none() {
            self.resourceVersion.set_default();
        }
        self.resourceVersion.as_mut().unwrap()
    }

    // Take field
    pub fn take_resourceVersion(&mut self) -> ::std::string::String {
        self.resourceVersion.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string fieldPath = 7;


    pub fn get_fieldPath(&self) -> &str {
        match self.fieldPath.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_fieldPath(&mut self) {
        self.fieldPath.clear();
    }

    pub fn has_fieldPath(&self) -> bool {
        self.fieldPath.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fieldPath(&mut self, v: ::std::string::String) {
        self.fieldPath = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fieldPath(&mut self) -> &mut ::std::string::String {
        if self.fieldPath.is_none() {
            self.fieldPath.set_default();
        }
        self.fieldPath.as_mut().unwrap()
    }

    // Take field
    pub fn take_fieldPath(&mut self) -> ::std::string::String {
        self.fieldPath.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for ObjectReference {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.kind)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.namespace)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.uid)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.apiVersion)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.resourceVersion)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.fieldPath)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.kind.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.namespace.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.uid.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.apiVersion.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.resourceVersion.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(ref v) = self.fieldPath.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.kind.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.namespace.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.uid.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.apiVersion.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.resourceVersion.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(ref v) = self.fieldPath.as_ref() {
            os.write_string(7, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ObjectReference {
        ObjectReference::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "kind",
                |m: &ObjectReference| { &m.kind },
                |m: &mut ObjectReference| { &mut m.kind },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "namespace",
                |m: &ObjectReference| { &m.namespace },
                |m: &mut ObjectReference| { &mut m.namespace },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &ObjectReference| { &m.name },
                |m: &mut ObjectReference| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "uid",
                |m: &ObjectReference| { &m.uid },
                |m: &mut ObjectReference| { &mut m.uid },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "apiVersion",
                |m: &ObjectReference| { &m.apiVersion },
                |m: &mut ObjectReference| { &mut m.apiVersion },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "resourceVersion",
                |m: &ObjectReference| { &m.resourceVersion },
                |m: &mut ObjectReference| { &mut m.resourceVersion },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "fieldPath",
                |m: &ObjectReference| { &m.fieldPath },
                |m: &mut ObjectReference| { &mut m.fieldPath },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ObjectReference>(
                "ObjectReference",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ObjectReference {
        static instance: ::protobuf::rt::LazyV2<ObjectReference> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ObjectReference::new)
    }
}

impl ::protobuf::Clear for ObjectReference {
    fn clear(&mut self) {
        self.kind.clear();
        self.namespace.clear();
        self.name.clear();
        self.uid.clear();
        self.apiVersion.clear();
        self.resourceVersion.clear();
        self.fieldPath.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ObjectReference {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ObjectReference {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PersistentVolume {
    // message fields
    pub metadata: ::protobuf::SingularPtrField<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta>,
    pub spec: ::protobuf::SingularPtrField<PersistentVolumeSpec>,
    pub status: ::protobuf::SingularPtrField<PersistentVolumeStatus>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PersistentVolume {
    fn default() -> &'a PersistentVolume {
        <PersistentVolume as ::protobuf::Message>::default_instance()
    }
}

impl PersistentVolume {
    pub fn new() -> PersistentVolume {
        ::std::default::Default::default()
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;


    pub fn get_metadata(&self) -> &super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta::new())
    }

    // optional .k8s.io.api.core.v1.PersistentVolumeSpec spec = 2;


    pub fn get_spec(&self) -> &PersistentVolumeSpec {
        self.spec.as_ref().unwrap_or_else(|| <PersistentVolumeSpec as ::protobuf::Message>::default_instance())
    }
    pub fn clear_spec(&mut self) {
        self.spec.clear();
    }

    pub fn has_spec(&self) -> bool {
        self.spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spec(&mut self, v: PersistentVolumeSpec) {
        self.spec = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spec(&mut self) -> &mut PersistentVolumeSpec {
        if self.spec.is_none() {
            self.spec.set_default();
        }
        self.spec.as_mut().unwrap()
    }

    // Take field
    pub fn take_spec(&mut self) -> PersistentVolumeSpec {
        self.spec.take().unwrap_or_else(|| PersistentVolumeSpec::new())
    }

    // optional .k8s.io.api.core.v1.PersistentVolumeStatus status = 3;


    pub fn get_status(&self) -> &PersistentVolumeStatus {
        self.status.as_ref().unwrap_or_else(|| <PersistentVolumeStatus as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: PersistentVolumeStatus) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut PersistentVolumeStatus {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> PersistentVolumeStatus {
        self.status.take().unwrap_or_else(|| PersistentVolumeStatus::new())
    }
}

impl ::protobuf::Message for PersistentVolume {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.spec {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.spec)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.spec.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PersistentVolume {
        PersistentVolume::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta>>(
                "metadata",
                |m: &PersistentVolume| { &m.metadata },
                |m: &mut PersistentVolume| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PersistentVolumeSpec>>(
                "spec",
                |m: &PersistentVolume| { &m.spec },
                |m: &mut PersistentVolume| { &mut m.spec },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PersistentVolumeStatus>>(
                "status",
                |m: &PersistentVolume| { &m.status },
                |m: &mut PersistentVolume| { &mut m.status },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PersistentVolume>(
                "PersistentVolume",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PersistentVolume {
        static instance: ::protobuf::rt::LazyV2<PersistentVolume> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PersistentVolume::new)
    }
}

impl ::protobuf::Clear for PersistentVolume {
    fn clear(&mut self) {
        self.metadata.clear();
        self.spec.clear();
        self.status.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PersistentVolume {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PersistentVolume {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PersistentVolumeClaim {
    // message fields
    pub metadata: ::protobuf::SingularPtrField<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta>,
    pub spec: ::protobuf::SingularPtrField<PersistentVolumeClaimSpec>,
    pub status: ::protobuf::SingularPtrField<PersistentVolumeClaimStatus>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PersistentVolumeClaim {
    fn default() -> &'a PersistentVolumeClaim {
        <PersistentVolumeClaim as ::protobuf::Message>::default_instance()
    }
}

impl PersistentVolumeClaim {
    pub fn new() -> PersistentVolumeClaim {
        ::std::default::Default::default()
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;


    pub fn get_metadata(&self) -> &super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta::new())
    }

    // optional .k8s.io.api.core.v1.PersistentVolumeClaimSpec spec = 2;


    pub fn get_spec(&self) -> &PersistentVolumeClaimSpec {
        self.spec.as_ref().unwrap_or_else(|| <PersistentVolumeClaimSpec as ::protobuf::Message>::default_instance())
    }
    pub fn clear_spec(&mut self) {
        self.spec.clear();
    }

    pub fn has_spec(&self) -> bool {
        self.spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spec(&mut self, v: PersistentVolumeClaimSpec) {
        self.spec = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spec(&mut self) -> &mut PersistentVolumeClaimSpec {
        if self.spec.is_none() {
            self.spec.set_default();
        }
        self.spec.as_mut().unwrap()
    }

    // Take field
    pub fn take_spec(&mut self) -> PersistentVolumeClaimSpec {
        self.spec.take().unwrap_or_else(|| PersistentVolumeClaimSpec::new())
    }

    // optional .k8s.io.api.core.v1.PersistentVolumeClaimStatus status = 3;


    pub fn get_status(&self) -> &PersistentVolumeClaimStatus {
        self.status.as_ref().unwrap_or_else(|| <PersistentVolumeClaimStatus as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: PersistentVolumeClaimStatus) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut PersistentVolumeClaimStatus {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> PersistentVolumeClaimStatus {
        self.status.take().unwrap_or_else(|| PersistentVolumeClaimStatus::new())
    }
}

impl ::protobuf::Message for PersistentVolumeClaim {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.spec {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.spec)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.spec.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PersistentVolumeClaim {
        PersistentVolumeClaim::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta>>(
                "metadata",
                |m: &PersistentVolumeClaim| { &m.metadata },
                |m: &mut PersistentVolumeClaim| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PersistentVolumeClaimSpec>>(
                "spec",
                |m: &PersistentVolumeClaim| { &m.spec },
                |m: &mut PersistentVolumeClaim| { &mut m.spec },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PersistentVolumeClaimStatus>>(
                "status",
                |m: &PersistentVolumeClaim| { &m.status },
                |m: &mut PersistentVolumeClaim| { &mut m.status },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PersistentVolumeClaim>(
                "PersistentVolumeClaim",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PersistentVolumeClaim {
        static instance: ::protobuf::rt::LazyV2<PersistentVolumeClaim> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PersistentVolumeClaim::new)
    }
}

impl ::protobuf::Clear for PersistentVolumeClaim {
    fn clear(&mut self) {
        self.metadata.clear();
        self.spec.clear();
        self.status.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PersistentVolumeClaim {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PersistentVolumeClaim {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PersistentVolumeClaimCondition {
    // message fields
    field_type: ::protobuf::SingularField<::std::string::String>,
    status: ::protobuf::SingularField<::std::string::String>,
    pub lastProbeTime: ::protobuf::SingularPtrField<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time>,
    pub lastTransitionTime: ::protobuf::SingularPtrField<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time>,
    reason: ::protobuf::SingularField<::std::string::String>,
    message: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PersistentVolumeClaimCondition {
    fn default() -> &'a PersistentVolumeClaimCondition {
        <PersistentVolumeClaimCondition as ::protobuf::Message>::default_instance()
    }
}

impl PersistentVolumeClaimCondition {
    pub fn new() -> PersistentVolumeClaimCondition {
        ::std::default::Default::default()
    }

    // optional string type = 1;


    pub fn get_field_type(&self) -> &str {
        match self.field_type.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ::std::string::String) {
        self.field_type = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut ::std::string::String {
        if self.field_type.is_none() {
            self.field_type.set_default();
        }
        self.field_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_field_type(&mut self) -> ::std::string::String {
        self.field_type.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string status = 2;


    pub fn get_status(&self) -> &str {
        match self.status.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: ::std::string::String) {
        self.status = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut ::std::string::String {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> ::std::string::String {
        self.status.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastProbeTime = 3;


    pub fn get_lastProbeTime(&self) -> &super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time {
        self.lastProbeTime.as_ref().unwrap_or_else(|| <super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time as ::protobuf::Message>::default_instance())
    }
    pub fn clear_lastProbeTime(&mut self) {
        self.lastProbeTime.clear();
    }

    pub fn has_lastProbeTime(&self) -> bool {
        self.lastProbeTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lastProbeTime(&mut self, v: super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time) {
        self.lastProbeTime = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lastProbeTime(&mut self) -> &mut super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time {
        if self.lastProbeTime.is_none() {
            self.lastProbeTime.set_default();
        }
        self.lastProbeTime.as_mut().unwrap()
    }

    // Take field
    pub fn take_lastProbeTime(&mut self) -> super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time {
        self.lastProbeTime.take().unwrap_or_else(|| super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time::new())
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 4;


    pub fn get_lastTransitionTime(&self) -> &super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time {
        self.lastTransitionTime.as_ref().unwrap_or_else(|| <super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time as ::protobuf::Message>::default_instance())
    }
    pub fn clear_lastTransitionTime(&mut self) {
        self.lastTransitionTime.clear();
    }

    pub fn has_lastTransitionTime(&self) -> bool {
        self.lastTransitionTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lastTransitionTime(&mut self, v: super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time) {
        self.lastTransitionTime = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lastTransitionTime(&mut self) -> &mut super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time {
        if self.lastTransitionTime.is_none() {
            self.lastTransitionTime.set_default();
        }
        self.lastTransitionTime.as_mut().unwrap()
    }

    // Take field
    pub fn take_lastTransitionTime(&mut self) -> super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time {
        self.lastTransitionTime.take().unwrap_or_else(|| super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time::new())
    }

    // optional string reason = 5;


    pub fn get_reason(&self) -> &str {
        match self.reason.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_reason(&mut self) {
        self.reason.clear();
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: ::std::string::String) {
        self.reason = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reason(&mut self) -> &mut ::std::string::String {
        if self.reason.is_none() {
            self.reason.set_default();
        }
        self.reason.as_mut().unwrap()
    }

    // Take field
    pub fn take_reason(&mut self) -> ::std::string::String {
        self.reason.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string message = 6;


    pub fn get_message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for PersistentVolumeClaimCondition {
    fn is_initialized(&self) -> bool {
        for v in &self.lastProbeTime {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.lastTransitionTime {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.field_type)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.status)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.lastProbeTime)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.lastTransitionTime)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.reason)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.field_type.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.status.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.lastProbeTime.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.lastTransitionTime.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.reason.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.field_type.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.status.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.lastProbeTime.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.lastTransitionTime.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.reason.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.message.as_ref() {
            os.write_string(6, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PersistentVolumeClaimCondition {
        PersistentVolumeClaimCondition::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "type",
                |m: &PersistentVolumeClaimCondition| { &m.field_type },
                |m: &mut PersistentVolumeClaimCondition| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "status",
                |m: &PersistentVolumeClaimCondition| { &m.status },
                |m: &mut PersistentVolumeClaimCondition| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time>>(
                "lastProbeTime",
                |m: &PersistentVolumeClaimCondition| { &m.lastProbeTime },
                |m: &mut PersistentVolumeClaimCondition| { &mut m.lastProbeTime },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time>>(
                "lastTransitionTime",
                |m: &PersistentVolumeClaimCondition| { &m.lastTransitionTime },
                |m: &mut PersistentVolumeClaimCondition| { &mut m.lastTransitionTime },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "reason",
                |m: &PersistentVolumeClaimCondition| { &m.reason },
                |m: &mut PersistentVolumeClaimCondition| { &mut m.reason },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "message",
                |m: &PersistentVolumeClaimCondition| { &m.message },
                |m: &mut PersistentVolumeClaimCondition| { &mut m.message },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PersistentVolumeClaimCondition>(
                "PersistentVolumeClaimCondition",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PersistentVolumeClaimCondition {
        static instance: ::protobuf::rt::LazyV2<PersistentVolumeClaimCondition> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PersistentVolumeClaimCondition::new)
    }
}

impl ::protobuf::Clear for PersistentVolumeClaimCondition {
    fn clear(&mut self) {
        self.field_type.clear();
        self.status.clear();
        self.lastProbeTime.clear();
        self.lastTransitionTime.clear();
        self.reason.clear();
        self.message.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PersistentVolumeClaimCondition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PersistentVolumeClaimCondition {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PersistentVolumeClaimList {
    // message fields
    pub metadata: ::protobuf::SingularPtrField<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta>,
    pub items: ::protobuf::RepeatedField<PersistentVolumeClaim>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PersistentVolumeClaimList {
    fn default() -> &'a PersistentVolumeClaimList {
        <PersistentVolumeClaimList as ::protobuf::Message>::default_instance()
    }
}

impl PersistentVolumeClaimList {
    pub fn new() -> PersistentVolumeClaimList {
        ::std::default::Default::default()
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;


    pub fn get_metadata(&self) -> &super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta {
        self.metadata.take().unwrap_or_else(|| super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta::new())
    }

    // repeated .k8s.io.api.core.v1.PersistentVolumeClaim items = 2;


    pub fn get_items(&self) -> &[PersistentVolumeClaim] {
        &self.items
    }
    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::protobuf::RepeatedField<PersistentVolumeClaim>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::protobuf::RepeatedField<PersistentVolumeClaim> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::protobuf::RepeatedField<PersistentVolumeClaim> {
        ::std::mem::replace(&mut self.items, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PersistentVolumeClaimList {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.items {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.items)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.items {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PersistentVolumeClaimList {
        PersistentVolumeClaimList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta>>(
                "metadata",
                |m: &PersistentVolumeClaimList| { &m.metadata },
                |m: &mut PersistentVolumeClaimList| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PersistentVolumeClaim>>(
                "items",
                |m: &PersistentVolumeClaimList| { &m.items },
                |m: &mut PersistentVolumeClaimList| { &mut m.items },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PersistentVolumeClaimList>(
                "PersistentVolumeClaimList",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PersistentVolumeClaimList {
        static instance: ::protobuf::rt::LazyV2<PersistentVolumeClaimList> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PersistentVolumeClaimList::new)
    }
}

impl ::protobuf::Clear for PersistentVolumeClaimList {
    fn clear(&mut self) {
        self.metadata.clear();
        self.items.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PersistentVolumeClaimList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PersistentVolumeClaimList {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PersistentVolumeClaimSpec {
    // message fields
    pub accessModes: ::protobuf::RepeatedField<::std::string::String>,
    pub selector: ::protobuf::SingularPtrField<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::LabelSelector>,
    pub resources: ::protobuf::SingularPtrField<ResourceRequirements>,
    volumeName: ::protobuf::SingularField<::std::string::String>,
    storageClassName: ::protobuf::SingularField<::std::string::String>,
    volumeMode: ::protobuf::SingularField<::std::string::String>,
    pub dataSource: ::protobuf::SingularPtrField<TypedLocalObjectReference>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PersistentVolumeClaimSpec {
    fn default() -> &'a PersistentVolumeClaimSpec {
        <PersistentVolumeClaimSpec as ::protobuf::Message>::default_instance()
    }
}

impl PersistentVolumeClaimSpec {
    pub fn new() -> PersistentVolumeClaimSpec {
        ::std::default::Default::default()
    }

    // repeated string accessModes = 1;


    pub fn get_accessModes(&self) -> &[::std::string::String] {
        &self.accessModes
    }
    pub fn clear_accessModes(&mut self) {
        self.accessModes.clear();
    }

    // Param is passed by value, moved
    pub fn set_accessModes(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.accessModes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_accessModes(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.accessModes
    }

    // Take field
    pub fn take_accessModes(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.accessModes, ::protobuf::RepeatedField::new())
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector selector = 4;


    pub fn get_selector(&self) -> &super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::LabelSelector {
        self.selector.as_ref().unwrap_or_else(|| <super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::LabelSelector as ::protobuf::Message>::default_instance())
    }
    pub fn clear_selector(&mut self) {
        self.selector.clear();
    }

    pub fn has_selector(&self) -> bool {
        self.selector.is_some()
    }

    // Param is passed by value, moved
    pub fn set_selector(&mut self, v: super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::LabelSelector) {
        self.selector = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_selector(&mut self) -> &mut super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::LabelSelector {
        if self.selector.is_none() {
            self.selector.set_default();
        }
        self.selector.as_mut().unwrap()
    }

    // Take field
    pub fn take_selector(&mut self) -> super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::LabelSelector {
        self.selector.take().unwrap_or_else(|| super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::LabelSelector::new())
    }

    // optional .k8s.io.api.core.v1.ResourceRequirements resources = 2;


    pub fn get_resources(&self) -> &ResourceRequirements {
        self.resources.as_ref().unwrap_or_else(|| <ResourceRequirements as ::protobuf::Message>::default_instance())
    }
    pub fn clear_resources(&mut self) {
        self.resources.clear();
    }

    pub fn has_resources(&self) -> bool {
        self.resources.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resources(&mut self, v: ResourceRequirements) {
        self.resources = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_resources(&mut self) -> &mut ResourceRequirements {
        if self.resources.is_none() {
            self.resources.set_default();
        }
        self.resources.as_mut().unwrap()
    }

    // Take field
    pub fn take_resources(&mut self) -> ResourceRequirements {
        self.resources.take().unwrap_or_else(|| ResourceRequirements::new())
    }

    // optional string volumeName = 3;


    pub fn get_volumeName(&self) -> &str {
        match self.volumeName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_volumeName(&mut self) {
        self.volumeName.clear();
    }

    pub fn has_volumeName(&self) -> bool {
        self.volumeName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_volumeName(&mut self, v: ::std::string::String) {
        self.volumeName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_volumeName(&mut self) -> &mut ::std::string::String {
        if self.volumeName.is_none() {
            self.volumeName.set_default();
        }
        self.volumeName.as_mut().unwrap()
    }

    // Take field
    pub fn take_volumeName(&mut self) -> ::std::string::String {
        self.volumeName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string storageClassName = 5;


    pub fn get_storageClassName(&self) -> &str {
        match self.storageClassName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_storageClassName(&mut self) {
        self.storageClassName.clear();
    }

    pub fn has_storageClassName(&self) -> bool {
        self.storageClassName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_storageClassName(&mut self, v: ::std::string::String) {
        self.storageClassName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_storageClassName(&mut self) -> &mut ::std::string::String {
        if self.storageClassName.is_none() {
            self.storageClassName.set_default();
        }
        self.storageClassName.as_mut().unwrap()
    }

    // Take field
    pub fn take_storageClassName(&mut self) -> ::std::string::String {
        self.storageClassName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string volumeMode = 6;


    pub fn get_volumeMode(&self) -> &str {
        match self.volumeMode.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_volumeMode(&mut self) {
        self.volumeMode.clear();
    }

    pub fn has_volumeMode(&self) -> bool {
        self.volumeMode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_volumeMode(&mut self, v: ::std::string::String) {
        self.volumeMode = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_volumeMode(&mut self) -> &mut ::std::string::String {
        if self.volumeMode.is_none() {
            self.volumeMode.set_default();
        }
        self.volumeMode.as_mut().unwrap()
    }

    // Take field
    pub fn take_volumeMode(&mut self) -> ::std::string::String {
        self.volumeMode.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .k8s.io.api.core.v1.TypedLocalObjectReference dataSource = 7;


    pub fn get_dataSource(&self) -> &TypedLocalObjectReference {
        self.dataSource.as_ref().unwrap_or_else(|| <TypedLocalObjectReference as ::protobuf::Message>::default_instance())
    }
    pub fn clear_dataSource(&mut self) {
        self.dataSource.clear();
    }

    pub fn has_dataSource(&self) -> bool {
        self.dataSource.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dataSource(&mut self, v: TypedLocalObjectReference) {
        self.dataSource = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dataSource(&mut self) -> &mut TypedLocalObjectReference {
        if self.dataSource.is_none() {
            self.dataSource.set_default();
        }
        self.dataSource.as_mut().unwrap()
    }

    // Take field
    pub fn take_dataSource(&mut self) -> TypedLocalObjectReference {
        self.dataSource.take().unwrap_or_else(|| TypedLocalObjectReference::new())
    }
}

impl ::protobuf::Message for PersistentVolumeClaimSpec {
    fn is_initialized(&self) -> bool {
        for v in &self.selector {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.resources {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.dataSource {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.accessModes)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.selector)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.resources)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.volumeName)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.storageClassName)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.volumeMode)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.dataSource)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.accessModes {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if let Some(ref v) = self.selector.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.resources.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.volumeName.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.storageClassName.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.volumeMode.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(ref v) = self.dataSource.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.accessModes {
            os.write_string(1, &v)?;
        };
        if let Some(ref v) = self.selector.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.resources.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.volumeName.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.storageClassName.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.volumeMode.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(ref v) = self.dataSource.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PersistentVolumeClaimSpec {
        PersistentVolumeClaimSpec::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "accessModes",
                |m: &PersistentVolumeClaimSpec| { &m.accessModes },
                |m: &mut PersistentVolumeClaimSpec| { &mut m.accessModes },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::LabelSelector>>(
                "selector",
                |m: &PersistentVolumeClaimSpec| { &m.selector },
                |m: &mut PersistentVolumeClaimSpec| { &mut m.selector },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResourceRequirements>>(
                "resources",
                |m: &PersistentVolumeClaimSpec| { &m.resources },
                |m: &mut PersistentVolumeClaimSpec| { &mut m.resources },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "volumeName",
                |m: &PersistentVolumeClaimSpec| { &m.volumeName },
                |m: &mut PersistentVolumeClaimSpec| { &mut m.volumeName },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "storageClassName",
                |m: &PersistentVolumeClaimSpec| { &m.storageClassName },
                |m: &mut PersistentVolumeClaimSpec| { &mut m.storageClassName },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "volumeMode",
                |m: &PersistentVolumeClaimSpec| { &m.volumeMode },
                |m: &mut PersistentVolumeClaimSpec| { &mut m.volumeMode },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TypedLocalObjectReference>>(
                "dataSource",
                |m: &PersistentVolumeClaimSpec| { &m.dataSource },
                |m: &mut PersistentVolumeClaimSpec| { &mut m.dataSource },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PersistentVolumeClaimSpec>(
                "PersistentVolumeClaimSpec",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PersistentVolumeClaimSpec {
        static instance: ::protobuf::rt::LazyV2<PersistentVolumeClaimSpec> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PersistentVolumeClaimSpec::new)
    }
}

impl ::protobuf::Clear for PersistentVolumeClaimSpec {
    fn clear(&mut self) {
        self.accessModes.clear();
        self.selector.clear();
        self.resources.clear();
        self.volumeName.clear();
        self.storageClassName.clear();
        self.volumeMode.clear();
        self.dataSource.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PersistentVolumeClaimSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PersistentVolumeClaimSpec {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PersistentVolumeClaimStatus {
    // message fields
    phase: ::protobuf::SingularField<::std::string::String>,
    pub accessModes: ::protobuf::RepeatedField<::std::string::String>,
    pub capacity: ::std::collections::HashMap<::std::string::String, super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity>,
    pub conditions: ::protobuf::RepeatedField<PersistentVolumeClaimCondition>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PersistentVolumeClaimStatus {
    fn default() -> &'a PersistentVolumeClaimStatus {
        <PersistentVolumeClaimStatus as ::protobuf::Message>::default_instance()
    }
}

impl PersistentVolumeClaimStatus {
    pub fn new() -> PersistentVolumeClaimStatus {
        ::std::default::Default::default()
    }

    // optional string phase = 1;


    pub fn get_phase(&self) -> &str {
        match self.phase.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_phase(&mut self) {
        self.phase.clear();
    }

    pub fn has_phase(&self) -> bool {
        self.phase.is_some()
    }

    // Param is passed by value, moved
    pub fn set_phase(&mut self, v: ::std::string::String) {
        self.phase = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_phase(&mut self) -> &mut ::std::string::String {
        if self.phase.is_none() {
            self.phase.set_default();
        }
        self.phase.as_mut().unwrap()
    }

    // Take field
    pub fn take_phase(&mut self) -> ::std::string::String {
        self.phase.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated string accessModes = 2;


    pub fn get_accessModes(&self) -> &[::std::string::String] {
        &self.accessModes
    }
    pub fn clear_accessModes(&mut self) {
        self.accessModes.clear();
    }

    // Param is passed by value, moved
    pub fn set_accessModes(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.accessModes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_accessModes(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.accessModes
    }

    // Take field
    pub fn take_accessModes(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.accessModes, ::protobuf::RepeatedField::new())
    }

    // repeated .k8s.io.api.core.v1.PersistentVolumeClaimStatus.CapacityEntry capacity = 3;


    pub fn get_capacity(&self) -> &::std::collections::HashMap<::std::string::String, super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity> {
        &self.capacity
    }
    pub fn clear_capacity(&mut self) {
        self.capacity.clear();
    }

    // Param is passed by value, moved
    pub fn set_capacity(&mut self, v: ::std::collections::HashMap<::std::string::String, super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity>) {
        self.capacity = v;
    }

    // Mutable pointer to the field.
    pub fn mut_capacity(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity> {
        &mut self.capacity
    }

    // Take field
    pub fn take_capacity(&mut self) -> ::std::collections::HashMap<::std::string::String, super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity> {
        ::std::mem::replace(&mut self.capacity, ::std::collections::HashMap::new())
    }

    // repeated .k8s.io.api.core.v1.PersistentVolumeClaimCondition conditions = 4;


    pub fn get_conditions(&self) -> &[PersistentVolumeClaimCondition] {
        &self.conditions
    }
    pub fn clear_conditions(&mut self) {
        self.conditions.clear();
    }

    // Param is passed by value, moved
    pub fn set_conditions(&mut self, v: ::protobuf::RepeatedField<PersistentVolumeClaimCondition>) {
        self.conditions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_conditions(&mut self) -> &mut ::protobuf::RepeatedField<PersistentVolumeClaimCondition> {
        &mut self.conditions
    }

    // Take field
    pub fn take_conditions(&mut self) -> ::protobuf::RepeatedField<PersistentVolumeClaimCondition> {
        ::std::mem::replace(&mut self.conditions, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PersistentVolumeClaimStatus {
    fn is_initialized(&self) -> bool {
        for v in &self.conditions {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.phase)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.accessModes)?;
                },
                3 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity>>(wire_type, is, &mut self.capacity)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.conditions)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.phase.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.accessModes {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity>>(3, &self.capacity);
        for value in &self.conditions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.phase.as_ref() {
            os.write_string(1, &v)?;
        }
        for v in &self.accessModes {
            os.write_string(2, &v)?;
        };
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity>>(3, &self.capacity, os)?;
        for v in &self.conditions {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PersistentVolumeClaimStatus {
        PersistentVolumeClaimStatus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "phase",
                |m: &PersistentVolumeClaimStatus| { &m.phase },
                |m: &mut PersistentVolumeClaimStatus| { &mut m.phase },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "accessModes",
                |m: &PersistentVolumeClaimStatus| { &m.accessModes },
                |m: &mut PersistentVolumeClaimStatus| { &mut m.accessModes },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity>>(
                "capacity",
                |m: &PersistentVolumeClaimStatus| { &m.capacity },
                |m: &mut PersistentVolumeClaimStatus| { &mut m.capacity },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PersistentVolumeClaimCondition>>(
                "conditions",
                |m: &PersistentVolumeClaimStatus| { &m.conditions },
                |m: &mut PersistentVolumeClaimStatus| { &mut m.conditions },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PersistentVolumeClaimStatus>(
                "PersistentVolumeClaimStatus",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PersistentVolumeClaimStatus {
        static instance: ::protobuf::rt::LazyV2<PersistentVolumeClaimStatus> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PersistentVolumeClaimStatus::new)
    }
}

impl ::protobuf::Clear for PersistentVolumeClaimStatus {
    fn clear(&mut self) {
        self.phase.clear();
        self.accessModes.clear();
        self.capacity.clear();
        self.conditions.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PersistentVolumeClaimStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PersistentVolumeClaimStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PersistentVolumeClaimTemplate {
    // message fields
    pub metadata: ::protobuf::SingularPtrField<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta>,
    pub spec: ::protobuf::SingularPtrField<PersistentVolumeClaimSpec>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PersistentVolumeClaimTemplate {
    fn default() -> &'a PersistentVolumeClaimTemplate {
        <PersistentVolumeClaimTemplate as ::protobuf::Message>::default_instance()
    }
}

impl PersistentVolumeClaimTemplate {
    pub fn new() -> PersistentVolumeClaimTemplate {
        ::std::default::Default::default()
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;


    pub fn get_metadata(&self) -> &super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta::new())
    }

    // optional .k8s.io.api.core.v1.PersistentVolumeClaimSpec spec = 2;


    pub fn get_spec(&self) -> &PersistentVolumeClaimSpec {
        self.spec.as_ref().unwrap_or_else(|| <PersistentVolumeClaimSpec as ::protobuf::Message>::default_instance())
    }
    pub fn clear_spec(&mut self) {
        self.spec.clear();
    }

    pub fn has_spec(&self) -> bool {
        self.spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spec(&mut self, v: PersistentVolumeClaimSpec) {
        self.spec = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spec(&mut self) -> &mut PersistentVolumeClaimSpec {
        if self.spec.is_none() {
            self.spec.set_default();
        }
        self.spec.as_mut().unwrap()
    }

    // Take field
    pub fn take_spec(&mut self) -> PersistentVolumeClaimSpec {
        self.spec.take().unwrap_or_else(|| PersistentVolumeClaimSpec::new())
    }
}

impl ::protobuf::Message for PersistentVolumeClaimTemplate {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.spec {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.spec)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.spec.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PersistentVolumeClaimTemplate {
        PersistentVolumeClaimTemplate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta>>(
                "metadata",
                |m: &PersistentVolumeClaimTemplate| { &m.metadata },
                |m: &mut PersistentVolumeClaimTemplate| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PersistentVolumeClaimSpec>>(
                "spec",
                |m: &PersistentVolumeClaimTemplate| { &m.spec },
                |m: &mut PersistentVolumeClaimTemplate| { &mut m.spec },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PersistentVolumeClaimTemplate>(
                "PersistentVolumeClaimTemplate",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PersistentVolumeClaimTemplate {
        static instance: ::protobuf::rt::LazyV2<PersistentVolumeClaimTemplate> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PersistentVolumeClaimTemplate::new)
    }
}

impl ::protobuf::Clear for PersistentVolumeClaimTemplate {
    fn clear(&mut self) {
        self.metadata.clear();
        self.spec.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PersistentVolumeClaimTemplate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PersistentVolumeClaimTemplate {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PersistentVolumeClaimVolumeSource {
    // message fields
    claimName: ::protobuf::SingularField<::std::string::String>,
    readOnly: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PersistentVolumeClaimVolumeSource {
    fn default() -> &'a PersistentVolumeClaimVolumeSource {
        <PersistentVolumeClaimVolumeSource as ::protobuf::Message>::default_instance()
    }
}

impl PersistentVolumeClaimVolumeSource {
    pub fn new() -> PersistentVolumeClaimVolumeSource {
        ::std::default::Default::default()
    }

    // optional string claimName = 1;


    pub fn get_claimName(&self) -> &str {
        match self.claimName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_claimName(&mut self) {
        self.claimName.clear();
    }

    pub fn has_claimName(&self) -> bool {
        self.claimName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_claimName(&mut self, v: ::std::string::String) {
        self.claimName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_claimName(&mut self) -> &mut ::std::string::String {
        if self.claimName.is_none() {
            self.claimName.set_default();
        }
        self.claimName.as_mut().unwrap()
    }

    // Take field
    pub fn take_claimName(&mut self) -> ::std::string::String {
        self.claimName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool readOnly = 2;


    pub fn get_readOnly(&self) -> bool {
        self.readOnly.unwrap_or(false)
    }
    pub fn clear_readOnly(&mut self) {
        self.readOnly = ::std::option::Option::None;
    }

    pub fn has_readOnly(&self) -> bool {
        self.readOnly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readOnly(&mut self, v: bool) {
        self.readOnly = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for PersistentVolumeClaimVolumeSource {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.claimName)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.readOnly = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.claimName.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.readOnly {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.claimName.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.readOnly {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PersistentVolumeClaimVolumeSource {
        PersistentVolumeClaimVolumeSource::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "claimName",
                |m: &PersistentVolumeClaimVolumeSource| { &m.claimName },
                |m: &mut PersistentVolumeClaimVolumeSource| { &mut m.claimName },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "readOnly",
                |m: &PersistentVolumeClaimVolumeSource| { &m.readOnly },
                |m: &mut PersistentVolumeClaimVolumeSource| { &mut m.readOnly },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PersistentVolumeClaimVolumeSource>(
                "PersistentVolumeClaimVolumeSource",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PersistentVolumeClaimVolumeSource {
        static instance: ::protobuf::rt::LazyV2<PersistentVolumeClaimVolumeSource> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PersistentVolumeClaimVolumeSource::new)
    }
}

impl ::protobuf::Clear for PersistentVolumeClaimVolumeSource {
    fn clear(&mut self) {
        self.claimName.clear();
        self.readOnly = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PersistentVolumeClaimVolumeSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PersistentVolumeClaimVolumeSource {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PersistentVolumeList {
    // message fields
    pub metadata: ::protobuf::SingularPtrField<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta>,
    pub items: ::protobuf::RepeatedField<PersistentVolume>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PersistentVolumeList {
    fn default() -> &'a PersistentVolumeList {
        <PersistentVolumeList as ::protobuf::Message>::default_instance()
    }
}

impl PersistentVolumeList {
    pub fn new() -> PersistentVolumeList {
        ::std::default::Default::default()
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;


    pub fn get_metadata(&self) -> &super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta {
        self.metadata.take().unwrap_or_else(|| super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta::new())
    }

    // repeated .k8s.io.api.core.v1.PersistentVolume items = 2;


    pub fn get_items(&self) -> &[PersistentVolume] {
        &self.items
    }
    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::protobuf::RepeatedField<PersistentVolume>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::protobuf::RepeatedField<PersistentVolume> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::protobuf::RepeatedField<PersistentVolume> {
        ::std::mem::replace(&mut self.items, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PersistentVolumeList {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.items {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.items)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.items {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PersistentVolumeList {
        PersistentVolumeList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta>>(
                "metadata",
                |m: &PersistentVolumeList| { &m.metadata },
                |m: &mut PersistentVolumeList| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PersistentVolume>>(
                "items",
                |m: &PersistentVolumeList| { &m.items },
                |m: &mut PersistentVolumeList| { &mut m.items },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PersistentVolumeList>(
                "PersistentVolumeList",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PersistentVolumeList {
        static instance: ::protobuf::rt::LazyV2<PersistentVolumeList> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PersistentVolumeList::new)
    }
}

impl ::protobuf::Clear for PersistentVolumeList {
    fn clear(&mut self) {
        self.metadata.clear();
        self.items.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PersistentVolumeList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PersistentVolumeList {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PersistentVolumeSource {
    // message fields
    pub gcePersistentDisk: ::protobuf::SingularPtrField<GCEPersistentDiskVolumeSource>,
    pub awsElasticBlockStore: ::protobuf::SingularPtrField<AWSElasticBlockStoreVolumeSource>,
    pub hostPath: ::protobuf::SingularPtrField<HostPathVolumeSource>,
    pub glusterfs: ::protobuf::SingularPtrField<GlusterfsPersistentVolumeSource>,
    pub nfs: ::protobuf::SingularPtrField<NFSVolumeSource>,
    pub rbd: ::protobuf::SingularPtrField<RBDPersistentVolumeSource>,
    pub iscsi: ::protobuf::SingularPtrField<ISCSIPersistentVolumeSource>,
    pub cinder: ::protobuf::SingularPtrField<CinderPersistentVolumeSource>,
    pub cephfs: ::protobuf::SingularPtrField<CephFSPersistentVolumeSource>,
    pub fc: ::protobuf::SingularPtrField<FCVolumeSource>,
    pub flocker: ::protobuf::SingularPtrField<FlockerVolumeSource>,
    pub flexVolume: ::protobuf::SingularPtrField<FlexPersistentVolumeSource>,
    pub azureFile: ::protobuf::SingularPtrField<AzureFilePersistentVolumeSource>,
    pub vsphereVolume: ::protobuf::SingularPtrField<VsphereVirtualDiskVolumeSource>,
    pub quobyte: ::protobuf::SingularPtrField<QuobyteVolumeSource>,
    pub azureDisk: ::protobuf::SingularPtrField<AzureDiskVolumeSource>,
    pub photonPersistentDisk: ::protobuf::SingularPtrField<PhotonPersistentDiskVolumeSource>,
    pub portworxVolume: ::protobuf::SingularPtrField<PortworxVolumeSource>,
    pub scaleIO: ::protobuf::SingularPtrField<ScaleIOPersistentVolumeSource>,
    pub local: ::protobuf::SingularPtrField<LocalVolumeSource>,
    pub storageos: ::protobuf::SingularPtrField<StorageOSPersistentVolumeSource>,
    pub csi: ::protobuf::SingularPtrField<CSIPersistentVolumeSource>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PersistentVolumeSource {
    fn default() -> &'a PersistentVolumeSource {
        <PersistentVolumeSource as ::protobuf::Message>::default_instance()
    }
}

impl PersistentVolumeSource {
    pub fn new() -> PersistentVolumeSource {
        ::std::default::Default::default()
    }

    // optional .k8s.io.api.core.v1.GCEPersistentDiskVolumeSource gcePersistentDisk = 1;


    pub fn get_gcePersistentDisk(&self) -> &GCEPersistentDiskVolumeSource {
        self.gcePersistentDisk.as_ref().unwrap_or_else(|| <GCEPersistentDiskVolumeSource as ::protobuf::Message>::default_instance())
    }
    pub fn clear_gcePersistentDisk(&mut self) {
        self.gcePersistentDisk.clear();
    }

    pub fn has_gcePersistentDisk(&self) -> bool {
        self.gcePersistentDisk.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gcePersistentDisk(&mut self, v: GCEPersistentDiskVolumeSource) {
        self.gcePersistentDisk = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gcePersistentDisk(&mut self) -> &mut GCEPersistentDiskVolumeSource {
        if self.gcePersistentDisk.is_none() {
            self.gcePersistentDisk.set_default();
        }
        self.gcePersistentDisk.as_mut().unwrap()
    }

    // Take field
    pub fn take_gcePersistentDisk(&mut self) -> GCEPersistentDiskVolumeSource {
        self.gcePersistentDisk.take().unwrap_or_else(|| GCEPersistentDiskVolumeSource::new())
    }

    // optional .k8s.io.api.core.v1.AWSElasticBlockStoreVolumeSource awsElasticBlockStore = 2;


    pub fn get_awsElasticBlockStore(&self) -> &AWSElasticBlockStoreVolumeSource {
        self.awsElasticBlockStore.as_ref().unwrap_or_else(|| <AWSElasticBlockStoreVolumeSource as ::protobuf::Message>::default_instance())
    }
    pub fn clear_awsElasticBlockStore(&mut self) {
        self.awsElasticBlockStore.clear();
    }

    pub fn has_awsElasticBlockStore(&self) -> bool {
        self.awsElasticBlockStore.is_some()
    }

    // Param is passed by value, moved
    pub fn set_awsElasticBlockStore(&mut self, v: AWSElasticBlockStoreVolumeSource) {
        self.awsElasticBlockStore = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_awsElasticBlockStore(&mut self) -> &mut AWSElasticBlockStoreVolumeSource {
        if self.awsElasticBlockStore.is_none() {
            self.awsElasticBlockStore.set_default();
        }
        self.awsElasticBlockStore.as_mut().unwrap()
    }

    // Take field
    pub fn take_awsElasticBlockStore(&mut self) -> AWSElasticBlockStoreVolumeSource {
        self.awsElasticBlockStore.take().unwrap_or_else(|| AWSElasticBlockStoreVolumeSource::new())
    }

    // optional .k8s.io.api.core.v1.HostPathVolumeSource hostPath = 3;


    pub fn get_hostPath(&self) -> &HostPathVolumeSource {
        self.hostPath.as_ref().unwrap_or_else(|| <HostPathVolumeSource as ::protobuf::Message>::default_instance())
    }
    pub fn clear_hostPath(&mut self) {
        self.hostPath.clear();
    }

    pub fn has_hostPath(&self) -> bool {
        self.hostPath.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hostPath(&mut self, v: HostPathVolumeSource) {
        self.hostPath = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hostPath(&mut self) -> &mut HostPathVolumeSource {
        if self.hostPath.is_none() {
            self.hostPath.set_default();
        }
        self.hostPath.as_mut().unwrap()
    }

    // Take field
    pub fn take_hostPath(&mut self) -> HostPathVolumeSource {
        self.hostPath.take().unwrap_or_else(|| HostPathVolumeSource::new())
    }

    // optional .k8s.io.api.core.v1.GlusterfsPersistentVolumeSource glusterfs = 4;


    pub fn get_glusterfs(&self) -> &GlusterfsPersistentVolumeSource {
        self.glusterfs.as_ref().unwrap_or_else(|| <GlusterfsPersistentVolumeSource as ::protobuf::Message>::default_instance())
    }
    pub fn clear_glusterfs(&mut self) {
        self.glusterfs.clear();
    }

    pub fn has_glusterfs(&self) -> bool {
        self.glusterfs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_glusterfs(&mut self, v: GlusterfsPersistentVolumeSource) {
        self.glusterfs = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_glusterfs(&mut self) -> &mut GlusterfsPersistentVolumeSource {
        if self.glusterfs.is_none() {
            self.glusterfs.set_default();
        }
        self.glusterfs.as_mut().unwrap()
    }

    // Take field
    pub fn take_glusterfs(&mut self) -> GlusterfsPersistentVolumeSource {
        self.glusterfs.take().unwrap_or_else(|| GlusterfsPersistentVolumeSource::new())
    }

    // optional .k8s.io.api.core.v1.NFSVolumeSource nfs = 5;


    pub fn get_nfs(&self) -> &NFSVolumeSource {
        self.nfs.as_ref().unwrap_or_else(|| <NFSVolumeSource as ::protobuf::Message>::default_instance())
    }
    pub fn clear_nfs(&mut self) {
        self.nfs.clear();
    }

    pub fn has_nfs(&self) -> bool {
        self.nfs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nfs(&mut self, v: NFSVolumeSource) {
        self.nfs = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nfs(&mut self) -> &mut NFSVolumeSource {
        if self.nfs.is_none() {
            self.nfs.set_default();
        }
        self.nfs.as_mut().unwrap()
    }

    // Take field
    pub fn take_nfs(&mut self) -> NFSVolumeSource {
        self.nfs.take().unwrap_or_else(|| NFSVolumeSource::new())
    }

    // optional .k8s.io.api.core.v1.RBDPersistentVolumeSource rbd = 6;


    pub fn get_rbd(&self) -> &RBDPersistentVolumeSource {
        self.rbd.as_ref().unwrap_or_else(|| <RBDPersistentVolumeSource as ::protobuf::Message>::default_instance())
    }
    pub fn clear_rbd(&mut self) {
        self.rbd.clear();
    }

    pub fn has_rbd(&self) -> bool {
        self.rbd.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rbd(&mut self, v: RBDPersistentVolumeSource) {
        self.rbd = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rbd(&mut self) -> &mut RBDPersistentVolumeSource {
        if self.rbd.is_none() {
            self.rbd.set_default();
        }
        self.rbd.as_mut().unwrap()
    }

    // Take field
    pub fn take_rbd(&mut self) -> RBDPersistentVolumeSource {
        self.rbd.take().unwrap_or_else(|| RBDPersistentVolumeSource::new())
    }

    // optional .k8s.io.api.core.v1.ISCSIPersistentVolumeSource iscsi = 7;


    pub fn get_iscsi(&self) -> &ISCSIPersistentVolumeSource {
        self.iscsi.as_ref().unwrap_or_else(|| <ISCSIPersistentVolumeSource as ::protobuf::Message>::default_instance())
    }
    pub fn clear_iscsi(&mut self) {
        self.iscsi.clear();
    }

    pub fn has_iscsi(&self) -> bool {
        self.iscsi.is_some()
    }

    // Param is passed by value, moved
    pub fn set_iscsi(&mut self, v: ISCSIPersistentVolumeSource) {
        self.iscsi = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_iscsi(&mut self) -> &mut ISCSIPersistentVolumeSource {
        if self.iscsi.is_none() {
            self.iscsi.set_default();
        }
        self.iscsi.as_mut().unwrap()
    }

    // Take field
    pub fn take_iscsi(&mut self) -> ISCSIPersistentVolumeSource {
        self.iscsi.take().unwrap_or_else(|| ISCSIPersistentVolumeSource::new())
    }

    // optional .k8s.io.api.core.v1.CinderPersistentVolumeSource cinder = 8;


    pub fn get_cinder(&self) -> &CinderPersistentVolumeSource {
        self.cinder.as_ref().unwrap_or_else(|| <CinderPersistentVolumeSource as ::protobuf::Message>::default_instance())
    }
    pub fn clear_cinder(&mut self) {
        self.cinder.clear();
    }

    pub fn has_cinder(&self) -> bool {
        self.cinder.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cinder(&mut self, v: CinderPersistentVolumeSource) {
        self.cinder = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cinder(&mut self) -> &mut CinderPersistentVolumeSource {
        if self.cinder.is_none() {
            self.cinder.set_default();
        }
        self.cinder.as_mut().unwrap()
    }

    // Take field
    pub fn take_cinder(&mut self) -> CinderPersistentVolumeSource {
        self.cinder.take().unwrap_or_else(|| CinderPersistentVolumeSource::new())
    }

    // optional .k8s.io.api.core.v1.CephFSPersistentVolumeSource cephfs = 9;


    pub fn get_cephfs(&self) -> &CephFSPersistentVolumeSource {
        self.cephfs.as_ref().unwrap_or_else(|| <CephFSPersistentVolumeSource as ::protobuf::Message>::default_instance())
    }
    pub fn clear_cephfs(&mut self) {
        self.cephfs.clear();
    }

    pub fn has_cephfs(&self) -> bool {
        self.cephfs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cephfs(&mut self, v: CephFSPersistentVolumeSource) {
        self.cephfs = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cephfs(&mut self) -> &mut CephFSPersistentVolumeSource {
        if self.cephfs.is_none() {
            self.cephfs.set_default();
        }
        self.cephfs.as_mut().unwrap()
    }

    // Take field
    pub fn take_cephfs(&mut self) -> CephFSPersistentVolumeSource {
        self.cephfs.take().unwrap_or_else(|| CephFSPersistentVolumeSource::new())
    }

    // optional .k8s.io.api.core.v1.FCVolumeSource fc = 10;


    pub fn get_fc(&self) -> &FCVolumeSource {
        self.fc.as_ref().unwrap_or_else(|| <FCVolumeSource as ::protobuf::Message>::default_instance())
    }
    pub fn clear_fc(&mut self) {
        self.fc.clear();
    }

    pub fn has_fc(&self) -> bool {
        self.fc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fc(&mut self, v: FCVolumeSource) {
        self.fc = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fc(&mut self) -> &mut FCVolumeSource {
        if self.fc.is_none() {
            self.fc.set_default();
        }
        self.fc.as_mut().unwrap()
    }

    // Take field
    pub fn take_fc(&mut self) -> FCVolumeSource {
        self.fc.take().unwrap_or_else(|| FCVolumeSource::new())
    }

    // optional .k8s.io.api.core.v1.FlockerVolumeSource flocker = 11;


    pub fn get_flocker(&self) -> &FlockerVolumeSource {
        self.flocker.as_ref().unwrap_or_else(|| <FlockerVolumeSource as ::protobuf::Message>::default_instance())
    }
    pub fn clear_flocker(&mut self) {
        self.flocker.clear();
    }

    pub fn has_flocker(&self) -> bool {
        self.flocker.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flocker(&mut self, v: FlockerVolumeSource) {
        self.flocker = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_flocker(&mut self) -> &mut FlockerVolumeSource {
        if self.flocker.is_none() {
            self.flocker.set_default();
        }
        self.flocker.as_mut().unwrap()
    }

    // Take field
    pub fn take_flocker(&mut self) -> FlockerVolumeSource {
        self.flocker.take().unwrap_or_else(|| FlockerVolumeSource::new())
    }

    // optional .k8s.io.api.core.v1.FlexPersistentVolumeSource flexVolume = 12;


    pub fn get_flexVolume(&self) -> &FlexPersistentVolumeSource {
        self.flexVolume.as_ref().unwrap_or_else(|| <FlexPersistentVolumeSource as ::protobuf::Message>::default_instance())
    }
    pub fn clear_flexVolume(&mut self) {
        self.flexVolume.clear();
    }

    pub fn has_flexVolume(&self) -> bool {
        self.flexVolume.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flexVolume(&mut self, v: FlexPersistentVolumeSource) {
        self.flexVolume = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_flexVolume(&mut self) -> &mut FlexPersistentVolumeSource {
        if self.flexVolume.is_none() {
            self.flexVolume.set_default();
        }
        self.flexVolume.as_mut().unwrap()
    }

    // Take field
    pub fn take_flexVolume(&mut self) -> FlexPersistentVolumeSource {
        self.flexVolume.take().unwrap_or_else(|| FlexPersistentVolumeSource::new())
    }

    // optional .k8s.io.api.core.v1.AzureFilePersistentVolumeSource azureFile = 13;


    pub fn get_azureFile(&self) -> &AzureFilePersistentVolumeSource {
        self.azureFile.as_ref().unwrap_or_else(|| <AzureFilePersistentVolumeSource as ::protobuf::Message>::default_instance())
    }
    pub fn clear_azureFile(&mut self) {
        self.azureFile.clear();
    }

    pub fn has_azureFile(&self) -> bool {
        self.azureFile.is_some()
    }

    // Param is passed by value, moved
    pub fn set_azureFile(&mut self, v: AzureFilePersistentVolumeSource) {
        self.azureFile = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_azureFile(&mut self) -> &mut AzureFilePersistentVolumeSource {
        if self.azureFile.is_none() {
            self.azureFile.set_default();
        }
        self.azureFile.as_mut().unwrap()
    }

    // Take field
    pub fn take_azureFile(&mut self) -> AzureFilePersistentVolumeSource {
        self.azureFile.take().unwrap_or_else(|| AzureFilePersistentVolumeSource::new())
    }

    // optional .k8s.io.api.core.v1.VsphereVirtualDiskVolumeSource vsphereVolume = 14;


    pub fn get_vsphereVolume(&self) -> &VsphereVirtualDiskVolumeSource {
        self.vsphereVolume.as_ref().unwrap_or_else(|| <VsphereVirtualDiskVolumeSource as ::protobuf::Message>::default_instance())
    }
    pub fn clear_vsphereVolume(&mut self) {
        self.vsphereVolume.clear();
    }

    pub fn has_vsphereVolume(&self) -> bool {
        self.vsphereVolume.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vsphereVolume(&mut self, v: VsphereVirtualDiskVolumeSource) {
        self.vsphereVolume = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vsphereVolume(&mut self) -> &mut VsphereVirtualDiskVolumeSource {
        if self.vsphereVolume.is_none() {
            self.vsphereVolume.set_default();
        }
        self.vsphereVolume.as_mut().unwrap()
    }

    // Take field
    pub fn take_vsphereVolume(&mut self) -> VsphereVirtualDiskVolumeSource {
        self.vsphereVolume.take().unwrap_or_else(|| VsphereVirtualDiskVolumeSource::new())
    }

    // optional .k8s.io.api.core.v1.QuobyteVolumeSource quobyte = 15;


    pub fn get_quobyte(&self) -> &QuobyteVolumeSource {
        self.quobyte.as_ref().unwrap_or_else(|| <QuobyteVolumeSource as ::protobuf::Message>::default_instance())
    }
    pub fn clear_quobyte(&mut self) {
        self.quobyte.clear();
    }

    pub fn has_quobyte(&self) -> bool {
        self.quobyte.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quobyte(&mut self, v: QuobyteVolumeSource) {
        self.quobyte = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_quobyte(&mut self) -> &mut QuobyteVolumeSource {
        if self.quobyte.is_none() {
            self.quobyte.set_default();
        }
        self.quobyte.as_mut().unwrap()
    }

    // Take field
    pub fn take_quobyte(&mut self) -> QuobyteVolumeSource {
        self.quobyte.take().unwrap_or_else(|| QuobyteVolumeSource::new())
    }

    // optional .k8s.io.api.core.v1.AzureDiskVolumeSource azureDisk = 16;


    pub fn get_azureDisk(&self) -> &AzureDiskVolumeSource {
        self.azureDisk.as_ref().unwrap_or_else(|| <AzureDiskVolumeSource as ::protobuf::Message>::default_instance())
    }
    pub fn clear_azureDisk(&mut self) {
        self.azureDisk.clear();
    }

    pub fn has_azureDisk(&self) -> bool {
        self.azureDisk.is_some()
    }

    // Param is passed by value, moved
    pub fn set_azureDisk(&mut self, v: AzureDiskVolumeSource) {
        self.azureDisk = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_azureDisk(&mut self) -> &mut AzureDiskVolumeSource {
        if self.azureDisk.is_none() {
            self.azureDisk.set_default();
        }
        self.azureDisk.as_mut().unwrap()
    }

    // Take field
    pub fn take_azureDisk(&mut self) -> AzureDiskVolumeSource {
        self.azureDisk.take().unwrap_or_else(|| AzureDiskVolumeSource::new())
    }

    // optional .k8s.io.api.core.v1.PhotonPersistentDiskVolumeSource photonPersistentDisk = 17;


    pub fn get_photonPersistentDisk(&self) -> &PhotonPersistentDiskVolumeSource {
        self.photonPersistentDisk.as_ref().unwrap_or_else(|| <PhotonPersistentDiskVolumeSource as ::protobuf::Message>::default_instance())
    }
    pub fn clear_photonPersistentDisk(&mut self) {
        self.photonPersistentDisk.clear();
    }

    pub fn has_photonPersistentDisk(&self) -> bool {
        self.photonPersistentDisk.is_some()
    }

    // Param is passed by value, moved
    pub fn set_photonPersistentDisk(&mut self, v: PhotonPersistentDiskVolumeSource) {
        self.photonPersistentDisk = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_photonPersistentDisk(&mut self) -> &mut PhotonPersistentDiskVolumeSource {
        if self.photonPersistentDisk.is_none() {
            self.photonPersistentDisk.set_default();
        }
        self.photonPersistentDisk.as_mut().unwrap()
    }

    // Take field
    pub fn take_photonPersistentDisk(&mut self) -> PhotonPersistentDiskVolumeSource {
        self.photonPersistentDisk.take().unwrap_or_else(|| PhotonPersistentDiskVolumeSource::new())
    }

    // optional .k8s.io.api.core.v1.PortworxVolumeSource portworxVolume = 18;


    pub fn get_portworxVolume(&self) -> &PortworxVolumeSource {
        self.portworxVolume.as_ref().unwrap_or_else(|| <PortworxVolumeSource as ::protobuf::Message>::default_instance())
    }
    pub fn clear_portworxVolume(&mut self) {
        self.portworxVolume.clear();
    }

    pub fn has_portworxVolume(&self) -> bool {
        self.portworxVolume.is_some()
    }

    // Param is passed by value, moved
    pub fn set_portworxVolume(&mut self, v: PortworxVolumeSource) {
        self.portworxVolume = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_portworxVolume(&mut self) -> &mut PortworxVolumeSource {
        if self.portworxVolume.is_none() {
            self.portworxVolume.set_default();
        }
        self.portworxVolume.as_mut().unwrap()
    }

    // Take field
    pub fn take_portworxVolume(&mut self) -> PortworxVolumeSource {
        self.portworxVolume.take().unwrap_or_else(|| PortworxVolumeSource::new())
    }

    // optional .k8s.io.api.core.v1.ScaleIOPersistentVolumeSource scaleIO = 19;


    pub fn get_scaleIO(&self) -> &ScaleIOPersistentVolumeSource {
        self.scaleIO.as_ref().unwrap_or_else(|| <ScaleIOPersistentVolumeSource as ::protobuf::Message>::default_instance())
    }
    pub fn clear_scaleIO(&mut self) {
        self.scaleIO.clear();
    }

    pub fn has_scaleIO(&self) -> bool {
        self.scaleIO.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scaleIO(&mut self, v: ScaleIOPersistentVolumeSource) {
        self.scaleIO = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_scaleIO(&mut self) -> &mut ScaleIOPersistentVolumeSource {
        if self.scaleIO.is_none() {
            self.scaleIO.set_default();
        }
        self.scaleIO.as_mut().unwrap()
    }

    // Take field
    pub fn take_scaleIO(&mut self) -> ScaleIOPersistentVolumeSource {
        self.scaleIO.take().unwrap_or_else(|| ScaleIOPersistentVolumeSource::new())
    }

    // optional .k8s.io.api.core.v1.LocalVolumeSource local = 20;


    pub fn get_local(&self) -> &LocalVolumeSource {
        self.local.as_ref().unwrap_or_else(|| <LocalVolumeSource as ::protobuf::Message>::default_instance())
    }
    pub fn clear_local(&mut self) {
        self.local.clear();
    }

    pub fn has_local(&self) -> bool {
        self.local.is_some()
    }

    // Param is passed by value, moved
    pub fn set_local(&mut self, v: LocalVolumeSource) {
        self.local = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_local(&mut self) -> &mut LocalVolumeSource {
        if self.local.is_none() {
            self.local.set_default();
        }
        self.local.as_mut().unwrap()
    }

    // Take field
    pub fn take_local(&mut self) -> LocalVolumeSource {
        self.local.take().unwrap_or_else(|| LocalVolumeSource::new())
    }

    // optional .k8s.io.api.core.v1.StorageOSPersistentVolumeSource storageos = 21;


    pub fn get_storageos(&self) -> &StorageOSPersistentVolumeSource {
        self.storageos.as_ref().unwrap_or_else(|| <StorageOSPersistentVolumeSource as ::protobuf::Message>::default_instance())
    }
    pub fn clear_storageos(&mut self) {
        self.storageos.clear();
    }

    pub fn has_storageos(&self) -> bool {
        self.storageos.is_some()
    }

    // Param is passed by value, moved
    pub fn set_storageos(&mut self, v: StorageOSPersistentVolumeSource) {
        self.storageos = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_storageos(&mut self) -> &mut StorageOSPersistentVolumeSource {
        if self.storageos.is_none() {
            self.storageos.set_default();
        }
        self.storageos.as_mut().unwrap()
    }

    // Take field
    pub fn take_storageos(&mut self) -> StorageOSPersistentVolumeSource {
        self.storageos.take().unwrap_or_else(|| StorageOSPersistentVolumeSource::new())
    }

    // optional .k8s.io.api.core.v1.CSIPersistentVolumeSource csi = 22;


    pub fn get_csi(&self) -> &CSIPersistentVolumeSource {
        self.csi.as_ref().unwrap_or_else(|| <CSIPersistentVolumeSource as ::protobuf::Message>::default_instance())
    }
    pub fn clear_csi(&mut self) {
        self.csi.clear();
    }

    pub fn has_csi(&self) -> bool {
        self.csi.is_some()
    }

    // Param is passed by value, moved
    pub fn set_csi(&mut self, v: CSIPersistentVolumeSource) {
        self.csi = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_csi(&mut self) -> &mut CSIPersistentVolumeSource {
        if self.csi.is_none() {
            self.csi.set_default();
        }
        self.csi.as_mut().unwrap()
    }

    // Take field
    pub fn take_csi(&mut self) -> CSIPersistentVolumeSource {
        self.csi.take().unwrap_or_else(|| CSIPersistentVolumeSource::new())
    }
}

impl ::protobuf::Message for PersistentVolumeSource {
    fn is_initialized(&self) -> bool {
        for v in &self.gcePersistentDisk {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.awsElasticBlockStore {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.hostPath {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.glusterfs {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.nfs {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.rbd {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.iscsi {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.cinder {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.cephfs {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.fc {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.flocker {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.flexVolume {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.azureFile {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.vsphereVolume {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.quobyte {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.azureDisk {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.photonPersistentDisk {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.portworxVolume {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.scaleIO {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.local {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.storageos {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.csi {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.gcePersistentDisk)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.awsElasticBlockStore)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.hostPath)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.glusterfs)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.nfs)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.rbd)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.iscsi)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.cinder)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.cephfs)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.fc)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.flocker)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.flexVolume)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.azureFile)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.vsphereVolume)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.quobyte)?;
                },
                16 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.azureDisk)?;
                },
                17 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.photonPersistentDisk)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.portworxVolume)?;
                },
                19 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.scaleIO)?;
                },
                20 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.local)?;
                },
                21 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.storageos)?;
                },
                22 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.csi)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.gcePersistentDisk.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.awsElasticBlockStore.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.hostPath.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.glusterfs.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.nfs.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.rbd.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.iscsi.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.cinder.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.cephfs.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.fc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.flocker.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.flexVolume.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.azureFile.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.vsphereVolume.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.quobyte.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.azureDisk.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.photonPersistentDisk.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.portworxVolume.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.scaleIO.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.local.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.storageos.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.csi.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.gcePersistentDisk.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.awsElasticBlockStore.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.hostPath.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.glusterfs.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.nfs.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.rbd.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.iscsi.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.cinder.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.cephfs.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.fc.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.flocker.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.flexVolume.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.azureFile.as_ref() {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.vsphereVolume.as_ref() {
            os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.quobyte.as_ref() {
            os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.azureDisk.as_ref() {
            os.write_tag(16, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.photonPersistentDisk.as_ref() {
            os.write_tag(17, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.portworxVolume.as_ref() {
            os.write_tag(18, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.scaleIO.as_ref() {
            os.write_tag(19, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.local.as_ref() {
            os.write_tag(20, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.storageos.as_ref() {
            os.write_tag(21, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.csi.as_ref() {
            os.write_tag(22, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PersistentVolumeSource {
        PersistentVolumeSource::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GCEPersistentDiskVolumeSource>>(
                "gcePersistentDisk",
                |m: &PersistentVolumeSource| { &m.gcePersistentDisk },
                |m: &mut PersistentVolumeSource| { &mut m.gcePersistentDisk },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AWSElasticBlockStoreVolumeSource>>(
                "awsElasticBlockStore",
                |m: &PersistentVolumeSource| { &m.awsElasticBlockStore },
                |m: &mut PersistentVolumeSource| { &mut m.awsElasticBlockStore },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<HostPathVolumeSource>>(
                "hostPath",
                |m: &PersistentVolumeSource| { &m.hostPath },
                |m: &mut PersistentVolumeSource| { &mut m.hostPath },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GlusterfsPersistentVolumeSource>>(
                "glusterfs",
                |m: &PersistentVolumeSource| { &m.glusterfs },
                |m: &mut PersistentVolumeSource| { &mut m.glusterfs },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NFSVolumeSource>>(
                "nfs",
                |m: &PersistentVolumeSource| { &m.nfs },
                |m: &mut PersistentVolumeSource| { &mut m.nfs },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RBDPersistentVolumeSource>>(
                "rbd",
                |m: &PersistentVolumeSource| { &m.rbd },
                |m: &mut PersistentVolumeSource| { &mut m.rbd },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ISCSIPersistentVolumeSource>>(
                "iscsi",
                |m: &PersistentVolumeSource| { &m.iscsi },
                |m: &mut PersistentVolumeSource| { &mut m.iscsi },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CinderPersistentVolumeSource>>(
                "cinder",
                |m: &PersistentVolumeSource| { &m.cinder },
                |m: &mut PersistentVolumeSource| { &mut m.cinder },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CephFSPersistentVolumeSource>>(
                "cephfs",
                |m: &PersistentVolumeSource| { &m.cephfs },
                |m: &mut PersistentVolumeSource| { &mut m.cephfs },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FCVolumeSource>>(
                "fc",
                |m: &PersistentVolumeSource| { &m.fc },
                |m: &mut PersistentVolumeSource| { &mut m.fc },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FlockerVolumeSource>>(
                "flocker",
                |m: &PersistentVolumeSource| { &m.flocker },
                |m: &mut PersistentVolumeSource| { &mut m.flocker },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FlexPersistentVolumeSource>>(
                "flexVolume",
                |m: &PersistentVolumeSource| { &m.flexVolume },
                |m: &mut PersistentVolumeSource| { &mut m.flexVolume },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AzureFilePersistentVolumeSource>>(
                "azureFile",
                |m: &PersistentVolumeSource| { &m.azureFile },
                |m: &mut PersistentVolumeSource| { &mut m.azureFile },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<VsphereVirtualDiskVolumeSource>>(
                "vsphereVolume",
                |m: &PersistentVolumeSource| { &m.vsphereVolume },
                |m: &mut PersistentVolumeSource| { &mut m.vsphereVolume },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<QuobyteVolumeSource>>(
                "quobyte",
                |m: &PersistentVolumeSource| { &m.quobyte },
                |m: &mut PersistentVolumeSource| { &mut m.quobyte },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AzureDiskVolumeSource>>(
                "azureDisk",
                |m: &PersistentVolumeSource| { &m.azureDisk },
                |m: &mut PersistentVolumeSource| { &mut m.azureDisk },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PhotonPersistentDiskVolumeSource>>(
                "photonPersistentDisk",
                |m: &PersistentVolumeSource| { &m.photonPersistentDisk },
                |m: &mut PersistentVolumeSource| { &mut m.photonPersistentDisk },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PortworxVolumeSource>>(
                "portworxVolume",
                |m: &PersistentVolumeSource| { &m.portworxVolume },
                |m: &mut PersistentVolumeSource| { &mut m.portworxVolume },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ScaleIOPersistentVolumeSource>>(
                "scaleIO",
                |m: &PersistentVolumeSource| { &m.scaleIO },
                |m: &mut PersistentVolumeSource| { &mut m.scaleIO },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LocalVolumeSource>>(
                "local",
                |m: &PersistentVolumeSource| { &m.local },
                |m: &mut PersistentVolumeSource| { &mut m.local },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StorageOSPersistentVolumeSource>>(
                "storageos",
                |m: &PersistentVolumeSource| { &m.storageos },
                |m: &mut PersistentVolumeSource| { &mut m.storageos },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CSIPersistentVolumeSource>>(
                "csi",
                |m: &PersistentVolumeSource| { &m.csi },
                |m: &mut PersistentVolumeSource| { &mut m.csi },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PersistentVolumeSource>(
                "PersistentVolumeSource",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PersistentVolumeSource {
        static instance: ::protobuf::rt::LazyV2<PersistentVolumeSource> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PersistentVolumeSource::new)
    }
}

impl ::protobuf::Clear for PersistentVolumeSource {
    fn clear(&mut self) {
        self.gcePersistentDisk.clear();
        self.awsElasticBlockStore.clear();
        self.hostPath.clear();
        self.glusterfs.clear();
        self.nfs.clear();
        self.rbd.clear();
        self.iscsi.clear();
        self.cinder.clear();
        self.cephfs.clear();
        self.fc.clear();
        self.flocker.clear();
        self.flexVolume.clear();
        self.azureFile.clear();
        self.vsphereVolume.clear();
        self.quobyte.clear();
        self.azureDisk.clear();
        self.photonPersistentDisk.clear();
        self.portworxVolume.clear();
        self.scaleIO.clear();
        self.local.clear();
        self.storageos.clear();
        self.csi.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PersistentVolumeSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PersistentVolumeSource {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PersistentVolumeSpec {
    // message fields
    pub capacity: ::std::collections::HashMap<::std::string::String, super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity>,
    pub persistentVolumeSource: ::protobuf::SingularPtrField<PersistentVolumeSource>,
    pub accessModes: ::protobuf::RepeatedField<::std::string::String>,
    pub claimRef: ::protobuf::SingularPtrField<ObjectReference>,
    persistentVolumeReclaimPolicy: ::protobuf::SingularField<::std::string::String>,
    storageClassName: ::protobuf::SingularField<::std::string::String>,
    pub mountOptions: ::protobuf::RepeatedField<::std::string::String>,
    volumeMode: ::protobuf::SingularField<::std::string::String>,
    pub nodeAffinity: ::protobuf::SingularPtrField<VolumeNodeAffinity>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PersistentVolumeSpec {
    fn default() -> &'a PersistentVolumeSpec {
        <PersistentVolumeSpec as ::protobuf::Message>::default_instance()
    }
}

impl PersistentVolumeSpec {
    pub fn new() -> PersistentVolumeSpec {
        ::std::default::Default::default()
    }

    // repeated .k8s.io.api.core.v1.PersistentVolumeSpec.CapacityEntry capacity = 1;


    pub fn get_capacity(&self) -> &::std::collections::HashMap<::std::string::String, super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity> {
        &self.capacity
    }
    pub fn clear_capacity(&mut self) {
        self.capacity.clear();
    }

    // Param is passed by value, moved
    pub fn set_capacity(&mut self, v: ::std::collections::HashMap<::std::string::String, super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity>) {
        self.capacity = v;
    }

    // Mutable pointer to the field.
    pub fn mut_capacity(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity> {
        &mut self.capacity
    }

    // Take field
    pub fn take_capacity(&mut self) -> ::std::collections::HashMap<::std::string::String, super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity> {
        ::std::mem::replace(&mut self.capacity, ::std::collections::HashMap::new())
    }

    // optional .k8s.io.api.core.v1.PersistentVolumeSource persistentVolumeSource = 2;


    pub fn get_persistentVolumeSource(&self) -> &PersistentVolumeSource {
        self.persistentVolumeSource.as_ref().unwrap_or_else(|| <PersistentVolumeSource as ::protobuf::Message>::default_instance())
    }
    pub fn clear_persistentVolumeSource(&mut self) {
        self.persistentVolumeSource.clear();
    }

    pub fn has_persistentVolumeSource(&self) -> bool {
        self.persistentVolumeSource.is_some()
    }

    // Param is passed by value, moved
    pub fn set_persistentVolumeSource(&mut self, v: PersistentVolumeSource) {
        self.persistentVolumeSource = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_persistentVolumeSource(&mut self) -> &mut PersistentVolumeSource {
        if self.persistentVolumeSource.is_none() {
            self.persistentVolumeSource.set_default();
        }
        self.persistentVolumeSource.as_mut().unwrap()
    }

    // Take field
    pub fn take_persistentVolumeSource(&mut self) -> PersistentVolumeSource {
        self.persistentVolumeSource.take().unwrap_or_else(|| PersistentVolumeSource::new())
    }

    // repeated string accessModes = 3;


    pub fn get_accessModes(&self) -> &[::std::string::String] {
        &self.accessModes
    }
    pub fn clear_accessModes(&mut self) {
        self.accessModes.clear();
    }

    // Param is passed by value, moved
    pub fn set_accessModes(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.accessModes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_accessModes(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.accessModes
    }

    // Take field
    pub fn take_accessModes(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.accessModes, ::protobuf::RepeatedField::new())
    }

    // optional .k8s.io.api.core.v1.ObjectReference claimRef = 4;


    pub fn get_claimRef(&self) -> &ObjectReference {
        self.claimRef.as_ref().unwrap_or_else(|| <ObjectReference as ::protobuf::Message>::default_instance())
    }
    pub fn clear_claimRef(&mut self) {
        self.claimRef.clear();
    }

    pub fn has_claimRef(&self) -> bool {
        self.claimRef.is_some()
    }

    // Param is passed by value, moved
    pub fn set_claimRef(&mut self, v: ObjectReference) {
        self.claimRef = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_claimRef(&mut self) -> &mut ObjectReference {
        if self.claimRef.is_none() {
            self.claimRef.set_default();
        }
        self.claimRef.as_mut().unwrap()
    }

    // Take field
    pub fn take_claimRef(&mut self) -> ObjectReference {
        self.claimRef.take().unwrap_or_else(|| ObjectReference::new())
    }

    // optional string persistentVolumeReclaimPolicy = 5;


    pub fn get_persistentVolumeReclaimPolicy(&self) -> &str {
        match self.persistentVolumeReclaimPolicy.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_persistentVolumeReclaimPolicy(&mut self) {
        self.persistentVolumeReclaimPolicy.clear();
    }

    pub fn has_persistentVolumeReclaimPolicy(&self) -> bool {
        self.persistentVolumeReclaimPolicy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_persistentVolumeReclaimPolicy(&mut self, v: ::std::string::String) {
        self.persistentVolumeReclaimPolicy = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_persistentVolumeReclaimPolicy(&mut self) -> &mut ::std::string::String {
        if self.persistentVolumeReclaimPolicy.is_none() {
            self.persistentVolumeReclaimPolicy.set_default();
        }
        self.persistentVolumeReclaimPolicy.as_mut().unwrap()
    }

    // Take field
    pub fn take_persistentVolumeReclaimPolicy(&mut self) -> ::std::string::String {
        self.persistentVolumeReclaimPolicy.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string storageClassName = 6;


    pub fn get_storageClassName(&self) -> &str {
        match self.storageClassName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_storageClassName(&mut self) {
        self.storageClassName.clear();
    }

    pub fn has_storageClassName(&self) -> bool {
        self.storageClassName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_storageClassName(&mut self, v: ::std::string::String) {
        self.storageClassName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_storageClassName(&mut self) -> &mut ::std::string::String {
        if self.storageClassName.is_none() {
            self.storageClassName.set_default();
        }
        self.storageClassName.as_mut().unwrap()
    }

    // Take field
    pub fn take_storageClassName(&mut self) -> ::std::string::String {
        self.storageClassName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated string mountOptions = 7;


    pub fn get_mountOptions(&self) -> &[::std::string::String] {
        &self.mountOptions
    }
    pub fn clear_mountOptions(&mut self) {
        self.mountOptions.clear();
    }

    // Param is passed by value, moved
    pub fn set_mountOptions(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.mountOptions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_mountOptions(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.mountOptions
    }

    // Take field
    pub fn take_mountOptions(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.mountOptions, ::protobuf::RepeatedField::new())
    }

    // optional string volumeMode = 8;


    pub fn get_volumeMode(&self) -> &str {
        match self.volumeMode.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_volumeMode(&mut self) {
        self.volumeMode.clear();
    }

    pub fn has_volumeMode(&self) -> bool {
        self.volumeMode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_volumeMode(&mut self, v: ::std::string::String) {
        self.volumeMode = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_volumeMode(&mut self) -> &mut ::std::string::String {
        if self.volumeMode.is_none() {
            self.volumeMode.set_default();
        }
        self.volumeMode.as_mut().unwrap()
    }

    // Take field
    pub fn take_volumeMode(&mut self) -> ::std::string::String {
        self.volumeMode.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .k8s.io.api.core.v1.VolumeNodeAffinity nodeAffinity = 9;


    pub fn get_nodeAffinity(&self) -> &VolumeNodeAffinity {
        self.nodeAffinity.as_ref().unwrap_or_else(|| <VolumeNodeAffinity as ::protobuf::Message>::default_instance())
    }
    pub fn clear_nodeAffinity(&mut self) {
        self.nodeAffinity.clear();
    }

    pub fn has_nodeAffinity(&self) -> bool {
        self.nodeAffinity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nodeAffinity(&mut self, v: VolumeNodeAffinity) {
        self.nodeAffinity = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nodeAffinity(&mut self) -> &mut VolumeNodeAffinity {
        if self.nodeAffinity.is_none() {
            self.nodeAffinity.set_default();
        }
        self.nodeAffinity.as_mut().unwrap()
    }

    // Take field
    pub fn take_nodeAffinity(&mut self) -> VolumeNodeAffinity {
        self.nodeAffinity.take().unwrap_or_else(|| VolumeNodeAffinity::new())
    }
}

impl ::protobuf::Message for PersistentVolumeSpec {
    fn is_initialized(&self) -> bool {
        for v in &self.persistentVolumeSource {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.claimRef {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.nodeAffinity {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity>>(wire_type, is, &mut self.capacity)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.persistentVolumeSource)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.accessModes)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.claimRef)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.persistentVolumeReclaimPolicy)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.storageClassName)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.mountOptions)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.volumeMode)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.nodeAffinity)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity>>(1, &self.capacity);
        if let Some(ref v) = self.persistentVolumeSource.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.accessModes {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        if let Some(ref v) = self.claimRef.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.persistentVolumeReclaimPolicy.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.storageClassName.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        for value in &self.mountOptions {
            my_size += ::protobuf::rt::string_size(7, &value);
        };
        if let Some(ref v) = self.volumeMode.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(ref v) = self.nodeAffinity.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity>>(1, &self.capacity, os)?;
        if let Some(ref v) = self.persistentVolumeSource.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.accessModes {
            os.write_string(3, &v)?;
        };
        if let Some(ref v) = self.claimRef.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.persistentVolumeReclaimPolicy.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.storageClassName.as_ref() {
            os.write_string(6, &v)?;
        }
        for v in &self.mountOptions {
            os.write_string(7, &v)?;
        };
        if let Some(ref v) = self.volumeMode.as_ref() {
            os.write_string(8, &v)?;
        }
        if let Some(ref v) = self.nodeAffinity.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PersistentVolumeSpec {
        PersistentVolumeSpec::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity>>(
                "capacity",
                |m: &PersistentVolumeSpec| { &m.capacity },
                |m: &mut PersistentVolumeSpec| { &mut m.capacity },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PersistentVolumeSource>>(
                "persistentVolumeSource",
                |m: &PersistentVolumeSpec| { &m.persistentVolumeSource },
                |m: &mut PersistentVolumeSpec| { &mut m.persistentVolumeSource },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "accessModes",
                |m: &PersistentVolumeSpec| { &m.accessModes },
                |m: &mut PersistentVolumeSpec| { &mut m.accessModes },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ObjectReference>>(
                "claimRef",
                |m: &PersistentVolumeSpec| { &m.claimRef },
                |m: &mut PersistentVolumeSpec| { &mut m.claimRef },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "persistentVolumeReclaimPolicy",
                |m: &PersistentVolumeSpec| { &m.persistentVolumeReclaimPolicy },
                |m: &mut PersistentVolumeSpec| { &mut m.persistentVolumeReclaimPolicy },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "storageClassName",
                |m: &PersistentVolumeSpec| { &m.storageClassName },
                |m: &mut PersistentVolumeSpec| { &mut m.storageClassName },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "mountOptions",
                |m: &PersistentVolumeSpec| { &m.mountOptions },
                |m: &mut PersistentVolumeSpec| { &mut m.mountOptions },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "volumeMode",
                |m: &PersistentVolumeSpec| { &m.volumeMode },
                |m: &mut PersistentVolumeSpec| { &mut m.volumeMode },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<VolumeNodeAffinity>>(
                "nodeAffinity",
                |m: &PersistentVolumeSpec| { &m.nodeAffinity },
                |m: &mut PersistentVolumeSpec| { &mut m.nodeAffinity },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PersistentVolumeSpec>(
                "PersistentVolumeSpec",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PersistentVolumeSpec {
        static instance: ::protobuf::rt::LazyV2<PersistentVolumeSpec> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PersistentVolumeSpec::new)
    }
}

impl ::protobuf::Clear for PersistentVolumeSpec {
    fn clear(&mut self) {
        self.capacity.clear();
        self.persistentVolumeSource.clear();
        self.accessModes.clear();
        self.claimRef.clear();
        self.persistentVolumeReclaimPolicy.clear();
        self.storageClassName.clear();
        self.mountOptions.clear();
        self.volumeMode.clear();
        self.nodeAffinity.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PersistentVolumeSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PersistentVolumeSpec {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PersistentVolumeStatus {
    // message fields
    phase: ::protobuf::SingularField<::std::string::String>,
    message: ::protobuf::SingularField<::std::string::String>,
    reason: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PersistentVolumeStatus {
    fn default() -> &'a PersistentVolumeStatus {
        <PersistentVolumeStatus as ::protobuf::Message>::default_instance()
    }
}

impl PersistentVolumeStatus {
    pub fn new() -> PersistentVolumeStatus {
        ::std::default::Default::default()
    }

    // optional string phase = 1;


    pub fn get_phase(&self) -> &str {
        match self.phase.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_phase(&mut self) {
        self.phase.clear();
    }

    pub fn has_phase(&self) -> bool {
        self.phase.is_some()
    }

    // Param is passed by value, moved
    pub fn set_phase(&mut self, v: ::std::string::String) {
        self.phase = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_phase(&mut self) -> &mut ::std::string::String {
        if self.phase.is_none() {
            self.phase.set_default();
        }
        self.phase.as_mut().unwrap()
    }

    // Take field
    pub fn take_phase(&mut self) -> ::std::string::String {
        self.phase.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string message = 2;


    pub fn get_message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string reason = 3;


    pub fn get_reason(&self) -> &str {
        match self.reason.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_reason(&mut self) {
        self.reason.clear();
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: ::std::string::String) {
        self.reason = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reason(&mut self) -> &mut ::std::string::String {
        if self.reason.is_none() {
            self.reason.set_default();
        }
        self.reason.as_mut().unwrap()
    }

    // Take field
    pub fn take_reason(&mut self) -> ::std::string::String {
        self.reason.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for PersistentVolumeStatus {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.phase)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.message)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.reason)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.phase.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.reason.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.phase.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.message.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.reason.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PersistentVolumeStatus {
        PersistentVolumeStatus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "phase",
                |m: &PersistentVolumeStatus| { &m.phase },
                |m: &mut PersistentVolumeStatus| { &mut m.phase },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "message",
                |m: &PersistentVolumeStatus| { &m.message },
                |m: &mut PersistentVolumeStatus| { &mut m.message },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "reason",
                |m: &PersistentVolumeStatus| { &m.reason },
                |m: &mut PersistentVolumeStatus| { &mut m.reason },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PersistentVolumeStatus>(
                "PersistentVolumeStatus",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PersistentVolumeStatus {
        static instance: ::protobuf::rt::LazyV2<PersistentVolumeStatus> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PersistentVolumeStatus::new)
    }
}

impl ::protobuf::Clear for PersistentVolumeStatus {
    fn clear(&mut self) {
        self.phase.clear();
        self.message.clear();
        self.reason.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PersistentVolumeStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PersistentVolumeStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PhotonPersistentDiskVolumeSource {
    // message fields
    pdID: ::protobuf::SingularField<::std::string::String>,
    fsType: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PhotonPersistentDiskVolumeSource {
    fn default() -> &'a PhotonPersistentDiskVolumeSource {
        <PhotonPersistentDiskVolumeSource as ::protobuf::Message>::default_instance()
    }
}

impl PhotonPersistentDiskVolumeSource {
    pub fn new() -> PhotonPersistentDiskVolumeSource {
        ::std::default::Default::default()
    }

    // optional string pdID = 1;


    pub fn get_pdID(&self) -> &str {
        match self.pdID.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_pdID(&mut self) {
        self.pdID.clear();
    }

    pub fn has_pdID(&self) -> bool {
        self.pdID.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pdID(&mut self, v: ::std::string::String) {
        self.pdID = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pdID(&mut self) -> &mut ::std::string::String {
        if self.pdID.is_none() {
            self.pdID.set_default();
        }
        self.pdID.as_mut().unwrap()
    }

    // Take field
    pub fn take_pdID(&mut self) -> ::std::string::String {
        self.pdID.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string fsType = 2;


    pub fn get_fsType(&self) -> &str {
        match self.fsType.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_fsType(&mut self) {
        self.fsType.clear();
    }

    pub fn has_fsType(&self) -> bool {
        self.fsType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fsType(&mut self, v: ::std::string::String) {
        self.fsType = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fsType(&mut self) -> &mut ::std::string::String {
        if self.fsType.is_none() {
            self.fsType.set_default();
        }
        self.fsType.as_mut().unwrap()
    }

    // Take field
    pub fn take_fsType(&mut self) -> ::std::string::String {
        self.fsType.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for PhotonPersistentDiskVolumeSource {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.pdID)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.fsType)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.pdID.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.fsType.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.pdID.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.fsType.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PhotonPersistentDiskVolumeSource {
        PhotonPersistentDiskVolumeSource::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "pdID",
                |m: &PhotonPersistentDiskVolumeSource| { &m.pdID },
                |m: &mut PhotonPersistentDiskVolumeSource| { &mut m.pdID },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "fsType",
                |m: &PhotonPersistentDiskVolumeSource| { &m.fsType },
                |m: &mut PhotonPersistentDiskVolumeSource| { &mut m.fsType },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PhotonPersistentDiskVolumeSource>(
                "PhotonPersistentDiskVolumeSource",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PhotonPersistentDiskVolumeSource {
        static instance: ::protobuf::rt::LazyV2<PhotonPersistentDiskVolumeSource> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PhotonPersistentDiskVolumeSource::new)
    }
}

impl ::protobuf::Clear for PhotonPersistentDiskVolumeSource {
    fn clear(&mut self) {
        self.pdID.clear();
        self.fsType.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PhotonPersistentDiskVolumeSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PhotonPersistentDiskVolumeSource {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Pod {
    // message fields
    pub metadata: ::protobuf::SingularPtrField<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta>,
    pub spec: ::protobuf::SingularPtrField<PodSpec>,
    pub status: ::protobuf::SingularPtrField<PodStatus>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Pod {
    fn default() -> &'a Pod {
        <Pod as ::protobuf::Message>::default_instance()
    }
}

impl Pod {
    pub fn new() -> Pod {
        ::std::default::Default::default()
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;


    pub fn get_metadata(&self) -> &super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta::new())
    }

    // optional .k8s.io.api.core.v1.PodSpec spec = 2;


    pub fn get_spec(&self) -> &PodSpec {
        self.spec.as_ref().unwrap_or_else(|| <PodSpec as ::protobuf::Message>::default_instance())
    }
    pub fn clear_spec(&mut self) {
        self.spec.clear();
    }

    pub fn has_spec(&self) -> bool {
        self.spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spec(&mut self, v: PodSpec) {
        self.spec = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spec(&mut self) -> &mut PodSpec {
        if self.spec.is_none() {
            self.spec.set_default();
        }
        self.spec.as_mut().unwrap()
    }

    // Take field
    pub fn take_spec(&mut self) -> PodSpec {
        self.spec.take().unwrap_or_else(|| PodSpec::new())
    }

    // optional .k8s.io.api.core.v1.PodStatus status = 3;


    pub fn get_status(&self) -> &PodStatus {
        self.status.as_ref().unwrap_or_else(|| <PodStatus as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: PodStatus) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut PodStatus {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> PodStatus {
        self.status.take().unwrap_or_else(|| PodStatus::new())
    }
}

impl ::protobuf::Message for Pod {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.spec {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.spec)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.spec.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Pod {
        Pod::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta>>(
                "metadata",
                |m: &Pod| { &m.metadata },
                |m: &mut Pod| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PodSpec>>(
                "spec",
                |m: &Pod| { &m.spec },
                |m: &mut Pod| { &mut m.spec },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PodStatus>>(
                "status",
                |m: &Pod| { &m.status },
                |m: &mut Pod| { &mut m.status },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Pod>(
                "Pod",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Pod {
        static instance: ::protobuf::rt::LazyV2<Pod> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Pod::new)
    }
}

impl ::protobuf::Clear for Pod {
    fn clear(&mut self) {
        self.metadata.clear();
        self.spec.clear();
        self.status.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Pod {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Pod {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PodAffinity {
    // message fields
    pub requiredDuringSchedulingIgnoredDuringExecution: ::protobuf::RepeatedField<PodAffinityTerm>,
    pub preferredDuringSchedulingIgnoredDuringExecution: ::protobuf::RepeatedField<WeightedPodAffinityTerm>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PodAffinity {
    fn default() -> &'a PodAffinity {
        <PodAffinity as ::protobuf::Message>::default_instance()
    }
}

impl PodAffinity {
    pub fn new() -> PodAffinity {
        ::std::default::Default::default()
    }

    // repeated .k8s.io.api.core.v1.PodAffinityTerm requiredDuringSchedulingIgnoredDuringExecution = 1;


    pub fn get_requiredDuringSchedulingIgnoredDuringExecution(&self) -> &[PodAffinityTerm] {
        &self.requiredDuringSchedulingIgnoredDuringExecution
    }
    pub fn clear_requiredDuringSchedulingIgnoredDuringExecution(&mut self) {
        self.requiredDuringSchedulingIgnoredDuringExecution.clear();
    }

    // Param is passed by value, moved
    pub fn set_requiredDuringSchedulingIgnoredDuringExecution(&mut self, v: ::protobuf::RepeatedField<PodAffinityTerm>) {
        self.requiredDuringSchedulingIgnoredDuringExecution = v;
    }

    // Mutable pointer to the field.
    pub fn mut_requiredDuringSchedulingIgnoredDuringExecution(&mut self) -> &mut ::protobuf::RepeatedField<PodAffinityTerm> {
        &mut self.requiredDuringSchedulingIgnoredDuringExecution
    }

    // Take field
    pub fn take_requiredDuringSchedulingIgnoredDuringExecution(&mut self) -> ::protobuf::RepeatedField<PodAffinityTerm> {
        ::std::mem::replace(&mut self.requiredDuringSchedulingIgnoredDuringExecution, ::protobuf::RepeatedField::new())
    }

    // repeated .k8s.io.api.core.v1.WeightedPodAffinityTerm preferredDuringSchedulingIgnoredDuringExecution = 2;


    pub fn get_preferredDuringSchedulingIgnoredDuringExecution(&self) -> &[WeightedPodAffinityTerm] {
        &self.preferredDuringSchedulingIgnoredDuringExecution
    }
    pub fn clear_preferredDuringSchedulingIgnoredDuringExecution(&mut self) {
        self.preferredDuringSchedulingIgnoredDuringExecution.clear();
    }

    // Param is passed by value, moved
    pub fn set_preferredDuringSchedulingIgnoredDuringExecution(&mut self, v: ::protobuf::RepeatedField<WeightedPodAffinityTerm>) {
        self.preferredDuringSchedulingIgnoredDuringExecution = v;
    }

    // Mutable pointer to the field.
    pub fn mut_preferredDuringSchedulingIgnoredDuringExecution(&mut self) -> &mut ::protobuf::RepeatedField<WeightedPodAffinityTerm> {
        &mut self.preferredDuringSchedulingIgnoredDuringExecution
    }

    // Take field
    pub fn take_preferredDuringSchedulingIgnoredDuringExecution(&mut self) -> ::protobuf::RepeatedField<WeightedPodAffinityTerm> {
        ::std::mem::replace(&mut self.preferredDuringSchedulingIgnoredDuringExecution, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PodAffinity {
    fn is_initialized(&self) -> bool {
        for v in &self.requiredDuringSchedulingIgnoredDuringExecution {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.preferredDuringSchedulingIgnoredDuringExecution {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.requiredDuringSchedulingIgnoredDuringExecution)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.preferredDuringSchedulingIgnoredDuringExecution)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.requiredDuringSchedulingIgnoredDuringExecution {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.preferredDuringSchedulingIgnoredDuringExecution {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.requiredDuringSchedulingIgnoredDuringExecution {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.preferredDuringSchedulingIgnoredDuringExecution {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PodAffinity {
        PodAffinity::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PodAffinityTerm>>(
                "requiredDuringSchedulingIgnoredDuringExecution",
                |m: &PodAffinity| { &m.requiredDuringSchedulingIgnoredDuringExecution },
                |m: &mut PodAffinity| { &mut m.requiredDuringSchedulingIgnoredDuringExecution },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<WeightedPodAffinityTerm>>(
                "preferredDuringSchedulingIgnoredDuringExecution",
                |m: &PodAffinity| { &m.preferredDuringSchedulingIgnoredDuringExecution },
                |m: &mut PodAffinity| { &mut m.preferredDuringSchedulingIgnoredDuringExecution },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PodAffinity>(
                "PodAffinity",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PodAffinity {
        static instance: ::protobuf::rt::LazyV2<PodAffinity> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PodAffinity::new)
    }
}

impl ::protobuf::Clear for PodAffinity {
    fn clear(&mut self) {
        self.requiredDuringSchedulingIgnoredDuringExecution.clear();
        self.preferredDuringSchedulingIgnoredDuringExecution.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PodAffinity {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PodAffinity {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PodAffinityTerm {
    // message fields
    pub labelSelector: ::protobuf::SingularPtrField<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::LabelSelector>,
    pub namespaces: ::protobuf::RepeatedField<::std::string::String>,
    topologyKey: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PodAffinityTerm {
    fn default() -> &'a PodAffinityTerm {
        <PodAffinityTerm as ::protobuf::Message>::default_instance()
    }
}

impl PodAffinityTerm {
    pub fn new() -> PodAffinityTerm {
        ::std::default::Default::default()
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector labelSelector = 1;


    pub fn get_labelSelector(&self) -> &super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::LabelSelector {
        self.labelSelector.as_ref().unwrap_or_else(|| <super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::LabelSelector as ::protobuf::Message>::default_instance())
    }
    pub fn clear_labelSelector(&mut self) {
        self.labelSelector.clear();
    }

    pub fn has_labelSelector(&self) -> bool {
        self.labelSelector.is_some()
    }

    // Param is passed by value, moved
    pub fn set_labelSelector(&mut self, v: super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::LabelSelector) {
        self.labelSelector = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_labelSelector(&mut self) -> &mut super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::LabelSelector {
        if self.labelSelector.is_none() {
            self.labelSelector.set_default();
        }
        self.labelSelector.as_mut().unwrap()
    }

    // Take field
    pub fn take_labelSelector(&mut self) -> super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::LabelSelector {
        self.labelSelector.take().unwrap_or_else(|| super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::LabelSelector::new())
    }

    // repeated string namespaces = 2;


    pub fn get_namespaces(&self) -> &[::std::string::String] {
        &self.namespaces
    }
    pub fn clear_namespaces(&mut self) {
        self.namespaces.clear();
    }

    // Param is passed by value, moved
    pub fn set_namespaces(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.namespaces = v;
    }

    // Mutable pointer to the field.
    pub fn mut_namespaces(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.namespaces
    }

    // Take field
    pub fn take_namespaces(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.namespaces, ::protobuf::RepeatedField::new())
    }

    // optional string topologyKey = 3;


    pub fn get_topologyKey(&self) -> &str {
        match self.topologyKey.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_topologyKey(&mut self) {
        self.topologyKey.clear();
    }

    pub fn has_topologyKey(&self) -> bool {
        self.topologyKey.is_some()
    }

    // Param is passed by value, moved
    pub fn set_topologyKey(&mut self, v: ::std::string::String) {
        self.topologyKey = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_topologyKey(&mut self) -> &mut ::std::string::String {
        if self.topologyKey.is_none() {
            self.topologyKey.set_default();
        }
        self.topologyKey.as_mut().unwrap()
    }

    // Take field
    pub fn take_topologyKey(&mut self) -> ::std::string::String {
        self.topologyKey.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for PodAffinityTerm {
    fn is_initialized(&self) -> bool {
        for v in &self.labelSelector {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.labelSelector)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.namespaces)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.topologyKey)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.labelSelector.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.namespaces {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        if let Some(ref v) = self.topologyKey.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.labelSelector.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.namespaces {
            os.write_string(2, &v)?;
        };
        if let Some(ref v) = self.topologyKey.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PodAffinityTerm {
        PodAffinityTerm::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::LabelSelector>>(
                "labelSelector",
                |m: &PodAffinityTerm| { &m.labelSelector },
                |m: &mut PodAffinityTerm| { &mut m.labelSelector },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "namespaces",
                |m: &PodAffinityTerm| { &m.namespaces },
                |m: &mut PodAffinityTerm| { &mut m.namespaces },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "topologyKey",
                |m: &PodAffinityTerm| { &m.topologyKey },
                |m: &mut PodAffinityTerm| { &mut m.topologyKey },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PodAffinityTerm>(
                "PodAffinityTerm",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PodAffinityTerm {
        static instance: ::protobuf::rt::LazyV2<PodAffinityTerm> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PodAffinityTerm::new)
    }
}

impl ::protobuf::Clear for PodAffinityTerm {
    fn clear(&mut self) {
        self.labelSelector.clear();
        self.namespaces.clear();
        self.topologyKey.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PodAffinityTerm {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PodAffinityTerm {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PodAntiAffinity {
    // message fields
    pub requiredDuringSchedulingIgnoredDuringExecution: ::protobuf::RepeatedField<PodAffinityTerm>,
    pub preferredDuringSchedulingIgnoredDuringExecution: ::protobuf::RepeatedField<WeightedPodAffinityTerm>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PodAntiAffinity {
    fn default() -> &'a PodAntiAffinity {
        <PodAntiAffinity as ::protobuf::Message>::default_instance()
    }
}

impl PodAntiAffinity {
    pub fn new() -> PodAntiAffinity {
        ::std::default::Default::default()
    }

    // repeated .k8s.io.api.core.v1.PodAffinityTerm requiredDuringSchedulingIgnoredDuringExecution = 1;


    pub fn get_requiredDuringSchedulingIgnoredDuringExecution(&self) -> &[PodAffinityTerm] {
        &self.requiredDuringSchedulingIgnoredDuringExecution
    }
    pub fn clear_requiredDuringSchedulingIgnoredDuringExecution(&mut self) {
        self.requiredDuringSchedulingIgnoredDuringExecution.clear();
    }

    // Param is passed by value, moved
    pub fn set_requiredDuringSchedulingIgnoredDuringExecution(&mut self, v: ::protobuf::RepeatedField<PodAffinityTerm>) {
        self.requiredDuringSchedulingIgnoredDuringExecution = v;
    }

    // Mutable pointer to the field.
    pub fn mut_requiredDuringSchedulingIgnoredDuringExecution(&mut self) -> &mut ::protobuf::RepeatedField<PodAffinityTerm> {
        &mut self.requiredDuringSchedulingIgnoredDuringExecution
    }

    // Take field
    pub fn take_requiredDuringSchedulingIgnoredDuringExecution(&mut self) -> ::protobuf::RepeatedField<PodAffinityTerm> {
        ::std::mem::replace(&mut self.requiredDuringSchedulingIgnoredDuringExecution, ::protobuf::RepeatedField::new())
    }

    // repeated .k8s.io.api.core.v1.WeightedPodAffinityTerm preferredDuringSchedulingIgnoredDuringExecution = 2;


    pub fn get_preferredDuringSchedulingIgnoredDuringExecution(&self) -> &[WeightedPodAffinityTerm] {
        &self.preferredDuringSchedulingIgnoredDuringExecution
    }
    pub fn clear_preferredDuringSchedulingIgnoredDuringExecution(&mut self) {
        self.preferredDuringSchedulingIgnoredDuringExecution.clear();
    }

    // Param is passed by value, moved
    pub fn set_preferredDuringSchedulingIgnoredDuringExecution(&mut self, v: ::protobuf::RepeatedField<WeightedPodAffinityTerm>) {
        self.preferredDuringSchedulingIgnoredDuringExecution = v;
    }

    // Mutable pointer to the field.
    pub fn mut_preferredDuringSchedulingIgnoredDuringExecution(&mut self) -> &mut ::protobuf::RepeatedField<WeightedPodAffinityTerm> {
        &mut self.preferredDuringSchedulingIgnoredDuringExecution
    }

    // Take field
    pub fn take_preferredDuringSchedulingIgnoredDuringExecution(&mut self) -> ::protobuf::RepeatedField<WeightedPodAffinityTerm> {
        ::std::mem::replace(&mut self.preferredDuringSchedulingIgnoredDuringExecution, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PodAntiAffinity {
    fn is_initialized(&self) -> bool {
        for v in &self.requiredDuringSchedulingIgnoredDuringExecution {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.preferredDuringSchedulingIgnoredDuringExecution {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.requiredDuringSchedulingIgnoredDuringExecution)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.preferredDuringSchedulingIgnoredDuringExecution)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.requiredDuringSchedulingIgnoredDuringExecution {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.preferredDuringSchedulingIgnoredDuringExecution {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.requiredDuringSchedulingIgnoredDuringExecution {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.preferredDuringSchedulingIgnoredDuringExecution {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PodAntiAffinity {
        PodAntiAffinity::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PodAffinityTerm>>(
                "requiredDuringSchedulingIgnoredDuringExecution",
                |m: &PodAntiAffinity| { &m.requiredDuringSchedulingIgnoredDuringExecution },
                |m: &mut PodAntiAffinity| { &mut m.requiredDuringSchedulingIgnoredDuringExecution },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<WeightedPodAffinityTerm>>(
                "preferredDuringSchedulingIgnoredDuringExecution",
                |m: &PodAntiAffinity| { &m.preferredDuringSchedulingIgnoredDuringExecution },
                |m: &mut PodAntiAffinity| { &mut m.preferredDuringSchedulingIgnoredDuringExecution },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PodAntiAffinity>(
                "PodAntiAffinity",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PodAntiAffinity {
        static instance: ::protobuf::rt::LazyV2<PodAntiAffinity> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PodAntiAffinity::new)
    }
}

impl ::protobuf::Clear for PodAntiAffinity {
    fn clear(&mut self) {
        self.requiredDuringSchedulingIgnoredDuringExecution.clear();
        self.preferredDuringSchedulingIgnoredDuringExecution.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PodAntiAffinity {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PodAntiAffinity {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PodAttachOptions {
    // message fields
    stdin: ::std::option::Option<bool>,
    stdout: ::std::option::Option<bool>,
    stderr: ::std::option::Option<bool>,
    tty: ::std::option::Option<bool>,
    container: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PodAttachOptions {
    fn default() -> &'a PodAttachOptions {
        <PodAttachOptions as ::protobuf::Message>::default_instance()
    }
}

impl PodAttachOptions {
    pub fn new() -> PodAttachOptions {
        ::std::default::Default::default()
    }

    // optional bool stdin = 1;


    pub fn get_stdin(&self) -> bool {
        self.stdin.unwrap_or(false)
    }
    pub fn clear_stdin(&mut self) {
        self.stdin = ::std::option::Option::None;
    }

    pub fn has_stdin(&self) -> bool {
        self.stdin.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stdin(&mut self, v: bool) {
        self.stdin = ::std::option::Option::Some(v);
    }

    // optional bool stdout = 2;


    pub fn get_stdout(&self) -> bool {
        self.stdout.unwrap_or(false)
    }
    pub fn clear_stdout(&mut self) {
        self.stdout = ::std::option::Option::None;
    }

    pub fn has_stdout(&self) -> bool {
        self.stdout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stdout(&mut self, v: bool) {
        self.stdout = ::std::option::Option::Some(v);
    }

    // optional bool stderr = 3;


    pub fn get_stderr(&self) -> bool {
        self.stderr.unwrap_or(false)
    }
    pub fn clear_stderr(&mut self) {
        self.stderr = ::std::option::Option::None;
    }

    pub fn has_stderr(&self) -> bool {
        self.stderr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stderr(&mut self, v: bool) {
        self.stderr = ::std::option::Option::Some(v);
    }

    // optional bool tty = 4;


    pub fn get_tty(&self) -> bool {
        self.tty.unwrap_or(false)
    }
    pub fn clear_tty(&mut self) {
        self.tty = ::std::option::Option::None;
    }

    pub fn has_tty(&self) -> bool {
        self.tty.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tty(&mut self, v: bool) {
        self.tty = ::std::option::Option::Some(v);
    }

    // optional string container = 5;


    pub fn get_container(&self) -> &str {
        match self.container.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_container(&mut self) {
        self.container.clear();
    }

    pub fn has_container(&self) -> bool {
        self.container.is_some()
    }

    // Param is passed by value, moved
    pub fn set_container(&mut self, v: ::std::string::String) {
        self.container = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_container(&mut self) -> &mut ::std::string::String {
        if self.container.is_none() {
            self.container.set_default();
        }
        self.container.as_mut().unwrap()
    }

    // Take field
    pub fn take_container(&mut self) -> ::std::string::String {
        self.container.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for PodAttachOptions {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.stdin = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.stdout = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.stderr = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.tty = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.container)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.stdin {
            my_size += 2;
        }
        if let Some(v) = self.stdout {
            my_size += 2;
        }
        if let Some(v) = self.stderr {
            my_size += 2;
        }
        if let Some(v) = self.tty {
            my_size += 2;
        }
        if let Some(ref v) = self.container.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.stdin {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.stdout {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.stderr {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.tty {
            os.write_bool(4, v)?;
        }
        if let Some(ref v) = self.container.as_ref() {
            os.write_string(5, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PodAttachOptions {
        PodAttachOptions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "stdin",
                |m: &PodAttachOptions| { &m.stdin },
                |m: &mut PodAttachOptions| { &mut m.stdin },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "stdout",
                |m: &PodAttachOptions| { &m.stdout },
                |m: &mut PodAttachOptions| { &mut m.stdout },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "stderr",
                |m: &PodAttachOptions| { &m.stderr },
                |m: &mut PodAttachOptions| { &mut m.stderr },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "tty",
                |m: &PodAttachOptions| { &m.tty },
                |m: &mut PodAttachOptions| { &mut m.tty },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "container",
                |m: &PodAttachOptions| { &m.container },
                |m: &mut PodAttachOptions| { &mut m.container },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PodAttachOptions>(
                "PodAttachOptions",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PodAttachOptions {
        static instance: ::protobuf::rt::LazyV2<PodAttachOptions> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PodAttachOptions::new)
    }
}

impl ::protobuf::Clear for PodAttachOptions {
    fn clear(&mut self) {
        self.stdin = ::std::option::Option::None;
        self.stdout = ::std::option::Option::None;
        self.stderr = ::std::option::Option::None;
        self.tty = ::std::option::Option::None;
        self.container.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PodAttachOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PodAttachOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PodCondition {
    // message fields
    field_type: ::protobuf::SingularField<::std::string::String>,
    status: ::protobuf::SingularField<::std::string::String>,
    pub lastProbeTime: ::protobuf::SingularPtrField<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time>,
    pub lastTransitionTime: ::protobuf::SingularPtrField<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time>,
    reason: ::protobuf::SingularField<::std::string::String>,
    message: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PodCondition {
    fn default() -> &'a PodCondition {
        <PodCondition as ::protobuf::Message>::default_instance()
    }
}

impl PodCondition {
    pub fn new() -> PodCondition {
        ::std::default::Default::default()
    }

    // optional string type = 1;


    pub fn get_field_type(&self) -> &str {
        match self.field_type.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ::std::string::String) {
        self.field_type = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut ::std::string::String {
        if self.field_type.is_none() {
            self.field_type.set_default();
        }
        self.field_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_field_type(&mut self) -> ::std::string::String {
        self.field_type.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string status = 2;


    pub fn get_status(&self) -> &str {
        match self.status.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: ::std::string::String) {
        self.status = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut ::std::string::String {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> ::std::string::String {
        self.status.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastProbeTime = 3;


    pub fn get_lastProbeTime(&self) -> &super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time {
        self.lastProbeTime.as_ref().unwrap_or_else(|| <super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time as ::protobuf::Message>::default_instance())
    }
    pub fn clear_lastProbeTime(&mut self) {
        self.lastProbeTime.clear();
    }

    pub fn has_lastProbeTime(&self) -> bool {
        self.lastProbeTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lastProbeTime(&mut self, v: super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time) {
        self.lastProbeTime = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lastProbeTime(&mut self) -> &mut super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time {
        if self.lastProbeTime.is_none() {
            self.lastProbeTime.set_default();
        }
        self.lastProbeTime.as_mut().unwrap()
    }

    // Take field
    pub fn take_lastProbeTime(&mut self) -> super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time {
        self.lastProbeTime.take().unwrap_or_else(|| super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time::new())
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 4;


    pub fn get_lastTransitionTime(&self) -> &super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time {
        self.lastTransitionTime.as_ref().unwrap_or_else(|| <super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time as ::protobuf::Message>::default_instance())
    }
    pub fn clear_lastTransitionTime(&mut self) {
        self.lastTransitionTime.clear();
    }

    pub fn has_lastTransitionTime(&self) -> bool {
        self.lastTransitionTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lastTransitionTime(&mut self, v: super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time) {
        self.lastTransitionTime = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lastTransitionTime(&mut self) -> &mut super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time {
        if self.lastTransitionTime.is_none() {
            self.lastTransitionTime.set_default();
        }
        self.lastTransitionTime.as_mut().unwrap()
    }

    // Take field
    pub fn take_lastTransitionTime(&mut self) -> super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time {
        self.lastTransitionTime.take().unwrap_or_else(|| super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time::new())
    }

    // optional string reason = 5;


    pub fn get_reason(&self) -> &str {
        match self.reason.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_reason(&mut self) {
        self.reason.clear();
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: ::std::string::String) {
        self.reason = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reason(&mut self) -> &mut ::std::string::String {
        if self.reason.is_none() {
            self.reason.set_default();
        }
        self.reason.as_mut().unwrap()
    }

    // Take field
    pub fn take_reason(&mut self) -> ::std::string::String {
        self.reason.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string message = 6;


    pub fn get_message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for PodCondition {
    fn is_initialized(&self) -> bool {
        for v in &self.lastProbeTime {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.lastTransitionTime {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.field_type)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.status)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.lastProbeTime)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.lastTransitionTime)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.reason)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.field_type.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.status.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.lastProbeTime.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.lastTransitionTime.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.reason.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.field_type.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.status.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.lastProbeTime.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.lastTransitionTime.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.reason.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.message.as_ref() {
            os.write_string(6, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PodCondition {
        PodCondition::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "type",
                |m: &PodCondition| { &m.field_type },
                |m: &mut PodCondition| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "status",
                |m: &PodCondition| { &m.status },
                |m: &mut PodCondition| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time>>(
                "lastProbeTime",
                |m: &PodCondition| { &m.lastProbeTime },
                |m: &mut PodCondition| { &mut m.lastProbeTime },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time>>(
                "lastTransitionTime",
                |m: &PodCondition| { &m.lastTransitionTime },
                |m: &mut PodCondition| { &mut m.lastTransitionTime },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "reason",
                |m: &PodCondition| { &m.reason },
                |m: &mut PodCondition| { &mut m.reason },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "message",
                |m: &PodCondition| { &m.message },
                |m: &mut PodCondition| { &mut m.message },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PodCondition>(
                "PodCondition",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PodCondition {
        static instance: ::protobuf::rt::LazyV2<PodCondition> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PodCondition::new)
    }
}

impl ::protobuf::Clear for PodCondition {
    fn clear(&mut self) {
        self.field_type.clear();
        self.status.clear();
        self.lastProbeTime.clear();
        self.lastTransitionTime.clear();
        self.reason.clear();
        self.message.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PodCondition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PodCondition {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PodDNSConfig {
    // message fields
    pub nameservers: ::protobuf::RepeatedField<::std::string::String>,
    pub searches: ::protobuf::RepeatedField<::std::string::String>,
    pub options: ::protobuf::RepeatedField<PodDNSConfigOption>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PodDNSConfig {
    fn default() -> &'a PodDNSConfig {
        <PodDNSConfig as ::protobuf::Message>::default_instance()
    }
}

impl PodDNSConfig {
    pub fn new() -> PodDNSConfig {
        ::std::default::Default::default()
    }

    // repeated string nameservers = 1;


    pub fn get_nameservers(&self) -> &[::std::string::String] {
        &self.nameservers
    }
    pub fn clear_nameservers(&mut self) {
        self.nameservers.clear();
    }

    // Param is passed by value, moved
    pub fn set_nameservers(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.nameservers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_nameservers(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.nameservers
    }

    // Take field
    pub fn take_nameservers(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.nameservers, ::protobuf::RepeatedField::new())
    }

    // repeated string searches = 2;


    pub fn get_searches(&self) -> &[::std::string::String] {
        &self.searches
    }
    pub fn clear_searches(&mut self) {
        self.searches.clear();
    }

    // Param is passed by value, moved
    pub fn set_searches(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.searches = v;
    }

    // Mutable pointer to the field.
    pub fn mut_searches(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.searches
    }

    // Take field
    pub fn take_searches(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.searches, ::protobuf::RepeatedField::new())
    }

    // repeated .k8s.io.api.core.v1.PodDNSConfigOption options = 3;


    pub fn get_options(&self) -> &[PodDNSConfigOption] {
        &self.options
    }
    pub fn clear_options(&mut self) {
        self.options.clear();
    }

    // Param is passed by value, moved
    pub fn set_options(&mut self, v: ::protobuf::RepeatedField<PodDNSConfigOption>) {
        self.options = v;
    }

    // Mutable pointer to the field.
    pub fn mut_options(&mut self) -> &mut ::protobuf::RepeatedField<PodDNSConfigOption> {
        &mut self.options
    }

    // Take field
    pub fn take_options(&mut self) -> ::protobuf::RepeatedField<PodDNSConfigOption> {
        ::std::mem::replace(&mut self.options, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PodDNSConfig {
    fn is_initialized(&self) -> bool {
        for v in &self.options {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.nameservers)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.searches)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.options)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.nameservers {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in &self.searches {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        for value in &self.options {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.nameservers {
            os.write_string(1, &v)?;
        };
        for v in &self.searches {
            os.write_string(2, &v)?;
        };
        for v in &self.options {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PodDNSConfig {
        PodDNSConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "nameservers",
                |m: &PodDNSConfig| { &m.nameservers },
                |m: &mut PodDNSConfig| { &mut m.nameservers },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "searches",
                |m: &PodDNSConfig| { &m.searches },
                |m: &mut PodDNSConfig| { &mut m.searches },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PodDNSConfigOption>>(
                "options",
                |m: &PodDNSConfig| { &m.options },
                |m: &mut PodDNSConfig| { &mut m.options },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PodDNSConfig>(
                "PodDNSConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PodDNSConfig {
        static instance: ::protobuf::rt::LazyV2<PodDNSConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PodDNSConfig::new)
    }
}

impl ::protobuf::Clear for PodDNSConfig {
    fn clear(&mut self) {
        self.nameservers.clear();
        self.searches.clear();
        self.options.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PodDNSConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PodDNSConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PodDNSConfigOption {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    value: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PodDNSConfigOption {
    fn default() -> &'a PodDNSConfigOption {
        <PodDNSConfigOption as ::protobuf::Message>::default_instance()
    }
}

impl PodDNSConfigOption {
    pub fn new() -> PodDNSConfigOption {
        ::std::default::Default::default()
    }

    // optional string name = 1;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string value = 2;


    pub fn get_value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        if self.value.is_none() {
            self.value.set_default();
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for PodDNSConfigOption {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.value.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.value.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PodDNSConfigOption {
        PodDNSConfigOption::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &PodDNSConfigOption| { &m.name },
                |m: &mut PodDNSConfigOption| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "value",
                |m: &PodDNSConfigOption| { &m.value },
                |m: &mut PodDNSConfigOption| { &mut m.value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PodDNSConfigOption>(
                "PodDNSConfigOption",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PodDNSConfigOption {
        static instance: ::protobuf::rt::LazyV2<PodDNSConfigOption> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PodDNSConfigOption::new)
    }
}

impl ::protobuf::Clear for PodDNSConfigOption {
    fn clear(&mut self) {
        self.name.clear();
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PodDNSConfigOption {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PodDNSConfigOption {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PodExecOptions {
    // message fields
    stdin: ::std::option::Option<bool>,
    stdout: ::std::option::Option<bool>,
    stderr: ::std::option::Option<bool>,
    tty: ::std::option::Option<bool>,
    container: ::protobuf::SingularField<::std::string::String>,
    pub command: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PodExecOptions {
    fn default() -> &'a PodExecOptions {
        <PodExecOptions as ::protobuf::Message>::default_instance()
    }
}

impl PodExecOptions {
    pub fn new() -> PodExecOptions {
        ::std::default::Default::default()
    }

    // optional bool stdin = 1;


    pub fn get_stdin(&self) -> bool {
        self.stdin.unwrap_or(false)
    }
    pub fn clear_stdin(&mut self) {
        self.stdin = ::std::option::Option::None;
    }

    pub fn has_stdin(&self) -> bool {
        self.stdin.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stdin(&mut self, v: bool) {
        self.stdin = ::std::option::Option::Some(v);
    }

    // optional bool stdout = 2;


    pub fn get_stdout(&self) -> bool {
        self.stdout.unwrap_or(false)
    }
    pub fn clear_stdout(&mut self) {
        self.stdout = ::std::option::Option::None;
    }

    pub fn has_stdout(&self) -> bool {
        self.stdout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stdout(&mut self, v: bool) {
        self.stdout = ::std::option::Option::Some(v);
    }

    // optional bool stderr = 3;


    pub fn get_stderr(&self) -> bool {
        self.stderr.unwrap_or(false)
    }
    pub fn clear_stderr(&mut self) {
        self.stderr = ::std::option::Option::None;
    }

    pub fn has_stderr(&self) -> bool {
        self.stderr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_stderr(&mut self, v: bool) {
        self.stderr = ::std::option::Option::Some(v);
    }

    // optional bool tty = 4;


    pub fn get_tty(&self) -> bool {
        self.tty.unwrap_or(false)
    }
    pub fn clear_tty(&mut self) {
        self.tty = ::std::option::Option::None;
    }

    pub fn has_tty(&self) -> bool {
        self.tty.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tty(&mut self, v: bool) {
        self.tty = ::std::option::Option::Some(v);
    }

    // optional string container = 5;


    pub fn get_container(&self) -> &str {
        match self.container.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_container(&mut self) {
        self.container.clear();
    }

    pub fn has_container(&self) -> bool {
        self.container.is_some()
    }

    // Param is passed by value, moved
    pub fn set_container(&mut self, v: ::std::string::String) {
        self.container = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_container(&mut self) -> &mut ::std::string::String {
        if self.container.is_none() {
            self.container.set_default();
        }
        self.container.as_mut().unwrap()
    }

    // Take field
    pub fn take_container(&mut self) -> ::std::string::String {
        self.container.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated string command = 6;


    pub fn get_command(&self) -> &[::std::string::String] {
        &self.command
    }
    pub fn clear_command(&mut self) {
        self.command.clear();
    }

    // Param is passed by value, moved
    pub fn set_command(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.command = v;
    }

    // Mutable pointer to the field.
    pub fn mut_command(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.command
    }

    // Take field
    pub fn take_command(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.command, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PodExecOptions {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.stdin = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.stdout = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.stderr = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.tty = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.container)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.command)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.stdin {
            my_size += 2;
        }
        if let Some(v) = self.stdout {
            my_size += 2;
        }
        if let Some(v) = self.stderr {
            my_size += 2;
        }
        if let Some(v) = self.tty {
            my_size += 2;
        }
        if let Some(ref v) = self.container.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        for value in &self.command {
            my_size += ::protobuf::rt::string_size(6, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.stdin {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.stdout {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.stderr {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.tty {
            os.write_bool(4, v)?;
        }
        if let Some(ref v) = self.container.as_ref() {
            os.write_string(5, &v)?;
        }
        for v in &self.command {
            os.write_string(6, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PodExecOptions {
        PodExecOptions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "stdin",
                |m: &PodExecOptions| { &m.stdin },
                |m: &mut PodExecOptions| { &mut m.stdin },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "stdout",
                |m: &PodExecOptions| { &m.stdout },
                |m: &mut PodExecOptions| { &mut m.stdout },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "stderr",
                |m: &PodExecOptions| { &m.stderr },
                |m: &mut PodExecOptions| { &mut m.stderr },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "tty",
                |m: &PodExecOptions| { &m.tty },
                |m: &mut PodExecOptions| { &mut m.tty },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "container",
                |m: &PodExecOptions| { &m.container },
                |m: &mut PodExecOptions| { &mut m.container },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "command",
                |m: &PodExecOptions| { &m.command },
                |m: &mut PodExecOptions| { &mut m.command },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PodExecOptions>(
                "PodExecOptions",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PodExecOptions {
        static instance: ::protobuf::rt::LazyV2<PodExecOptions> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PodExecOptions::new)
    }
}

impl ::protobuf::Clear for PodExecOptions {
    fn clear(&mut self) {
        self.stdin = ::std::option::Option::None;
        self.stdout = ::std::option::Option::None;
        self.stderr = ::std::option::Option::None;
        self.tty = ::std::option::Option::None;
        self.container.clear();
        self.command.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PodExecOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PodExecOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PodIP {
    // message fields
    ip: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PodIP {
    fn default() -> &'a PodIP {
        <PodIP as ::protobuf::Message>::default_instance()
    }
}

impl PodIP {
    pub fn new() -> PodIP {
        ::std::default::Default::default()
    }

    // optional string ip = 1;


    pub fn get_ip(&self) -> &str {
        match self.ip.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_ip(&mut self) {
        self.ip.clear();
    }

    pub fn has_ip(&self) -> bool {
        self.ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ip(&mut self, v: ::std::string::String) {
        self.ip = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ip(&mut self) -> &mut ::std::string::String {
        if self.ip.is_none() {
            self.ip.set_default();
        }
        self.ip.as_mut().unwrap()
    }

    // Take field
    pub fn take_ip(&mut self) -> ::std::string::String {
        self.ip.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for PodIP {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.ip)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.ip.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.ip.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PodIP {
        PodIP::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "ip",
                |m: &PodIP| { &m.ip },
                |m: &mut PodIP| { &mut m.ip },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PodIP>(
                "PodIP",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PodIP {
        static instance: ::protobuf::rt::LazyV2<PodIP> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PodIP::new)
    }
}

impl ::protobuf::Clear for PodIP {
    fn clear(&mut self) {
        self.ip.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PodIP {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PodIP {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PodList {
    // message fields
    pub metadata: ::protobuf::SingularPtrField<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta>,
    pub items: ::protobuf::RepeatedField<Pod>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PodList {
    fn default() -> &'a PodList {
        <PodList as ::protobuf::Message>::default_instance()
    }
}

impl PodList {
    pub fn new() -> PodList {
        ::std::default::Default::default()
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;


    pub fn get_metadata(&self) -> &super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta {
        self.metadata.take().unwrap_or_else(|| super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta::new())
    }

    // repeated .k8s.io.api.core.v1.Pod items = 2;


    pub fn get_items(&self) -> &[Pod] {
        &self.items
    }
    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::protobuf::RepeatedField<Pod>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::protobuf::RepeatedField<Pod> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::protobuf::RepeatedField<Pod> {
        ::std::mem::replace(&mut self.items, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PodList {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.items {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.items)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.items {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PodList {
        PodList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta>>(
                "metadata",
                |m: &PodList| { &m.metadata },
                |m: &mut PodList| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Pod>>(
                "items",
                |m: &PodList| { &m.items },
                |m: &mut PodList| { &mut m.items },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PodList>(
                "PodList",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PodList {
        static instance: ::protobuf::rt::LazyV2<PodList> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PodList::new)
    }
}

impl ::protobuf::Clear for PodList {
    fn clear(&mut self) {
        self.metadata.clear();
        self.items.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PodList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PodList {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PodLogOptions {
    // message fields
    container: ::protobuf::SingularField<::std::string::String>,
    follow: ::std::option::Option<bool>,
    previous: ::std::option::Option<bool>,
    sinceSeconds: ::std::option::Option<i64>,
    pub sinceTime: ::protobuf::SingularPtrField<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time>,
    timestamps: ::std::option::Option<bool>,
    tailLines: ::std::option::Option<i64>,
    limitBytes: ::std::option::Option<i64>,
    insecureSkipTLSVerifyBackend: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PodLogOptions {
    fn default() -> &'a PodLogOptions {
        <PodLogOptions as ::protobuf::Message>::default_instance()
    }
}

impl PodLogOptions {
    pub fn new() -> PodLogOptions {
        ::std::default::Default::default()
    }

    // optional string container = 1;


    pub fn get_container(&self) -> &str {
        match self.container.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_container(&mut self) {
        self.container.clear();
    }

    pub fn has_container(&self) -> bool {
        self.container.is_some()
    }

    // Param is passed by value, moved
    pub fn set_container(&mut self, v: ::std::string::String) {
        self.container = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_container(&mut self) -> &mut ::std::string::String {
        if self.container.is_none() {
            self.container.set_default();
        }
        self.container.as_mut().unwrap()
    }

    // Take field
    pub fn take_container(&mut self) -> ::std::string::String {
        self.container.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool follow = 2;


    pub fn get_follow(&self) -> bool {
        self.follow.unwrap_or(false)
    }
    pub fn clear_follow(&mut self) {
        self.follow = ::std::option::Option::None;
    }

    pub fn has_follow(&self) -> bool {
        self.follow.is_some()
    }

    // Param is passed by value, moved
    pub fn set_follow(&mut self, v: bool) {
        self.follow = ::std::option::Option::Some(v);
    }

    // optional bool previous = 3;


    pub fn get_previous(&self) -> bool {
        self.previous.unwrap_or(false)
    }
    pub fn clear_previous(&mut self) {
        self.previous = ::std::option::Option::None;
    }

    pub fn has_previous(&self) -> bool {
        self.previous.is_some()
    }

    // Param is passed by value, moved
    pub fn set_previous(&mut self, v: bool) {
        self.previous = ::std::option::Option::Some(v);
    }

    // optional int64 sinceSeconds = 4;


    pub fn get_sinceSeconds(&self) -> i64 {
        self.sinceSeconds.unwrap_or(0)
    }
    pub fn clear_sinceSeconds(&mut self) {
        self.sinceSeconds = ::std::option::Option::None;
    }

    pub fn has_sinceSeconds(&self) -> bool {
        self.sinceSeconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sinceSeconds(&mut self, v: i64) {
        self.sinceSeconds = ::std::option::Option::Some(v);
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time sinceTime = 5;


    pub fn get_sinceTime(&self) -> &super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time {
        self.sinceTime.as_ref().unwrap_or_else(|| <super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time as ::protobuf::Message>::default_instance())
    }
    pub fn clear_sinceTime(&mut self) {
        self.sinceTime.clear();
    }

    pub fn has_sinceTime(&self) -> bool {
        self.sinceTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sinceTime(&mut self, v: super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time) {
        self.sinceTime = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sinceTime(&mut self) -> &mut super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time {
        if self.sinceTime.is_none() {
            self.sinceTime.set_default();
        }
        self.sinceTime.as_mut().unwrap()
    }

    // Take field
    pub fn take_sinceTime(&mut self) -> super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time {
        self.sinceTime.take().unwrap_or_else(|| super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time::new())
    }

    // optional bool timestamps = 6;


    pub fn get_timestamps(&self) -> bool {
        self.timestamps.unwrap_or(false)
    }
    pub fn clear_timestamps(&mut self) {
        self.timestamps = ::std::option::Option::None;
    }

    pub fn has_timestamps(&self) -> bool {
        self.timestamps.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timestamps(&mut self, v: bool) {
        self.timestamps = ::std::option::Option::Some(v);
    }

    // optional int64 tailLines = 7;


    pub fn get_tailLines(&self) -> i64 {
        self.tailLines.unwrap_or(0)
    }
    pub fn clear_tailLines(&mut self) {
        self.tailLines = ::std::option::Option::None;
    }

    pub fn has_tailLines(&self) -> bool {
        self.tailLines.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tailLines(&mut self, v: i64) {
        self.tailLines = ::std::option::Option::Some(v);
    }

    // optional int64 limitBytes = 8;


    pub fn get_limitBytes(&self) -> i64 {
        self.limitBytes.unwrap_or(0)
    }
    pub fn clear_limitBytes(&mut self) {
        self.limitBytes = ::std::option::Option::None;
    }

    pub fn has_limitBytes(&self) -> bool {
        self.limitBytes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_limitBytes(&mut self, v: i64) {
        self.limitBytes = ::std::option::Option::Some(v);
    }

    // optional bool insecureSkipTLSVerifyBackend = 9;


    pub fn get_insecureSkipTLSVerifyBackend(&self) -> bool {
        self.insecureSkipTLSVerifyBackend.unwrap_or(false)
    }
    pub fn clear_insecureSkipTLSVerifyBackend(&mut self) {
        self.insecureSkipTLSVerifyBackend = ::std::option::Option::None;
    }

    pub fn has_insecureSkipTLSVerifyBackend(&self) -> bool {
        self.insecureSkipTLSVerifyBackend.is_some()
    }

    // Param is passed by value, moved
    pub fn set_insecureSkipTLSVerifyBackend(&mut self, v: bool) {
        self.insecureSkipTLSVerifyBackend = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for PodLogOptions {
    fn is_initialized(&self) -> bool {
        for v in &self.sinceTime {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.container)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.follow = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.previous = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.sinceSeconds = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.sinceTime)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.timestamps = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.tailLines = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.limitBytes = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.insecureSkipTLSVerifyBackend = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.container.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.follow {
            my_size += 2;
        }
        if let Some(v) = self.previous {
            my_size += 2;
        }
        if let Some(v) = self.sinceSeconds {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.sinceTime.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.timestamps {
            my_size += 2;
        }
        if let Some(v) = self.tailLines {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.limitBytes {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.insecureSkipTLSVerifyBackend {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.container.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.follow {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.previous {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.sinceSeconds {
            os.write_int64(4, v)?;
        }
        if let Some(ref v) = self.sinceTime.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.timestamps {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.tailLines {
            os.write_int64(7, v)?;
        }
        if let Some(v) = self.limitBytes {
            os.write_int64(8, v)?;
        }
        if let Some(v) = self.insecureSkipTLSVerifyBackend {
            os.write_bool(9, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PodLogOptions {
        PodLogOptions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "container",
                |m: &PodLogOptions| { &m.container },
                |m: &mut PodLogOptions| { &mut m.container },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "follow",
                |m: &PodLogOptions| { &m.follow },
                |m: &mut PodLogOptions| { &mut m.follow },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "previous",
                |m: &PodLogOptions| { &m.previous },
                |m: &mut PodLogOptions| { &mut m.previous },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "sinceSeconds",
                |m: &PodLogOptions| { &m.sinceSeconds },
                |m: &mut PodLogOptions| { &mut m.sinceSeconds },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time>>(
                "sinceTime",
                |m: &PodLogOptions| { &m.sinceTime },
                |m: &mut PodLogOptions| { &mut m.sinceTime },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "timestamps",
                |m: &PodLogOptions| { &m.timestamps },
                |m: &mut PodLogOptions| { &mut m.timestamps },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "tailLines",
                |m: &PodLogOptions| { &m.tailLines },
                |m: &mut PodLogOptions| { &mut m.tailLines },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "limitBytes",
                |m: &PodLogOptions| { &m.limitBytes },
                |m: &mut PodLogOptions| { &mut m.limitBytes },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "insecureSkipTLSVerifyBackend",
                |m: &PodLogOptions| { &m.insecureSkipTLSVerifyBackend },
                |m: &mut PodLogOptions| { &mut m.insecureSkipTLSVerifyBackend },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PodLogOptions>(
                "PodLogOptions",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PodLogOptions {
        static instance: ::protobuf::rt::LazyV2<PodLogOptions> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PodLogOptions::new)
    }
}

impl ::protobuf::Clear for PodLogOptions {
    fn clear(&mut self) {
        self.container.clear();
        self.follow = ::std::option::Option::None;
        self.previous = ::std::option::Option::None;
        self.sinceSeconds = ::std::option::Option::None;
        self.sinceTime.clear();
        self.timestamps = ::std::option::Option::None;
        self.tailLines = ::std::option::Option::None;
        self.limitBytes = ::std::option::Option::None;
        self.insecureSkipTLSVerifyBackend = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PodLogOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PodLogOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PodPortForwardOptions {
    // message fields
    pub ports: ::std::vec::Vec<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PodPortForwardOptions {
    fn default() -> &'a PodPortForwardOptions {
        <PodPortForwardOptions as ::protobuf::Message>::default_instance()
    }
}

impl PodPortForwardOptions {
    pub fn new() -> PodPortForwardOptions {
        ::std::default::Default::default()
    }

    // repeated int32 ports = 1;


    pub fn get_ports(&self) -> &[i32] {
        &self.ports
    }
    pub fn clear_ports(&mut self) {
        self.ports.clear();
    }

    // Param is passed by value, moved
    pub fn set_ports(&mut self, v: ::std::vec::Vec<i32>) {
        self.ports = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ports(&mut self) -> &mut ::std::vec::Vec<i32> {
        &mut self.ports
    }

    // Take field
    pub fn take_ports(&mut self) -> ::std::vec::Vec<i32> {
        ::std::mem::replace(&mut self.ports, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for PodPortForwardOptions {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_int32_into(wire_type, is, &mut self.ports)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.ports {
            my_size += ::protobuf::rt::value_size(1, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.ports {
            os.write_int32(1, *v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PodPortForwardOptions {
        PodPortForwardOptions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "ports",
                |m: &PodPortForwardOptions| { &m.ports },
                |m: &mut PodPortForwardOptions| { &mut m.ports },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PodPortForwardOptions>(
                "PodPortForwardOptions",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PodPortForwardOptions {
        static instance: ::protobuf::rt::LazyV2<PodPortForwardOptions> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PodPortForwardOptions::new)
    }
}

impl ::protobuf::Clear for PodPortForwardOptions {
    fn clear(&mut self) {
        self.ports.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PodPortForwardOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PodPortForwardOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PodProxyOptions {
    // message fields
    path: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PodProxyOptions {
    fn default() -> &'a PodProxyOptions {
        <PodProxyOptions as ::protobuf::Message>::default_instance()
    }
}

impl PodProxyOptions {
    pub fn new() -> PodProxyOptions {
        ::std::default::Default::default()
    }

    // optional string path = 1;


    pub fn get_path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path.set_default();
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for PodProxyOptions {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.path)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.path.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.path.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PodProxyOptions {
        PodProxyOptions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "path",
                |m: &PodProxyOptions| { &m.path },
                |m: &mut PodProxyOptions| { &mut m.path },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PodProxyOptions>(
                "PodProxyOptions",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PodProxyOptions {
        static instance: ::protobuf::rt::LazyV2<PodProxyOptions> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PodProxyOptions::new)
    }
}

impl ::protobuf::Clear for PodProxyOptions {
    fn clear(&mut self) {
        self.path.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PodProxyOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PodProxyOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PodReadinessGate {
    // message fields
    conditionType: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PodReadinessGate {
    fn default() -> &'a PodReadinessGate {
        <PodReadinessGate as ::protobuf::Message>::default_instance()
    }
}

impl PodReadinessGate {
    pub fn new() -> PodReadinessGate {
        ::std::default::Default::default()
    }

    // optional string conditionType = 1;


    pub fn get_conditionType(&self) -> &str {
        match self.conditionType.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_conditionType(&mut self) {
        self.conditionType.clear();
    }

    pub fn has_conditionType(&self) -> bool {
        self.conditionType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_conditionType(&mut self, v: ::std::string::String) {
        self.conditionType = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_conditionType(&mut self) -> &mut ::std::string::String {
        if self.conditionType.is_none() {
            self.conditionType.set_default();
        }
        self.conditionType.as_mut().unwrap()
    }

    // Take field
    pub fn take_conditionType(&mut self) -> ::std::string::String {
        self.conditionType.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for PodReadinessGate {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.conditionType)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.conditionType.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.conditionType.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PodReadinessGate {
        PodReadinessGate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "conditionType",
                |m: &PodReadinessGate| { &m.conditionType },
                |m: &mut PodReadinessGate| { &mut m.conditionType },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PodReadinessGate>(
                "PodReadinessGate",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PodReadinessGate {
        static instance: ::protobuf::rt::LazyV2<PodReadinessGate> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PodReadinessGate::new)
    }
}

impl ::protobuf::Clear for PodReadinessGate {
    fn clear(&mut self) {
        self.conditionType.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PodReadinessGate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PodReadinessGate {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PodSecurityContext {
    // message fields
    pub seLinuxOptions: ::protobuf::SingularPtrField<SELinuxOptions>,
    pub windowsOptions: ::protobuf::SingularPtrField<WindowsSecurityContextOptions>,
    runAsUser: ::std::option::Option<i64>,
    runAsGroup: ::std::option::Option<i64>,
    runAsNonRoot: ::std::option::Option<bool>,
    pub supplementalGroups: ::std::vec::Vec<i64>,
    fsGroup: ::std::option::Option<i64>,
    pub sysctls: ::protobuf::RepeatedField<Sysctl>,
    fsGroupChangePolicy: ::protobuf::SingularField<::std::string::String>,
    pub seccompProfile: ::protobuf::SingularPtrField<SeccompProfile>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PodSecurityContext {
    fn default() -> &'a PodSecurityContext {
        <PodSecurityContext as ::protobuf::Message>::default_instance()
    }
}

impl PodSecurityContext {
    pub fn new() -> PodSecurityContext {
        ::std::default::Default::default()
    }

    // optional .k8s.io.api.core.v1.SELinuxOptions seLinuxOptions = 1;


    pub fn get_seLinuxOptions(&self) -> &SELinuxOptions {
        self.seLinuxOptions.as_ref().unwrap_or_else(|| <SELinuxOptions as ::protobuf::Message>::default_instance())
    }
    pub fn clear_seLinuxOptions(&mut self) {
        self.seLinuxOptions.clear();
    }

    pub fn has_seLinuxOptions(&self) -> bool {
        self.seLinuxOptions.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seLinuxOptions(&mut self, v: SELinuxOptions) {
        self.seLinuxOptions = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_seLinuxOptions(&mut self) -> &mut SELinuxOptions {
        if self.seLinuxOptions.is_none() {
            self.seLinuxOptions.set_default();
        }
        self.seLinuxOptions.as_mut().unwrap()
    }

    // Take field
    pub fn take_seLinuxOptions(&mut self) -> SELinuxOptions {
        self.seLinuxOptions.take().unwrap_or_else(|| SELinuxOptions::new())
    }

    // optional .k8s.io.api.core.v1.WindowsSecurityContextOptions windowsOptions = 8;


    pub fn get_windowsOptions(&self) -> &WindowsSecurityContextOptions {
        self.windowsOptions.as_ref().unwrap_or_else(|| <WindowsSecurityContextOptions as ::protobuf::Message>::default_instance())
    }
    pub fn clear_windowsOptions(&mut self) {
        self.windowsOptions.clear();
    }

    pub fn has_windowsOptions(&self) -> bool {
        self.windowsOptions.is_some()
    }

    // Param is passed by value, moved
    pub fn set_windowsOptions(&mut self, v: WindowsSecurityContextOptions) {
        self.windowsOptions = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_windowsOptions(&mut self) -> &mut WindowsSecurityContextOptions {
        if self.windowsOptions.is_none() {
            self.windowsOptions.set_default();
        }
        self.windowsOptions.as_mut().unwrap()
    }

    // Take field
    pub fn take_windowsOptions(&mut self) -> WindowsSecurityContextOptions {
        self.windowsOptions.take().unwrap_or_else(|| WindowsSecurityContextOptions::new())
    }

    // optional int64 runAsUser = 2;


    pub fn get_runAsUser(&self) -> i64 {
        self.runAsUser.unwrap_or(0)
    }
    pub fn clear_runAsUser(&mut self) {
        self.runAsUser = ::std::option::Option::None;
    }

    pub fn has_runAsUser(&self) -> bool {
        self.runAsUser.is_some()
    }

    // Param is passed by value, moved
    pub fn set_runAsUser(&mut self, v: i64) {
        self.runAsUser = ::std::option::Option::Some(v);
    }

    // optional int64 runAsGroup = 6;


    pub fn get_runAsGroup(&self) -> i64 {
        self.runAsGroup.unwrap_or(0)
    }
    pub fn clear_runAsGroup(&mut self) {
        self.runAsGroup = ::std::option::Option::None;
    }

    pub fn has_runAsGroup(&self) -> bool {
        self.runAsGroup.is_some()
    }

    // Param is passed by value, moved
    pub fn set_runAsGroup(&mut self, v: i64) {
        self.runAsGroup = ::std::option::Option::Some(v);
    }

    // optional bool runAsNonRoot = 3;


    pub fn get_runAsNonRoot(&self) -> bool {
        self.runAsNonRoot.unwrap_or(false)
    }
    pub fn clear_runAsNonRoot(&mut self) {
        self.runAsNonRoot = ::std::option::Option::None;
    }

    pub fn has_runAsNonRoot(&self) -> bool {
        self.runAsNonRoot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_runAsNonRoot(&mut self, v: bool) {
        self.runAsNonRoot = ::std::option::Option::Some(v);
    }

    // repeated int64 supplementalGroups = 4;


    pub fn get_supplementalGroups(&self) -> &[i64] {
        &self.supplementalGroups
    }
    pub fn clear_supplementalGroups(&mut self) {
        self.supplementalGroups.clear();
    }

    // Param is passed by value, moved
    pub fn set_supplementalGroups(&mut self, v: ::std::vec::Vec<i64>) {
        self.supplementalGroups = v;
    }

    // Mutable pointer to the field.
    pub fn mut_supplementalGroups(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.supplementalGroups
    }

    // Take field
    pub fn take_supplementalGroups(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.supplementalGroups, ::std::vec::Vec::new())
    }

    // optional int64 fsGroup = 5;


    pub fn get_fsGroup(&self) -> i64 {
        self.fsGroup.unwrap_or(0)
    }
    pub fn clear_fsGroup(&mut self) {
        self.fsGroup = ::std::option::Option::None;
    }

    pub fn has_fsGroup(&self) -> bool {
        self.fsGroup.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fsGroup(&mut self, v: i64) {
        self.fsGroup = ::std::option::Option::Some(v);
    }

    // repeated .k8s.io.api.core.v1.Sysctl sysctls = 7;


    pub fn get_sysctls(&self) -> &[Sysctl] {
        &self.sysctls
    }
    pub fn clear_sysctls(&mut self) {
        self.sysctls.clear();
    }

    // Param is passed by value, moved
    pub fn set_sysctls(&mut self, v: ::protobuf::RepeatedField<Sysctl>) {
        self.sysctls = v;
    }

    // Mutable pointer to the field.
    pub fn mut_sysctls(&mut self) -> &mut ::protobuf::RepeatedField<Sysctl> {
        &mut self.sysctls
    }

    // Take field
    pub fn take_sysctls(&mut self) -> ::protobuf::RepeatedField<Sysctl> {
        ::std::mem::replace(&mut self.sysctls, ::protobuf::RepeatedField::new())
    }

    // optional string fsGroupChangePolicy = 9;


    pub fn get_fsGroupChangePolicy(&self) -> &str {
        match self.fsGroupChangePolicy.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_fsGroupChangePolicy(&mut self) {
        self.fsGroupChangePolicy.clear();
    }

    pub fn has_fsGroupChangePolicy(&self) -> bool {
        self.fsGroupChangePolicy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fsGroupChangePolicy(&mut self, v: ::std::string::String) {
        self.fsGroupChangePolicy = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fsGroupChangePolicy(&mut self) -> &mut ::std::string::String {
        if self.fsGroupChangePolicy.is_none() {
            self.fsGroupChangePolicy.set_default();
        }
        self.fsGroupChangePolicy.as_mut().unwrap()
    }

    // Take field
    pub fn take_fsGroupChangePolicy(&mut self) -> ::std::string::String {
        self.fsGroupChangePolicy.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .k8s.io.api.core.v1.SeccompProfile seccompProfile = 10;


    pub fn get_seccompProfile(&self) -> &SeccompProfile {
        self.seccompProfile.as_ref().unwrap_or_else(|| <SeccompProfile as ::protobuf::Message>::default_instance())
    }
    pub fn clear_seccompProfile(&mut self) {
        self.seccompProfile.clear();
    }

    pub fn has_seccompProfile(&self) -> bool {
        self.seccompProfile.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seccompProfile(&mut self, v: SeccompProfile) {
        self.seccompProfile = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_seccompProfile(&mut self) -> &mut SeccompProfile {
        if self.seccompProfile.is_none() {
            self.seccompProfile.set_default();
        }
        self.seccompProfile.as_mut().unwrap()
    }

    // Take field
    pub fn take_seccompProfile(&mut self) -> SeccompProfile {
        self.seccompProfile.take().unwrap_or_else(|| SeccompProfile::new())
    }
}

impl ::protobuf::Message for PodSecurityContext {
    fn is_initialized(&self) -> bool {
        for v in &self.seLinuxOptions {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.windowsOptions {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.sysctls {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.seccompProfile {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.seLinuxOptions)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.windowsOptions)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.runAsUser = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.runAsGroup = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.runAsNonRoot = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_repeated_int64_into(wire_type, is, &mut self.supplementalGroups)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.fsGroup = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.sysctls)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.fsGroupChangePolicy)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.seccompProfile)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.seLinuxOptions.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.windowsOptions.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.runAsUser {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.runAsGroup {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.runAsNonRoot {
            my_size += 2;
        }
        for value in &self.supplementalGroups {
            my_size += ::protobuf::rt::value_size(4, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.fsGroup {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.sysctls {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.fsGroupChangePolicy.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(ref v) = self.seccompProfile.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.seLinuxOptions.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.windowsOptions.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.runAsUser {
            os.write_int64(2, v)?;
        }
        if let Some(v) = self.runAsGroup {
            os.write_int64(6, v)?;
        }
        if let Some(v) = self.runAsNonRoot {
            os.write_bool(3, v)?;
        }
        for v in &self.supplementalGroups {
            os.write_int64(4, *v)?;
        };
        if let Some(v) = self.fsGroup {
            os.write_int64(5, v)?;
        }
        for v in &self.sysctls {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.fsGroupChangePolicy.as_ref() {
            os.write_string(9, &v)?;
        }
        if let Some(ref v) = self.seccompProfile.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PodSecurityContext {
        PodSecurityContext::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SELinuxOptions>>(
                "seLinuxOptions",
                |m: &PodSecurityContext| { &m.seLinuxOptions },
                |m: &mut PodSecurityContext| { &mut m.seLinuxOptions },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<WindowsSecurityContextOptions>>(
                "windowsOptions",
                |m: &PodSecurityContext| { &m.windowsOptions },
                |m: &mut PodSecurityContext| { &mut m.windowsOptions },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "runAsUser",
                |m: &PodSecurityContext| { &m.runAsUser },
                |m: &mut PodSecurityContext| { &mut m.runAsUser },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "runAsGroup",
                |m: &PodSecurityContext| { &m.runAsGroup },
                |m: &mut PodSecurityContext| { &mut m.runAsGroup },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "runAsNonRoot",
                |m: &PodSecurityContext| { &m.runAsNonRoot },
                |m: &mut PodSecurityContext| { &mut m.runAsNonRoot },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "supplementalGroups",
                |m: &PodSecurityContext| { &m.supplementalGroups },
                |m: &mut PodSecurityContext| { &mut m.supplementalGroups },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "fsGroup",
                |m: &PodSecurityContext| { &m.fsGroup },
                |m: &mut PodSecurityContext| { &mut m.fsGroup },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Sysctl>>(
                "sysctls",
                |m: &PodSecurityContext| { &m.sysctls },
                |m: &mut PodSecurityContext| { &mut m.sysctls },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "fsGroupChangePolicy",
                |m: &PodSecurityContext| { &m.fsGroupChangePolicy },
                |m: &mut PodSecurityContext| { &mut m.fsGroupChangePolicy },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SeccompProfile>>(
                "seccompProfile",
                |m: &PodSecurityContext| { &m.seccompProfile },
                |m: &mut PodSecurityContext| { &mut m.seccompProfile },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PodSecurityContext>(
                "PodSecurityContext",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PodSecurityContext {
        static instance: ::protobuf::rt::LazyV2<PodSecurityContext> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PodSecurityContext::new)
    }
}

impl ::protobuf::Clear for PodSecurityContext {
    fn clear(&mut self) {
        self.seLinuxOptions.clear();
        self.windowsOptions.clear();
        self.runAsUser = ::std::option::Option::None;
        self.runAsGroup = ::std::option::Option::None;
        self.runAsNonRoot = ::std::option::Option::None;
        self.supplementalGroups.clear();
        self.fsGroup = ::std::option::Option::None;
        self.sysctls.clear();
        self.fsGroupChangePolicy.clear();
        self.seccompProfile.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PodSecurityContext {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PodSecurityContext {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PodSignature {
    // message fields
    pub podController: ::protobuf::SingularPtrField<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::OwnerReference>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PodSignature {
    fn default() -> &'a PodSignature {
        <PodSignature as ::protobuf::Message>::default_instance()
    }
}

impl PodSignature {
    pub fn new() -> PodSignature {
        ::std::default::Default::default()
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.OwnerReference podController = 1;


    pub fn get_podController(&self) -> &super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::OwnerReference {
        self.podController.as_ref().unwrap_or_else(|| <super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::OwnerReference as ::protobuf::Message>::default_instance())
    }
    pub fn clear_podController(&mut self) {
        self.podController.clear();
    }

    pub fn has_podController(&self) -> bool {
        self.podController.is_some()
    }

    // Param is passed by value, moved
    pub fn set_podController(&mut self, v: super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::OwnerReference) {
        self.podController = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_podController(&mut self) -> &mut super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::OwnerReference {
        if self.podController.is_none() {
            self.podController.set_default();
        }
        self.podController.as_mut().unwrap()
    }

    // Take field
    pub fn take_podController(&mut self) -> super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::OwnerReference {
        self.podController.take().unwrap_or_else(|| super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::OwnerReference::new())
    }
}

impl ::protobuf::Message for PodSignature {
    fn is_initialized(&self) -> bool {
        for v in &self.podController {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.podController)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.podController.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.podController.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PodSignature {
        PodSignature::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::OwnerReference>>(
                "podController",
                |m: &PodSignature| { &m.podController },
                |m: &mut PodSignature| { &mut m.podController },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PodSignature>(
                "PodSignature",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PodSignature {
        static instance: ::protobuf::rt::LazyV2<PodSignature> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PodSignature::new)
    }
}

impl ::protobuf::Clear for PodSignature {
    fn clear(&mut self) {
        self.podController.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PodSignature {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PodSignature {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PodSpec {
    // message fields
    pub volumes: ::protobuf::RepeatedField<Volume>,
    pub initContainers: ::protobuf::RepeatedField<Container>,
    pub containers: ::protobuf::RepeatedField<Container>,
    pub ephemeralContainers: ::protobuf::RepeatedField<EphemeralContainer>,
    restartPolicy: ::protobuf::SingularField<::std::string::String>,
    terminationGracePeriodSeconds: ::std::option::Option<i64>,
    activeDeadlineSeconds: ::std::option::Option<i64>,
    dnsPolicy: ::protobuf::SingularField<::std::string::String>,
    pub nodeSelector: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    serviceAccountName: ::protobuf::SingularField<::std::string::String>,
    serviceAccount: ::protobuf::SingularField<::std::string::String>,
    automountServiceAccountToken: ::std::option::Option<bool>,
    nodeName: ::protobuf::SingularField<::std::string::String>,
    hostNetwork: ::std::option::Option<bool>,
    hostPID: ::std::option::Option<bool>,
    hostIPC: ::std::option::Option<bool>,
    shareProcessNamespace: ::std::option::Option<bool>,
    pub securityContext: ::protobuf::SingularPtrField<PodSecurityContext>,
    pub imagePullSecrets: ::protobuf::RepeatedField<LocalObjectReference>,
    hostname: ::protobuf::SingularField<::std::string::String>,
    subdomain: ::protobuf::SingularField<::std::string::String>,
    pub affinity: ::protobuf::SingularPtrField<Affinity>,
    schedulerName: ::protobuf::SingularField<::std::string::String>,
    pub tolerations: ::protobuf::RepeatedField<Toleration>,
    pub hostAliases: ::protobuf::RepeatedField<HostAlias>,
    priorityClassName: ::protobuf::SingularField<::std::string::String>,
    priority: ::std::option::Option<i32>,
    pub dnsConfig: ::protobuf::SingularPtrField<PodDNSConfig>,
    pub readinessGates: ::protobuf::RepeatedField<PodReadinessGate>,
    runtimeClassName: ::protobuf::SingularField<::std::string::String>,
    enableServiceLinks: ::std::option::Option<bool>,
    preemptionPolicy: ::protobuf::SingularField<::std::string::String>,
    pub overhead: ::std::collections::HashMap<::std::string::String, super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity>,
    pub topologySpreadConstraints: ::protobuf::RepeatedField<TopologySpreadConstraint>,
    setHostnameAsFQDN: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PodSpec {
    fn default() -> &'a PodSpec {
        <PodSpec as ::protobuf::Message>::default_instance()
    }
}

impl PodSpec {
    pub fn new() -> PodSpec {
        ::std::default::Default::default()
    }

    // repeated .k8s.io.api.core.v1.Volume volumes = 1;


    pub fn get_volumes(&self) -> &[Volume] {
        &self.volumes
    }
    pub fn clear_volumes(&mut self) {
        self.volumes.clear();
    }

    // Param is passed by value, moved
    pub fn set_volumes(&mut self, v: ::protobuf::RepeatedField<Volume>) {
        self.volumes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_volumes(&mut self) -> &mut ::protobuf::RepeatedField<Volume> {
        &mut self.volumes
    }

    // Take field
    pub fn take_volumes(&mut self) -> ::protobuf::RepeatedField<Volume> {
        ::std::mem::replace(&mut self.volumes, ::protobuf::RepeatedField::new())
    }

    // repeated .k8s.io.api.core.v1.Container initContainers = 20;


    pub fn get_initContainers(&self) -> &[Container] {
        &self.initContainers
    }
    pub fn clear_initContainers(&mut self) {
        self.initContainers.clear();
    }

    // Param is passed by value, moved
    pub fn set_initContainers(&mut self, v: ::protobuf::RepeatedField<Container>) {
        self.initContainers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_initContainers(&mut self) -> &mut ::protobuf::RepeatedField<Container> {
        &mut self.initContainers
    }

    // Take field
    pub fn take_initContainers(&mut self) -> ::protobuf::RepeatedField<Container> {
        ::std::mem::replace(&mut self.initContainers, ::protobuf::RepeatedField::new())
    }

    // repeated .k8s.io.api.core.v1.Container containers = 2;


    pub fn get_containers(&self) -> &[Container] {
        &self.containers
    }
    pub fn clear_containers(&mut self) {
        self.containers.clear();
    }

    // Param is passed by value, moved
    pub fn set_containers(&mut self, v: ::protobuf::RepeatedField<Container>) {
        self.containers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_containers(&mut self) -> &mut ::protobuf::RepeatedField<Container> {
        &mut self.containers
    }

    // Take field
    pub fn take_containers(&mut self) -> ::protobuf::RepeatedField<Container> {
        ::std::mem::replace(&mut self.containers, ::protobuf::RepeatedField::new())
    }

    // repeated .k8s.io.api.core.v1.EphemeralContainer ephemeralContainers = 34;


    pub fn get_ephemeralContainers(&self) -> &[EphemeralContainer] {
        &self.ephemeralContainers
    }
    pub fn clear_ephemeralContainers(&mut self) {
        self.ephemeralContainers.clear();
    }

    // Param is passed by value, moved
    pub fn set_ephemeralContainers(&mut self, v: ::protobuf::RepeatedField<EphemeralContainer>) {
        self.ephemeralContainers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ephemeralContainers(&mut self) -> &mut ::protobuf::RepeatedField<EphemeralContainer> {
        &mut self.ephemeralContainers
    }

    // Take field
    pub fn take_ephemeralContainers(&mut self) -> ::protobuf::RepeatedField<EphemeralContainer> {
        ::std::mem::replace(&mut self.ephemeralContainers, ::protobuf::RepeatedField::new())
    }

    // optional string restartPolicy = 3;


    pub fn get_restartPolicy(&self) -> &str {
        match self.restartPolicy.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_restartPolicy(&mut self) {
        self.restartPolicy.clear();
    }

    pub fn has_restartPolicy(&self) -> bool {
        self.restartPolicy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_restartPolicy(&mut self, v: ::std::string::String) {
        self.restartPolicy = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_restartPolicy(&mut self) -> &mut ::std::string::String {
        if self.restartPolicy.is_none() {
            self.restartPolicy.set_default();
        }
        self.restartPolicy.as_mut().unwrap()
    }

    // Take field
    pub fn take_restartPolicy(&mut self) -> ::std::string::String {
        self.restartPolicy.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int64 terminationGracePeriodSeconds = 4;


    pub fn get_terminationGracePeriodSeconds(&self) -> i64 {
        self.terminationGracePeriodSeconds.unwrap_or(0)
    }
    pub fn clear_terminationGracePeriodSeconds(&mut self) {
        self.terminationGracePeriodSeconds = ::std::option::Option::None;
    }

    pub fn has_terminationGracePeriodSeconds(&self) -> bool {
        self.terminationGracePeriodSeconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_terminationGracePeriodSeconds(&mut self, v: i64) {
        self.terminationGracePeriodSeconds = ::std::option::Option::Some(v);
    }

    // optional int64 activeDeadlineSeconds = 5;


    pub fn get_activeDeadlineSeconds(&self) -> i64 {
        self.activeDeadlineSeconds.unwrap_or(0)
    }
    pub fn clear_activeDeadlineSeconds(&mut self) {
        self.activeDeadlineSeconds = ::std::option::Option::None;
    }

    pub fn has_activeDeadlineSeconds(&self) -> bool {
        self.activeDeadlineSeconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_activeDeadlineSeconds(&mut self, v: i64) {
        self.activeDeadlineSeconds = ::std::option::Option::Some(v);
    }

    // optional string dnsPolicy = 6;


    pub fn get_dnsPolicy(&self) -> &str {
        match self.dnsPolicy.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_dnsPolicy(&mut self) {
        self.dnsPolicy.clear();
    }

    pub fn has_dnsPolicy(&self) -> bool {
        self.dnsPolicy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dnsPolicy(&mut self, v: ::std::string::String) {
        self.dnsPolicy = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dnsPolicy(&mut self) -> &mut ::std::string::String {
        if self.dnsPolicy.is_none() {
            self.dnsPolicy.set_default();
        }
        self.dnsPolicy.as_mut().unwrap()
    }

    // Take field
    pub fn take_dnsPolicy(&mut self) -> ::std::string::String {
        self.dnsPolicy.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .k8s.io.api.core.v1.PodSpec.NodeSelectorEntry nodeSelector = 7;


    pub fn get_nodeSelector(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.nodeSelector
    }
    pub fn clear_nodeSelector(&mut self) {
        self.nodeSelector.clear();
    }

    // Param is passed by value, moved
    pub fn set_nodeSelector(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.nodeSelector = v;
    }

    // Mutable pointer to the field.
    pub fn mut_nodeSelector(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.nodeSelector
    }

    // Take field
    pub fn take_nodeSelector(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.nodeSelector, ::std::collections::HashMap::new())
    }

    // optional string serviceAccountName = 8;


    pub fn get_serviceAccountName(&self) -> &str {
        match self.serviceAccountName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_serviceAccountName(&mut self) {
        self.serviceAccountName.clear();
    }

    pub fn has_serviceAccountName(&self) -> bool {
        self.serviceAccountName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_serviceAccountName(&mut self, v: ::std::string::String) {
        self.serviceAccountName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_serviceAccountName(&mut self) -> &mut ::std::string::String {
        if self.serviceAccountName.is_none() {
            self.serviceAccountName.set_default();
        }
        self.serviceAccountName.as_mut().unwrap()
    }

    // Take field
    pub fn take_serviceAccountName(&mut self) -> ::std::string::String {
        self.serviceAccountName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string serviceAccount = 9;


    pub fn get_serviceAccount(&self) -> &str {
        match self.serviceAccount.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_serviceAccount(&mut self) {
        self.serviceAccount.clear();
    }

    pub fn has_serviceAccount(&self) -> bool {
        self.serviceAccount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_serviceAccount(&mut self, v: ::std::string::String) {
        self.serviceAccount = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_serviceAccount(&mut self) -> &mut ::std::string::String {
        if self.serviceAccount.is_none() {
            self.serviceAccount.set_default();
        }
        self.serviceAccount.as_mut().unwrap()
    }

    // Take field
    pub fn take_serviceAccount(&mut self) -> ::std::string::String {
        self.serviceAccount.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool automountServiceAccountToken = 21;


    pub fn get_automountServiceAccountToken(&self) -> bool {
        self.automountServiceAccountToken.unwrap_or(false)
    }
    pub fn clear_automountServiceAccountToken(&mut self) {
        self.automountServiceAccountToken = ::std::option::Option::None;
    }

    pub fn has_automountServiceAccountToken(&self) -> bool {
        self.automountServiceAccountToken.is_some()
    }

    // Param is passed by value, moved
    pub fn set_automountServiceAccountToken(&mut self, v: bool) {
        self.automountServiceAccountToken = ::std::option::Option::Some(v);
    }

    // optional string nodeName = 10;


    pub fn get_nodeName(&self) -> &str {
        match self.nodeName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_nodeName(&mut self) {
        self.nodeName.clear();
    }

    pub fn has_nodeName(&self) -> bool {
        self.nodeName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nodeName(&mut self, v: ::std::string::String) {
        self.nodeName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nodeName(&mut self) -> &mut ::std::string::String {
        if self.nodeName.is_none() {
            self.nodeName.set_default();
        }
        self.nodeName.as_mut().unwrap()
    }

    // Take field
    pub fn take_nodeName(&mut self) -> ::std::string::String {
        self.nodeName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool hostNetwork = 11;


    pub fn get_hostNetwork(&self) -> bool {
        self.hostNetwork.unwrap_or(false)
    }
    pub fn clear_hostNetwork(&mut self) {
        self.hostNetwork = ::std::option::Option::None;
    }

    pub fn has_hostNetwork(&self) -> bool {
        self.hostNetwork.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hostNetwork(&mut self, v: bool) {
        self.hostNetwork = ::std::option::Option::Some(v);
    }

    // optional bool hostPID = 12;


    pub fn get_hostPID(&self) -> bool {
        self.hostPID.unwrap_or(false)
    }
    pub fn clear_hostPID(&mut self) {
        self.hostPID = ::std::option::Option::None;
    }

    pub fn has_hostPID(&self) -> bool {
        self.hostPID.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hostPID(&mut self, v: bool) {
        self.hostPID = ::std::option::Option::Some(v);
    }

    // optional bool hostIPC = 13;


    pub fn get_hostIPC(&self) -> bool {
        self.hostIPC.unwrap_or(false)
    }
    pub fn clear_hostIPC(&mut self) {
        self.hostIPC = ::std::option::Option::None;
    }

    pub fn has_hostIPC(&self) -> bool {
        self.hostIPC.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hostIPC(&mut self, v: bool) {
        self.hostIPC = ::std::option::Option::Some(v);
    }

    // optional bool shareProcessNamespace = 27;


    pub fn get_shareProcessNamespace(&self) -> bool {
        self.shareProcessNamespace.unwrap_or(false)
    }
    pub fn clear_shareProcessNamespace(&mut self) {
        self.shareProcessNamespace = ::std::option::Option::None;
    }

    pub fn has_shareProcessNamespace(&self) -> bool {
        self.shareProcessNamespace.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shareProcessNamespace(&mut self, v: bool) {
        self.shareProcessNamespace = ::std::option::Option::Some(v);
    }

    // optional .k8s.io.api.core.v1.PodSecurityContext securityContext = 14;


    pub fn get_securityContext(&self) -> &PodSecurityContext {
        self.securityContext.as_ref().unwrap_or_else(|| <PodSecurityContext as ::protobuf::Message>::default_instance())
    }
    pub fn clear_securityContext(&mut self) {
        self.securityContext.clear();
    }

    pub fn has_securityContext(&self) -> bool {
        self.securityContext.is_some()
    }

    // Param is passed by value, moved
    pub fn set_securityContext(&mut self, v: PodSecurityContext) {
        self.securityContext = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_securityContext(&mut self) -> &mut PodSecurityContext {
        if self.securityContext.is_none() {
            self.securityContext.set_default();
        }
        self.securityContext.as_mut().unwrap()
    }

    // Take field
    pub fn take_securityContext(&mut self) -> PodSecurityContext {
        self.securityContext.take().unwrap_or_else(|| PodSecurityContext::new())
    }

    // repeated .k8s.io.api.core.v1.LocalObjectReference imagePullSecrets = 15;


    pub fn get_imagePullSecrets(&self) -> &[LocalObjectReference] {
        &self.imagePullSecrets
    }
    pub fn clear_imagePullSecrets(&mut self) {
        self.imagePullSecrets.clear();
    }

    // Param is passed by value, moved
    pub fn set_imagePullSecrets(&mut self, v: ::protobuf::RepeatedField<LocalObjectReference>) {
        self.imagePullSecrets = v;
    }

    // Mutable pointer to the field.
    pub fn mut_imagePullSecrets(&mut self) -> &mut ::protobuf::RepeatedField<LocalObjectReference> {
        &mut self.imagePullSecrets
    }

    // Take field
    pub fn take_imagePullSecrets(&mut self) -> ::protobuf::RepeatedField<LocalObjectReference> {
        ::std::mem::replace(&mut self.imagePullSecrets, ::protobuf::RepeatedField::new())
    }

    // optional string hostname = 16;


    pub fn get_hostname(&self) -> &str {
        match self.hostname.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_hostname(&mut self) {
        self.hostname.clear();
    }

    pub fn has_hostname(&self) -> bool {
        self.hostname.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hostname(&mut self, v: ::std::string::String) {
        self.hostname = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hostname(&mut self) -> &mut ::std::string::String {
        if self.hostname.is_none() {
            self.hostname.set_default();
        }
        self.hostname.as_mut().unwrap()
    }

    // Take field
    pub fn take_hostname(&mut self) -> ::std::string::String {
        self.hostname.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string subdomain = 17;


    pub fn get_subdomain(&self) -> &str {
        match self.subdomain.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_subdomain(&mut self) {
        self.subdomain.clear();
    }

    pub fn has_subdomain(&self) -> bool {
        self.subdomain.is_some()
    }

    // Param is passed by value, moved
    pub fn set_subdomain(&mut self, v: ::std::string::String) {
        self.subdomain = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subdomain(&mut self) -> &mut ::std::string::String {
        if self.subdomain.is_none() {
            self.subdomain.set_default();
        }
        self.subdomain.as_mut().unwrap()
    }

    // Take field
    pub fn take_subdomain(&mut self) -> ::std::string::String {
        self.subdomain.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .k8s.io.api.core.v1.Affinity affinity = 18;


    pub fn get_affinity(&self) -> &Affinity {
        self.affinity.as_ref().unwrap_or_else(|| <Affinity as ::protobuf::Message>::default_instance())
    }
    pub fn clear_affinity(&mut self) {
        self.affinity.clear();
    }

    pub fn has_affinity(&self) -> bool {
        self.affinity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_affinity(&mut self, v: Affinity) {
        self.affinity = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_affinity(&mut self) -> &mut Affinity {
        if self.affinity.is_none() {
            self.affinity.set_default();
        }
        self.affinity.as_mut().unwrap()
    }

    // Take field
    pub fn take_affinity(&mut self) -> Affinity {
        self.affinity.take().unwrap_or_else(|| Affinity::new())
    }

    // optional string schedulerName = 19;


    pub fn get_schedulerName(&self) -> &str {
        match self.schedulerName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_schedulerName(&mut self) {
        self.schedulerName.clear();
    }

    pub fn has_schedulerName(&self) -> bool {
        self.schedulerName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_schedulerName(&mut self, v: ::std::string::String) {
        self.schedulerName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_schedulerName(&mut self) -> &mut ::std::string::String {
        if self.schedulerName.is_none() {
            self.schedulerName.set_default();
        }
        self.schedulerName.as_mut().unwrap()
    }

    // Take field
    pub fn take_schedulerName(&mut self) -> ::std::string::String {
        self.schedulerName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .k8s.io.api.core.v1.Toleration tolerations = 22;


    pub fn get_tolerations(&self) -> &[Toleration] {
        &self.tolerations
    }
    pub fn clear_tolerations(&mut self) {
        self.tolerations.clear();
    }

    // Param is passed by value, moved
    pub fn set_tolerations(&mut self, v: ::protobuf::RepeatedField<Toleration>) {
        self.tolerations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tolerations(&mut self) -> &mut ::protobuf::RepeatedField<Toleration> {
        &mut self.tolerations
    }

    // Take field
    pub fn take_tolerations(&mut self) -> ::protobuf::RepeatedField<Toleration> {
        ::std::mem::replace(&mut self.tolerations, ::protobuf::RepeatedField::new())
    }

    // repeated .k8s.io.api.core.v1.HostAlias hostAliases = 23;


    pub fn get_hostAliases(&self) -> &[HostAlias] {
        &self.hostAliases
    }
    pub fn clear_hostAliases(&mut self) {
        self.hostAliases.clear();
    }

    // Param is passed by value, moved
    pub fn set_hostAliases(&mut self, v: ::protobuf::RepeatedField<HostAlias>) {
        self.hostAliases = v;
    }

    // Mutable pointer to the field.
    pub fn mut_hostAliases(&mut self) -> &mut ::protobuf::RepeatedField<HostAlias> {
        &mut self.hostAliases
    }

    // Take field
    pub fn take_hostAliases(&mut self) -> ::protobuf::RepeatedField<HostAlias> {
        ::std::mem::replace(&mut self.hostAliases, ::protobuf::RepeatedField::new())
    }

    // optional string priorityClassName = 24;


    pub fn get_priorityClassName(&self) -> &str {
        match self.priorityClassName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_priorityClassName(&mut self) {
        self.priorityClassName.clear();
    }

    pub fn has_priorityClassName(&self) -> bool {
        self.priorityClassName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_priorityClassName(&mut self, v: ::std::string::String) {
        self.priorityClassName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_priorityClassName(&mut self) -> &mut ::std::string::String {
        if self.priorityClassName.is_none() {
            self.priorityClassName.set_default();
        }
        self.priorityClassName.as_mut().unwrap()
    }

    // Take field
    pub fn take_priorityClassName(&mut self) -> ::std::string::String {
        self.priorityClassName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 priority = 25;


    pub fn get_priority(&self) -> i32 {
        self.priority.unwrap_or(0)
    }
    pub fn clear_priority(&mut self) {
        self.priority = ::std::option::Option::None;
    }

    pub fn has_priority(&self) -> bool {
        self.priority.is_some()
    }

    // Param is passed by value, moved
    pub fn set_priority(&mut self, v: i32) {
        self.priority = ::std::option::Option::Some(v);
    }

    // optional .k8s.io.api.core.v1.PodDNSConfig dnsConfig = 26;


    pub fn get_dnsConfig(&self) -> &PodDNSConfig {
        self.dnsConfig.as_ref().unwrap_or_else(|| <PodDNSConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_dnsConfig(&mut self) {
        self.dnsConfig.clear();
    }

    pub fn has_dnsConfig(&self) -> bool {
        self.dnsConfig.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dnsConfig(&mut self, v: PodDNSConfig) {
        self.dnsConfig = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_dnsConfig(&mut self) -> &mut PodDNSConfig {
        if self.dnsConfig.is_none() {
            self.dnsConfig.set_default();
        }
        self.dnsConfig.as_mut().unwrap()
    }

    // Take field
    pub fn take_dnsConfig(&mut self) -> PodDNSConfig {
        self.dnsConfig.take().unwrap_or_else(|| PodDNSConfig::new())
    }

    // repeated .k8s.io.api.core.v1.PodReadinessGate readinessGates = 28;


    pub fn get_readinessGates(&self) -> &[PodReadinessGate] {
        &self.readinessGates
    }
    pub fn clear_readinessGates(&mut self) {
        self.readinessGates.clear();
    }

    // Param is passed by value, moved
    pub fn set_readinessGates(&mut self, v: ::protobuf::RepeatedField<PodReadinessGate>) {
        self.readinessGates = v;
    }

    // Mutable pointer to the field.
    pub fn mut_readinessGates(&mut self) -> &mut ::protobuf::RepeatedField<PodReadinessGate> {
        &mut self.readinessGates
    }

    // Take field
    pub fn take_readinessGates(&mut self) -> ::protobuf::RepeatedField<PodReadinessGate> {
        ::std::mem::replace(&mut self.readinessGates, ::protobuf::RepeatedField::new())
    }

    // optional string runtimeClassName = 29;


    pub fn get_runtimeClassName(&self) -> &str {
        match self.runtimeClassName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_runtimeClassName(&mut self) {
        self.runtimeClassName.clear();
    }

    pub fn has_runtimeClassName(&self) -> bool {
        self.runtimeClassName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_runtimeClassName(&mut self, v: ::std::string::String) {
        self.runtimeClassName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_runtimeClassName(&mut self) -> &mut ::std::string::String {
        if self.runtimeClassName.is_none() {
            self.runtimeClassName.set_default();
        }
        self.runtimeClassName.as_mut().unwrap()
    }

    // Take field
    pub fn take_runtimeClassName(&mut self) -> ::std::string::String {
        self.runtimeClassName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool enableServiceLinks = 30;


    pub fn get_enableServiceLinks(&self) -> bool {
        self.enableServiceLinks.unwrap_or(false)
    }
    pub fn clear_enableServiceLinks(&mut self) {
        self.enableServiceLinks = ::std::option::Option::None;
    }

    pub fn has_enableServiceLinks(&self) -> bool {
        self.enableServiceLinks.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enableServiceLinks(&mut self, v: bool) {
        self.enableServiceLinks = ::std::option::Option::Some(v);
    }

    // optional string preemptionPolicy = 31;


    pub fn get_preemptionPolicy(&self) -> &str {
        match self.preemptionPolicy.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_preemptionPolicy(&mut self) {
        self.preemptionPolicy.clear();
    }

    pub fn has_preemptionPolicy(&self) -> bool {
        self.preemptionPolicy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_preemptionPolicy(&mut self, v: ::std::string::String) {
        self.preemptionPolicy = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_preemptionPolicy(&mut self) -> &mut ::std::string::String {
        if self.preemptionPolicy.is_none() {
            self.preemptionPolicy.set_default();
        }
        self.preemptionPolicy.as_mut().unwrap()
    }

    // Take field
    pub fn take_preemptionPolicy(&mut self) -> ::std::string::String {
        self.preemptionPolicy.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .k8s.io.api.core.v1.PodSpec.OverheadEntry overhead = 32;


    pub fn get_overhead(&self) -> &::std::collections::HashMap<::std::string::String, super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity> {
        &self.overhead
    }
    pub fn clear_overhead(&mut self) {
        self.overhead.clear();
    }

    // Param is passed by value, moved
    pub fn set_overhead(&mut self, v: ::std::collections::HashMap<::std::string::String, super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity>) {
        self.overhead = v;
    }

    // Mutable pointer to the field.
    pub fn mut_overhead(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity> {
        &mut self.overhead
    }

    // Take field
    pub fn take_overhead(&mut self) -> ::std::collections::HashMap<::std::string::String, super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity> {
        ::std::mem::replace(&mut self.overhead, ::std::collections::HashMap::new())
    }

    // repeated .k8s.io.api.core.v1.TopologySpreadConstraint topologySpreadConstraints = 33;


    pub fn get_topologySpreadConstraints(&self) -> &[TopologySpreadConstraint] {
        &self.topologySpreadConstraints
    }
    pub fn clear_topologySpreadConstraints(&mut self) {
        self.topologySpreadConstraints.clear();
    }

    // Param is passed by value, moved
    pub fn set_topologySpreadConstraints(&mut self, v: ::protobuf::RepeatedField<TopologySpreadConstraint>) {
        self.topologySpreadConstraints = v;
    }

    // Mutable pointer to the field.
    pub fn mut_topologySpreadConstraints(&mut self) -> &mut ::protobuf::RepeatedField<TopologySpreadConstraint> {
        &mut self.topologySpreadConstraints
    }

    // Take field
    pub fn take_topologySpreadConstraints(&mut self) -> ::protobuf::RepeatedField<TopologySpreadConstraint> {
        ::std::mem::replace(&mut self.topologySpreadConstraints, ::protobuf::RepeatedField::new())
    }

    // optional bool setHostnameAsFQDN = 35;


    pub fn get_setHostnameAsFQDN(&self) -> bool {
        self.setHostnameAsFQDN.unwrap_or(false)
    }
    pub fn clear_setHostnameAsFQDN(&mut self) {
        self.setHostnameAsFQDN = ::std::option::Option::None;
    }

    pub fn has_setHostnameAsFQDN(&self) -> bool {
        self.setHostnameAsFQDN.is_some()
    }

    // Param is passed by value, moved
    pub fn set_setHostnameAsFQDN(&mut self, v: bool) {
        self.setHostnameAsFQDN = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for PodSpec {
    fn is_initialized(&self) -> bool {
        for v in &self.volumes {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.initContainers {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.containers {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ephemeralContainers {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.securityContext {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.imagePullSecrets {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.affinity {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tolerations {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.hostAliases {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.dnsConfig {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.readinessGates {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.topologySpreadConstraints {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.volumes)?;
                },
                20 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.initContainers)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.containers)?;
                },
                34 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.ephemeralContainers)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.restartPolicy)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.terminationGracePeriodSeconds = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.activeDeadlineSeconds = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.dnsPolicy)?;
                },
                7 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.nodeSelector)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.serviceAccountName)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.serviceAccount)?;
                },
                21 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.automountServiceAccountToken = ::std::option::Option::Some(tmp);
                },
                10 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.nodeName)?;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.hostNetwork = ::std::option::Option::Some(tmp);
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.hostPID = ::std::option::Option::Some(tmp);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.hostIPC = ::std::option::Option::Some(tmp);
                },
                27 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.shareProcessNamespace = ::std::option::Option::Some(tmp);
                },
                14 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.securityContext)?;
                },
                15 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.imagePullSecrets)?;
                },
                16 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.hostname)?;
                },
                17 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.subdomain)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.affinity)?;
                },
                19 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.schedulerName)?;
                },
                22 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.tolerations)?;
                },
                23 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.hostAliases)?;
                },
                24 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.priorityClassName)?;
                },
                25 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.priority = ::std::option::Option::Some(tmp);
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.dnsConfig)?;
                },
                28 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.readinessGates)?;
                },
                29 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.runtimeClassName)?;
                },
                30 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.enableServiceLinks = ::std::option::Option::Some(tmp);
                },
                31 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.preemptionPolicy)?;
                },
                32 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity>>(wire_type, is, &mut self.overhead)?;
                },
                33 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.topologySpreadConstraints)?;
                },
                35 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.setHostnameAsFQDN = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.volumes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.initContainers {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.containers {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.ephemeralContainers {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.restartPolicy.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.terminationGracePeriodSeconds {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.activeDeadlineSeconds {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.dnsPolicy.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(7, &self.nodeSelector);
        if let Some(ref v) = self.serviceAccountName.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(ref v) = self.serviceAccount.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(v) = self.automountServiceAccountToken {
            my_size += 3;
        }
        if let Some(ref v) = self.nodeName.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        if let Some(v) = self.hostNetwork {
            my_size += 2;
        }
        if let Some(v) = self.hostPID {
            my_size += 2;
        }
        if let Some(v) = self.hostIPC {
            my_size += 2;
        }
        if let Some(v) = self.shareProcessNamespace {
            my_size += 3;
        }
        if let Some(ref v) = self.securityContext.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.imagePullSecrets {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.hostname.as_ref() {
            my_size += ::protobuf::rt::string_size(16, &v);
        }
        if let Some(ref v) = self.subdomain.as_ref() {
            my_size += ::protobuf::rt::string_size(17, &v);
        }
        if let Some(ref v) = self.affinity.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.schedulerName.as_ref() {
            my_size += ::protobuf::rt::string_size(19, &v);
        }
        for value in &self.tolerations {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.hostAliases {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.priorityClassName.as_ref() {
            my_size += ::protobuf::rt::string_size(24, &v);
        }
        if let Some(v) = self.priority {
            my_size += ::protobuf::rt::value_size(25, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.dnsConfig.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.readinessGates {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.runtimeClassName.as_ref() {
            my_size += ::protobuf::rt::string_size(29, &v);
        }
        if let Some(v) = self.enableServiceLinks {
            my_size += 3;
        }
        if let Some(ref v) = self.preemptionPolicy.as_ref() {
            my_size += ::protobuf::rt::string_size(31, &v);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity>>(32, &self.overhead);
        for value in &self.topologySpreadConstraints {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.setHostnameAsFQDN {
            my_size += 3;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.volumes {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.initContainers {
            os.write_tag(20, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.containers {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.ephemeralContainers {
            os.write_tag(34, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.restartPolicy.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.terminationGracePeriodSeconds {
            os.write_int64(4, v)?;
        }
        if let Some(v) = self.activeDeadlineSeconds {
            os.write_int64(5, v)?;
        }
        if let Some(ref v) = self.dnsPolicy.as_ref() {
            os.write_string(6, &v)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(7, &self.nodeSelector, os)?;
        if let Some(ref v) = self.serviceAccountName.as_ref() {
            os.write_string(8, &v)?;
        }
        if let Some(ref v) = self.serviceAccount.as_ref() {
            os.write_string(9, &v)?;
        }
        if let Some(v) = self.automountServiceAccountToken {
            os.write_bool(21, v)?;
        }
        if let Some(ref v) = self.nodeName.as_ref() {
            os.write_string(10, &v)?;
        }
        if let Some(v) = self.hostNetwork {
            os.write_bool(11, v)?;
        }
        if let Some(v) = self.hostPID {
            os.write_bool(12, v)?;
        }
        if let Some(v) = self.hostIPC {
            os.write_bool(13, v)?;
        }
        if let Some(v) = self.shareProcessNamespace {
            os.write_bool(27, v)?;
        }
        if let Some(ref v) = self.securityContext.as_ref() {
            os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.imagePullSecrets {
            os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.hostname.as_ref() {
            os.write_string(16, &v)?;
        }
        if let Some(ref v) = self.subdomain.as_ref() {
            os.write_string(17, &v)?;
        }
        if let Some(ref v) = self.affinity.as_ref() {
            os.write_tag(18, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.schedulerName.as_ref() {
            os.write_string(19, &v)?;
        }
        for v in &self.tolerations {
            os.write_tag(22, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.hostAliases {
            os.write_tag(23, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.priorityClassName.as_ref() {
            os.write_string(24, &v)?;
        }
        if let Some(v) = self.priority {
            os.write_int32(25, v)?;
        }
        if let Some(ref v) = self.dnsConfig.as_ref() {
            os.write_tag(26, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.readinessGates {
            os.write_tag(28, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.runtimeClassName.as_ref() {
            os.write_string(29, &v)?;
        }
        if let Some(v) = self.enableServiceLinks {
            os.write_bool(30, v)?;
        }
        if let Some(ref v) = self.preemptionPolicy.as_ref() {
            os.write_string(31, &v)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity>>(32, &self.overhead, os)?;
        for v in &self.topologySpreadConstraints {
            os.write_tag(33, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.setHostnameAsFQDN {
            os.write_bool(35, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PodSpec {
        PodSpec::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Volume>>(
                "volumes",
                |m: &PodSpec| { &m.volumes },
                |m: &mut PodSpec| { &mut m.volumes },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Container>>(
                "initContainers",
                |m: &PodSpec| { &m.initContainers },
                |m: &mut PodSpec| { &mut m.initContainers },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Container>>(
                "containers",
                |m: &PodSpec| { &m.containers },
                |m: &mut PodSpec| { &mut m.containers },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EphemeralContainer>>(
                "ephemeralContainers",
                |m: &PodSpec| { &m.ephemeralContainers },
                |m: &mut PodSpec| { &mut m.ephemeralContainers },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "restartPolicy",
                |m: &PodSpec| { &m.restartPolicy },
                |m: &mut PodSpec| { &mut m.restartPolicy },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "terminationGracePeriodSeconds",
                |m: &PodSpec| { &m.terminationGracePeriodSeconds },
                |m: &mut PodSpec| { &mut m.terminationGracePeriodSeconds },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "activeDeadlineSeconds",
                |m: &PodSpec| { &m.activeDeadlineSeconds },
                |m: &mut PodSpec| { &mut m.activeDeadlineSeconds },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "dnsPolicy",
                |m: &PodSpec| { &m.dnsPolicy },
                |m: &mut PodSpec| { &mut m.dnsPolicy },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                "nodeSelector",
                |m: &PodSpec| { &m.nodeSelector },
                |m: &mut PodSpec| { &mut m.nodeSelector },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "serviceAccountName",
                |m: &PodSpec| { &m.serviceAccountName },
                |m: &mut PodSpec| { &mut m.serviceAccountName },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "serviceAccount",
                |m: &PodSpec| { &m.serviceAccount },
                |m: &mut PodSpec| { &mut m.serviceAccount },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "automountServiceAccountToken",
                |m: &PodSpec| { &m.automountServiceAccountToken },
                |m: &mut PodSpec| { &mut m.automountServiceAccountToken },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "nodeName",
                |m: &PodSpec| { &m.nodeName },
                |m: &mut PodSpec| { &mut m.nodeName },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "hostNetwork",
                |m: &PodSpec| { &m.hostNetwork },
                |m: &mut PodSpec| { &mut m.hostNetwork },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "hostPID",
                |m: &PodSpec| { &m.hostPID },
                |m: &mut PodSpec| { &mut m.hostPID },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "hostIPC",
                |m: &PodSpec| { &m.hostIPC },
                |m: &mut PodSpec| { &mut m.hostIPC },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "shareProcessNamespace",
                |m: &PodSpec| { &m.shareProcessNamespace },
                |m: &mut PodSpec| { &mut m.shareProcessNamespace },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PodSecurityContext>>(
                "securityContext",
                |m: &PodSpec| { &m.securityContext },
                |m: &mut PodSpec| { &mut m.securityContext },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LocalObjectReference>>(
                "imagePullSecrets",
                |m: &PodSpec| { &m.imagePullSecrets },
                |m: &mut PodSpec| { &mut m.imagePullSecrets },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "hostname",
                |m: &PodSpec| { &m.hostname },
                |m: &mut PodSpec| { &mut m.hostname },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "subdomain",
                |m: &PodSpec| { &m.subdomain },
                |m: &mut PodSpec| { &mut m.subdomain },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Affinity>>(
                "affinity",
                |m: &PodSpec| { &m.affinity },
                |m: &mut PodSpec| { &mut m.affinity },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "schedulerName",
                |m: &PodSpec| { &m.schedulerName },
                |m: &mut PodSpec| { &mut m.schedulerName },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Toleration>>(
                "tolerations",
                |m: &PodSpec| { &m.tolerations },
                |m: &mut PodSpec| { &mut m.tolerations },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<HostAlias>>(
                "hostAliases",
                |m: &PodSpec| { &m.hostAliases },
                |m: &mut PodSpec| { &mut m.hostAliases },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "priorityClassName",
                |m: &PodSpec| { &m.priorityClassName },
                |m: &mut PodSpec| { &mut m.priorityClassName },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "priority",
                |m: &PodSpec| { &m.priority },
                |m: &mut PodSpec| { &mut m.priority },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PodDNSConfig>>(
                "dnsConfig",
                |m: &PodSpec| { &m.dnsConfig },
                |m: &mut PodSpec| { &mut m.dnsConfig },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PodReadinessGate>>(
                "readinessGates",
                |m: &PodSpec| { &m.readinessGates },
                |m: &mut PodSpec| { &mut m.readinessGates },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "runtimeClassName",
                |m: &PodSpec| { &m.runtimeClassName },
                |m: &mut PodSpec| { &mut m.runtimeClassName },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "enableServiceLinks",
                |m: &PodSpec| { &m.enableServiceLinks },
                |m: &mut PodSpec| { &mut m.enableServiceLinks },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "preemptionPolicy",
                |m: &PodSpec| { &m.preemptionPolicy },
                |m: &mut PodSpec| { &mut m.preemptionPolicy },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity>>(
                "overhead",
                |m: &PodSpec| { &m.overhead },
                |m: &mut PodSpec| { &mut m.overhead },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TopologySpreadConstraint>>(
                "topologySpreadConstraints",
                |m: &PodSpec| { &m.topologySpreadConstraints },
                |m: &mut PodSpec| { &mut m.topologySpreadConstraints },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "setHostnameAsFQDN",
                |m: &PodSpec| { &m.setHostnameAsFQDN },
                |m: &mut PodSpec| { &mut m.setHostnameAsFQDN },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PodSpec>(
                "PodSpec",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PodSpec {
        static instance: ::protobuf::rt::LazyV2<PodSpec> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PodSpec::new)
    }
}

impl ::protobuf::Clear for PodSpec {
    fn clear(&mut self) {
        self.volumes.clear();
        self.initContainers.clear();
        self.containers.clear();
        self.ephemeralContainers.clear();
        self.restartPolicy.clear();
        self.terminationGracePeriodSeconds = ::std::option::Option::None;
        self.activeDeadlineSeconds = ::std::option::Option::None;
        self.dnsPolicy.clear();
        self.nodeSelector.clear();
        self.serviceAccountName.clear();
        self.serviceAccount.clear();
        self.automountServiceAccountToken = ::std::option::Option::None;
        self.nodeName.clear();
        self.hostNetwork = ::std::option::Option::None;
        self.hostPID = ::std::option::Option::None;
        self.hostIPC = ::std::option::Option::None;
        self.shareProcessNamespace = ::std::option::Option::None;
        self.securityContext.clear();
        self.imagePullSecrets.clear();
        self.hostname.clear();
        self.subdomain.clear();
        self.affinity.clear();
        self.schedulerName.clear();
        self.tolerations.clear();
        self.hostAliases.clear();
        self.priorityClassName.clear();
        self.priority = ::std::option::Option::None;
        self.dnsConfig.clear();
        self.readinessGates.clear();
        self.runtimeClassName.clear();
        self.enableServiceLinks = ::std::option::Option::None;
        self.preemptionPolicy.clear();
        self.overhead.clear();
        self.topologySpreadConstraints.clear();
        self.setHostnameAsFQDN = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PodSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PodSpec {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PodStatus {
    // message fields
    phase: ::protobuf::SingularField<::std::string::String>,
    pub conditions: ::protobuf::RepeatedField<PodCondition>,
    message: ::protobuf::SingularField<::std::string::String>,
    reason: ::protobuf::SingularField<::std::string::String>,
    nominatedNodeName: ::protobuf::SingularField<::std::string::String>,
    hostIP: ::protobuf::SingularField<::std::string::String>,
    podIP: ::protobuf::SingularField<::std::string::String>,
    pub podIPs: ::protobuf::RepeatedField<PodIP>,
    pub startTime: ::protobuf::SingularPtrField<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time>,
    pub initContainerStatuses: ::protobuf::RepeatedField<ContainerStatus>,
    pub containerStatuses: ::protobuf::RepeatedField<ContainerStatus>,
    qosClass: ::protobuf::SingularField<::std::string::String>,
    pub ephemeralContainerStatuses: ::protobuf::RepeatedField<ContainerStatus>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PodStatus {
    fn default() -> &'a PodStatus {
        <PodStatus as ::protobuf::Message>::default_instance()
    }
}

impl PodStatus {
    pub fn new() -> PodStatus {
        ::std::default::Default::default()
    }

    // optional string phase = 1;


    pub fn get_phase(&self) -> &str {
        match self.phase.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_phase(&mut self) {
        self.phase.clear();
    }

    pub fn has_phase(&self) -> bool {
        self.phase.is_some()
    }

    // Param is passed by value, moved
    pub fn set_phase(&mut self, v: ::std::string::String) {
        self.phase = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_phase(&mut self) -> &mut ::std::string::String {
        if self.phase.is_none() {
            self.phase.set_default();
        }
        self.phase.as_mut().unwrap()
    }

    // Take field
    pub fn take_phase(&mut self) -> ::std::string::String {
        self.phase.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .k8s.io.api.core.v1.PodCondition conditions = 2;


    pub fn get_conditions(&self) -> &[PodCondition] {
        &self.conditions
    }
    pub fn clear_conditions(&mut self) {
        self.conditions.clear();
    }

    // Param is passed by value, moved
    pub fn set_conditions(&mut self, v: ::protobuf::RepeatedField<PodCondition>) {
        self.conditions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_conditions(&mut self) -> &mut ::protobuf::RepeatedField<PodCondition> {
        &mut self.conditions
    }

    // Take field
    pub fn take_conditions(&mut self) -> ::protobuf::RepeatedField<PodCondition> {
        ::std::mem::replace(&mut self.conditions, ::protobuf::RepeatedField::new())
    }

    // optional string message = 3;


    pub fn get_message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string reason = 4;


    pub fn get_reason(&self) -> &str {
        match self.reason.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_reason(&mut self) {
        self.reason.clear();
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: ::std::string::String) {
        self.reason = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reason(&mut self) -> &mut ::std::string::String {
        if self.reason.is_none() {
            self.reason.set_default();
        }
        self.reason.as_mut().unwrap()
    }

    // Take field
    pub fn take_reason(&mut self) -> ::std::string::String {
        self.reason.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string nominatedNodeName = 11;


    pub fn get_nominatedNodeName(&self) -> &str {
        match self.nominatedNodeName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_nominatedNodeName(&mut self) {
        self.nominatedNodeName.clear();
    }

    pub fn has_nominatedNodeName(&self) -> bool {
        self.nominatedNodeName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nominatedNodeName(&mut self, v: ::std::string::String) {
        self.nominatedNodeName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nominatedNodeName(&mut self) -> &mut ::std::string::String {
        if self.nominatedNodeName.is_none() {
            self.nominatedNodeName.set_default();
        }
        self.nominatedNodeName.as_mut().unwrap()
    }

    // Take field
    pub fn take_nominatedNodeName(&mut self) -> ::std::string::String {
        self.nominatedNodeName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string hostIP = 5;


    pub fn get_hostIP(&self) -> &str {
        match self.hostIP.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_hostIP(&mut self) {
        self.hostIP.clear();
    }

    pub fn has_hostIP(&self) -> bool {
        self.hostIP.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hostIP(&mut self, v: ::std::string::String) {
        self.hostIP = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hostIP(&mut self) -> &mut ::std::string::String {
        if self.hostIP.is_none() {
            self.hostIP.set_default();
        }
        self.hostIP.as_mut().unwrap()
    }

    // Take field
    pub fn take_hostIP(&mut self) -> ::std::string::String {
        self.hostIP.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string podIP = 6;


    pub fn get_podIP(&self) -> &str {
        match self.podIP.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_podIP(&mut self) {
        self.podIP.clear();
    }

    pub fn has_podIP(&self) -> bool {
        self.podIP.is_some()
    }

    // Param is passed by value, moved
    pub fn set_podIP(&mut self, v: ::std::string::String) {
        self.podIP = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_podIP(&mut self) -> &mut ::std::string::String {
        if self.podIP.is_none() {
            self.podIP.set_default();
        }
        self.podIP.as_mut().unwrap()
    }

    // Take field
    pub fn take_podIP(&mut self) -> ::std::string::String {
        self.podIP.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .k8s.io.api.core.v1.PodIP podIPs = 12;


    pub fn get_podIPs(&self) -> &[PodIP] {
        &self.podIPs
    }
    pub fn clear_podIPs(&mut self) {
        self.podIPs.clear();
    }

    // Param is passed by value, moved
    pub fn set_podIPs(&mut self, v: ::protobuf::RepeatedField<PodIP>) {
        self.podIPs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_podIPs(&mut self) -> &mut ::protobuf::RepeatedField<PodIP> {
        &mut self.podIPs
    }

    // Take field
    pub fn take_podIPs(&mut self) -> ::protobuf::RepeatedField<PodIP> {
        ::std::mem::replace(&mut self.podIPs, ::protobuf::RepeatedField::new())
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time startTime = 7;


    pub fn get_startTime(&self) -> &super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time {
        self.startTime.as_ref().unwrap_or_else(|| <super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time as ::protobuf::Message>::default_instance())
    }
    pub fn clear_startTime(&mut self) {
        self.startTime.clear();
    }

    pub fn has_startTime(&self) -> bool {
        self.startTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_startTime(&mut self, v: super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time) {
        self.startTime = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_startTime(&mut self) -> &mut super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time {
        if self.startTime.is_none() {
            self.startTime.set_default();
        }
        self.startTime.as_mut().unwrap()
    }

    // Take field
    pub fn take_startTime(&mut self) -> super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time {
        self.startTime.take().unwrap_or_else(|| super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time::new())
    }

    // repeated .k8s.io.api.core.v1.ContainerStatus initContainerStatuses = 10;


    pub fn get_initContainerStatuses(&self) -> &[ContainerStatus] {
        &self.initContainerStatuses
    }
    pub fn clear_initContainerStatuses(&mut self) {
        self.initContainerStatuses.clear();
    }

    // Param is passed by value, moved
    pub fn set_initContainerStatuses(&mut self, v: ::protobuf::RepeatedField<ContainerStatus>) {
        self.initContainerStatuses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_initContainerStatuses(&mut self) -> &mut ::protobuf::RepeatedField<ContainerStatus> {
        &mut self.initContainerStatuses
    }

    // Take field
    pub fn take_initContainerStatuses(&mut self) -> ::protobuf::RepeatedField<ContainerStatus> {
        ::std::mem::replace(&mut self.initContainerStatuses, ::protobuf::RepeatedField::new())
    }

    // repeated .k8s.io.api.core.v1.ContainerStatus containerStatuses = 8;


    pub fn get_containerStatuses(&self) -> &[ContainerStatus] {
        &self.containerStatuses
    }
    pub fn clear_containerStatuses(&mut self) {
        self.containerStatuses.clear();
    }

    // Param is passed by value, moved
    pub fn set_containerStatuses(&mut self, v: ::protobuf::RepeatedField<ContainerStatus>) {
        self.containerStatuses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_containerStatuses(&mut self) -> &mut ::protobuf::RepeatedField<ContainerStatus> {
        &mut self.containerStatuses
    }

    // Take field
    pub fn take_containerStatuses(&mut self) -> ::protobuf::RepeatedField<ContainerStatus> {
        ::std::mem::replace(&mut self.containerStatuses, ::protobuf::RepeatedField::new())
    }

    // optional string qosClass = 9;


    pub fn get_qosClass(&self) -> &str {
        match self.qosClass.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_qosClass(&mut self) {
        self.qosClass.clear();
    }

    pub fn has_qosClass(&self) -> bool {
        self.qosClass.is_some()
    }

    // Param is passed by value, moved
    pub fn set_qosClass(&mut self, v: ::std::string::String) {
        self.qosClass = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_qosClass(&mut self) -> &mut ::std::string::String {
        if self.qosClass.is_none() {
            self.qosClass.set_default();
        }
        self.qosClass.as_mut().unwrap()
    }

    // Take field
    pub fn take_qosClass(&mut self) -> ::std::string::String {
        self.qosClass.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .k8s.io.api.core.v1.ContainerStatus ephemeralContainerStatuses = 13;


    pub fn get_ephemeralContainerStatuses(&self) -> &[ContainerStatus] {
        &self.ephemeralContainerStatuses
    }
    pub fn clear_ephemeralContainerStatuses(&mut self) {
        self.ephemeralContainerStatuses.clear();
    }

    // Param is passed by value, moved
    pub fn set_ephemeralContainerStatuses(&mut self, v: ::protobuf::RepeatedField<ContainerStatus>) {
        self.ephemeralContainerStatuses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ephemeralContainerStatuses(&mut self) -> &mut ::protobuf::RepeatedField<ContainerStatus> {
        &mut self.ephemeralContainerStatuses
    }

    // Take field
    pub fn take_ephemeralContainerStatuses(&mut self) -> ::protobuf::RepeatedField<ContainerStatus> {
        ::std::mem::replace(&mut self.ephemeralContainerStatuses, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PodStatus {
    fn is_initialized(&self) -> bool {
        for v in &self.conditions {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.podIPs {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.startTime {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.initContainerStatuses {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.containerStatuses {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ephemeralContainerStatuses {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.phase)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.conditions)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.message)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.reason)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.nominatedNodeName)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.hostIP)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.podIP)?;
                },
                12 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.podIPs)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.startTime)?;
                },
                10 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.initContainerStatuses)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.containerStatuses)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.qosClass)?;
                },
                13 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.ephemeralContainerStatuses)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.phase.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.conditions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.reason.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.nominatedNodeName.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        if let Some(ref v) = self.hostIP.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.podIP.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        for value in &self.podIPs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.startTime.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.initContainerStatuses {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.containerStatuses {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.qosClass.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        for value in &self.ephemeralContainerStatuses {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.phase.as_ref() {
            os.write_string(1, &v)?;
        }
        for v in &self.conditions {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.message.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.reason.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.nominatedNodeName.as_ref() {
            os.write_string(11, &v)?;
        }
        if let Some(ref v) = self.hostIP.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.podIP.as_ref() {
            os.write_string(6, &v)?;
        }
        for v in &self.podIPs {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.startTime.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.initContainerStatuses {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.containerStatuses {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.qosClass.as_ref() {
            os.write_string(9, &v)?;
        }
        for v in &self.ephemeralContainerStatuses {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PodStatus {
        PodStatus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "phase",
                |m: &PodStatus| { &m.phase },
                |m: &mut PodStatus| { &mut m.phase },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PodCondition>>(
                "conditions",
                |m: &PodStatus| { &m.conditions },
                |m: &mut PodStatus| { &mut m.conditions },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "message",
                |m: &PodStatus| { &m.message },
                |m: &mut PodStatus| { &mut m.message },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "reason",
                |m: &PodStatus| { &m.reason },
                |m: &mut PodStatus| { &mut m.reason },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "nominatedNodeName",
                |m: &PodStatus| { &m.nominatedNodeName },
                |m: &mut PodStatus| { &mut m.nominatedNodeName },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "hostIP",
                |m: &PodStatus| { &m.hostIP },
                |m: &mut PodStatus| { &mut m.hostIP },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "podIP",
                |m: &PodStatus| { &m.podIP },
                |m: &mut PodStatus| { &mut m.podIP },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PodIP>>(
                "podIPs",
                |m: &PodStatus| { &m.podIPs },
                |m: &mut PodStatus| { &mut m.podIPs },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time>>(
                "startTime",
                |m: &PodStatus| { &m.startTime },
                |m: &mut PodStatus| { &mut m.startTime },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ContainerStatus>>(
                "initContainerStatuses",
                |m: &PodStatus| { &m.initContainerStatuses },
                |m: &mut PodStatus| { &mut m.initContainerStatuses },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ContainerStatus>>(
                "containerStatuses",
                |m: &PodStatus| { &m.containerStatuses },
                |m: &mut PodStatus| { &mut m.containerStatuses },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "qosClass",
                |m: &PodStatus| { &m.qosClass },
                |m: &mut PodStatus| { &mut m.qosClass },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ContainerStatus>>(
                "ephemeralContainerStatuses",
                |m: &PodStatus| { &m.ephemeralContainerStatuses },
                |m: &mut PodStatus| { &mut m.ephemeralContainerStatuses },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PodStatus>(
                "PodStatus",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PodStatus {
        static instance: ::protobuf::rt::LazyV2<PodStatus> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PodStatus::new)
    }
}

impl ::protobuf::Clear for PodStatus {
    fn clear(&mut self) {
        self.phase.clear();
        self.conditions.clear();
        self.message.clear();
        self.reason.clear();
        self.nominatedNodeName.clear();
        self.hostIP.clear();
        self.podIP.clear();
        self.podIPs.clear();
        self.startTime.clear();
        self.initContainerStatuses.clear();
        self.containerStatuses.clear();
        self.qosClass.clear();
        self.ephemeralContainerStatuses.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PodStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PodStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PodStatusResult {
    // message fields
    pub metadata: ::protobuf::SingularPtrField<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta>,
    pub status: ::protobuf::SingularPtrField<PodStatus>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PodStatusResult {
    fn default() -> &'a PodStatusResult {
        <PodStatusResult as ::protobuf::Message>::default_instance()
    }
}

impl PodStatusResult {
    pub fn new() -> PodStatusResult {
        ::std::default::Default::default()
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;


    pub fn get_metadata(&self) -> &super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta::new())
    }

    // optional .k8s.io.api.core.v1.PodStatus status = 2;


    pub fn get_status(&self) -> &PodStatus {
        self.status.as_ref().unwrap_or_else(|| <PodStatus as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: PodStatus) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut PodStatus {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> PodStatus {
        self.status.take().unwrap_or_else(|| PodStatus::new())
    }
}

impl ::protobuf::Message for PodStatusResult {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PodStatusResult {
        PodStatusResult::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta>>(
                "metadata",
                |m: &PodStatusResult| { &m.metadata },
                |m: &mut PodStatusResult| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PodStatus>>(
                "status",
                |m: &PodStatusResult| { &m.status },
                |m: &mut PodStatusResult| { &mut m.status },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PodStatusResult>(
                "PodStatusResult",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PodStatusResult {
        static instance: ::protobuf::rt::LazyV2<PodStatusResult> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PodStatusResult::new)
    }
}

impl ::protobuf::Clear for PodStatusResult {
    fn clear(&mut self) {
        self.metadata.clear();
        self.status.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PodStatusResult {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PodStatusResult {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PodTemplate {
    // message fields
    pub metadata: ::protobuf::SingularPtrField<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta>,
    pub template: ::protobuf::SingularPtrField<PodTemplateSpec>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PodTemplate {
    fn default() -> &'a PodTemplate {
        <PodTemplate as ::protobuf::Message>::default_instance()
    }
}

impl PodTemplate {
    pub fn new() -> PodTemplate {
        ::std::default::Default::default()
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;


    pub fn get_metadata(&self) -> &super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta::new())
    }

    // optional .k8s.io.api.core.v1.PodTemplateSpec template = 2;


    pub fn get_template(&self) -> &PodTemplateSpec {
        self.template.as_ref().unwrap_or_else(|| <PodTemplateSpec as ::protobuf::Message>::default_instance())
    }
    pub fn clear_template(&mut self) {
        self.template.clear();
    }

    pub fn has_template(&self) -> bool {
        self.template.is_some()
    }

    // Param is passed by value, moved
    pub fn set_template(&mut self, v: PodTemplateSpec) {
        self.template = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_template(&mut self) -> &mut PodTemplateSpec {
        if self.template.is_none() {
            self.template.set_default();
        }
        self.template.as_mut().unwrap()
    }

    // Take field
    pub fn take_template(&mut self) -> PodTemplateSpec {
        self.template.take().unwrap_or_else(|| PodTemplateSpec::new())
    }
}

impl ::protobuf::Message for PodTemplate {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.template {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.template)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.template.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.template.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PodTemplate {
        PodTemplate::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta>>(
                "metadata",
                |m: &PodTemplate| { &m.metadata },
                |m: &mut PodTemplate| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PodTemplateSpec>>(
                "template",
                |m: &PodTemplate| { &m.template },
                |m: &mut PodTemplate| { &mut m.template },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PodTemplate>(
                "PodTemplate",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PodTemplate {
        static instance: ::protobuf::rt::LazyV2<PodTemplate> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PodTemplate::new)
    }
}

impl ::protobuf::Clear for PodTemplate {
    fn clear(&mut self) {
        self.metadata.clear();
        self.template.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PodTemplate {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PodTemplate {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PodTemplateList {
    // message fields
    pub metadata: ::protobuf::SingularPtrField<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta>,
    pub items: ::protobuf::RepeatedField<PodTemplate>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PodTemplateList {
    fn default() -> &'a PodTemplateList {
        <PodTemplateList as ::protobuf::Message>::default_instance()
    }
}

impl PodTemplateList {
    pub fn new() -> PodTemplateList {
        ::std::default::Default::default()
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;


    pub fn get_metadata(&self) -> &super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta {
        self.metadata.take().unwrap_or_else(|| super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta::new())
    }

    // repeated .k8s.io.api.core.v1.PodTemplate items = 2;


    pub fn get_items(&self) -> &[PodTemplate] {
        &self.items
    }
    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::protobuf::RepeatedField<PodTemplate>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::protobuf::RepeatedField<PodTemplate> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::protobuf::RepeatedField<PodTemplate> {
        ::std::mem::replace(&mut self.items, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PodTemplateList {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.items {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.items)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.items {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PodTemplateList {
        PodTemplateList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta>>(
                "metadata",
                |m: &PodTemplateList| { &m.metadata },
                |m: &mut PodTemplateList| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PodTemplate>>(
                "items",
                |m: &PodTemplateList| { &m.items },
                |m: &mut PodTemplateList| { &mut m.items },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PodTemplateList>(
                "PodTemplateList",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PodTemplateList {
        static instance: ::protobuf::rt::LazyV2<PodTemplateList> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PodTemplateList::new)
    }
}

impl ::protobuf::Clear for PodTemplateList {
    fn clear(&mut self) {
        self.metadata.clear();
        self.items.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PodTemplateList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PodTemplateList {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PodTemplateSpec {
    // message fields
    pub metadata: ::protobuf::SingularPtrField<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta>,
    pub spec: ::protobuf::SingularPtrField<PodSpec>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PodTemplateSpec {
    fn default() -> &'a PodTemplateSpec {
        <PodTemplateSpec as ::protobuf::Message>::default_instance()
    }
}

impl PodTemplateSpec {
    pub fn new() -> PodTemplateSpec {
        ::std::default::Default::default()
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;


    pub fn get_metadata(&self) -> &super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta::new())
    }

    // optional .k8s.io.api.core.v1.PodSpec spec = 2;


    pub fn get_spec(&self) -> &PodSpec {
        self.spec.as_ref().unwrap_or_else(|| <PodSpec as ::protobuf::Message>::default_instance())
    }
    pub fn clear_spec(&mut self) {
        self.spec.clear();
    }

    pub fn has_spec(&self) -> bool {
        self.spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spec(&mut self, v: PodSpec) {
        self.spec = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spec(&mut self) -> &mut PodSpec {
        if self.spec.is_none() {
            self.spec.set_default();
        }
        self.spec.as_mut().unwrap()
    }

    // Take field
    pub fn take_spec(&mut self) -> PodSpec {
        self.spec.take().unwrap_or_else(|| PodSpec::new())
    }
}

impl ::protobuf::Message for PodTemplateSpec {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.spec {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.spec)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.spec.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PodTemplateSpec {
        PodTemplateSpec::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta>>(
                "metadata",
                |m: &PodTemplateSpec| { &m.metadata },
                |m: &mut PodTemplateSpec| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PodSpec>>(
                "spec",
                |m: &PodTemplateSpec| { &m.spec },
                |m: &mut PodTemplateSpec| { &mut m.spec },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PodTemplateSpec>(
                "PodTemplateSpec",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PodTemplateSpec {
        static instance: ::protobuf::rt::LazyV2<PodTemplateSpec> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PodTemplateSpec::new)
    }
}

impl ::protobuf::Clear for PodTemplateSpec {
    fn clear(&mut self) {
        self.metadata.clear();
        self.spec.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PodTemplateSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PodTemplateSpec {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PortStatus {
    // message fields
    port: ::std::option::Option<i32>,
    protocol: ::protobuf::SingularField<::std::string::String>,
    error: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PortStatus {
    fn default() -> &'a PortStatus {
        <PortStatus as ::protobuf::Message>::default_instance()
    }
}

impl PortStatus {
    pub fn new() -> PortStatus {
        ::std::default::Default::default()
    }

    // optional int32 port = 1;


    pub fn get_port(&self) -> i32 {
        self.port.unwrap_or(0)
    }
    pub fn clear_port(&mut self) {
        self.port = ::std::option::Option::None;
    }

    pub fn has_port(&self) -> bool {
        self.port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_port(&mut self, v: i32) {
        self.port = ::std::option::Option::Some(v);
    }

    // optional string protocol = 2;


    pub fn get_protocol(&self) -> &str {
        match self.protocol.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_protocol(&mut self) {
        self.protocol.clear();
    }

    pub fn has_protocol(&self) -> bool {
        self.protocol.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protocol(&mut self, v: ::std::string::String) {
        self.protocol = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_protocol(&mut self) -> &mut ::std::string::String {
        if self.protocol.is_none() {
            self.protocol.set_default();
        }
        self.protocol.as_mut().unwrap()
    }

    // Take field
    pub fn take_protocol(&mut self) -> ::std::string::String {
        self.protocol.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string error = 3;


    pub fn get_error(&self) -> &str {
        match self.error.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_error(&mut self) {
        self.error.clear();
    }

    pub fn has_error(&self) -> bool {
        self.error.is_some()
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: ::std::string::String) {
        self.error = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_error(&mut self) -> &mut ::std::string::String {
        if self.error.is_none() {
            self.error.set_default();
        }
        self.error.as_mut().unwrap()
    }

    // Take field
    pub fn take_error(&mut self) -> ::std::string::String {
        self.error.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for PortStatus {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.port = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.protocol)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.error)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.port {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.protocol.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.error.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.port {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.protocol.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.error.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PortStatus {
        PortStatus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "port",
                |m: &PortStatus| { &m.port },
                |m: &mut PortStatus| { &mut m.port },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "protocol",
                |m: &PortStatus| { &m.protocol },
                |m: &mut PortStatus| { &mut m.protocol },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "error",
                |m: &PortStatus| { &m.error },
                |m: &mut PortStatus| { &mut m.error },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PortStatus>(
                "PortStatus",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PortStatus {
        static instance: ::protobuf::rt::LazyV2<PortStatus> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PortStatus::new)
    }
}

impl ::protobuf::Clear for PortStatus {
    fn clear(&mut self) {
        self.port = ::std::option::Option::None;
        self.protocol.clear();
        self.error.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PortStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PortStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PortworxVolumeSource {
    // message fields
    volumeID: ::protobuf::SingularField<::std::string::String>,
    fsType: ::protobuf::SingularField<::std::string::String>,
    readOnly: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PortworxVolumeSource {
    fn default() -> &'a PortworxVolumeSource {
        <PortworxVolumeSource as ::protobuf::Message>::default_instance()
    }
}

impl PortworxVolumeSource {
    pub fn new() -> PortworxVolumeSource {
        ::std::default::Default::default()
    }

    // optional string volumeID = 1;


    pub fn get_volumeID(&self) -> &str {
        match self.volumeID.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_volumeID(&mut self) {
        self.volumeID.clear();
    }

    pub fn has_volumeID(&self) -> bool {
        self.volumeID.is_some()
    }

    // Param is passed by value, moved
    pub fn set_volumeID(&mut self, v: ::std::string::String) {
        self.volumeID = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_volumeID(&mut self) -> &mut ::std::string::String {
        if self.volumeID.is_none() {
            self.volumeID.set_default();
        }
        self.volumeID.as_mut().unwrap()
    }

    // Take field
    pub fn take_volumeID(&mut self) -> ::std::string::String {
        self.volumeID.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string fsType = 2;


    pub fn get_fsType(&self) -> &str {
        match self.fsType.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_fsType(&mut self) {
        self.fsType.clear();
    }

    pub fn has_fsType(&self) -> bool {
        self.fsType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fsType(&mut self, v: ::std::string::String) {
        self.fsType = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fsType(&mut self) -> &mut ::std::string::String {
        if self.fsType.is_none() {
            self.fsType.set_default();
        }
        self.fsType.as_mut().unwrap()
    }

    // Take field
    pub fn take_fsType(&mut self) -> ::std::string::String {
        self.fsType.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool readOnly = 3;


    pub fn get_readOnly(&self) -> bool {
        self.readOnly.unwrap_or(false)
    }
    pub fn clear_readOnly(&mut self) {
        self.readOnly = ::std::option::Option::None;
    }

    pub fn has_readOnly(&self) -> bool {
        self.readOnly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readOnly(&mut self, v: bool) {
        self.readOnly = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for PortworxVolumeSource {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.volumeID)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.fsType)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.readOnly = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.volumeID.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.fsType.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.readOnly {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.volumeID.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.fsType.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.readOnly {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PortworxVolumeSource {
        PortworxVolumeSource::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "volumeID",
                |m: &PortworxVolumeSource| { &m.volumeID },
                |m: &mut PortworxVolumeSource| { &mut m.volumeID },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "fsType",
                |m: &PortworxVolumeSource| { &m.fsType },
                |m: &mut PortworxVolumeSource| { &mut m.fsType },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "readOnly",
                |m: &PortworxVolumeSource| { &m.readOnly },
                |m: &mut PortworxVolumeSource| { &mut m.readOnly },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PortworxVolumeSource>(
                "PortworxVolumeSource",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PortworxVolumeSource {
        static instance: ::protobuf::rt::LazyV2<PortworxVolumeSource> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PortworxVolumeSource::new)
    }
}

impl ::protobuf::Clear for PortworxVolumeSource {
    fn clear(&mut self) {
        self.volumeID.clear();
        self.fsType.clear();
        self.readOnly = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PortworxVolumeSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PortworxVolumeSource {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Preconditions {
    // message fields
    uid: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Preconditions {
    fn default() -> &'a Preconditions {
        <Preconditions as ::protobuf::Message>::default_instance()
    }
}

impl Preconditions {
    pub fn new() -> Preconditions {
        ::std::default::Default::default()
    }

    // optional string uid = 1;


    pub fn get_uid(&self) -> &str {
        match self.uid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_uid(&mut self) {
        self.uid.clear();
    }

    pub fn has_uid(&self) -> bool {
        self.uid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_uid(&mut self, v: ::std::string::String) {
        self.uid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uid(&mut self) -> &mut ::std::string::String {
        if self.uid.is_none() {
            self.uid.set_default();
        }
        self.uid.as_mut().unwrap()
    }

    // Take field
    pub fn take_uid(&mut self) -> ::std::string::String {
        self.uid.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for Preconditions {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.uid)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.uid.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.uid.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Preconditions {
        Preconditions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "uid",
                |m: &Preconditions| { &m.uid },
                |m: &mut Preconditions| { &mut m.uid },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Preconditions>(
                "Preconditions",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Preconditions {
        static instance: ::protobuf::rt::LazyV2<Preconditions> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Preconditions::new)
    }
}

impl ::protobuf::Clear for Preconditions {
    fn clear(&mut self) {
        self.uid.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Preconditions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Preconditions {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PreferAvoidPodsEntry {
    // message fields
    pub podSignature: ::protobuf::SingularPtrField<PodSignature>,
    pub evictionTime: ::protobuf::SingularPtrField<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time>,
    reason: ::protobuf::SingularField<::std::string::String>,
    message: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PreferAvoidPodsEntry {
    fn default() -> &'a PreferAvoidPodsEntry {
        <PreferAvoidPodsEntry as ::protobuf::Message>::default_instance()
    }
}

impl PreferAvoidPodsEntry {
    pub fn new() -> PreferAvoidPodsEntry {
        ::std::default::Default::default()
    }

    // optional .k8s.io.api.core.v1.PodSignature podSignature = 1;


    pub fn get_podSignature(&self) -> &PodSignature {
        self.podSignature.as_ref().unwrap_or_else(|| <PodSignature as ::protobuf::Message>::default_instance())
    }
    pub fn clear_podSignature(&mut self) {
        self.podSignature.clear();
    }

    pub fn has_podSignature(&self) -> bool {
        self.podSignature.is_some()
    }

    // Param is passed by value, moved
    pub fn set_podSignature(&mut self, v: PodSignature) {
        self.podSignature = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_podSignature(&mut self) -> &mut PodSignature {
        if self.podSignature.is_none() {
            self.podSignature.set_default();
        }
        self.podSignature.as_mut().unwrap()
    }

    // Take field
    pub fn take_podSignature(&mut self) -> PodSignature {
        self.podSignature.take().unwrap_or_else(|| PodSignature::new())
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time evictionTime = 2;


    pub fn get_evictionTime(&self) -> &super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time {
        self.evictionTime.as_ref().unwrap_or_else(|| <super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time as ::protobuf::Message>::default_instance())
    }
    pub fn clear_evictionTime(&mut self) {
        self.evictionTime.clear();
    }

    pub fn has_evictionTime(&self) -> bool {
        self.evictionTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_evictionTime(&mut self, v: super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time) {
        self.evictionTime = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_evictionTime(&mut self) -> &mut super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time {
        if self.evictionTime.is_none() {
            self.evictionTime.set_default();
        }
        self.evictionTime.as_mut().unwrap()
    }

    // Take field
    pub fn take_evictionTime(&mut self) -> super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time {
        self.evictionTime.take().unwrap_or_else(|| super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time::new())
    }

    // optional string reason = 3;


    pub fn get_reason(&self) -> &str {
        match self.reason.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_reason(&mut self) {
        self.reason.clear();
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: ::std::string::String) {
        self.reason = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reason(&mut self) -> &mut ::std::string::String {
        if self.reason.is_none() {
            self.reason.set_default();
        }
        self.reason.as_mut().unwrap()
    }

    // Take field
    pub fn take_reason(&mut self) -> ::std::string::String {
        self.reason.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string message = 4;


    pub fn get_message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for PreferAvoidPodsEntry {
    fn is_initialized(&self) -> bool {
        for v in &self.podSignature {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.evictionTime {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.podSignature)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.evictionTime)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.reason)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.podSignature.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.evictionTime.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.reason.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.podSignature.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.evictionTime.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.reason.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.message.as_ref() {
            os.write_string(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PreferAvoidPodsEntry {
        PreferAvoidPodsEntry::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PodSignature>>(
                "podSignature",
                |m: &PreferAvoidPodsEntry| { &m.podSignature },
                |m: &mut PreferAvoidPodsEntry| { &mut m.podSignature },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time>>(
                "evictionTime",
                |m: &PreferAvoidPodsEntry| { &m.evictionTime },
                |m: &mut PreferAvoidPodsEntry| { &mut m.evictionTime },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "reason",
                |m: &PreferAvoidPodsEntry| { &m.reason },
                |m: &mut PreferAvoidPodsEntry| { &mut m.reason },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "message",
                |m: &PreferAvoidPodsEntry| { &m.message },
                |m: &mut PreferAvoidPodsEntry| { &mut m.message },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PreferAvoidPodsEntry>(
                "PreferAvoidPodsEntry",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PreferAvoidPodsEntry {
        static instance: ::protobuf::rt::LazyV2<PreferAvoidPodsEntry> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PreferAvoidPodsEntry::new)
    }
}

impl ::protobuf::Clear for PreferAvoidPodsEntry {
    fn clear(&mut self) {
        self.podSignature.clear();
        self.evictionTime.clear();
        self.reason.clear();
        self.message.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PreferAvoidPodsEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PreferAvoidPodsEntry {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PreferredSchedulingTerm {
    // message fields
    weight: ::std::option::Option<i32>,
    pub preference: ::protobuf::SingularPtrField<NodeSelectorTerm>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PreferredSchedulingTerm {
    fn default() -> &'a PreferredSchedulingTerm {
        <PreferredSchedulingTerm as ::protobuf::Message>::default_instance()
    }
}

impl PreferredSchedulingTerm {
    pub fn new() -> PreferredSchedulingTerm {
        ::std::default::Default::default()
    }

    // optional int32 weight = 1;


    pub fn get_weight(&self) -> i32 {
        self.weight.unwrap_or(0)
    }
    pub fn clear_weight(&mut self) {
        self.weight = ::std::option::Option::None;
    }

    pub fn has_weight(&self) -> bool {
        self.weight.is_some()
    }

    // Param is passed by value, moved
    pub fn set_weight(&mut self, v: i32) {
        self.weight = ::std::option::Option::Some(v);
    }

    // optional .k8s.io.api.core.v1.NodeSelectorTerm preference = 2;


    pub fn get_preference(&self) -> &NodeSelectorTerm {
        self.preference.as_ref().unwrap_or_else(|| <NodeSelectorTerm as ::protobuf::Message>::default_instance())
    }
    pub fn clear_preference(&mut self) {
        self.preference.clear();
    }

    pub fn has_preference(&self) -> bool {
        self.preference.is_some()
    }

    // Param is passed by value, moved
    pub fn set_preference(&mut self, v: NodeSelectorTerm) {
        self.preference = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_preference(&mut self) -> &mut NodeSelectorTerm {
        if self.preference.is_none() {
            self.preference.set_default();
        }
        self.preference.as_mut().unwrap()
    }

    // Take field
    pub fn take_preference(&mut self) -> NodeSelectorTerm {
        self.preference.take().unwrap_or_else(|| NodeSelectorTerm::new())
    }
}

impl ::protobuf::Message for PreferredSchedulingTerm {
    fn is_initialized(&self) -> bool {
        for v in &self.preference {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.weight = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.preference)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.weight {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.preference.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.weight {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.preference.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PreferredSchedulingTerm {
        PreferredSchedulingTerm::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "weight",
                |m: &PreferredSchedulingTerm| { &m.weight },
                |m: &mut PreferredSchedulingTerm| { &mut m.weight },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NodeSelectorTerm>>(
                "preference",
                |m: &PreferredSchedulingTerm| { &m.preference },
                |m: &mut PreferredSchedulingTerm| { &mut m.preference },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PreferredSchedulingTerm>(
                "PreferredSchedulingTerm",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PreferredSchedulingTerm {
        static instance: ::protobuf::rt::LazyV2<PreferredSchedulingTerm> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PreferredSchedulingTerm::new)
    }
}

impl ::protobuf::Clear for PreferredSchedulingTerm {
    fn clear(&mut self) {
        self.weight = ::std::option::Option::None;
        self.preference.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PreferredSchedulingTerm {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PreferredSchedulingTerm {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Probe {
    // message fields
    pub handler: ::protobuf::SingularPtrField<Handler>,
    initialDelaySeconds: ::std::option::Option<i32>,
    timeoutSeconds: ::std::option::Option<i32>,
    periodSeconds: ::std::option::Option<i32>,
    successThreshold: ::std::option::Option<i32>,
    failureThreshold: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Probe {
    fn default() -> &'a Probe {
        <Probe as ::protobuf::Message>::default_instance()
    }
}

impl Probe {
    pub fn new() -> Probe {
        ::std::default::Default::default()
    }

    // optional .k8s.io.api.core.v1.Handler handler = 1;


    pub fn get_handler(&self) -> &Handler {
        self.handler.as_ref().unwrap_or_else(|| <Handler as ::protobuf::Message>::default_instance())
    }
    pub fn clear_handler(&mut self) {
        self.handler.clear();
    }

    pub fn has_handler(&self) -> bool {
        self.handler.is_some()
    }

    // Param is passed by value, moved
    pub fn set_handler(&mut self, v: Handler) {
        self.handler = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_handler(&mut self) -> &mut Handler {
        if self.handler.is_none() {
            self.handler.set_default();
        }
        self.handler.as_mut().unwrap()
    }

    // Take field
    pub fn take_handler(&mut self) -> Handler {
        self.handler.take().unwrap_or_else(|| Handler::new())
    }

    // optional int32 initialDelaySeconds = 2;


    pub fn get_initialDelaySeconds(&self) -> i32 {
        self.initialDelaySeconds.unwrap_or(0)
    }
    pub fn clear_initialDelaySeconds(&mut self) {
        self.initialDelaySeconds = ::std::option::Option::None;
    }

    pub fn has_initialDelaySeconds(&self) -> bool {
        self.initialDelaySeconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_initialDelaySeconds(&mut self, v: i32) {
        self.initialDelaySeconds = ::std::option::Option::Some(v);
    }

    // optional int32 timeoutSeconds = 3;


    pub fn get_timeoutSeconds(&self) -> i32 {
        self.timeoutSeconds.unwrap_or(0)
    }
    pub fn clear_timeoutSeconds(&mut self) {
        self.timeoutSeconds = ::std::option::Option::None;
    }

    pub fn has_timeoutSeconds(&self) -> bool {
        self.timeoutSeconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timeoutSeconds(&mut self, v: i32) {
        self.timeoutSeconds = ::std::option::Option::Some(v);
    }

    // optional int32 periodSeconds = 4;


    pub fn get_periodSeconds(&self) -> i32 {
        self.periodSeconds.unwrap_or(0)
    }
    pub fn clear_periodSeconds(&mut self) {
        self.periodSeconds = ::std::option::Option::None;
    }

    pub fn has_periodSeconds(&self) -> bool {
        self.periodSeconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_periodSeconds(&mut self, v: i32) {
        self.periodSeconds = ::std::option::Option::Some(v);
    }

    // optional int32 successThreshold = 5;


    pub fn get_successThreshold(&self) -> i32 {
        self.successThreshold.unwrap_or(0)
    }
    pub fn clear_successThreshold(&mut self) {
        self.successThreshold = ::std::option::Option::None;
    }

    pub fn has_successThreshold(&self) -> bool {
        self.successThreshold.is_some()
    }

    // Param is passed by value, moved
    pub fn set_successThreshold(&mut self, v: i32) {
        self.successThreshold = ::std::option::Option::Some(v);
    }

    // optional int32 failureThreshold = 6;


    pub fn get_failureThreshold(&self) -> i32 {
        self.failureThreshold.unwrap_or(0)
    }
    pub fn clear_failureThreshold(&mut self) {
        self.failureThreshold = ::std::option::Option::None;
    }

    pub fn has_failureThreshold(&self) -> bool {
        self.failureThreshold.is_some()
    }

    // Param is passed by value, moved
    pub fn set_failureThreshold(&mut self, v: i32) {
        self.failureThreshold = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for Probe {
    fn is_initialized(&self) -> bool {
        for v in &self.handler {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.handler)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.initialDelaySeconds = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.timeoutSeconds = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.periodSeconds = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.successThreshold = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.failureThreshold = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.handler.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.initialDelaySeconds {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.timeoutSeconds {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.periodSeconds {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.successThreshold {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.failureThreshold {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.handler.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.initialDelaySeconds {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.timeoutSeconds {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.periodSeconds {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.successThreshold {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.failureThreshold {
            os.write_int32(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Probe {
        Probe::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Handler>>(
                "handler",
                |m: &Probe| { &m.handler },
                |m: &mut Probe| { &mut m.handler },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "initialDelaySeconds",
                |m: &Probe| { &m.initialDelaySeconds },
                |m: &mut Probe| { &mut m.initialDelaySeconds },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "timeoutSeconds",
                |m: &Probe| { &m.timeoutSeconds },
                |m: &mut Probe| { &mut m.timeoutSeconds },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "periodSeconds",
                |m: &Probe| { &m.periodSeconds },
                |m: &mut Probe| { &mut m.periodSeconds },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "successThreshold",
                |m: &Probe| { &m.successThreshold },
                |m: &mut Probe| { &mut m.successThreshold },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "failureThreshold",
                |m: &Probe| { &m.failureThreshold },
                |m: &mut Probe| { &mut m.failureThreshold },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Probe>(
                "Probe",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Probe {
        static instance: ::protobuf::rt::LazyV2<Probe> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Probe::new)
    }
}

impl ::protobuf::Clear for Probe {
    fn clear(&mut self) {
        self.handler.clear();
        self.initialDelaySeconds = ::std::option::Option::None;
        self.timeoutSeconds = ::std::option::Option::None;
        self.periodSeconds = ::std::option::Option::None;
        self.successThreshold = ::std::option::Option::None;
        self.failureThreshold = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Probe {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Probe {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ProjectedVolumeSource {
    // message fields
    pub sources: ::protobuf::RepeatedField<VolumeProjection>,
    defaultMode: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ProjectedVolumeSource {
    fn default() -> &'a ProjectedVolumeSource {
        <ProjectedVolumeSource as ::protobuf::Message>::default_instance()
    }
}

impl ProjectedVolumeSource {
    pub fn new() -> ProjectedVolumeSource {
        ::std::default::Default::default()
    }

    // repeated .k8s.io.api.core.v1.VolumeProjection sources = 1;


    pub fn get_sources(&self) -> &[VolumeProjection] {
        &self.sources
    }
    pub fn clear_sources(&mut self) {
        self.sources.clear();
    }

    // Param is passed by value, moved
    pub fn set_sources(&mut self, v: ::protobuf::RepeatedField<VolumeProjection>) {
        self.sources = v;
    }

    // Mutable pointer to the field.
    pub fn mut_sources(&mut self) -> &mut ::protobuf::RepeatedField<VolumeProjection> {
        &mut self.sources
    }

    // Take field
    pub fn take_sources(&mut self) -> ::protobuf::RepeatedField<VolumeProjection> {
        ::std::mem::replace(&mut self.sources, ::protobuf::RepeatedField::new())
    }

    // optional int32 defaultMode = 2;


    pub fn get_defaultMode(&self) -> i32 {
        self.defaultMode.unwrap_or(0)
    }
    pub fn clear_defaultMode(&mut self) {
        self.defaultMode = ::std::option::Option::None;
    }

    pub fn has_defaultMode(&self) -> bool {
        self.defaultMode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_defaultMode(&mut self, v: i32) {
        self.defaultMode = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ProjectedVolumeSource {
    fn is_initialized(&self) -> bool {
        for v in &self.sources {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.sources)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.defaultMode = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.sources {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.defaultMode {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.sources {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.defaultMode {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ProjectedVolumeSource {
        ProjectedVolumeSource::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<VolumeProjection>>(
                "sources",
                |m: &ProjectedVolumeSource| { &m.sources },
                |m: &mut ProjectedVolumeSource| { &mut m.sources },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "defaultMode",
                |m: &ProjectedVolumeSource| { &m.defaultMode },
                |m: &mut ProjectedVolumeSource| { &mut m.defaultMode },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ProjectedVolumeSource>(
                "ProjectedVolumeSource",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ProjectedVolumeSource {
        static instance: ::protobuf::rt::LazyV2<ProjectedVolumeSource> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ProjectedVolumeSource::new)
    }
}

impl ::protobuf::Clear for ProjectedVolumeSource {
    fn clear(&mut self) {
        self.sources.clear();
        self.defaultMode = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ProjectedVolumeSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ProjectedVolumeSource {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct QuobyteVolumeSource {
    // message fields
    registry: ::protobuf::SingularField<::std::string::String>,
    volume: ::protobuf::SingularField<::std::string::String>,
    readOnly: ::std::option::Option<bool>,
    user: ::protobuf::SingularField<::std::string::String>,
    group: ::protobuf::SingularField<::std::string::String>,
    tenant: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a QuobyteVolumeSource {
    fn default() -> &'a QuobyteVolumeSource {
        <QuobyteVolumeSource as ::protobuf::Message>::default_instance()
    }
}

impl QuobyteVolumeSource {
    pub fn new() -> QuobyteVolumeSource {
        ::std::default::Default::default()
    }

    // optional string registry = 1;


    pub fn get_registry(&self) -> &str {
        match self.registry.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_registry(&mut self) {
        self.registry.clear();
    }

    pub fn has_registry(&self) -> bool {
        self.registry.is_some()
    }

    // Param is passed by value, moved
    pub fn set_registry(&mut self, v: ::std::string::String) {
        self.registry = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_registry(&mut self) -> &mut ::std::string::String {
        if self.registry.is_none() {
            self.registry.set_default();
        }
        self.registry.as_mut().unwrap()
    }

    // Take field
    pub fn take_registry(&mut self) -> ::std::string::String {
        self.registry.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string volume = 2;


    pub fn get_volume(&self) -> &str {
        match self.volume.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_volume(&mut self) {
        self.volume.clear();
    }

    pub fn has_volume(&self) -> bool {
        self.volume.is_some()
    }

    // Param is passed by value, moved
    pub fn set_volume(&mut self, v: ::std::string::String) {
        self.volume = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_volume(&mut self) -> &mut ::std::string::String {
        if self.volume.is_none() {
            self.volume.set_default();
        }
        self.volume.as_mut().unwrap()
    }

    // Take field
    pub fn take_volume(&mut self) -> ::std::string::String {
        self.volume.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool readOnly = 3;


    pub fn get_readOnly(&self) -> bool {
        self.readOnly.unwrap_or(false)
    }
    pub fn clear_readOnly(&mut self) {
        self.readOnly = ::std::option::Option::None;
    }

    pub fn has_readOnly(&self) -> bool {
        self.readOnly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readOnly(&mut self, v: bool) {
        self.readOnly = ::std::option::Option::Some(v);
    }

    // optional string user = 4;


    pub fn get_user(&self) -> &str {
        match self.user.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_user(&mut self) {
        self.user.clear();
    }

    pub fn has_user(&self) -> bool {
        self.user.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user(&mut self, v: ::std::string::String) {
        self.user = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user(&mut self) -> &mut ::std::string::String {
        if self.user.is_none() {
            self.user.set_default();
        }
        self.user.as_mut().unwrap()
    }

    // Take field
    pub fn take_user(&mut self) -> ::std::string::String {
        self.user.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string group = 5;


    pub fn get_group(&self) -> &str {
        match self.group.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_group(&mut self) {
        self.group.clear();
    }

    pub fn has_group(&self) -> bool {
        self.group.is_some()
    }

    // Param is passed by value, moved
    pub fn set_group(&mut self, v: ::std::string::String) {
        self.group = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_group(&mut self) -> &mut ::std::string::String {
        if self.group.is_none() {
            self.group.set_default();
        }
        self.group.as_mut().unwrap()
    }

    // Take field
    pub fn take_group(&mut self) -> ::std::string::String {
        self.group.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string tenant = 6;


    pub fn get_tenant(&self) -> &str {
        match self.tenant.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_tenant(&mut self) {
        self.tenant.clear();
    }

    pub fn has_tenant(&self) -> bool {
        self.tenant.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tenant(&mut self, v: ::std::string::String) {
        self.tenant = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tenant(&mut self) -> &mut ::std::string::String {
        if self.tenant.is_none() {
            self.tenant.set_default();
        }
        self.tenant.as_mut().unwrap()
    }

    // Take field
    pub fn take_tenant(&mut self) -> ::std::string::String {
        self.tenant.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for QuobyteVolumeSource {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.registry)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.volume)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.readOnly = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.user)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.group)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.tenant)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.registry.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.volume.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.readOnly {
            my_size += 2;
        }
        if let Some(ref v) = self.user.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.group.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.tenant.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.registry.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.volume.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.readOnly {
            os.write_bool(3, v)?;
        }
        if let Some(ref v) = self.user.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.group.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.tenant.as_ref() {
            os.write_string(6, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> QuobyteVolumeSource {
        QuobyteVolumeSource::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "registry",
                |m: &QuobyteVolumeSource| { &m.registry },
                |m: &mut QuobyteVolumeSource| { &mut m.registry },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "volume",
                |m: &QuobyteVolumeSource| { &m.volume },
                |m: &mut QuobyteVolumeSource| { &mut m.volume },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "readOnly",
                |m: &QuobyteVolumeSource| { &m.readOnly },
                |m: &mut QuobyteVolumeSource| { &mut m.readOnly },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "user",
                |m: &QuobyteVolumeSource| { &m.user },
                |m: &mut QuobyteVolumeSource| { &mut m.user },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "group",
                |m: &QuobyteVolumeSource| { &m.group },
                |m: &mut QuobyteVolumeSource| { &mut m.group },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "tenant",
                |m: &QuobyteVolumeSource| { &m.tenant },
                |m: &mut QuobyteVolumeSource| { &mut m.tenant },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<QuobyteVolumeSource>(
                "QuobyteVolumeSource",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static QuobyteVolumeSource {
        static instance: ::protobuf::rt::LazyV2<QuobyteVolumeSource> = ::protobuf::rt::LazyV2::INIT;
        instance.get(QuobyteVolumeSource::new)
    }
}

impl ::protobuf::Clear for QuobyteVolumeSource {
    fn clear(&mut self) {
        self.registry.clear();
        self.volume.clear();
        self.readOnly = ::std::option::Option::None;
        self.user.clear();
        self.group.clear();
        self.tenant.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for QuobyteVolumeSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for QuobyteVolumeSource {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RBDPersistentVolumeSource {
    // message fields
    pub monitors: ::protobuf::RepeatedField<::std::string::String>,
    image: ::protobuf::SingularField<::std::string::String>,
    fsType: ::protobuf::SingularField<::std::string::String>,
    pool: ::protobuf::SingularField<::std::string::String>,
    user: ::protobuf::SingularField<::std::string::String>,
    keyring: ::protobuf::SingularField<::std::string::String>,
    pub secretRef: ::protobuf::SingularPtrField<SecretReference>,
    readOnly: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RBDPersistentVolumeSource {
    fn default() -> &'a RBDPersistentVolumeSource {
        <RBDPersistentVolumeSource as ::protobuf::Message>::default_instance()
    }
}

impl RBDPersistentVolumeSource {
    pub fn new() -> RBDPersistentVolumeSource {
        ::std::default::Default::default()
    }

    // repeated string monitors = 1;


    pub fn get_monitors(&self) -> &[::std::string::String] {
        &self.monitors
    }
    pub fn clear_monitors(&mut self) {
        self.monitors.clear();
    }

    // Param is passed by value, moved
    pub fn set_monitors(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.monitors = v;
    }

    // Mutable pointer to the field.
    pub fn mut_monitors(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.monitors
    }

    // Take field
    pub fn take_monitors(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.monitors, ::protobuf::RepeatedField::new())
    }

    // optional string image = 2;


    pub fn get_image(&self) -> &str {
        match self.image.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_image(&mut self) {
        self.image.clear();
    }

    pub fn has_image(&self) -> bool {
        self.image.is_some()
    }

    // Param is passed by value, moved
    pub fn set_image(&mut self, v: ::std::string::String) {
        self.image = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_image(&mut self) -> &mut ::std::string::String {
        if self.image.is_none() {
            self.image.set_default();
        }
        self.image.as_mut().unwrap()
    }

    // Take field
    pub fn take_image(&mut self) -> ::std::string::String {
        self.image.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string fsType = 3;


    pub fn get_fsType(&self) -> &str {
        match self.fsType.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_fsType(&mut self) {
        self.fsType.clear();
    }

    pub fn has_fsType(&self) -> bool {
        self.fsType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fsType(&mut self, v: ::std::string::String) {
        self.fsType = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fsType(&mut self) -> &mut ::std::string::String {
        if self.fsType.is_none() {
            self.fsType.set_default();
        }
        self.fsType.as_mut().unwrap()
    }

    // Take field
    pub fn take_fsType(&mut self) -> ::std::string::String {
        self.fsType.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string pool = 4;


    pub fn get_pool(&self) -> &str {
        match self.pool.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_pool(&mut self) {
        self.pool.clear();
    }

    pub fn has_pool(&self) -> bool {
        self.pool.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pool(&mut self, v: ::std::string::String) {
        self.pool = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pool(&mut self) -> &mut ::std::string::String {
        if self.pool.is_none() {
            self.pool.set_default();
        }
        self.pool.as_mut().unwrap()
    }

    // Take field
    pub fn take_pool(&mut self) -> ::std::string::String {
        self.pool.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string user = 5;


    pub fn get_user(&self) -> &str {
        match self.user.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_user(&mut self) {
        self.user.clear();
    }

    pub fn has_user(&self) -> bool {
        self.user.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user(&mut self, v: ::std::string::String) {
        self.user = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user(&mut self) -> &mut ::std::string::String {
        if self.user.is_none() {
            self.user.set_default();
        }
        self.user.as_mut().unwrap()
    }

    // Take field
    pub fn take_user(&mut self) -> ::std::string::String {
        self.user.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string keyring = 6;


    pub fn get_keyring(&self) -> &str {
        match self.keyring.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_keyring(&mut self) {
        self.keyring.clear();
    }

    pub fn has_keyring(&self) -> bool {
        self.keyring.is_some()
    }

    // Param is passed by value, moved
    pub fn set_keyring(&mut self, v: ::std::string::String) {
        self.keyring = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_keyring(&mut self) -> &mut ::std::string::String {
        if self.keyring.is_none() {
            self.keyring.set_default();
        }
        self.keyring.as_mut().unwrap()
    }

    // Take field
    pub fn take_keyring(&mut self) -> ::std::string::String {
        self.keyring.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .k8s.io.api.core.v1.SecretReference secretRef = 7;


    pub fn get_secretRef(&self) -> &SecretReference {
        self.secretRef.as_ref().unwrap_or_else(|| <SecretReference as ::protobuf::Message>::default_instance())
    }
    pub fn clear_secretRef(&mut self) {
        self.secretRef.clear();
    }

    pub fn has_secretRef(&self) -> bool {
        self.secretRef.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secretRef(&mut self, v: SecretReference) {
        self.secretRef = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_secretRef(&mut self) -> &mut SecretReference {
        if self.secretRef.is_none() {
            self.secretRef.set_default();
        }
        self.secretRef.as_mut().unwrap()
    }

    // Take field
    pub fn take_secretRef(&mut self) -> SecretReference {
        self.secretRef.take().unwrap_or_else(|| SecretReference::new())
    }

    // optional bool readOnly = 8;


    pub fn get_readOnly(&self) -> bool {
        self.readOnly.unwrap_or(false)
    }
    pub fn clear_readOnly(&mut self) {
        self.readOnly = ::std::option::Option::None;
    }

    pub fn has_readOnly(&self) -> bool {
        self.readOnly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readOnly(&mut self, v: bool) {
        self.readOnly = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for RBDPersistentVolumeSource {
    fn is_initialized(&self) -> bool {
        for v in &self.secretRef {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.monitors)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.image)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.fsType)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.pool)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.user)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.keyring)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.secretRef)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.readOnly = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.monitors {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if let Some(ref v) = self.image.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.fsType.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.pool.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.user.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.keyring.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(ref v) = self.secretRef.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.readOnly {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.monitors {
            os.write_string(1, &v)?;
        };
        if let Some(ref v) = self.image.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.fsType.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.pool.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.user.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.keyring.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(ref v) = self.secretRef.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.readOnly {
            os.write_bool(8, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RBDPersistentVolumeSource {
        RBDPersistentVolumeSource::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "monitors",
                |m: &RBDPersistentVolumeSource| { &m.monitors },
                |m: &mut RBDPersistentVolumeSource| { &mut m.monitors },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "image",
                |m: &RBDPersistentVolumeSource| { &m.image },
                |m: &mut RBDPersistentVolumeSource| { &mut m.image },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "fsType",
                |m: &RBDPersistentVolumeSource| { &m.fsType },
                |m: &mut RBDPersistentVolumeSource| { &mut m.fsType },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "pool",
                |m: &RBDPersistentVolumeSource| { &m.pool },
                |m: &mut RBDPersistentVolumeSource| { &mut m.pool },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "user",
                |m: &RBDPersistentVolumeSource| { &m.user },
                |m: &mut RBDPersistentVolumeSource| { &mut m.user },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "keyring",
                |m: &RBDPersistentVolumeSource| { &m.keyring },
                |m: &mut RBDPersistentVolumeSource| { &mut m.keyring },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SecretReference>>(
                "secretRef",
                |m: &RBDPersistentVolumeSource| { &m.secretRef },
                |m: &mut RBDPersistentVolumeSource| { &mut m.secretRef },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "readOnly",
                |m: &RBDPersistentVolumeSource| { &m.readOnly },
                |m: &mut RBDPersistentVolumeSource| { &mut m.readOnly },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RBDPersistentVolumeSource>(
                "RBDPersistentVolumeSource",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RBDPersistentVolumeSource {
        static instance: ::protobuf::rt::LazyV2<RBDPersistentVolumeSource> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RBDPersistentVolumeSource::new)
    }
}

impl ::protobuf::Clear for RBDPersistentVolumeSource {
    fn clear(&mut self) {
        self.monitors.clear();
        self.image.clear();
        self.fsType.clear();
        self.pool.clear();
        self.user.clear();
        self.keyring.clear();
        self.secretRef.clear();
        self.readOnly = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RBDPersistentVolumeSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RBDPersistentVolumeSource {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RBDVolumeSource {
    // message fields
    pub monitors: ::protobuf::RepeatedField<::std::string::String>,
    image: ::protobuf::SingularField<::std::string::String>,
    fsType: ::protobuf::SingularField<::std::string::String>,
    pool: ::protobuf::SingularField<::std::string::String>,
    user: ::protobuf::SingularField<::std::string::String>,
    keyring: ::protobuf::SingularField<::std::string::String>,
    pub secretRef: ::protobuf::SingularPtrField<LocalObjectReference>,
    readOnly: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RBDVolumeSource {
    fn default() -> &'a RBDVolumeSource {
        <RBDVolumeSource as ::protobuf::Message>::default_instance()
    }
}

impl RBDVolumeSource {
    pub fn new() -> RBDVolumeSource {
        ::std::default::Default::default()
    }

    // repeated string monitors = 1;


    pub fn get_monitors(&self) -> &[::std::string::String] {
        &self.monitors
    }
    pub fn clear_monitors(&mut self) {
        self.monitors.clear();
    }

    // Param is passed by value, moved
    pub fn set_monitors(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.monitors = v;
    }

    // Mutable pointer to the field.
    pub fn mut_monitors(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.monitors
    }

    // Take field
    pub fn take_monitors(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.monitors, ::protobuf::RepeatedField::new())
    }

    // optional string image = 2;


    pub fn get_image(&self) -> &str {
        match self.image.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_image(&mut self) {
        self.image.clear();
    }

    pub fn has_image(&self) -> bool {
        self.image.is_some()
    }

    // Param is passed by value, moved
    pub fn set_image(&mut self, v: ::std::string::String) {
        self.image = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_image(&mut self) -> &mut ::std::string::String {
        if self.image.is_none() {
            self.image.set_default();
        }
        self.image.as_mut().unwrap()
    }

    // Take field
    pub fn take_image(&mut self) -> ::std::string::String {
        self.image.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string fsType = 3;


    pub fn get_fsType(&self) -> &str {
        match self.fsType.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_fsType(&mut self) {
        self.fsType.clear();
    }

    pub fn has_fsType(&self) -> bool {
        self.fsType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fsType(&mut self, v: ::std::string::String) {
        self.fsType = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fsType(&mut self) -> &mut ::std::string::String {
        if self.fsType.is_none() {
            self.fsType.set_default();
        }
        self.fsType.as_mut().unwrap()
    }

    // Take field
    pub fn take_fsType(&mut self) -> ::std::string::String {
        self.fsType.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string pool = 4;


    pub fn get_pool(&self) -> &str {
        match self.pool.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_pool(&mut self) {
        self.pool.clear();
    }

    pub fn has_pool(&self) -> bool {
        self.pool.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pool(&mut self, v: ::std::string::String) {
        self.pool = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pool(&mut self) -> &mut ::std::string::String {
        if self.pool.is_none() {
            self.pool.set_default();
        }
        self.pool.as_mut().unwrap()
    }

    // Take field
    pub fn take_pool(&mut self) -> ::std::string::String {
        self.pool.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string user = 5;


    pub fn get_user(&self) -> &str {
        match self.user.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_user(&mut self) {
        self.user.clear();
    }

    pub fn has_user(&self) -> bool {
        self.user.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user(&mut self, v: ::std::string::String) {
        self.user = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user(&mut self) -> &mut ::std::string::String {
        if self.user.is_none() {
            self.user.set_default();
        }
        self.user.as_mut().unwrap()
    }

    // Take field
    pub fn take_user(&mut self) -> ::std::string::String {
        self.user.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string keyring = 6;


    pub fn get_keyring(&self) -> &str {
        match self.keyring.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_keyring(&mut self) {
        self.keyring.clear();
    }

    pub fn has_keyring(&self) -> bool {
        self.keyring.is_some()
    }

    // Param is passed by value, moved
    pub fn set_keyring(&mut self, v: ::std::string::String) {
        self.keyring = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_keyring(&mut self) -> &mut ::std::string::String {
        if self.keyring.is_none() {
            self.keyring.set_default();
        }
        self.keyring.as_mut().unwrap()
    }

    // Take field
    pub fn take_keyring(&mut self) -> ::std::string::String {
        self.keyring.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .k8s.io.api.core.v1.LocalObjectReference secretRef = 7;


    pub fn get_secretRef(&self) -> &LocalObjectReference {
        self.secretRef.as_ref().unwrap_or_else(|| <LocalObjectReference as ::protobuf::Message>::default_instance())
    }
    pub fn clear_secretRef(&mut self) {
        self.secretRef.clear();
    }

    pub fn has_secretRef(&self) -> bool {
        self.secretRef.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secretRef(&mut self, v: LocalObjectReference) {
        self.secretRef = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_secretRef(&mut self) -> &mut LocalObjectReference {
        if self.secretRef.is_none() {
            self.secretRef.set_default();
        }
        self.secretRef.as_mut().unwrap()
    }

    // Take field
    pub fn take_secretRef(&mut self) -> LocalObjectReference {
        self.secretRef.take().unwrap_or_else(|| LocalObjectReference::new())
    }

    // optional bool readOnly = 8;


    pub fn get_readOnly(&self) -> bool {
        self.readOnly.unwrap_or(false)
    }
    pub fn clear_readOnly(&mut self) {
        self.readOnly = ::std::option::Option::None;
    }

    pub fn has_readOnly(&self) -> bool {
        self.readOnly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readOnly(&mut self, v: bool) {
        self.readOnly = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for RBDVolumeSource {
    fn is_initialized(&self) -> bool {
        for v in &self.secretRef {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.monitors)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.image)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.fsType)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.pool)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.user)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.keyring)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.secretRef)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.readOnly = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.monitors {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if let Some(ref v) = self.image.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.fsType.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.pool.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.user.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.keyring.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(ref v) = self.secretRef.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.readOnly {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.monitors {
            os.write_string(1, &v)?;
        };
        if let Some(ref v) = self.image.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.fsType.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.pool.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.user.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.keyring.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(ref v) = self.secretRef.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.readOnly {
            os.write_bool(8, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RBDVolumeSource {
        RBDVolumeSource::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "monitors",
                |m: &RBDVolumeSource| { &m.monitors },
                |m: &mut RBDVolumeSource| { &mut m.monitors },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "image",
                |m: &RBDVolumeSource| { &m.image },
                |m: &mut RBDVolumeSource| { &mut m.image },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "fsType",
                |m: &RBDVolumeSource| { &m.fsType },
                |m: &mut RBDVolumeSource| { &mut m.fsType },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "pool",
                |m: &RBDVolumeSource| { &m.pool },
                |m: &mut RBDVolumeSource| { &mut m.pool },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "user",
                |m: &RBDVolumeSource| { &m.user },
                |m: &mut RBDVolumeSource| { &mut m.user },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "keyring",
                |m: &RBDVolumeSource| { &m.keyring },
                |m: &mut RBDVolumeSource| { &mut m.keyring },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LocalObjectReference>>(
                "secretRef",
                |m: &RBDVolumeSource| { &m.secretRef },
                |m: &mut RBDVolumeSource| { &mut m.secretRef },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "readOnly",
                |m: &RBDVolumeSource| { &m.readOnly },
                |m: &mut RBDVolumeSource| { &mut m.readOnly },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RBDVolumeSource>(
                "RBDVolumeSource",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RBDVolumeSource {
        static instance: ::protobuf::rt::LazyV2<RBDVolumeSource> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RBDVolumeSource::new)
    }
}

impl ::protobuf::Clear for RBDVolumeSource {
    fn clear(&mut self) {
        self.monitors.clear();
        self.image.clear();
        self.fsType.clear();
        self.pool.clear();
        self.user.clear();
        self.keyring.clear();
        self.secretRef.clear();
        self.readOnly = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RBDVolumeSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RBDVolumeSource {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RangeAllocation {
    // message fields
    pub metadata: ::protobuf::SingularPtrField<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta>,
    range: ::protobuf::SingularField<::std::string::String>,
    data: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RangeAllocation {
    fn default() -> &'a RangeAllocation {
        <RangeAllocation as ::protobuf::Message>::default_instance()
    }
}

impl RangeAllocation {
    pub fn new() -> RangeAllocation {
        ::std::default::Default::default()
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;


    pub fn get_metadata(&self) -> &super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta::new())
    }

    // optional string range = 2;


    pub fn get_range(&self) -> &str {
        match self.range.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_range(&mut self) {
        self.range.clear();
    }

    pub fn has_range(&self) -> bool {
        self.range.is_some()
    }

    // Param is passed by value, moved
    pub fn set_range(&mut self, v: ::std::string::String) {
        self.range = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_range(&mut self) -> &mut ::std::string::String {
        if self.range.is_none() {
            self.range.set_default();
        }
        self.range.as_mut().unwrap()
    }

    // Take field
    pub fn take_range(&mut self) -> ::std::string::String {
        self.range.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bytes data = 3;


    pub fn get_data(&self) -> &[u8] {
        match self.data.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::vec::Vec<u8>) {
        self.data = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.data.is_none() {
            self.data.set_default();
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::vec::Vec<u8> {
        self.data.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for RangeAllocation {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.range)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.range.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.data.as_ref() {
            my_size += ::protobuf::rt::bytes_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.range.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.data.as_ref() {
            os.write_bytes(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RangeAllocation {
        RangeAllocation::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta>>(
                "metadata",
                |m: &RangeAllocation| { &m.metadata },
                |m: &mut RangeAllocation| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "range",
                |m: &RangeAllocation| { &m.range },
                |m: &mut RangeAllocation| { &mut m.range },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "data",
                |m: &RangeAllocation| { &m.data },
                |m: &mut RangeAllocation| { &mut m.data },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RangeAllocation>(
                "RangeAllocation",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RangeAllocation {
        static instance: ::protobuf::rt::LazyV2<RangeAllocation> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RangeAllocation::new)
    }
}

impl ::protobuf::Clear for RangeAllocation {
    fn clear(&mut self) {
        self.metadata.clear();
        self.range.clear();
        self.data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RangeAllocation {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RangeAllocation {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ReplicationController {
    // message fields
    pub metadata: ::protobuf::SingularPtrField<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta>,
    pub spec: ::protobuf::SingularPtrField<ReplicationControllerSpec>,
    pub status: ::protobuf::SingularPtrField<ReplicationControllerStatus>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ReplicationController {
    fn default() -> &'a ReplicationController {
        <ReplicationController as ::protobuf::Message>::default_instance()
    }
}

impl ReplicationController {
    pub fn new() -> ReplicationController {
        ::std::default::Default::default()
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;


    pub fn get_metadata(&self) -> &super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta::new())
    }

    // optional .k8s.io.api.core.v1.ReplicationControllerSpec spec = 2;


    pub fn get_spec(&self) -> &ReplicationControllerSpec {
        self.spec.as_ref().unwrap_or_else(|| <ReplicationControllerSpec as ::protobuf::Message>::default_instance())
    }
    pub fn clear_spec(&mut self) {
        self.spec.clear();
    }

    pub fn has_spec(&self) -> bool {
        self.spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spec(&mut self, v: ReplicationControllerSpec) {
        self.spec = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spec(&mut self) -> &mut ReplicationControllerSpec {
        if self.spec.is_none() {
            self.spec.set_default();
        }
        self.spec.as_mut().unwrap()
    }

    // Take field
    pub fn take_spec(&mut self) -> ReplicationControllerSpec {
        self.spec.take().unwrap_or_else(|| ReplicationControllerSpec::new())
    }

    // optional .k8s.io.api.core.v1.ReplicationControllerStatus status = 3;


    pub fn get_status(&self) -> &ReplicationControllerStatus {
        self.status.as_ref().unwrap_or_else(|| <ReplicationControllerStatus as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: ReplicationControllerStatus) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut ReplicationControllerStatus {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> ReplicationControllerStatus {
        self.status.take().unwrap_or_else(|| ReplicationControllerStatus::new())
    }
}

impl ::protobuf::Message for ReplicationController {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.spec {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.spec)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.spec.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReplicationController {
        ReplicationController::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta>>(
                "metadata",
                |m: &ReplicationController| { &m.metadata },
                |m: &mut ReplicationController| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ReplicationControllerSpec>>(
                "spec",
                |m: &ReplicationController| { &m.spec },
                |m: &mut ReplicationController| { &mut m.spec },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ReplicationControllerStatus>>(
                "status",
                |m: &ReplicationController| { &m.status },
                |m: &mut ReplicationController| { &mut m.status },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ReplicationController>(
                "ReplicationController",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ReplicationController {
        static instance: ::protobuf::rt::LazyV2<ReplicationController> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ReplicationController::new)
    }
}

impl ::protobuf::Clear for ReplicationController {
    fn clear(&mut self) {
        self.metadata.clear();
        self.spec.clear();
        self.status.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReplicationController {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReplicationController {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ReplicationControllerCondition {
    // message fields
    field_type: ::protobuf::SingularField<::std::string::String>,
    status: ::protobuf::SingularField<::std::string::String>,
    pub lastTransitionTime: ::protobuf::SingularPtrField<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time>,
    reason: ::protobuf::SingularField<::std::string::String>,
    message: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ReplicationControllerCondition {
    fn default() -> &'a ReplicationControllerCondition {
        <ReplicationControllerCondition as ::protobuf::Message>::default_instance()
    }
}

impl ReplicationControllerCondition {
    pub fn new() -> ReplicationControllerCondition {
        ::std::default::Default::default()
    }

    // optional string type = 1;


    pub fn get_field_type(&self) -> &str {
        match self.field_type.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ::std::string::String) {
        self.field_type = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut ::std::string::String {
        if self.field_type.is_none() {
            self.field_type.set_default();
        }
        self.field_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_field_type(&mut self) -> ::std::string::String {
        self.field_type.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string status = 2;


    pub fn get_status(&self) -> &str {
        match self.status.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: ::std::string::String) {
        self.status = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut ::std::string::String {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> ::std::string::String {
        self.status.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 3;


    pub fn get_lastTransitionTime(&self) -> &super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time {
        self.lastTransitionTime.as_ref().unwrap_or_else(|| <super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time as ::protobuf::Message>::default_instance())
    }
    pub fn clear_lastTransitionTime(&mut self) {
        self.lastTransitionTime.clear();
    }

    pub fn has_lastTransitionTime(&self) -> bool {
        self.lastTransitionTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lastTransitionTime(&mut self, v: super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time) {
        self.lastTransitionTime = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lastTransitionTime(&mut self) -> &mut super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time {
        if self.lastTransitionTime.is_none() {
            self.lastTransitionTime.set_default();
        }
        self.lastTransitionTime.as_mut().unwrap()
    }

    // Take field
    pub fn take_lastTransitionTime(&mut self) -> super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time {
        self.lastTransitionTime.take().unwrap_or_else(|| super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time::new())
    }

    // optional string reason = 4;


    pub fn get_reason(&self) -> &str {
        match self.reason.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_reason(&mut self) {
        self.reason.clear();
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: ::std::string::String) {
        self.reason = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reason(&mut self) -> &mut ::std::string::String {
        if self.reason.is_none() {
            self.reason.set_default();
        }
        self.reason.as_mut().unwrap()
    }

    // Take field
    pub fn take_reason(&mut self) -> ::std::string::String {
        self.reason.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string message = 5;


    pub fn get_message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for ReplicationControllerCondition {
    fn is_initialized(&self) -> bool {
        for v in &self.lastTransitionTime {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.field_type)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.status)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.lastTransitionTime)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.reason)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.field_type.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.status.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.lastTransitionTime.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.reason.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.field_type.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.status.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.lastTransitionTime.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.reason.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.message.as_ref() {
            os.write_string(5, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReplicationControllerCondition {
        ReplicationControllerCondition::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "type",
                |m: &ReplicationControllerCondition| { &m.field_type },
                |m: &mut ReplicationControllerCondition| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "status",
                |m: &ReplicationControllerCondition| { &m.status },
                |m: &mut ReplicationControllerCondition| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time>>(
                "lastTransitionTime",
                |m: &ReplicationControllerCondition| { &m.lastTransitionTime },
                |m: &mut ReplicationControllerCondition| { &mut m.lastTransitionTime },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "reason",
                |m: &ReplicationControllerCondition| { &m.reason },
                |m: &mut ReplicationControllerCondition| { &mut m.reason },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "message",
                |m: &ReplicationControllerCondition| { &m.message },
                |m: &mut ReplicationControllerCondition| { &mut m.message },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ReplicationControllerCondition>(
                "ReplicationControllerCondition",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ReplicationControllerCondition {
        static instance: ::protobuf::rt::LazyV2<ReplicationControllerCondition> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ReplicationControllerCondition::new)
    }
}

impl ::protobuf::Clear for ReplicationControllerCondition {
    fn clear(&mut self) {
        self.field_type.clear();
        self.status.clear();
        self.lastTransitionTime.clear();
        self.reason.clear();
        self.message.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReplicationControllerCondition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReplicationControllerCondition {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ReplicationControllerList {
    // message fields
    pub metadata: ::protobuf::SingularPtrField<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta>,
    pub items: ::protobuf::RepeatedField<ReplicationController>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ReplicationControllerList {
    fn default() -> &'a ReplicationControllerList {
        <ReplicationControllerList as ::protobuf::Message>::default_instance()
    }
}

impl ReplicationControllerList {
    pub fn new() -> ReplicationControllerList {
        ::std::default::Default::default()
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;


    pub fn get_metadata(&self) -> &super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta {
        self.metadata.take().unwrap_or_else(|| super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta::new())
    }

    // repeated .k8s.io.api.core.v1.ReplicationController items = 2;


    pub fn get_items(&self) -> &[ReplicationController] {
        &self.items
    }
    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::protobuf::RepeatedField<ReplicationController>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::protobuf::RepeatedField<ReplicationController> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::protobuf::RepeatedField<ReplicationController> {
        ::std::mem::replace(&mut self.items, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ReplicationControllerList {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.items {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.items)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.items {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReplicationControllerList {
        ReplicationControllerList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta>>(
                "metadata",
                |m: &ReplicationControllerList| { &m.metadata },
                |m: &mut ReplicationControllerList| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ReplicationController>>(
                "items",
                |m: &ReplicationControllerList| { &m.items },
                |m: &mut ReplicationControllerList| { &mut m.items },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ReplicationControllerList>(
                "ReplicationControllerList",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ReplicationControllerList {
        static instance: ::protobuf::rt::LazyV2<ReplicationControllerList> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ReplicationControllerList::new)
    }
}

impl ::protobuf::Clear for ReplicationControllerList {
    fn clear(&mut self) {
        self.metadata.clear();
        self.items.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReplicationControllerList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReplicationControllerList {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ReplicationControllerSpec {
    // message fields
    replicas: ::std::option::Option<i32>,
    minReadySeconds: ::std::option::Option<i32>,
    pub selector: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    pub template: ::protobuf::SingularPtrField<PodTemplateSpec>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ReplicationControllerSpec {
    fn default() -> &'a ReplicationControllerSpec {
        <ReplicationControllerSpec as ::protobuf::Message>::default_instance()
    }
}

impl ReplicationControllerSpec {
    pub fn new() -> ReplicationControllerSpec {
        ::std::default::Default::default()
    }

    // optional int32 replicas = 1;


    pub fn get_replicas(&self) -> i32 {
        self.replicas.unwrap_or(0)
    }
    pub fn clear_replicas(&mut self) {
        self.replicas = ::std::option::Option::None;
    }

    pub fn has_replicas(&self) -> bool {
        self.replicas.is_some()
    }

    // Param is passed by value, moved
    pub fn set_replicas(&mut self, v: i32) {
        self.replicas = ::std::option::Option::Some(v);
    }

    // optional int32 minReadySeconds = 4;


    pub fn get_minReadySeconds(&self) -> i32 {
        self.minReadySeconds.unwrap_or(0)
    }
    pub fn clear_minReadySeconds(&mut self) {
        self.minReadySeconds = ::std::option::Option::None;
    }

    pub fn has_minReadySeconds(&self) -> bool {
        self.minReadySeconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_minReadySeconds(&mut self, v: i32) {
        self.minReadySeconds = ::std::option::Option::Some(v);
    }

    // repeated .k8s.io.api.core.v1.ReplicationControllerSpec.SelectorEntry selector = 2;


    pub fn get_selector(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.selector
    }
    pub fn clear_selector(&mut self) {
        self.selector.clear();
    }

    // Param is passed by value, moved
    pub fn set_selector(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.selector = v;
    }

    // Mutable pointer to the field.
    pub fn mut_selector(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.selector
    }

    // Take field
    pub fn take_selector(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.selector, ::std::collections::HashMap::new())
    }

    // optional .k8s.io.api.core.v1.PodTemplateSpec template = 3;


    pub fn get_template(&self) -> &PodTemplateSpec {
        self.template.as_ref().unwrap_or_else(|| <PodTemplateSpec as ::protobuf::Message>::default_instance())
    }
    pub fn clear_template(&mut self) {
        self.template.clear();
    }

    pub fn has_template(&self) -> bool {
        self.template.is_some()
    }

    // Param is passed by value, moved
    pub fn set_template(&mut self, v: PodTemplateSpec) {
        self.template = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_template(&mut self) -> &mut PodTemplateSpec {
        if self.template.is_none() {
            self.template.set_default();
        }
        self.template.as_mut().unwrap()
    }

    // Take field
    pub fn take_template(&mut self) -> PodTemplateSpec {
        self.template.take().unwrap_or_else(|| PodTemplateSpec::new())
    }
}

impl ::protobuf::Message for ReplicationControllerSpec {
    fn is_initialized(&self) -> bool {
        for v in &self.template {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.replicas = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.minReadySeconds = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.selector)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.template)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.replicas {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.minReadySeconds {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(2, &self.selector);
        if let Some(ref v) = self.template.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.replicas {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.minReadySeconds {
            os.write_int32(4, v)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(2, &self.selector, os)?;
        if let Some(ref v) = self.template.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReplicationControllerSpec {
        ReplicationControllerSpec::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "replicas",
                |m: &ReplicationControllerSpec| { &m.replicas },
                |m: &mut ReplicationControllerSpec| { &mut m.replicas },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "minReadySeconds",
                |m: &ReplicationControllerSpec| { &m.minReadySeconds },
                |m: &mut ReplicationControllerSpec| { &mut m.minReadySeconds },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                "selector",
                |m: &ReplicationControllerSpec| { &m.selector },
                |m: &mut ReplicationControllerSpec| { &mut m.selector },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PodTemplateSpec>>(
                "template",
                |m: &ReplicationControllerSpec| { &m.template },
                |m: &mut ReplicationControllerSpec| { &mut m.template },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ReplicationControllerSpec>(
                "ReplicationControllerSpec",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ReplicationControllerSpec {
        static instance: ::protobuf::rt::LazyV2<ReplicationControllerSpec> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ReplicationControllerSpec::new)
    }
}

impl ::protobuf::Clear for ReplicationControllerSpec {
    fn clear(&mut self) {
        self.replicas = ::std::option::Option::None;
        self.minReadySeconds = ::std::option::Option::None;
        self.selector.clear();
        self.template.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReplicationControllerSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReplicationControllerSpec {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ReplicationControllerStatus {
    // message fields
    replicas: ::std::option::Option<i32>,
    fullyLabeledReplicas: ::std::option::Option<i32>,
    readyReplicas: ::std::option::Option<i32>,
    availableReplicas: ::std::option::Option<i32>,
    observedGeneration: ::std::option::Option<i64>,
    pub conditions: ::protobuf::RepeatedField<ReplicationControllerCondition>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ReplicationControllerStatus {
    fn default() -> &'a ReplicationControllerStatus {
        <ReplicationControllerStatus as ::protobuf::Message>::default_instance()
    }
}

impl ReplicationControllerStatus {
    pub fn new() -> ReplicationControllerStatus {
        ::std::default::Default::default()
    }

    // optional int32 replicas = 1;


    pub fn get_replicas(&self) -> i32 {
        self.replicas.unwrap_or(0)
    }
    pub fn clear_replicas(&mut self) {
        self.replicas = ::std::option::Option::None;
    }

    pub fn has_replicas(&self) -> bool {
        self.replicas.is_some()
    }

    // Param is passed by value, moved
    pub fn set_replicas(&mut self, v: i32) {
        self.replicas = ::std::option::Option::Some(v);
    }

    // optional int32 fullyLabeledReplicas = 2;


    pub fn get_fullyLabeledReplicas(&self) -> i32 {
        self.fullyLabeledReplicas.unwrap_or(0)
    }
    pub fn clear_fullyLabeledReplicas(&mut self) {
        self.fullyLabeledReplicas = ::std::option::Option::None;
    }

    pub fn has_fullyLabeledReplicas(&self) -> bool {
        self.fullyLabeledReplicas.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fullyLabeledReplicas(&mut self, v: i32) {
        self.fullyLabeledReplicas = ::std::option::Option::Some(v);
    }

    // optional int32 readyReplicas = 4;


    pub fn get_readyReplicas(&self) -> i32 {
        self.readyReplicas.unwrap_or(0)
    }
    pub fn clear_readyReplicas(&mut self) {
        self.readyReplicas = ::std::option::Option::None;
    }

    pub fn has_readyReplicas(&self) -> bool {
        self.readyReplicas.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readyReplicas(&mut self, v: i32) {
        self.readyReplicas = ::std::option::Option::Some(v);
    }

    // optional int32 availableReplicas = 5;


    pub fn get_availableReplicas(&self) -> i32 {
        self.availableReplicas.unwrap_or(0)
    }
    pub fn clear_availableReplicas(&mut self) {
        self.availableReplicas = ::std::option::Option::None;
    }

    pub fn has_availableReplicas(&self) -> bool {
        self.availableReplicas.is_some()
    }

    // Param is passed by value, moved
    pub fn set_availableReplicas(&mut self, v: i32) {
        self.availableReplicas = ::std::option::Option::Some(v);
    }

    // optional int64 observedGeneration = 3;


    pub fn get_observedGeneration(&self) -> i64 {
        self.observedGeneration.unwrap_or(0)
    }
    pub fn clear_observedGeneration(&mut self) {
        self.observedGeneration = ::std::option::Option::None;
    }

    pub fn has_observedGeneration(&self) -> bool {
        self.observedGeneration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_observedGeneration(&mut self, v: i64) {
        self.observedGeneration = ::std::option::Option::Some(v);
    }

    // repeated .k8s.io.api.core.v1.ReplicationControllerCondition conditions = 6;


    pub fn get_conditions(&self) -> &[ReplicationControllerCondition] {
        &self.conditions
    }
    pub fn clear_conditions(&mut self) {
        self.conditions.clear();
    }

    // Param is passed by value, moved
    pub fn set_conditions(&mut self, v: ::protobuf::RepeatedField<ReplicationControllerCondition>) {
        self.conditions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_conditions(&mut self) -> &mut ::protobuf::RepeatedField<ReplicationControllerCondition> {
        &mut self.conditions
    }

    // Take field
    pub fn take_conditions(&mut self) -> ::protobuf::RepeatedField<ReplicationControllerCondition> {
        ::std::mem::replace(&mut self.conditions, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ReplicationControllerStatus {
    fn is_initialized(&self) -> bool {
        for v in &self.conditions {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.replicas = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.fullyLabeledReplicas = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.readyReplicas = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.availableReplicas = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.observedGeneration = ::std::option::Option::Some(tmp);
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.conditions)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.replicas {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.fullyLabeledReplicas {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.readyReplicas {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.availableReplicas {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.observedGeneration {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.conditions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.replicas {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.fullyLabeledReplicas {
            os.write_int32(2, v)?;
        }
        if let Some(v) = self.readyReplicas {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.availableReplicas {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.observedGeneration {
            os.write_int64(3, v)?;
        }
        for v in &self.conditions {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReplicationControllerStatus {
        ReplicationControllerStatus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "replicas",
                |m: &ReplicationControllerStatus| { &m.replicas },
                |m: &mut ReplicationControllerStatus| { &mut m.replicas },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "fullyLabeledReplicas",
                |m: &ReplicationControllerStatus| { &m.fullyLabeledReplicas },
                |m: &mut ReplicationControllerStatus| { &mut m.fullyLabeledReplicas },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "readyReplicas",
                |m: &ReplicationControllerStatus| { &m.readyReplicas },
                |m: &mut ReplicationControllerStatus| { &mut m.readyReplicas },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "availableReplicas",
                |m: &ReplicationControllerStatus| { &m.availableReplicas },
                |m: &mut ReplicationControllerStatus| { &mut m.availableReplicas },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "observedGeneration",
                |m: &ReplicationControllerStatus| { &m.observedGeneration },
                |m: &mut ReplicationControllerStatus| { &mut m.observedGeneration },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ReplicationControllerCondition>>(
                "conditions",
                |m: &ReplicationControllerStatus| { &m.conditions },
                |m: &mut ReplicationControllerStatus| { &mut m.conditions },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ReplicationControllerStatus>(
                "ReplicationControllerStatus",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ReplicationControllerStatus {
        static instance: ::protobuf::rt::LazyV2<ReplicationControllerStatus> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ReplicationControllerStatus::new)
    }
}

impl ::protobuf::Clear for ReplicationControllerStatus {
    fn clear(&mut self) {
        self.replicas = ::std::option::Option::None;
        self.fullyLabeledReplicas = ::std::option::Option::None;
        self.readyReplicas = ::std::option::Option::None;
        self.availableReplicas = ::std::option::Option::None;
        self.observedGeneration = ::std::option::Option::None;
        self.conditions.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReplicationControllerStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReplicationControllerStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ResourceFieldSelector {
    // message fields
    containerName: ::protobuf::SingularField<::std::string::String>,
    resource: ::protobuf::SingularField<::std::string::String>,
    pub divisor: ::protobuf::SingularPtrField<super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ResourceFieldSelector {
    fn default() -> &'a ResourceFieldSelector {
        <ResourceFieldSelector as ::protobuf::Message>::default_instance()
    }
}

impl ResourceFieldSelector {
    pub fn new() -> ResourceFieldSelector {
        ::std::default::Default::default()
    }

    // optional string containerName = 1;


    pub fn get_containerName(&self) -> &str {
        match self.containerName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_containerName(&mut self) {
        self.containerName.clear();
    }

    pub fn has_containerName(&self) -> bool {
        self.containerName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_containerName(&mut self, v: ::std::string::String) {
        self.containerName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_containerName(&mut self) -> &mut ::std::string::String {
        if self.containerName.is_none() {
            self.containerName.set_default();
        }
        self.containerName.as_mut().unwrap()
    }

    // Take field
    pub fn take_containerName(&mut self) -> ::std::string::String {
        self.containerName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string resource = 2;


    pub fn get_resource(&self) -> &str {
        match self.resource.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_resource(&mut self) {
        self.resource.clear();
    }

    pub fn has_resource(&self) -> bool {
        self.resource.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resource(&mut self, v: ::std::string::String) {
        self.resource = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_resource(&mut self) -> &mut ::std::string::String {
        if self.resource.is_none() {
            self.resource.set_default();
        }
        self.resource.as_mut().unwrap()
    }

    // Take field
    pub fn take_resource(&mut self) -> ::std::string::String {
        self.resource.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .k8s.io.apimachinery.pkg.api.resource.Quantity divisor = 3;


    pub fn get_divisor(&self) -> &super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity {
        self.divisor.as_ref().unwrap_or_else(|| <super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity as ::protobuf::Message>::default_instance())
    }
    pub fn clear_divisor(&mut self) {
        self.divisor.clear();
    }

    pub fn has_divisor(&self) -> bool {
        self.divisor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_divisor(&mut self, v: super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity) {
        self.divisor = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_divisor(&mut self) -> &mut super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity {
        if self.divisor.is_none() {
            self.divisor.set_default();
        }
        self.divisor.as_mut().unwrap()
    }

    // Take field
    pub fn take_divisor(&mut self) -> super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity {
        self.divisor.take().unwrap_or_else(|| super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity::new())
    }
}

impl ::protobuf::Message for ResourceFieldSelector {
    fn is_initialized(&self) -> bool {
        for v in &self.divisor {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.containerName)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.resource)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.divisor)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.containerName.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.resource.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.divisor.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.containerName.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.resource.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.divisor.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ResourceFieldSelector {
        ResourceFieldSelector::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "containerName",
                |m: &ResourceFieldSelector| { &m.containerName },
                |m: &mut ResourceFieldSelector| { &mut m.containerName },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "resource",
                |m: &ResourceFieldSelector| { &m.resource },
                |m: &mut ResourceFieldSelector| { &mut m.resource },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity>>(
                "divisor",
                |m: &ResourceFieldSelector| { &m.divisor },
                |m: &mut ResourceFieldSelector| { &mut m.divisor },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ResourceFieldSelector>(
                "ResourceFieldSelector",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ResourceFieldSelector {
        static instance: ::protobuf::rt::LazyV2<ResourceFieldSelector> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ResourceFieldSelector::new)
    }
}

impl ::protobuf::Clear for ResourceFieldSelector {
    fn clear(&mut self) {
        self.containerName.clear();
        self.resource.clear();
        self.divisor.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ResourceFieldSelector {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResourceFieldSelector {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ResourceQuota {
    // message fields
    pub metadata: ::protobuf::SingularPtrField<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta>,
    pub spec: ::protobuf::SingularPtrField<ResourceQuotaSpec>,
    pub status: ::protobuf::SingularPtrField<ResourceQuotaStatus>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ResourceQuota {
    fn default() -> &'a ResourceQuota {
        <ResourceQuota as ::protobuf::Message>::default_instance()
    }
}

impl ResourceQuota {
    pub fn new() -> ResourceQuota {
        ::std::default::Default::default()
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;


    pub fn get_metadata(&self) -> &super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta::new())
    }

    // optional .k8s.io.api.core.v1.ResourceQuotaSpec spec = 2;


    pub fn get_spec(&self) -> &ResourceQuotaSpec {
        self.spec.as_ref().unwrap_or_else(|| <ResourceQuotaSpec as ::protobuf::Message>::default_instance())
    }
    pub fn clear_spec(&mut self) {
        self.spec.clear();
    }

    pub fn has_spec(&self) -> bool {
        self.spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spec(&mut self, v: ResourceQuotaSpec) {
        self.spec = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spec(&mut self) -> &mut ResourceQuotaSpec {
        if self.spec.is_none() {
            self.spec.set_default();
        }
        self.spec.as_mut().unwrap()
    }

    // Take field
    pub fn take_spec(&mut self) -> ResourceQuotaSpec {
        self.spec.take().unwrap_or_else(|| ResourceQuotaSpec::new())
    }

    // optional .k8s.io.api.core.v1.ResourceQuotaStatus status = 3;


    pub fn get_status(&self) -> &ResourceQuotaStatus {
        self.status.as_ref().unwrap_or_else(|| <ResourceQuotaStatus as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: ResourceQuotaStatus) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut ResourceQuotaStatus {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> ResourceQuotaStatus {
        self.status.take().unwrap_or_else(|| ResourceQuotaStatus::new())
    }
}

impl ::protobuf::Message for ResourceQuota {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.spec {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.spec)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.spec.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ResourceQuota {
        ResourceQuota::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta>>(
                "metadata",
                |m: &ResourceQuota| { &m.metadata },
                |m: &mut ResourceQuota| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResourceQuotaSpec>>(
                "spec",
                |m: &ResourceQuota| { &m.spec },
                |m: &mut ResourceQuota| { &mut m.spec },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResourceQuotaStatus>>(
                "status",
                |m: &ResourceQuota| { &m.status },
                |m: &mut ResourceQuota| { &mut m.status },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ResourceQuota>(
                "ResourceQuota",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ResourceQuota {
        static instance: ::protobuf::rt::LazyV2<ResourceQuota> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ResourceQuota::new)
    }
}

impl ::protobuf::Clear for ResourceQuota {
    fn clear(&mut self) {
        self.metadata.clear();
        self.spec.clear();
        self.status.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ResourceQuota {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResourceQuota {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ResourceQuotaList {
    // message fields
    pub metadata: ::protobuf::SingularPtrField<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta>,
    pub items: ::protobuf::RepeatedField<ResourceQuota>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ResourceQuotaList {
    fn default() -> &'a ResourceQuotaList {
        <ResourceQuotaList as ::protobuf::Message>::default_instance()
    }
}

impl ResourceQuotaList {
    pub fn new() -> ResourceQuotaList {
        ::std::default::Default::default()
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;


    pub fn get_metadata(&self) -> &super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta {
        self.metadata.take().unwrap_or_else(|| super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta::new())
    }

    // repeated .k8s.io.api.core.v1.ResourceQuota items = 2;


    pub fn get_items(&self) -> &[ResourceQuota] {
        &self.items
    }
    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::protobuf::RepeatedField<ResourceQuota>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::protobuf::RepeatedField<ResourceQuota> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::protobuf::RepeatedField<ResourceQuota> {
        ::std::mem::replace(&mut self.items, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ResourceQuotaList {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.items {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.items)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.items {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ResourceQuotaList {
        ResourceQuotaList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta>>(
                "metadata",
                |m: &ResourceQuotaList| { &m.metadata },
                |m: &mut ResourceQuotaList| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResourceQuota>>(
                "items",
                |m: &ResourceQuotaList| { &m.items },
                |m: &mut ResourceQuotaList| { &mut m.items },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ResourceQuotaList>(
                "ResourceQuotaList",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ResourceQuotaList {
        static instance: ::protobuf::rt::LazyV2<ResourceQuotaList> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ResourceQuotaList::new)
    }
}

impl ::protobuf::Clear for ResourceQuotaList {
    fn clear(&mut self) {
        self.metadata.clear();
        self.items.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ResourceQuotaList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResourceQuotaList {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ResourceQuotaSpec {
    // message fields
    pub hard: ::std::collections::HashMap<::std::string::String, super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity>,
    pub scopes: ::protobuf::RepeatedField<::std::string::String>,
    pub scopeSelector: ::protobuf::SingularPtrField<ScopeSelector>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ResourceQuotaSpec {
    fn default() -> &'a ResourceQuotaSpec {
        <ResourceQuotaSpec as ::protobuf::Message>::default_instance()
    }
}

impl ResourceQuotaSpec {
    pub fn new() -> ResourceQuotaSpec {
        ::std::default::Default::default()
    }

    // repeated .k8s.io.api.core.v1.ResourceQuotaSpec.HardEntry hard = 1;


    pub fn get_hard(&self) -> &::std::collections::HashMap<::std::string::String, super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity> {
        &self.hard
    }
    pub fn clear_hard(&mut self) {
        self.hard.clear();
    }

    // Param is passed by value, moved
    pub fn set_hard(&mut self, v: ::std::collections::HashMap<::std::string::String, super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity>) {
        self.hard = v;
    }

    // Mutable pointer to the field.
    pub fn mut_hard(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity> {
        &mut self.hard
    }

    // Take field
    pub fn take_hard(&mut self) -> ::std::collections::HashMap<::std::string::String, super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity> {
        ::std::mem::replace(&mut self.hard, ::std::collections::HashMap::new())
    }

    // repeated string scopes = 2;


    pub fn get_scopes(&self) -> &[::std::string::String] {
        &self.scopes
    }
    pub fn clear_scopes(&mut self) {
        self.scopes.clear();
    }

    // Param is passed by value, moved
    pub fn set_scopes(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.scopes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_scopes(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.scopes
    }

    // Take field
    pub fn take_scopes(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.scopes, ::protobuf::RepeatedField::new())
    }

    // optional .k8s.io.api.core.v1.ScopeSelector scopeSelector = 3;


    pub fn get_scopeSelector(&self) -> &ScopeSelector {
        self.scopeSelector.as_ref().unwrap_or_else(|| <ScopeSelector as ::protobuf::Message>::default_instance())
    }
    pub fn clear_scopeSelector(&mut self) {
        self.scopeSelector.clear();
    }

    pub fn has_scopeSelector(&self) -> bool {
        self.scopeSelector.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scopeSelector(&mut self, v: ScopeSelector) {
        self.scopeSelector = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_scopeSelector(&mut self) -> &mut ScopeSelector {
        if self.scopeSelector.is_none() {
            self.scopeSelector.set_default();
        }
        self.scopeSelector.as_mut().unwrap()
    }

    // Take field
    pub fn take_scopeSelector(&mut self) -> ScopeSelector {
        self.scopeSelector.take().unwrap_or_else(|| ScopeSelector::new())
    }
}

impl ::protobuf::Message for ResourceQuotaSpec {
    fn is_initialized(&self) -> bool {
        for v in &self.scopeSelector {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity>>(wire_type, is, &mut self.hard)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.scopes)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.scopeSelector)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity>>(1, &self.hard);
        for value in &self.scopes {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        if let Some(ref v) = self.scopeSelector.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity>>(1, &self.hard, os)?;
        for v in &self.scopes {
            os.write_string(2, &v)?;
        };
        if let Some(ref v) = self.scopeSelector.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ResourceQuotaSpec {
        ResourceQuotaSpec::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity>>(
                "hard",
                |m: &ResourceQuotaSpec| { &m.hard },
                |m: &mut ResourceQuotaSpec| { &mut m.hard },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "scopes",
                |m: &ResourceQuotaSpec| { &m.scopes },
                |m: &mut ResourceQuotaSpec| { &mut m.scopes },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ScopeSelector>>(
                "scopeSelector",
                |m: &ResourceQuotaSpec| { &m.scopeSelector },
                |m: &mut ResourceQuotaSpec| { &mut m.scopeSelector },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ResourceQuotaSpec>(
                "ResourceQuotaSpec",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ResourceQuotaSpec {
        static instance: ::protobuf::rt::LazyV2<ResourceQuotaSpec> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ResourceQuotaSpec::new)
    }
}

impl ::protobuf::Clear for ResourceQuotaSpec {
    fn clear(&mut self) {
        self.hard.clear();
        self.scopes.clear();
        self.scopeSelector.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ResourceQuotaSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResourceQuotaSpec {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ResourceQuotaStatus {
    // message fields
    pub hard: ::std::collections::HashMap<::std::string::String, super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity>,
    pub used: ::std::collections::HashMap<::std::string::String, super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ResourceQuotaStatus {
    fn default() -> &'a ResourceQuotaStatus {
        <ResourceQuotaStatus as ::protobuf::Message>::default_instance()
    }
}

impl ResourceQuotaStatus {
    pub fn new() -> ResourceQuotaStatus {
        ::std::default::Default::default()
    }

    // repeated .k8s.io.api.core.v1.ResourceQuotaStatus.HardEntry hard = 1;


    pub fn get_hard(&self) -> &::std::collections::HashMap<::std::string::String, super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity> {
        &self.hard
    }
    pub fn clear_hard(&mut self) {
        self.hard.clear();
    }

    // Param is passed by value, moved
    pub fn set_hard(&mut self, v: ::std::collections::HashMap<::std::string::String, super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity>) {
        self.hard = v;
    }

    // Mutable pointer to the field.
    pub fn mut_hard(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity> {
        &mut self.hard
    }

    // Take field
    pub fn take_hard(&mut self) -> ::std::collections::HashMap<::std::string::String, super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity> {
        ::std::mem::replace(&mut self.hard, ::std::collections::HashMap::new())
    }

    // repeated .k8s.io.api.core.v1.ResourceQuotaStatus.UsedEntry used = 2;


    pub fn get_used(&self) -> &::std::collections::HashMap<::std::string::String, super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity> {
        &self.used
    }
    pub fn clear_used(&mut self) {
        self.used.clear();
    }

    // Param is passed by value, moved
    pub fn set_used(&mut self, v: ::std::collections::HashMap<::std::string::String, super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity>) {
        self.used = v;
    }

    // Mutable pointer to the field.
    pub fn mut_used(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity> {
        &mut self.used
    }

    // Take field
    pub fn take_used(&mut self) -> ::std::collections::HashMap<::std::string::String, super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity> {
        ::std::mem::replace(&mut self.used, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for ResourceQuotaStatus {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity>>(wire_type, is, &mut self.hard)?;
                },
                2 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity>>(wire_type, is, &mut self.used)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity>>(1, &self.hard);
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity>>(2, &self.used);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity>>(1, &self.hard, os)?;
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity>>(2, &self.used, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ResourceQuotaStatus {
        ResourceQuotaStatus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity>>(
                "hard",
                |m: &ResourceQuotaStatus| { &m.hard },
                |m: &mut ResourceQuotaStatus| { &mut m.hard },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity>>(
                "used",
                |m: &ResourceQuotaStatus| { &m.used },
                |m: &mut ResourceQuotaStatus| { &mut m.used },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ResourceQuotaStatus>(
                "ResourceQuotaStatus",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ResourceQuotaStatus {
        static instance: ::protobuf::rt::LazyV2<ResourceQuotaStatus> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ResourceQuotaStatus::new)
    }
}

impl ::protobuf::Clear for ResourceQuotaStatus {
    fn clear(&mut self) {
        self.hard.clear();
        self.used.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ResourceQuotaStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResourceQuotaStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ResourceRequirements {
    // message fields
    pub limits: ::std::collections::HashMap<::std::string::String, super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity>,
    pub requests: ::std::collections::HashMap<::std::string::String, super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ResourceRequirements {
    fn default() -> &'a ResourceRequirements {
        <ResourceRequirements as ::protobuf::Message>::default_instance()
    }
}

impl ResourceRequirements {
    pub fn new() -> ResourceRequirements {
        ::std::default::Default::default()
    }

    // repeated .k8s.io.api.core.v1.ResourceRequirements.LimitsEntry limits = 1;


    pub fn get_limits(&self) -> &::std::collections::HashMap<::std::string::String, super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity> {
        &self.limits
    }
    pub fn clear_limits(&mut self) {
        self.limits.clear();
    }

    // Param is passed by value, moved
    pub fn set_limits(&mut self, v: ::std::collections::HashMap<::std::string::String, super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity>) {
        self.limits = v;
    }

    // Mutable pointer to the field.
    pub fn mut_limits(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity> {
        &mut self.limits
    }

    // Take field
    pub fn take_limits(&mut self) -> ::std::collections::HashMap<::std::string::String, super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity> {
        ::std::mem::replace(&mut self.limits, ::std::collections::HashMap::new())
    }

    // repeated .k8s.io.api.core.v1.ResourceRequirements.RequestsEntry requests = 2;


    pub fn get_requests(&self) -> &::std::collections::HashMap<::std::string::String, super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity> {
        &self.requests
    }
    pub fn clear_requests(&mut self) {
        self.requests.clear();
    }

    // Param is passed by value, moved
    pub fn set_requests(&mut self, v: ::std::collections::HashMap<::std::string::String, super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity>) {
        self.requests = v;
    }

    // Mutable pointer to the field.
    pub fn mut_requests(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity> {
        &mut self.requests
    }

    // Take field
    pub fn take_requests(&mut self) -> ::std::collections::HashMap<::std::string::String, super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity> {
        ::std::mem::replace(&mut self.requests, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for ResourceRequirements {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity>>(wire_type, is, &mut self.limits)?;
                },
                2 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity>>(wire_type, is, &mut self.requests)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity>>(1, &self.limits);
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity>>(2, &self.requests);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity>>(1, &self.limits, os)?;
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity>>(2, &self.requests, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ResourceRequirements {
        ResourceRequirements::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity>>(
                "limits",
                |m: &ResourceRequirements| { &m.limits },
                |m: &mut ResourceRequirements| { &mut m.limits },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_api_resource_generated::Quantity>>(
                "requests",
                |m: &ResourceRequirements| { &m.requests },
                |m: &mut ResourceRequirements| { &mut m.requests },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ResourceRequirements>(
                "ResourceRequirements",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ResourceRequirements {
        static instance: ::protobuf::rt::LazyV2<ResourceRequirements> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ResourceRequirements::new)
    }
}

impl ::protobuf::Clear for ResourceRequirements {
    fn clear(&mut self) {
        self.limits.clear();
        self.requests.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ResourceRequirements {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResourceRequirements {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SELinuxOptions {
    // message fields
    user: ::protobuf::SingularField<::std::string::String>,
    role: ::protobuf::SingularField<::std::string::String>,
    field_type: ::protobuf::SingularField<::std::string::String>,
    level: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SELinuxOptions {
    fn default() -> &'a SELinuxOptions {
        <SELinuxOptions as ::protobuf::Message>::default_instance()
    }
}

impl SELinuxOptions {
    pub fn new() -> SELinuxOptions {
        ::std::default::Default::default()
    }

    // optional string user = 1;


    pub fn get_user(&self) -> &str {
        match self.user.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_user(&mut self) {
        self.user.clear();
    }

    pub fn has_user(&self) -> bool {
        self.user.is_some()
    }

    // Param is passed by value, moved
    pub fn set_user(&mut self, v: ::std::string::String) {
        self.user = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user(&mut self) -> &mut ::std::string::String {
        if self.user.is_none() {
            self.user.set_default();
        }
        self.user.as_mut().unwrap()
    }

    // Take field
    pub fn take_user(&mut self) -> ::std::string::String {
        self.user.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string role = 2;


    pub fn get_role(&self) -> &str {
        match self.role.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_role(&mut self) {
        self.role.clear();
    }

    pub fn has_role(&self) -> bool {
        self.role.is_some()
    }

    // Param is passed by value, moved
    pub fn set_role(&mut self, v: ::std::string::String) {
        self.role = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_role(&mut self) -> &mut ::std::string::String {
        if self.role.is_none() {
            self.role.set_default();
        }
        self.role.as_mut().unwrap()
    }

    // Take field
    pub fn take_role(&mut self) -> ::std::string::String {
        self.role.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string type = 3;


    pub fn get_field_type(&self) -> &str {
        match self.field_type.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ::std::string::String) {
        self.field_type = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut ::std::string::String {
        if self.field_type.is_none() {
            self.field_type.set_default();
        }
        self.field_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_field_type(&mut self) -> ::std::string::String {
        self.field_type.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string level = 4;


    pub fn get_level(&self) -> &str {
        match self.level.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_level(&mut self) {
        self.level.clear();
    }

    pub fn has_level(&self) -> bool {
        self.level.is_some()
    }

    // Param is passed by value, moved
    pub fn set_level(&mut self, v: ::std::string::String) {
        self.level = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_level(&mut self) -> &mut ::std::string::String {
        if self.level.is_none() {
            self.level.set_default();
        }
        self.level.as_mut().unwrap()
    }

    // Take field
    pub fn take_level(&mut self) -> ::std::string::String {
        self.level.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for SELinuxOptions {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.user)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.role)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.field_type)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.level)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.user.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.role.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.field_type.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.level.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.user.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.role.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.field_type.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.level.as_ref() {
            os.write_string(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SELinuxOptions {
        SELinuxOptions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "user",
                |m: &SELinuxOptions| { &m.user },
                |m: &mut SELinuxOptions| { &mut m.user },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "role",
                |m: &SELinuxOptions| { &m.role },
                |m: &mut SELinuxOptions| { &mut m.role },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "type",
                |m: &SELinuxOptions| { &m.field_type },
                |m: &mut SELinuxOptions| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "level",
                |m: &SELinuxOptions| { &m.level },
                |m: &mut SELinuxOptions| { &mut m.level },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SELinuxOptions>(
                "SELinuxOptions",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SELinuxOptions {
        static instance: ::protobuf::rt::LazyV2<SELinuxOptions> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SELinuxOptions::new)
    }
}

impl ::protobuf::Clear for SELinuxOptions {
    fn clear(&mut self) {
        self.user.clear();
        self.role.clear();
        self.field_type.clear();
        self.level.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SELinuxOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SELinuxOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ScaleIOPersistentVolumeSource {
    // message fields
    gateway: ::protobuf::SingularField<::std::string::String>,
    system: ::protobuf::SingularField<::std::string::String>,
    pub secretRef: ::protobuf::SingularPtrField<SecretReference>,
    sslEnabled: ::std::option::Option<bool>,
    protectionDomain: ::protobuf::SingularField<::std::string::String>,
    storagePool: ::protobuf::SingularField<::std::string::String>,
    storageMode: ::protobuf::SingularField<::std::string::String>,
    volumeName: ::protobuf::SingularField<::std::string::String>,
    fsType: ::protobuf::SingularField<::std::string::String>,
    readOnly: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ScaleIOPersistentVolumeSource {
    fn default() -> &'a ScaleIOPersistentVolumeSource {
        <ScaleIOPersistentVolumeSource as ::protobuf::Message>::default_instance()
    }
}

impl ScaleIOPersistentVolumeSource {
    pub fn new() -> ScaleIOPersistentVolumeSource {
        ::std::default::Default::default()
    }

    // optional string gateway = 1;


    pub fn get_gateway(&self) -> &str {
        match self.gateway.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_gateway(&mut self) {
        self.gateway.clear();
    }

    pub fn has_gateway(&self) -> bool {
        self.gateway.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gateway(&mut self, v: ::std::string::String) {
        self.gateway = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gateway(&mut self) -> &mut ::std::string::String {
        if self.gateway.is_none() {
            self.gateway.set_default();
        }
        self.gateway.as_mut().unwrap()
    }

    // Take field
    pub fn take_gateway(&mut self) -> ::std::string::String {
        self.gateway.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string system = 2;


    pub fn get_system(&self) -> &str {
        match self.system.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_system(&mut self) {
        self.system.clear();
    }

    pub fn has_system(&self) -> bool {
        self.system.is_some()
    }

    // Param is passed by value, moved
    pub fn set_system(&mut self, v: ::std::string::String) {
        self.system = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_system(&mut self) -> &mut ::std::string::String {
        if self.system.is_none() {
            self.system.set_default();
        }
        self.system.as_mut().unwrap()
    }

    // Take field
    pub fn take_system(&mut self) -> ::std::string::String {
        self.system.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .k8s.io.api.core.v1.SecretReference secretRef = 3;


    pub fn get_secretRef(&self) -> &SecretReference {
        self.secretRef.as_ref().unwrap_or_else(|| <SecretReference as ::protobuf::Message>::default_instance())
    }
    pub fn clear_secretRef(&mut self) {
        self.secretRef.clear();
    }

    pub fn has_secretRef(&self) -> bool {
        self.secretRef.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secretRef(&mut self, v: SecretReference) {
        self.secretRef = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_secretRef(&mut self) -> &mut SecretReference {
        if self.secretRef.is_none() {
            self.secretRef.set_default();
        }
        self.secretRef.as_mut().unwrap()
    }

    // Take field
    pub fn take_secretRef(&mut self) -> SecretReference {
        self.secretRef.take().unwrap_or_else(|| SecretReference::new())
    }

    // optional bool sslEnabled = 4;


    pub fn get_sslEnabled(&self) -> bool {
        self.sslEnabled.unwrap_or(false)
    }
    pub fn clear_sslEnabled(&mut self) {
        self.sslEnabled = ::std::option::Option::None;
    }

    pub fn has_sslEnabled(&self) -> bool {
        self.sslEnabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sslEnabled(&mut self, v: bool) {
        self.sslEnabled = ::std::option::Option::Some(v);
    }

    // optional string protectionDomain = 5;


    pub fn get_protectionDomain(&self) -> &str {
        match self.protectionDomain.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_protectionDomain(&mut self) {
        self.protectionDomain.clear();
    }

    pub fn has_protectionDomain(&self) -> bool {
        self.protectionDomain.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protectionDomain(&mut self, v: ::std::string::String) {
        self.protectionDomain = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_protectionDomain(&mut self) -> &mut ::std::string::String {
        if self.protectionDomain.is_none() {
            self.protectionDomain.set_default();
        }
        self.protectionDomain.as_mut().unwrap()
    }

    // Take field
    pub fn take_protectionDomain(&mut self) -> ::std::string::String {
        self.protectionDomain.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string storagePool = 6;


    pub fn get_storagePool(&self) -> &str {
        match self.storagePool.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_storagePool(&mut self) {
        self.storagePool.clear();
    }

    pub fn has_storagePool(&self) -> bool {
        self.storagePool.is_some()
    }

    // Param is passed by value, moved
    pub fn set_storagePool(&mut self, v: ::std::string::String) {
        self.storagePool = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_storagePool(&mut self) -> &mut ::std::string::String {
        if self.storagePool.is_none() {
            self.storagePool.set_default();
        }
        self.storagePool.as_mut().unwrap()
    }

    // Take field
    pub fn take_storagePool(&mut self) -> ::std::string::String {
        self.storagePool.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string storageMode = 7;


    pub fn get_storageMode(&self) -> &str {
        match self.storageMode.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_storageMode(&mut self) {
        self.storageMode.clear();
    }

    pub fn has_storageMode(&self) -> bool {
        self.storageMode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_storageMode(&mut self, v: ::std::string::String) {
        self.storageMode = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_storageMode(&mut self) -> &mut ::std::string::String {
        if self.storageMode.is_none() {
            self.storageMode.set_default();
        }
        self.storageMode.as_mut().unwrap()
    }

    // Take field
    pub fn take_storageMode(&mut self) -> ::std::string::String {
        self.storageMode.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string volumeName = 8;


    pub fn get_volumeName(&self) -> &str {
        match self.volumeName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_volumeName(&mut self) {
        self.volumeName.clear();
    }

    pub fn has_volumeName(&self) -> bool {
        self.volumeName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_volumeName(&mut self, v: ::std::string::String) {
        self.volumeName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_volumeName(&mut self) -> &mut ::std::string::String {
        if self.volumeName.is_none() {
            self.volumeName.set_default();
        }
        self.volumeName.as_mut().unwrap()
    }

    // Take field
    pub fn take_volumeName(&mut self) -> ::std::string::String {
        self.volumeName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string fsType = 9;


    pub fn get_fsType(&self) -> &str {
        match self.fsType.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_fsType(&mut self) {
        self.fsType.clear();
    }

    pub fn has_fsType(&self) -> bool {
        self.fsType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fsType(&mut self, v: ::std::string::String) {
        self.fsType = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fsType(&mut self) -> &mut ::std::string::String {
        if self.fsType.is_none() {
            self.fsType.set_default();
        }
        self.fsType.as_mut().unwrap()
    }

    // Take field
    pub fn take_fsType(&mut self) -> ::std::string::String {
        self.fsType.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool readOnly = 10;


    pub fn get_readOnly(&self) -> bool {
        self.readOnly.unwrap_or(false)
    }
    pub fn clear_readOnly(&mut self) {
        self.readOnly = ::std::option::Option::None;
    }

    pub fn has_readOnly(&self) -> bool {
        self.readOnly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readOnly(&mut self, v: bool) {
        self.readOnly = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ScaleIOPersistentVolumeSource {
    fn is_initialized(&self) -> bool {
        for v in &self.secretRef {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.gateway)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.system)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.secretRef)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.sslEnabled = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.protectionDomain)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.storagePool)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.storageMode)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.volumeName)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.fsType)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.readOnly = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.gateway.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.system.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.secretRef.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.sslEnabled {
            my_size += 2;
        }
        if let Some(ref v) = self.protectionDomain.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.storagePool.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(ref v) = self.storageMode.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(ref v) = self.volumeName.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(ref v) = self.fsType.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(v) = self.readOnly {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.gateway.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.system.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.secretRef.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.sslEnabled {
            os.write_bool(4, v)?;
        }
        if let Some(ref v) = self.protectionDomain.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.storagePool.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(ref v) = self.storageMode.as_ref() {
            os.write_string(7, &v)?;
        }
        if let Some(ref v) = self.volumeName.as_ref() {
            os.write_string(8, &v)?;
        }
        if let Some(ref v) = self.fsType.as_ref() {
            os.write_string(9, &v)?;
        }
        if let Some(v) = self.readOnly {
            os.write_bool(10, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ScaleIOPersistentVolumeSource {
        ScaleIOPersistentVolumeSource::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "gateway",
                |m: &ScaleIOPersistentVolumeSource| { &m.gateway },
                |m: &mut ScaleIOPersistentVolumeSource| { &mut m.gateway },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "system",
                |m: &ScaleIOPersistentVolumeSource| { &m.system },
                |m: &mut ScaleIOPersistentVolumeSource| { &mut m.system },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SecretReference>>(
                "secretRef",
                |m: &ScaleIOPersistentVolumeSource| { &m.secretRef },
                |m: &mut ScaleIOPersistentVolumeSource| { &mut m.secretRef },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "sslEnabled",
                |m: &ScaleIOPersistentVolumeSource| { &m.sslEnabled },
                |m: &mut ScaleIOPersistentVolumeSource| { &mut m.sslEnabled },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "protectionDomain",
                |m: &ScaleIOPersistentVolumeSource| { &m.protectionDomain },
                |m: &mut ScaleIOPersistentVolumeSource| { &mut m.protectionDomain },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "storagePool",
                |m: &ScaleIOPersistentVolumeSource| { &m.storagePool },
                |m: &mut ScaleIOPersistentVolumeSource| { &mut m.storagePool },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "storageMode",
                |m: &ScaleIOPersistentVolumeSource| { &m.storageMode },
                |m: &mut ScaleIOPersistentVolumeSource| { &mut m.storageMode },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "volumeName",
                |m: &ScaleIOPersistentVolumeSource| { &m.volumeName },
                |m: &mut ScaleIOPersistentVolumeSource| { &mut m.volumeName },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "fsType",
                |m: &ScaleIOPersistentVolumeSource| { &m.fsType },
                |m: &mut ScaleIOPersistentVolumeSource| { &mut m.fsType },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "readOnly",
                |m: &ScaleIOPersistentVolumeSource| { &m.readOnly },
                |m: &mut ScaleIOPersistentVolumeSource| { &mut m.readOnly },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ScaleIOPersistentVolumeSource>(
                "ScaleIOPersistentVolumeSource",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ScaleIOPersistentVolumeSource {
        static instance: ::protobuf::rt::LazyV2<ScaleIOPersistentVolumeSource> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ScaleIOPersistentVolumeSource::new)
    }
}

impl ::protobuf::Clear for ScaleIOPersistentVolumeSource {
    fn clear(&mut self) {
        self.gateway.clear();
        self.system.clear();
        self.secretRef.clear();
        self.sslEnabled = ::std::option::Option::None;
        self.protectionDomain.clear();
        self.storagePool.clear();
        self.storageMode.clear();
        self.volumeName.clear();
        self.fsType.clear();
        self.readOnly = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ScaleIOPersistentVolumeSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ScaleIOPersistentVolumeSource {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ScaleIOVolumeSource {
    // message fields
    gateway: ::protobuf::SingularField<::std::string::String>,
    system: ::protobuf::SingularField<::std::string::String>,
    pub secretRef: ::protobuf::SingularPtrField<LocalObjectReference>,
    sslEnabled: ::std::option::Option<bool>,
    protectionDomain: ::protobuf::SingularField<::std::string::String>,
    storagePool: ::protobuf::SingularField<::std::string::String>,
    storageMode: ::protobuf::SingularField<::std::string::String>,
    volumeName: ::protobuf::SingularField<::std::string::String>,
    fsType: ::protobuf::SingularField<::std::string::String>,
    readOnly: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ScaleIOVolumeSource {
    fn default() -> &'a ScaleIOVolumeSource {
        <ScaleIOVolumeSource as ::protobuf::Message>::default_instance()
    }
}

impl ScaleIOVolumeSource {
    pub fn new() -> ScaleIOVolumeSource {
        ::std::default::Default::default()
    }

    // optional string gateway = 1;


    pub fn get_gateway(&self) -> &str {
        match self.gateway.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_gateway(&mut self) {
        self.gateway.clear();
    }

    pub fn has_gateway(&self) -> bool {
        self.gateway.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gateway(&mut self, v: ::std::string::String) {
        self.gateway = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gateway(&mut self) -> &mut ::std::string::String {
        if self.gateway.is_none() {
            self.gateway.set_default();
        }
        self.gateway.as_mut().unwrap()
    }

    // Take field
    pub fn take_gateway(&mut self) -> ::std::string::String {
        self.gateway.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string system = 2;


    pub fn get_system(&self) -> &str {
        match self.system.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_system(&mut self) {
        self.system.clear();
    }

    pub fn has_system(&self) -> bool {
        self.system.is_some()
    }

    // Param is passed by value, moved
    pub fn set_system(&mut self, v: ::std::string::String) {
        self.system = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_system(&mut self) -> &mut ::std::string::String {
        if self.system.is_none() {
            self.system.set_default();
        }
        self.system.as_mut().unwrap()
    }

    // Take field
    pub fn take_system(&mut self) -> ::std::string::String {
        self.system.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .k8s.io.api.core.v1.LocalObjectReference secretRef = 3;


    pub fn get_secretRef(&self) -> &LocalObjectReference {
        self.secretRef.as_ref().unwrap_or_else(|| <LocalObjectReference as ::protobuf::Message>::default_instance())
    }
    pub fn clear_secretRef(&mut self) {
        self.secretRef.clear();
    }

    pub fn has_secretRef(&self) -> bool {
        self.secretRef.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secretRef(&mut self, v: LocalObjectReference) {
        self.secretRef = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_secretRef(&mut self) -> &mut LocalObjectReference {
        if self.secretRef.is_none() {
            self.secretRef.set_default();
        }
        self.secretRef.as_mut().unwrap()
    }

    // Take field
    pub fn take_secretRef(&mut self) -> LocalObjectReference {
        self.secretRef.take().unwrap_or_else(|| LocalObjectReference::new())
    }

    // optional bool sslEnabled = 4;


    pub fn get_sslEnabled(&self) -> bool {
        self.sslEnabled.unwrap_or(false)
    }
    pub fn clear_sslEnabled(&mut self) {
        self.sslEnabled = ::std::option::Option::None;
    }

    pub fn has_sslEnabled(&self) -> bool {
        self.sslEnabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sslEnabled(&mut self, v: bool) {
        self.sslEnabled = ::std::option::Option::Some(v);
    }

    // optional string protectionDomain = 5;


    pub fn get_protectionDomain(&self) -> &str {
        match self.protectionDomain.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_protectionDomain(&mut self) {
        self.protectionDomain.clear();
    }

    pub fn has_protectionDomain(&self) -> bool {
        self.protectionDomain.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protectionDomain(&mut self, v: ::std::string::String) {
        self.protectionDomain = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_protectionDomain(&mut self) -> &mut ::std::string::String {
        if self.protectionDomain.is_none() {
            self.protectionDomain.set_default();
        }
        self.protectionDomain.as_mut().unwrap()
    }

    // Take field
    pub fn take_protectionDomain(&mut self) -> ::std::string::String {
        self.protectionDomain.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string storagePool = 6;


    pub fn get_storagePool(&self) -> &str {
        match self.storagePool.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_storagePool(&mut self) {
        self.storagePool.clear();
    }

    pub fn has_storagePool(&self) -> bool {
        self.storagePool.is_some()
    }

    // Param is passed by value, moved
    pub fn set_storagePool(&mut self, v: ::std::string::String) {
        self.storagePool = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_storagePool(&mut self) -> &mut ::std::string::String {
        if self.storagePool.is_none() {
            self.storagePool.set_default();
        }
        self.storagePool.as_mut().unwrap()
    }

    // Take field
    pub fn take_storagePool(&mut self) -> ::std::string::String {
        self.storagePool.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string storageMode = 7;


    pub fn get_storageMode(&self) -> &str {
        match self.storageMode.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_storageMode(&mut self) {
        self.storageMode.clear();
    }

    pub fn has_storageMode(&self) -> bool {
        self.storageMode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_storageMode(&mut self, v: ::std::string::String) {
        self.storageMode = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_storageMode(&mut self) -> &mut ::std::string::String {
        if self.storageMode.is_none() {
            self.storageMode.set_default();
        }
        self.storageMode.as_mut().unwrap()
    }

    // Take field
    pub fn take_storageMode(&mut self) -> ::std::string::String {
        self.storageMode.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string volumeName = 8;


    pub fn get_volumeName(&self) -> &str {
        match self.volumeName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_volumeName(&mut self) {
        self.volumeName.clear();
    }

    pub fn has_volumeName(&self) -> bool {
        self.volumeName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_volumeName(&mut self, v: ::std::string::String) {
        self.volumeName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_volumeName(&mut self) -> &mut ::std::string::String {
        if self.volumeName.is_none() {
            self.volumeName.set_default();
        }
        self.volumeName.as_mut().unwrap()
    }

    // Take field
    pub fn take_volumeName(&mut self) -> ::std::string::String {
        self.volumeName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string fsType = 9;


    pub fn get_fsType(&self) -> &str {
        match self.fsType.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_fsType(&mut self) {
        self.fsType.clear();
    }

    pub fn has_fsType(&self) -> bool {
        self.fsType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fsType(&mut self, v: ::std::string::String) {
        self.fsType = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fsType(&mut self) -> &mut ::std::string::String {
        if self.fsType.is_none() {
            self.fsType.set_default();
        }
        self.fsType.as_mut().unwrap()
    }

    // Take field
    pub fn take_fsType(&mut self) -> ::std::string::String {
        self.fsType.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool readOnly = 10;


    pub fn get_readOnly(&self) -> bool {
        self.readOnly.unwrap_or(false)
    }
    pub fn clear_readOnly(&mut self) {
        self.readOnly = ::std::option::Option::None;
    }

    pub fn has_readOnly(&self) -> bool {
        self.readOnly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readOnly(&mut self, v: bool) {
        self.readOnly = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ScaleIOVolumeSource {
    fn is_initialized(&self) -> bool {
        for v in &self.secretRef {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.gateway)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.system)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.secretRef)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.sslEnabled = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.protectionDomain)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.storagePool)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.storageMode)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.volumeName)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.fsType)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.readOnly = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.gateway.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.system.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.secretRef.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.sslEnabled {
            my_size += 2;
        }
        if let Some(ref v) = self.protectionDomain.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.storagePool.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(ref v) = self.storageMode.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(ref v) = self.volumeName.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(ref v) = self.fsType.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(v) = self.readOnly {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.gateway.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.system.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.secretRef.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.sslEnabled {
            os.write_bool(4, v)?;
        }
        if let Some(ref v) = self.protectionDomain.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.storagePool.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(ref v) = self.storageMode.as_ref() {
            os.write_string(7, &v)?;
        }
        if let Some(ref v) = self.volumeName.as_ref() {
            os.write_string(8, &v)?;
        }
        if let Some(ref v) = self.fsType.as_ref() {
            os.write_string(9, &v)?;
        }
        if let Some(v) = self.readOnly {
            os.write_bool(10, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ScaleIOVolumeSource {
        ScaleIOVolumeSource::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "gateway",
                |m: &ScaleIOVolumeSource| { &m.gateway },
                |m: &mut ScaleIOVolumeSource| { &mut m.gateway },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "system",
                |m: &ScaleIOVolumeSource| { &m.system },
                |m: &mut ScaleIOVolumeSource| { &mut m.system },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LocalObjectReference>>(
                "secretRef",
                |m: &ScaleIOVolumeSource| { &m.secretRef },
                |m: &mut ScaleIOVolumeSource| { &mut m.secretRef },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "sslEnabled",
                |m: &ScaleIOVolumeSource| { &m.sslEnabled },
                |m: &mut ScaleIOVolumeSource| { &mut m.sslEnabled },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "protectionDomain",
                |m: &ScaleIOVolumeSource| { &m.protectionDomain },
                |m: &mut ScaleIOVolumeSource| { &mut m.protectionDomain },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "storagePool",
                |m: &ScaleIOVolumeSource| { &m.storagePool },
                |m: &mut ScaleIOVolumeSource| { &mut m.storagePool },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "storageMode",
                |m: &ScaleIOVolumeSource| { &m.storageMode },
                |m: &mut ScaleIOVolumeSource| { &mut m.storageMode },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "volumeName",
                |m: &ScaleIOVolumeSource| { &m.volumeName },
                |m: &mut ScaleIOVolumeSource| { &mut m.volumeName },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "fsType",
                |m: &ScaleIOVolumeSource| { &m.fsType },
                |m: &mut ScaleIOVolumeSource| { &mut m.fsType },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "readOnly",
                |m: &ScaleIOVolumeSource| { &m.readOnly },
                |m: &mut ScaleIOVolumeSource| { &mut m.readOnly },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ScaleIOVolumeSource>(
                "ScaleIOVolumeSource",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ScaleIOVolumeSource {
        static instance: ::protobuf::rt::LazyV2<ScaleIOVolumeSource> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ScaleIOVolumeSource::new)
    }
}

impl ::protobuf::Clear for ScaleIOVolumeSource {
    fn clear(&mut self) {
        self.gateway.clear();
        self.system.clear();
        self.secretRef.clear();
        self.sslEnabled = ::std::option::Option::None;
        self.protectionDomain.clear();
        self.storagePool.clear();
        self.storageMode.clear();
        self.volumeName.clear();
        self.fsType.clear();
        self.readOnly = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ScaleIOVolumeSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ScaleIOVolumeSource {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ScopeSelector {
    // message fields
    pub matchExpressions: ::protobuf::RepeatedField<ScopedResourceSelectorRequirement>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ScopeSelector {
    fn default() -> &'a ScopeSelector {
        <ScopeSelector as ::protobuf::Message>::default_instance()
    }
}

impl ScopeSelector {
    pub fn new() -> ScopeSelector {
        ::std::default::Default::default()
    }

    // repeated .k8s.io.api.core.v1.ScopedResourceSelectorRequirement matchExpressions = 1;


    pub fn get_matchExpressions(&self) -> &[ScopedResourceSelectorRequirement] {
        &self.matchExpressions
    }
    pub fn clear_matchExpressions(&mut self) {
        self.matchExpressions.clear();
    }

    // Param is passed by value, moved
    pub fn set_matchExpressions(&mut self, v: ::protobuf::RepeatedField<ScopedResourceSelectorRequirement>) {
        self.matchExpressions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_matchExpressions(&mut self) -> &mut ::protobuf::RepeatedField<ScopedResourceSelectorRequirement> {
        &mut self.matchExpressions
    }

    // Take field
    pub fn take_matchExpressions(&mut self) -> ::protobuf::RepeatedField<ScopedResourceSelectorRequirement> {
        ::std::mem::replace(&mut self.matchExpressions, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ScopeSelector {
    fn is_initialized(&self) -> bool {
        for v in &self.matchExpressions {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.matchExpressions)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.matchExpressions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.matchExpressions {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ScopeSelector {
        ScopeSelector::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ScopedResourceSelectorRequirement>>(
                "matchExpressions",
                |m: &ScopeSelector| { &m.matchExpressions },
                |m: &mut ScopeSelector| { &mut m.matchExpressions },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ScopeSelector>(
                "ScopeSelector",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ScopeSelector {
        static instance: ::protobuf::rt::LazyV2<ScopeSelector> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ScopeSelector::new)
    }
}

impl ::protobuf::Clear for ScopeSelector {
    fn clear(&mut self) {
        self.matchExpressions.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ScopeSelector {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ScopeSelector {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ScopedResourceSelectorRequirement {
    // message fields
    scopeName: ::protobuf::SingularField<::std::string::String>,
    operator: ::protobuf::SingularField<::std::string::String>,
    pub values: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ScopedResourceSelectorRequirement {
    fn default() -> &'a ScopedResourceSelectorRequirement {
        <ScopedResourceSelectorRequirement as ::protobuf::Message>::default_instance()
    }
}

impl ScopedResourceSelectorRequirement {
    pub fn new() -> ScopedResourceSelectorRequirement {
        ::std::default::Default::default()
    }

    // optional string scopeName = 1;


    pub fn get_scopeName(&self) -> &str {
        match self.scopeName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_scopeName(&mut self) {
        self.scopeName.clear();
    }

    pub fn has_scopeName(&self) -> bool {
        self.scopeName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scopeName(&mut self, v: ::std::string::String) {
        self.scopeName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_scopeName(&mut self) -> &mut ::std::string::String {
        if self.scopeName.is_none() {
            self.scopeName.set_default();
        }
        self.scopeName.as_mut().unwrap()
    }

    // Take field
    pub fn take_scopeName(&mut self) -> ::std::string::String {
        self.scopeName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string operator = 2;


    pub fn get_operator(&self) -> &str {
        match self.operator.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_operator(&mut self) {
        self.operator.clear();
    }

    pub fn has_operator(&self) -> bool {
        self.operator.is_some()
    }

    // Param is passed by value, moved
    pub fn set_operator(&mut self, v: ::std::string::String) {
        self.operator = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_operator(&mut self) -> &mut ::std::string::String {
        if self.operator.is_none() {
            self.operator.set_default();
        }
        self.operator.as_mut().unwrap()
    }

    // Take field
    pub fn take_operator(&mut self) -> ::std::string::String {
        self.operator.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated string values = 3;


    pub fn get_values(&self) -> &[::std::string::String] {
        &self.values
    }
    pub fn clear_values(&mut self) {
        self.values.clear();
    }

    // Param is passed by value, moved
    pub fn set_values(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.values = v;
    }

    // Mutable pointer to the field.
    pub fn mut_values(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.values
    }

    // Take field
    pub fn take_values(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.values, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ScopedResourceSelectorRequirement {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.scopeName)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.operator)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.values)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.scopeName.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.operator.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        for value in &self.values {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.scopeName.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.operator.as_ref() {
            os.write_string(2, &v)?;
        }
        for v in &self.values {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ScopedResourceSelectorRequirement {
        ScopedResourceSelectorRequirement::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "scopeName",
                |m: &ScopedResourceSelectorRequirement| { &m.scopeName },
                |m: &mut ScopedResourceSelectorRequirement| { &mut m.scopeName },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "operator",
                |m: &ScopedResourceSelectorRequirement| { &m.operator },
                |m: &mut ScopedResourceSelectorRequirement| { &mut m.operator },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "values",
                |m: &ScopedResourceSelectorRequirement| { &m.values },
                |m: &mut ScopedResourceSelectorRequirement| { &mut m.values },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ScopedResourceSelectorRequirement>(
                "ScopedResourceSelectorRequirement",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ScopedResourceSelectorRequirement {
        static instance: ::protobuf::rt::LazyV2<ScopedResourceSelectorRequirement> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ScopedResourceSelectorRequirement::new)
    }
}

impl ::protobuf::Clear for ScopedResourceSelectorRequirement {
    fn clear(&mut self) {
        self.scopeName.clear();
        self.operator.clear();
        self.values.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ScopedResourceSelectorRequirement {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ScopedResourceSelectorRequirement {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SeccompProfile {
    // message fields
    field_type: ::protobuf::SingularField<::std::string::String>,
    localhostProfile: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SeccompProfile {
    fn default() -> &'a SeccompProfile {
        <SeccompProfile as ::protobuf::Message>::default_instance()
    }
}

impl SeccompProfile {
    pub fn new() -> SeccompProfile {
        ::std::default::Default::default()
    }

    // optional string type = 1;


    pub fn get_field_type(&self) -> &str {
        match self.field_type.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ::std::string::String) {
        self.field_type = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut ::std::string::String {
        if self.field_type.is_none() {
            self.field_type.set_default();
        }
        self.field_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_field_type(&mut self) -> ::std::string::String {
        self.field_type.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string localhostProfile = 2;


    pub fn get_localhostProfile(&self) -> &str {
        match self.localhostProfile.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_localhostProfile(&mut self) {
        self.localhostProfile.clear();
    }

    pub fn has_localhostProfile(&self) -> bool {
        self.localhostProfile.is_some()
    }

    // Param is passed by value, moved
    pub fn set_localhostProfile(&mut self, v: ::std::string::String) {
        self.localhostProfile = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_localhostProfile(&mut self) -> &mut ::std::string::String {
        if self.localhostProfile.is_none() {
            self.localhostProfile.set_default();
        }
        self.localhostProfile.as_mut().unwrap()
    }

    // Take field
    pub fn take_localhostProfile(&mut self) -> ::std::string::String {
        self.localhostProfile.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for SeccompProfile {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.field_type)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.localhostProfile)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.field_type.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.localhostProfile.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.field_type.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.localhostProfile.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SeccompProfile {
        SeccompProfile::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "type",
                |m: &SeccompProfile| { &m.field_type },
                |m: &mut SeccompProfile| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "localhostProfile",
                |m: &SeccompProfile| { &m.localhostProfile },
                |m: &mut SeccompProfile| { &mut m.localhostProfile },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SeccompProfile>(
                "SeccompProfile",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SeccompProfile {
        static instance: ::protobuf::rt::LazyV2<SeccompProfile> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SeccompProfile::new)
    }
}

impl ::protobuf::Clear for SeccompProfile {
    fn clear(&mut self) {
        self.field_type.clear();
        self.localhostProfile.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SeccompProfile {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SeccompProfile {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Secret {
    // message fields
    pub metadata: ::protobuf::SingularPtrField<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta>,
    immutable: ::std::option::Option<bool>,
    pub data: ::std::collections::HashMap<::std::string::String, ::std::vec::Vec<u8>>,
    pub stringData: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    field_type: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Secret {
    fn default() -> &'a Secret {
        <Secret as ::protobuf::Message>::default_instance()
    }
}

impl Secret {
    pub fn new() -> Secret {
        ::std::default::Default::default()
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;


    pub fn get_metadata(&self) -> &super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta::new())
    }

    // optional bool immutable = 5;


    pub fn get_immutable(&self) -> bool {
        self.immutable.unwrap_or(false)
    }
    pub fn clear_immutable(&mut self) {
        self.immutable = ::std::option::Option::None;
    }

    pub fn has_immutable(&self) -> bool {
        self.immutable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_immutable(&mut self, v: bool) {
        self.immutable = ::std::option::Option::Some(v);
    }

    // repeated .k8s.io.api.core.v1.Secret.DataEntry data = 2;


    pub fn get_data(&self) -> &::std::collections::HashMap<::std::string::String, ::std::vec::Vec<u8>> {
        &self.data
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::vec::Vec<u8>>) {
        self.data = v;
    }

    // Mutable pointer to the field.
    pub fn mut_data(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::vec::Vec<u8>> {
        &mut self.data
    }

    // Take field
    pub fn take_data(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.data, ::std::collections::HashMap::new())
    }

    // repeated .k8s.io.api.core.v1.Secret.StringDataEntry stringData = 4;


    pub fn get_stringData(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.stringData
    }
    pub fn clear_stringData(&mut self) {
        self.stringData.clear();
    }

    // Param is passed by value, moved
    pub fn set_stringData(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.stringData = v;
    }

    // Mutable pointer to the field.
    pub fn mut_stringData(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.stringData
    }

    // Take field
    pub fn take_stringData(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.stringData, ::std::collections::HashMap::new())
    }

    // optional string type = 3;


    pub fn get_field_type(&self) -> &str {
        match self.field_type.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ::std::string::String) {
        self.field_type = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut ::std::string::String {
        if self.field_type.is_none() {
            self.field_type.set_default();
        }
        self.field_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_field_type(&mut self) -> ::std::string::String {
        self.field_type.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for Secret {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.immutable = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeBytes>(wire_type, is, &mut self.data)?;
                },
                4 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.stringData)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.field_type)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.immutable {
            my_size += 2;
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeBytes>(2, &self.data);
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(4, &self.stringData);
        if let Some(ref v) = self.field_type.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.immutable {
            os.write_bool(5, v)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeBytes>(2, &self.data, os)?;
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(4, &self.stringData, os)?;
        if let Some(ref v) = self.field_type.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Secret {
        Secret::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta>>(
                "metadata",
                |m: &Secret| { &m.metadata },
                |m: &mut Secret| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "immutable",
                |m: &Secret| { &m.immutable },
                |m: &mut Secret| { &mut m.immutable },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeBytes>(
                "data",
                |m: &Secret| { &m.data },
                |m: &mut Secret| { &mut m.data },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                "stringData",
                |m: &Secret| { &m.stringData },
                |m: &mut Secret| { &mut m.stringData },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "type",
                |m: &Secret| { &m.field_type },
                |m: &mut Secret| { &mut m.field_type },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Secret>(
                "Secret",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Secret {
        static instance: ::protobuf::rt::LazyV2<Secret> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Secret::new)
    }
}

impl ::protobuf::Clear for Secret {
    fn clear(&mut self) {
        self.metadata.clear();
        self.immutable = ::std::option::Option::None;
        self.data.clear();
        self.stringData.clear();
        self.field_type.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Secret {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Secret {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SecretEnvSource {
    // message fields
    pub localObjectReference: ::protobuf::SingularPtrField<LocalObjectReference>,
    optional: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SecretEnvSource {
    fn default() -> &'a SecretEnvSource {
        <SecretEnvSource as ::protobuf::Message>::default_instance()
    }
}

impl SecretEnvSource {
    pub fn new() -> SecretEnvSource {
        ::std::default::Default::default()
    }

    // optional .k8s.io.api.core.v1.LocalObjectReference localObjectReference = 1;


    pub fn get_localObjectReference(&self) -> &LocalObjectReference {
        self.localObjectReference.as_ref().unwrap_or_else(|| <LocalObjectReference as ::protobuf::Message>::default_instance())
    }
    pub fn clear_localObjectReference(&mut self) {
        self.localObjectReference.clear();
    }

    pub fn has_localObjectReference(&self) -> bool {
        self.localObjectReference.is_some()
    }

    // Param is passed by value, moved
    pub fn set_localObjectReference(&mut self, v: LocalObjectReference) {
        self.localObjectReference = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_localObjectReference(&mut self) -> &mut LocalObjectReference {
        if self.localObjectReference.is_none() {
            self.localObjectReference.set_default();
        }
        self.localObjectReference.as_mut().unwrap()
    }

    // Take field
    pub fn take_localObjectReference(&mut self) -> LocalObjectReference {
        self.localObjectReference.take().unwrap_or_else(|| LocalObjectReference::new())
    }

    // optional bool optional = 2;


    pub fn get_optional(&self) -> bool {
        self.optional.unwrap_or(false)
    }
    pub fn clear_optional(&mut self) {
        self.optional = ::std::option::Option::None;
    }

    pub fn has_optional(&self) -> bool {
        self.optional.is_some()
    }

    // Param is passed by value, moved
    pub fn set_optional(&mut self, v: bool) {
        self.optional = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for SecretEnvSource {
    fn is_initialized(&self) -> bool {
        for v in &self.localObjectReference {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.localObjectReference)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.optional = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.localObjectReference.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.optional {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.localObjectReference.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.optional {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SecretEnvSource {
        SecretEnvSource::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LocalObjectReference>>(
                "localObjectReference",
                |m: &SecretEnvSource| { &m.localObjectReference },
                |m: &mut SecretEnvSource| { &mut m.localObjectReference },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "optional",
                |m: &SecretEnvSource| { &m.optional },
                |m: &mut SecretEnvSource| { &mut m.optional },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SecretEnvSource>(
                "SecretEnvSource",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SecretEnvSource {
        static instance: ::protobuf::rt::LazyV2<SecretEnvSource> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SecretEnvSource::new)
    }
}

impl ::protobuf::Clear for SecretEnvSource {
    fn clear(&mut self) {
        self.localObjectReference.clear();
        self.optional = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SecretEnvSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SecretEnvSource {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SecretKeySelector {
    // message fields
    pub localObjectReference: ::protobuf::SingularPtrField<LocalObjectReference>,
    key: ::protobuf::SingularField<::std::string::String>,
    optional: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SecretKeySelector {
    fn default() -> &'a SecretKeySelector {
        <SecretKeySelector as ::protobuf::Message>::default_instance()
    }
}

impl SecretKeySelector {
    pub fn new() -> SecretKeySelector {
        ::std::default::Default::default()
    }

    // optional .k8s.io.api.core.v1.LocalObjectReference localObjectReference = 1;


    pub fn get_localObjectReference(&self) -> &LocalObjectReference {
        self.localObjectReference.as_ref().unwrap_or_else(|| <LocalObjectReference as ::protobuf::Message>::default_instance())
    }
    pub fn clear_localObjectReference(&mut self) {
        self.localObjectReference.clear();
    }

    pub fn has_localObjectReference(&self) -> bool {
        self.localObjectReference.is_some()
    }

    // Param is passed by value, moved
    pub fn set_localObjectReference(&mut self, v: LocalObjectReference) {
        self.localObjectReference = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_localObjectReference(&mut self) -> &mut LocalObjectReference {
        if self.localObjectReference.is_none() {
            self.localObjectReference.set_default();
        }
        self.localObjectReference.as_mut().unwrap()
    }

    // Take field
    pub fn take_localObjectReference(&mut self) -> LocalObjectReference {
        self.localObjectReference.take().unwrap_or_else(|| LocalObjectReference::new())
    }

    // optional string key = 2;


    pub fn get_key(&self) -> &str {
        match self.key.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        if self.key.is_none() {
            self.key.set_default();
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        self.key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool optional = 3;


    pub fn get_optional(&self) -> bool {
        self.optional.unwrap_or(false)
    }
    pub fn clear_optional(&mut self) {
        self.optional = ::std::option::Option::None;
    }

    pub fn has_optional(&self) -> bool {
        self.optional.is_some()
    }

    // Param is passed by value, moved
    pub fn set_optional(&mut self, v: bool) {
        self.optional = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for SecretKeySelector {
    fn is_initialized(&self) -> bool {
        for v in &self.localObjectReference {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.localObjectReference)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.key)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.optional = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.localObjectReference.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.key.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.optional {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.localObjectReference.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.key.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.optional {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SecretKeySelector {
        SecretKeySelector::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LocalObjectReference>>(
                "localObjectReference",
                |m: &SecretKeySelector| { &m.localObjectReference },
                |m: &mut SecretKeySelector| { &mut m.localObjectReference },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "key",
                |m: &SecretKeySelector| { &m.key },
                |m: &mut SecretKeySelector| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "optional",
                |m: &SecretKeySelector| { &m.optional },
                |m: &mut SecretKeySelector| { &mut m.optional },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SecretKeySelector>(
                "SecretKeySelector",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SecretKeySelector {
        static instance: ::protobuf::rt::LazyV2<SecretKeySelector> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SecretKeySelector::new)
    }
}

impl ::protobuf::Clear for SecretKeySelector {
    fn clear(&mut self) {
        self.localObjectReference.clear();
        self.key.clear();
        self.optional = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SecretKeySelector {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SecretKeySelector {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SecretList {
    // message fields
    pub metadata: ::protobuf::SingularPtrField<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta>,
    pub items: ::protobuf::RepeatedField<Secret>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SecretList {
    fn default() -> &'a SecretList {
        <SecretList as ::protobuf::Message>::default_instance()
    }
}

impl SecretList {
    pub fn new() -> SecretList {
        ::std::default::Default::default()
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;


    pub fn get_metadata(&self) -> &super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta {
        self.metadata.take().unwrap_or_else(|| super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta::new())
    }

    // repeated .k8s.io.api.core.v1.Secret items = 2;


    pub fn get_items(&self) -> &[Secret] {
        &self.items
    }
    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::protobuf::RepeatedField<Secret>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::protobuf::RepeatedField<Secret> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::protobuf::RepeatedField<Secret> {
        ::std::mem::replace(&mut self.items, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for SecretList {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.items {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.items)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.items {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SecretList {
        SecretList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta>>(
                "metadata",
                |m: &SecretList| { &m.metadata },
                |m: &mut SecretList| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Secret>>(
                "items",
                |m: &SecretList| { &m.items },
                |m: &mut SecretList| { &mut m.items },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SecretList>(
                "SecretList",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SecretList {
        static instance: ::protobuf::rt::LazyV2<SecretList> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SecretList::new)
    }
}

impl ::protobuf::Clear for SecretList {
    fn clear(&mut self) {
        self.metadata.clear();
        self.items.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SecretList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SecretList {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SecretProjection {
    // message fields
    pub localObjectReference: ::protobuf::SingularPtrField<LocalObjectReference>,
    pub items: ::protobuf::RepeatedField<KeyToPath>,
    optional: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SecretProjection {
    fn default() -> &'a SecretProjection {
        <SecretProjection as ::protobuf::Message>::default_instance()
    }
}

impl SecretProjection {
    pub fn new() -> SecretProjection {
        ::std::default::Default::default()
    }

    // optional .k8s.io.api.core.v1.LocalObjectReference localObjectReference = 1;


    pub fn get_localObjectReference(&self) -> &LocalObjectReference {
        self.localObjectReference.as_ref().unwrap_or_else(|| <LocalObjectReference as ::protobuf::Message>::default_instance())
    }
    pub fn clear_localObjectReference(&mut self) {
        self.localObjectReference.clear();
    }

    pub fn has_localObjectReference(&self) -> bool {
        self.localObjectReference.is_some()
    }

    // Param is passed by value, moved
    pub fn set_localObjectReference(&mut self, v: LocalObjectReference) {
        self.localObjectReference = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_localObjectReference(&mut self) -> &mut LocalObjectReference {
        if self.localObjectReference.is_none() {
            self.localObjectReference.set_default();
        }
        self.localObjectReference.as_mut().unwrap()
    }

    // Take field
    pub fn take_localObjectReference(&mut self) -> LocalObjectReference {
        self.localObjectReference.take().unwrap_or_else(|| LocalObjectReference::new())
    }

    // repeated .k8s.io.api.core.v1.KeyToPath items = 2;


    pub fn get_items(&self) -> &[KeyToPath] {
        &self.items
    }
    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::protobuf::RepeatedField<KeyToPath>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::protobuf::RepeatedField<KeyToPath> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::protobuf::RepeatedField<KeyToPath> {
        ::std::mem::replace(&mut self.items, ::protobuf::RepeatedField::new())
    }

    // optional bool optional = 4;


    pub fn get_optional(&self) -> bool {
        self.optional.unwrap_or(false)
    }
    pub fn clear_optional(&mut self) {
        self.optional = ::std::option::Option::None;
    }

    pub fn has_optional(&self) -> bool {
        self.optional.is_some()
    }

    // Param is passed by value, moved
    pub fn set_optional(&mut self, v: bool) {
        self.optional = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for SecretProjection {
    fn is_initialized(&self) -> bool {
        for v in &self.localObjectReference {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.items {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.localObjectReference)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.items)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.optional = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.localObjectReference.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.optional {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.localObjectReference.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.items {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.optional {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SecretProjection {
        SecretProjection::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LocalObjectReference>>(
                "localObjectReference",
                |m: &SecretProjection| { &m.localObjectReference },
                |m: &mut SecretProjection| { &mut m.localObjectReference },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<KeyToPath>>(
                "items",
                |m: &SecretProjection| { &m.items },
                |m: &mut SecretProjection| { &mut m.items },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "optional",
                |m: &SecretProjection| { &m.optional },
                |m: &mut SecretProjection| { &mut m.optional },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SecretProjection>(
                "SecretProjection",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SecretProjection {
        static instance: ::protobuf::rt::LazyV2<SecretProjection> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SecretProjection::new)
    }
}

impl ::protobuf::Clear for SecretProjection {
    fn clear(&mut self) {
        self.localObjectReference.clear();
        self.items.clear();
        self.optional = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SecretProjection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SecretProjection {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SecretReference {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    namespace: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SecretReference {
    fn default() -> &'a SecretReference {
        <SecretReference as ::protobuf::Message>::default_instance()
    }
}

impl SecretReference {
    pub fn new() -> SecretReference {
        ::std::default::Default::default()
    }

    // optional string name = 1;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string namespace = 2;


    pub fn get_namespace(&self) -> &str {
        match self.namespace.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_namespace(&mut self) {
        self.namespace.clear();
    }

    pub fn has_namespace(&self) -> bool {
        self.namespace.is_some()
    }

    // Param is passed by value, moved
    pub fn set_namespace(&mut self, v: ::std::string::String) {
        self.namespace = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_namespace(&mut self) -> &mut ::std::string::String {
        if self.namespace.is_none() {
            self.namespace.set_default();
        }
        self.namespace.as_mut().unwrap()
    }

    // Take field
    pub fn take_namespace(&mut self) -> ::std::string::String {
        self.namespace.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for SecretReference {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.namespace)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.namespace.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.namespace.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SecretReference {
        SecretReference::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &SecretReference| { &m.name },
                |m: &mut SecretReference| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "namespace",
                |m: &SecretReference| { &m.namespace },
                |m: &mut SecretReference| { &mut m.namespace },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SecretReference>(
                "SecretReference",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SecretReference {
        static instance: ::protobuf::rt::LazyV2<SecretReference> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SecretReference::new)
    }
}

impl ::protobuf::Clear for SecretReference {
    fn clear(&mut self) {
        self.name.clear();
        self.namespace.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SecretReference {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SecretReference {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SecretVolumeSource {
    // message fields
    secretName: ::protobuf::SingularField<::std::string::String>,
    pub items: ::protobuf::RepeatedField<KeyToPath>,
    defaultMode: ::std::option::Option<i32>,
    optional: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SecretVolumeSource {
    fn default() -> &'a SecretVolumeSource {
        <SecretVolumeSource as ::protobuf::Message>::default_instance()
    }
}

impl SecretVolumeSource {
    pub fn new() -> SecretVolumeSource {
        ::std::default::Default::default()
    }

    // optional string secretName = 1;


    pub fn get_secretName(&self) -> &str {
        match self.secretName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_secretName(&mut self) {
        self.secretName.clear();
    }

    pub fn has_secretName(&self) -> bool {
        self.secretName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secretName(&mut self, v: ::std::string::String) {
        self.secretName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_secretName(&mut self) -> &mut ::std::string::String {
        if self.secretName.is_none() {
            self.secretName.set_default();
        }
        self.secretName.as_mut().unwrap()
    }

    // Take field
    pub fn take_secretName(&mut self) -> ::std::string::String {
        self.secretName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .k8s.io.api.core.v1.KeyToPath items = 2;


    pub fn get_items(&self) -> &[KeyToPath] {
        &self.items
    }
    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::protobuf::RepeatedField<KeyToPath>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::protobuf::RepeatedField<KeyToPath> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::protobuf::RepeatedField<KeyToPath> {
        ::std::mem::replace(&mut self.items, ::protobuf::RepeatedField::new())
    }

    // optional int32 defaultMode = 3;


    pub fn get_defaultMode(&self) -> i32 {
        self.defaultMode.unwrap_or(0)
    }
    pub fn clear_defaultMode(&mut self) {
        self.defaultMode = ::std::option::Option::None;
    }

    pub fn has_defaultMode(&self) -> bool {
        self.defaultMode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_defaultMode(&mut self, v: i32) {
        self.defaultMode = ::std::option::Option::Some(v);
    }

    // optional bool optional = 4;


    pub fn get_optional(&self) -> bool {
        self.optional.unwrap_or(false)
    }
    pub fn clear_optional(&mut self) {
        self.optional = ::std::option::Option::None;
    }

    pub fn has_optional(&self) -> bool {
        self.optional.is_some()
    }

    // Param is passed by value, moved
    pub fn set_optional(&mut self, v: bool) {
        self.optional = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for SecretVolumeSource {
    fn is_initialized(&self) -> bool {
        for v in &self.items {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.secretName)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.items)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.defaultMode = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.optional = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.secretName.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.defaultMode {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.optional {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.secretName.as_ref() {
            os.write_string(1, &v)?;
        }
        for v in &self.items {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.defaultMode {
            os.write_int32(3, v)?;
        }
        if let Some(v) = self.optional {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SecretVolumeSource {
        SecretVolumeSource::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "secretName",
                |m: &SecretVolumeSource| { &m.secretName },
                |m: &mut SecretVolumeSource| { &mut m.secretName },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<KeyToPath>>(
                "items",
                |m: &SecretVolumeSource| { &m.items },
                |m: &mut SecretVolumeSource| { &mut m.items },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "defaultMode",
                |m: &SecretVolumeSource| { &m.defaultMode },
                |m: &mut SecretVolumeSource| { &mut m.defaultMode },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "optional",
                |m: &SecretVolumeSource| { &m.optional },
                |m: &mut SecretVolumeSource| { &mut m.optional },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SecretVolumeSource>(
                "SecretVolumeSource",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SecretVolumeSource {
        static instance: ::protobuf::rt::LazyV2<SecretVolumeSource> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SecretVolumeSource::new)
    }
}

impl ::protobuf::Clear for SecretVolumeSource {
    fn clear(&mut self) {
        self.secretName.clear();
        self.items.clear();
        self.defaultMode = ::std::option::Option::None;
        self.optional = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SecretVolumeSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SecretVolumeSource {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SecurityContext {
    // message fields
    pub capabilities: ::protobuf::SingularPtrField<Capabilities>,
    privileged: ::std::option::Option<bool>,
    pub seLinuxOptions: ::protobuf::SingularPtrField<SELinuxOptions>,
    pub windowsOptions: ::protobuf::SingularPtrField<WindowsSecurityContextOptions>,
    runAsUser: ::std::option::Option<i64>,
    runAsGroup: ::std::option::Option<i64>,
    runAsNonRoot: ::std::option::Option<bool>,
    readOnlyRootFilesystem: ::std::option::Option<bool>,
    allowPrivilegeEscalation: ::std::option::Option<bool>,
    procMount: ::protobuf::SingularField<::std::string::String>,
    pub seccompProfile: ::protobuf::SingularPtrField<SeccompProfile>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SecurityContext {
    fn default() -> &'a SecurityContext {
        <SecurityContext as ::protobuf::Message>::default_instance()
    }
}

impl SecurityContext {
    pub fn new() -> SecurityContext {
        ::std::default::Default::default()
    }

    // optional .k8s.io.api.core.v1.Capabilities capabilities = 1;


    pub fn get_capabilities(&self) -> &Capabilities {
        self.capabilities.as_ref().unwrap_or_else(|| <Capabilities as ::protobuf::Message>::default_instance())
    }
    pub fn clear_capabilities(&mut self) {
        self.capabilities.clear();
    }

    pub fn has_capabilities(&self) -> bool {
        self.capabilities.is_some()
    }

    // Param is passed by value, moved
    pub fn set_capabilities(&mut self, v: Capabilities) {
        self.capabilities = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_capabilities(&mut self) -> &mut Capabilities {
        if self.capabilities.is_none() {
            self.capabilities.set_default();
        }
        self.capabilities.as_mut().unwrap()
    }

    // Take field
    pub fn take_capabilities(&mut self) -> Capabilities {
        self.capabilities.take().unwrap_or_else(|| Capabilities::new())
    }

    // optional bool privileged = 2;


    pub fn get_privileged(&self) -> bool {
        self.privileged.unwrap_or(false)
    }
    pub fn clear_privileged(&mut self) {
        self.privileged = ::std::option::Option::None;
    }

    pub fn has_privileged(&self) -> bool {
        self.privileged.is_some()
    }

    // Param is passed by value, moved
    pub fn set_privileged(&mut self, v: bool) {
        self.privileged = ::std::option::Option::Some(v);
    }

    // optional .k8s.io.api.core.v1.SELinuxOptions seLinuxOptions = 3;


    pub fn get_seLinuxOptions(&self) -> &SELinuxOptions {
        self.seLinuxOptions.as_ref().unwrap_or_else(|| <SELinuxOptions as ::protobuf::Message>::default_instance())
    }
    pub fn clear_seLinuxOptions(&mut self) {
        self.seLinuxOptions.clear();
    }

    pub fn has_seLinuxOptions(&self) -> bool {
        self.seLinuxOptions.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seLinuxOptions(&mut self, v: SELinuxOptions) {
        self.seLinuxOptions = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_seLinuxOptions(&mut self) -> &mut SELinuxOptions {
        if self.seLinuxOptions.is_none() {
            self.seLinuxOptions.set_default();
        }
        self.seLinuxOptions.as_mut().unwrap()
    }

    // Take field
    pub fn take_seLinuxOptions(&mut self) -> SELinuxOptions {
        self.seLinuxOptions.take().unwrap_or_else(|| SELinuxOptions::new())
    }

    // optional .k8s.io.api.core.v1.WindowsSecurityContextOptions windowsOptions = 10;


    pub fn get_windowsOptions(&self) -> &WindowsSecurityContextOptions {
        self.windowsOptions.as_ref().unwrap_or_else(|| <WindowsSecurityContextOptions as ::protobuf::Message>::default_instance())
    }
    pub fn clear_windowsOptions(&mut self) {
        self.windowsOptions.clear();
    }

    pub fn has_windowsOptions(&self) -> bool {
        self.windowsOptions.is_some()
    }

    // Param is passed by value, moved
    pub fn set_windowsOptions(&mut self, v: WindowsSecurityContextOptions) {
        self.windowsOptions = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_windowsOptions(&mut self) -> &mut WindowsSecurityContextOptions {
        if self.windowsOptions.is_none() {
            self.windowsOptions.set_default();
        }
        self.windowsOptions.as_mut().unwrap()
    }

    // Take field
    pub fn take_windowsOptions(&mut self) -> WindowsSecurityContextOptions {
        self.windowsOptions.take().unwrap_or_else(|| WindowsSecurityContextOptions::new())
    }

    // optional int64 runAsUser = 4;


    pub fn get_runAsUser(&self) -> i64 {
        self.runAsUser.unwrap_or(0)
    }
    pub fn clear_runAsUser(&mut self) {
        self.runAsUser = ::std::option::Option::None;
    }

    pub fn has_runAsUser(&self) -> bool {
        self.runAsUser.is_some()
    }

    // Param is passed by value, moved
    pub fn set_runAsUser(&mut self, v: i64) {
        self.runAsUser = ::std::option::Option::Some(v);
    }

    // optional int64 runAsGroup = 8;


    pub fn get_runAsGroup(&self) -> i64 {
        self.runAsGroup.unwrap_or(0)
    }
    pub fn clear_runAsGroup(&mut self) {
        self.runAsGroup = ::std::option::Option::None;
    }

    pub fn has_runAsGroup(&self) -> bool {
        self.runAsGroup.is_some()
    }

    // Param is passed by value, moved
    pub fn set_runAsGroup(&mut self, v: i64) {
        self.runAsGroup = ::std::option::Option::Some(v);
    }

    // optional bool runAsNonRoot = 5;


    pub fn get_runAsNonRoot(&self) -> bool {
        self.runAsNonRoot.unwrap_or(false)
    }
    pub fn clear_runAsNonRoot(&mut self) {
        self.runAsNonRoot = ::std::option::Option::None;
    }

    pub fn has_runAsNonRoot(&self) -> bool {
        self.runAsNonRoot.is_some()
    }

    // Param is passed by value, moved
    pub fn set_runAsNonRoot(&mut self, v: bool) {
        self.runAsNonRoot = ::std::option::Option::Some(v);
    }

    // optional bool readOnlyRootFilesystem = 6;


    pub fn get_readOnlyRootFilesystem(&self) -> bool {
        self.readOnlyRootFilesystem.unwrap_or(false)
    }
    pub fn clear_readOnlyRootFilesystem(&mut self) {
        self.readOnlyRootFilesystem = ::std::option::Option::None;
    }

    pub fn has_readOnlyRootFilesystem(&self) -> bool {
        self.readOnlyRootFilesystem.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readOnlyRootFilesystem(&mut self, v: bool) {
        self.readOnlyRootFilesystem = ::std::option::Option::Some(v);
    }

    // optional bool allowPrivilegeEscalation = 7;


    pub fn get_allowPrivilegeEscalation(&self) -> bool {
        self.allowPrivilegeEscalation.unwrap_or(false)
    }
    pub fn clear_allowPrivilegeEscalation(&mut self) {
        self.allowPrivilegeEscalation = ::std::option::Option::None;
    }

    pub fn has_allowPrivilegeEscalation(&self) -> bool {
        self.allowPrivilegeEscalation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_allowPrivilegeEscalation(&mut self, v: bool) {
        self.allowPrivilegeEscalation = ::std::option::Option::Some(v);
    }

    // optional string procMount = 9;


    pub fn get_procMount(&self) -> &str {
        match self.procMount.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_procMount(&mut self) {
        self.procMount.clear();
    }

    pub fn has_procMount(&self) -> bool {
        self.procMount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_procMount(&mut self, v: ::std::string::String) {
        self.procMount = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_procMount(&mut self) -> &mut ::std::string::String {
        if self.procMount.is_none() {
            self.procMount.set_default();
        }
        self.procMount.as_mut().unwrap()
    }

    // Take field
    pub fn take_procMount(&mut self) -> ::std::string::String {
        self.procMount.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .k8s.io.api.core.v1.SeccompProfile seccompProfile = 11;


    pub fn get_seccompProfile(&self) -> &SeccompProfile {
        self.seccompProfile.as_ref().unwrap_or_else(|| <SeccompProfile as ::protobuf::Message>::default_instance())
    }
    pub fn clear_seccompProfile(&mut self) {
        self.seccompProfile.clear();
    }

    pub fn has_seccompProfile(&self) -> bool {
        self.seccompProfile.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seccompProfile(&mut self, v: SeccompProfile) {
        self.seccompProfile = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_seccompProfile(&mut self) -> &mut SeccompProfile {
        if self.seccompProfile.is_none() {
            self.seccompProfile.set_default();
        }
        self.seccompProfile.as_mut().unwrap()
    }

    // Take field
    pub fn take_seccompProfile(&mut self) -> SeccompProfile {
        self.seccompProfile.take().unwrap_or_else(|| SeccompProfile::new())
    }
}

impl ::protobuf::Message for SecurityContext {
    fn is_initialized(&self) -> bool {
        for v in &self.capabilities {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.seLinuxOptions {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.windowsOptions {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.seccompProfile {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.capabilities)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.privileged = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.seLinuxOptions)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.windowsOptions)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.runAsUser = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.runAsGroup = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.runAsNonRoot = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.readOnlyRootFilesystem = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.allowPrivilegeEscalation = ::std::option::Option::Some(tmp);
                },
                9 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.procMount)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.seccompProfile)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.capabilities.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.privileged {
            my_size += 2;
        }
        if let Some(ref v) = self.seLinuxOptions.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.windowsOptions.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.runAsUser {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.runAsGroup {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.runAsNonRoot {
            my_size += 2;
        }
        if let Some(v) = self.readOnlyRootFilesystem {
            my_size += 2;
        }
        if let Some(v) = self.allowPrivilegeEscalation {
            my_size += 2;
        }
        if let Some(ref v) = self.procMount.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(ref v) = self.seccompProfile.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.capabilities.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.privileged {
            os.write_bool(2, v)?;
        }
        if let Some(ref v) = self.seLinuxOptions.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.windowsOptions.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.runAsUser {
            os.write_int64(4, v)?;
        }
        if let Some(v) = self.runAsGroup {
            os.write_int64(8, v)?;
        }
        if let Some(v) = self.runAsNonRoot {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.readOnlyRootFilesystem {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.allowPrivilegeEscalation {
            os.write_bool(7, v)?;
        }
        if let Some(ref v) = self.procMount.as_ref() {
            os.write_string(9, &v)?;
        }
        if let Some(ref v) = self.seccompProfile.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SecurityContext {
        SecurityContext::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Capabilities>>(
                "capabilities",
                |m: &SecurityContext| { &m.capabilities },
                |m: &mut SecurityContext| { &mut m.capabilities },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "privileged",
                |m: &SecurityContext| { &m.privileged },
                |m: &mut SecurityContext| { &mut m.privileged },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SELinuxOptions>>(
                "seLinuxOptions",
                |m: &SecurityContext| { &m.seLinuxOptions },
                |m: &mut SecurityContext| { &mut m.seLinuxOptions },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<WindowsSecurityContextOptions>>(
                "windowsOptions",
                |m: &SecurityContext| { &m.windowsOptions },
                |m: &mut SecurityContext| { &mut m.windowsOptions },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "runAsUser",
                |m: &SecurityContext| { &m.runAsUser },
                |m: &mut SecurityContext| { &mut m.runAsUser },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "runAsGroup",
                |m: &SecurityContext| { &m.runAsGroup },
                |m: &mut SecurityContext| { &mut m.runAsGroup },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "runAsNonRoot",
                |m: &SecurityContext| { &m.runAsNonRoot },
                |m: &mut SecurityContext| { &mut m.runAsNonRoot },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "readOnlyRootFilesystem",
                |m: &SecurityContext| { &m.readOnlyRootFilesystem },
                |m: &mut SecurityContext| { &mut m.readOnlyRootFilesystem },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "allowPrivilegeEscalation",
                |m: &SecurityContext| { &m.allowPrivilegeEscalation },
                |m: &mut SecurityContext| { &mut m.allowPrivilegeEscalation },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "procMount",
                |m: &SecurityContext| { &m.procMount },
                |m: &mut SecurityContext| { &mut m.procMount },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SeccompProfile>>(
                "seccompProfile",
                |m: &SecurityContext| { &m.seccompProfile },
                |m: &mut SecurityContext| { &mut m.seccompProfile },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SecurityContext>(
                "SecurityContext",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SecurityContext {
        static instance: ::protobuf::rt::LazyV2<SecurityContext> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SecurityContext::new)
    }
}

impl ::protobuf::Clear for SecurityContext {
    fn clear(&mut self) {
        self.capabilities.clear();
        self.privileged = ::std::option::Option::None;
        self.seLinuxOptions.clear();
        self.windowsOptions.clear();
        self.runAsUser = ::std::option::Option::None;
        self.runAsGroup = ::std::option::Option::None;
        self.runAsNonRoot = ::std::option::Option::None;
        self.readOnlyRootFilesystem = ::std::option::Option::None;
        self.allowPrivilegeEscalation = ::std::option::Option::None;
        self.procMount.clear();
        self.seccompProfile.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SecurityContext {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SecurityContext {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SerializedReference {
    // message fields
    pub reference: ::protobuf::SingularPtrField<ObjectReference>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SerializedReference {
    fn default() -> &'a SerializedReference {
        <SerializedReference as ::protobuf::Message>::default_instance()
    }
}

impl SerializedReference {
    pub fn new() -> SerializedReference {
        ::std::default::Default::default()
    }

    // optional .k8s.io.api.core.v1.ObjectReference reference = 1;


    pub fn get_reference(&self) -> &ObjectReference {
        self.reference.as_ref().unwrap_or_else(|| <ObjectReference as ::protobuf::Message>::default_instance())
    }
    pub fn clear_reference(&mut self) {
        self.reference.clear();
    }

    pub fn has_reference(&self) -> bool {
        self.reference.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reference(&mut self, v: ObjectReference) {
        self.reference = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reference(&mut self) -> &mut ObjectReference {
        if self.reference.is_none() {
            self.reference.set_default();
        }
        self.reference.as_mut().unwrap()
    }

    // Take field
    pub fn take_reference(&mut self) -> ObjectReference {
        self.reference.take().unwrap_or_else(|| ObjectReference::new())
    }
}

impl ::protobuf::Message for SerializedReference {
    fn is_initialized(&self) -> bool {
        for v in &self.reference {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.reference)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.reference.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.reference.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SerializedReference {
        SerializedReference::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ObjectReference>>(
                "reference",
                |m: &SerializedReference| { &m.reference },
                |m: &mut SerializedReference| { &mut m.reference },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SerializedReference>(
                "SerializedReference",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SerializedReference {
        static instance: ::protobuf::rt::LazyV2<SerializedReference> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SerializedReference::new)
    }
}

impl ::protobuf::Clear for SerializedReference {
    fn clear(&mut self) {
        self.reference.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SerializedReference {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SerializedReference {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Service {
    // message fields
    pub metadata: ::protobuf::SingularPtrField<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta>,
    pub spec: ::protobuf::SingularPtrField<ServiceSpec>,
    pub status: ::protobuf::SingularPtrField<ServiceStatus>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Service {
    fn default() -> &'a Service {
        <Service as ::protobuf::Message>::default_instance()
    }
}

impl Service {
    pub fn new() -> Service {
        ::std::default::Default::default()
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;


    pub fn get_metadata(&self) -> &super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta::new())
    }

    // optional .k8s.io.api.core.v1.ServiceSpec spec = 2;


    pub fn get_spec(&self) -> &ServiceSpec {
        self.spec.as_ref().unwrap_or_else(|| <ServiceSpec as ::protobuf::Message>::default_instance())
    }
    pub fn clear_spec(&mut self) {
        self.spec.clear();
    }

    pub fn has_spec(&self) -> bool {
        self.spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spec(&mut self, v: ServiceSpec) {
        self.spec = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spec(&mut self) -> &mut ServiceSpec {
        if self.spec.is_none() {
            self.spec.set_default();
        }
        self.spec.as_mut().unwrap()
    }

    // Take field
    pub fn take_spec(&mut self) -> ServiceSpec {
        self.spec.take().unwrap_or_else(|| ServiceSpec::new())
    }

    // optional .k8s.io.api.core.v1.ServiceStatus status = 3;


    pub fn get_status(&self) -> &ServiceStatus {
        self.status.as_ref().unwrap_or_else(|| <ServiceStatus as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: ServiceStatus) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut ServiceStatus {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> ServiceStatus {
        self.status.take().unwrap_or_else(|| ServiceStatus::new())
    }
}

impl ::protobuf::Message for Service {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.spec {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.spec)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.spec.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Service {
        Service::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta>>(
                "metadata",
                |m: &Service| { &m.metadata },
                |m: &mut Service| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ServiceSpec>>(
                "spec",
                |m: &Service| { &m.spec },
                |m: &mut Service| { &mut m.spec },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ServiceStatus>>(
                "status",
                |m: &Service| { &m.status },
                |m: &mut Service| { &mut m.status },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Service>(
                "Service",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Service {
        static instance: ::protobuf::rt::LazyV2<Service> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Service::new)
    }
}

impl ::protobuf::Clear for Service {
    fn clear(&mut self) {
        self.metadata.clear();
        self.spec.clear();
        self.status.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Service {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Service {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ServiceAccount {
    // message fields
    pub metadata: ::protobuf::SingularPtrField<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta>,
    pub secrets: ::protobuf::RepeatedField<ObjectReference>,
    pub imagePullSecrets: ::protobuf::RepeatedField<LocalObjectReference>,
    automountServiceAccountToken: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ServiceAccount {
    fn default() -> &'a ServiceAccount {
        <ServiceAccount as ::protobuf::Message>::default_instance()
    }
}

impl ServiceAccount {
    pub fn new() -> ServiceAccount {
        ::std::default::Default::default()
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;


    pub fn get_metadata(&self) -> &super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta::new())
    }

    // repeated .k8s.io.api.core.v1.ObjectReference secrets = 2;


    pub fn get_secrets(&self) -> &[ObjectReference] {
        &self.secrets
    }
    pub fn clear_secrets(&mut self) {
        self.secrets.clear();
    }

    // Param is passed by value, moved
    pub fn set_secrets(&mut self, v: ::protobuf::RepeatedField<ObjectReference>) {
        self.secrets = v;
    }

    // Mutable pointer to the field.
    pub fn mut_secrets(&mut self) -> &mut ::protobuf::RepeatedField<ObjectReference> {
        &mut self.secrets
    }

    // Take field
    pub fn take_secrets(&mut self) -> ::protobuf::RepeatedField<ObjectReference> {
        ::std::mem::replace(&mut self.secrets, ::protobuf::RepeatedField::new())
    }

    // repeated .k8s.io.api.core.v1.LocalObjectReference imagePullSecrets = 3;


    pub fn get_imagePullSecrets(&self) -> &[LocalObjectReference] {
        &self.imagePullSecrets
    }
    pub fn clear_imagePullSecrets(&mut self) {
        self.imagePullSecrets.clear();
    }

    // Param is passed by value, moved
    pub fn set_imagePullSecrets(&mut self, v: ::protobuf::RepeatedField<LocalObjectReference>) {
        self.imagePullSecrets = v;
    }

    // Mutable pointer to the field.
    pub fn mut_imagePullSecrets(&mut self) -> &mut ::protobuf::RepeatedField<LocalObjectReference> {
        &mut self.imagePullSecrets
    }

    // Take field
    pub fn take_imagePullSecrets(&mut self) -> ::protobuf::RepeatedField<LocalObjectReference> {
        ::std::mem::replace(&mut self.imagePullSecrets, ::protobuf::RepeatedField::new())
    }

    // optional bool automountServiceAccountToken = 4;


    pub fn get_automountServiceAccountToken(&self) -> bool {
        self.automountServiceAccountToken.unwrap_or(false)
    }
    pub fn clear_automountServiceAccountToken(&mut self) {
        self.automountServiceAccountToken = ::std::option::Option::None;
    }

    pub fn has_automountServiceAccountToken(&self) -> bool {
        self.automountServiceAccountToken.is_some()
    }

    // Param is passed by value, moved
    pub fn set_automountServiceAccountToken(&mut self, v: bool) {
        self.automountServiceAccountToken = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ServiceAccount {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.secrets {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.imagePullSecrets {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.secrets)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.imagePullSecrets)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.automountServiceAccountToken = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.secrets {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.imagePullSecrets {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.automountServiceAccountToken {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.secrets {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.imagePullSecrets {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.automountServiceAccountToken {
            os.write_bool(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ServiceAccount {
        ServiceAccount::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ObjectMeta>>(
                "metadata",
                |m: &ServiceAccount| { &m.metadata },
                |m: &mut ServiceAccount| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ObjectReference>>(
                "secrets",
                |m: &ServiceAccount| { &m.secrets },
                |m: &mut ServiceAccount| { &mut m.secrets },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LocalObjectReference>>(
                "imagePullSecrets",
                |m: &ServiceAccount| { &m.imagePullSecrets },
                |m: &mut ServiceAccount| { &mut m.imagePullSecrets },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "automountServiceAccountToken",
                |m: &ServiceAccount| { &m.automountServiceAccountToken },
                |m: &mut ServiceAccount| { &mut m.automountServiceAccountToken },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ServiceAccount>(
                "ServiceAccount",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ServiceAccount {
        static instance: ::protobuf::rt::LazyV2<ServiceAccount> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ServiceAccount::new)
    }
}

impl ::protobuf::Clear for ServiceAccount {
    fn clear(&mut self) {
        self.metadata.clear();
        self.secrets.clear();
        self.imagePullSecrets.clear();
        self.automountServiceAccountToken = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ServiceAccount {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ServiceAccount {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ServiceAccountList {
    // message fields
    pub metadata: ::protobuf::SingularPtrField<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta>,
    pub items: ::protobuf::RepeatedField<ServiceAccount>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ServiceAccountList {
    fn default() -> &'a ServiceAccountList {
        <ServiceAccountList as ::protobuf::Message>::default_instance()
    }
}

impl ServiceAccountList {
    pub fn new() -> ServiceAccountList {
        ::std::default::Default::default()
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;


    pub fn get_metadata(&self) -> &super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta {
        self.metadata.take().unwrap_or_else(|| super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta::new())
    }

    // repeated .k8s.io.api.core.v1.ServiceAccount items = 2;


    pub fn get_items(&self) -> &[ServiceAccount] {
        &self.items
    }
    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::protobuf::RepeatedField<ServiceAccount>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::protobuf::RepeatedField<ServiceAccount> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::protobuf::RepeatedField<ServiceAccount> {
        ::std::mem::replace(&mut self.items, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ServiceAccountList {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.items {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.items)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.items {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ServiceAccountList {
        ServiceAccountList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta>>(
                "metadata",
                |m: &ServiceAccountList| { &m.metadata },
                |m: &mut ServiceAccountList| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ServiceAccount>>(
                "items",
                |m: &ServiceAccountList| { &m.items },
                |m: &mut ServiceAccountList| { &mut m.items },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ServiceAccountList>(
                "ServiceAccountList",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ServiceAccountList {
        static instance: ::protobuf::rt::LazyV2<ServiceAccountList> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ServiceAccountList::new)
    }
}

impl ::protobuf::Clear for ServiceAccountList {
    fn clear(&mut self) {
        self.metadata.clear();
        self.items.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ServiceAccountList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ServiceAccountList {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ServiceAccountTokenProjection {
    // message fields
    audience: ::protobuf::SingularField<::std::string::String>,
    expirationSeconds: ::std::option::Option<i64>,
    path: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ServiceAccountTokenProjection {
    fn default() -> &'a ServiceAccountTokenProjection {
        <ServiceAccountTokenProjection as ::protobuf::Message>::default_instance()
    }
}

impl ServiceAccountTokenProjection {
    pub fn new() -> ServiceAccountTokenProjection {
        ::std::default::Default::default()
    }

    // optional string audience = 1;


    pub fn get_audience(&self) -> &str {
        match self.audience.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_audience(&mut self) {
        self.audience.clear();
    }

    pub fn has_audience(&self) -> bool {
        self.audience.is_some()
    }

    // Param is passed by value, moved
    pub fn set_audience(&mut self, v: ::std::string::String) {
        self.audience = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_audience(&mut self) -> &mut ::std::string::String {
        if self.audience.is_none() {
            self.audience.set_default();
        }
        self.audience.as_mut().unwrap()
    }

    // Take field
    pub fn take_audience(&mut self) -> ::std::string::String {
        self.audience.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int64 expirationSeconds = 2;


    pub fn get_expirationSeconds(&self) -> i64 {
        self.expirationSeconds.unwrap_or(0)
    }
    pub fn clear_expirationSeconds(&mut self) {
        self.expirationSeconds = ::std::option::Option::None;
    }

    pub fn has_expirationSeconds(&self) -> bool {
        self.expirationSeconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_expirationSeconds(&mut self, v: i64) {
        self.expirationSeconds = ::std::option::Option::Some(v);
    }

    // optional string path = 3;


    pub fn get_path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path.set_default();
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for ServiceAccountTokenProjection {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.audience)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.expirationSeconds = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.path)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.audience.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.expirationSeconds {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.path.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.audience.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.expirationSeconds {
            os.write_int64(2, v)?;
        }
        if let Some(ref v) = self.path.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ServiceAccountTokenProjection {
        ServiceAccountTokenProjection::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "audience",
                |m: &ServiceAccountTokenProjection| { &m.audience },
                |m: &mut ServiceAccountTokenProjection| { &mut m.audience },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "expirationSeconds",
                |m: &ServiceAccountTokenProjection| { &m.expirationSeconds },
                |m: &mut ServiceAccountTokenProjection| { &mut m.expirationSeconds },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "path",
                |m: &ServiceAccountTokenProjection| { &m.path },
                |m: &mut ServiceAccountTokenProjection| { &mut m.path },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ServiceAccountTokenProjection>(
                "ServiceAccountTokenProjection",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ServiceAccountTokenProjection {
        static instance: ::protobuf::rt::LazyV2<ServiceAccountTokenProjection> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ServiceAccountTokenProjection::new)
    }
}

impl ::protobuf::Clear for ServiceAccountTokenProjection {
    fn clear(&mut self) {
        self.audience.clear();
        self.expirationSeconds = ::std::option::Option::None;
        self.path.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ServiceAccountTokenProjection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ServiceAccountTokenProjection {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ServiceList {
    // message fields
    pub metadata: ::protobuf::SingularPtrField<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta>,
    pub items: ::protobuf::RepeatedField<Service>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ServiceList {
    fn default() -> &'a ServiceList {
        <ServiceList as ::protobuf::Message>::default_instance()
    }
}

impl ServiceList {
    pub fn new() -> ServiceList {
        ::std::default::Default::default()
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;


    pub fn get_metadata(&self) -> &super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta {
        self.metadata.take().unwrap_or_else(|| super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta::new())
    }

    // repeated .k8s.io.api.core.v1.Service items = 2;


    pub fn get_items(&self) -> &[Service] {
        &self.items
    }
    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::protobuf::RepeatedField<Service>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::protobuf::RepeatedField<Service> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::protobuf::RepeatedField<Service> {
        ::std::mem::replace(&mut self.items, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ServiceList {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.items {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.items)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.items {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ServiceList {
        ServiceList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::ListMeta>>(
                "metadata",
                |m: &ServiceList| { &m.metadata },
                |m: &mut ServiceList| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Service>>(
                "items",
                |m: &ServiceList| { &m.items },
                |m: &mut ServiceList| { &mut m.items },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ServiceList>(
                "ServiceList",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ServiceList {
        static instance: ::protobuf::rt::LazyV2<ServiceList> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ServiceList::new)
    }
}

impl ::protobuf::Clear for ServiceList {
    fn clear(&mut self) {
        self.metadata.clear();
        self.items.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ServiceList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ServiceList {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ServicePort {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    protocol: ::protobuf::SingularField<::std::string::String>,
    appProtocol: ::protobuf::SingularField<::std::string::String>,
    port: ::std::option::Option<i32>,
    pub targetPort: ::protobuf::SingularPtrField<super::k8s_io_apimachinery_pkg_util_intstr_generated::IntOrString>,
    nodePort: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ServicePort {
    fn default() -> &'a ServicePort {
        <ServicePort as ::protobuf::Message>::default_instance()
    }
}

impl ServicePort {
    pub fn new() -> ServicePort {
        ::std::default::Default::default()
    }

    // optional string name = 1;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string protocol = 2;


    pub fn get_protocol(&self) -> &str {
        match self.protocol.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_protocol(&mut self) {
        self.protocol.clear();
    }

    pub fn has_protocol(&self) -> bool {
        self.protocol.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protocol(&mut self, v: ::std::string::String) {
        self.protocol = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_protocol(&mut self) -> &mut ::std::string::String {
        if self.protocol.is_none() {
            self.protocol.set_default();
        }
        self.protocol.as_mut().unwrap()
    }

    // Take field
    pub fn take_protocol(&mut self) -> ::std::string::String {
        self.protocol.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string appProtocol = 6;


    pub fn get_appProtocol(&self) -> &str {
        match self.appProtocol.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_appProtocol(&mut self) {
        self.appProtocol.clear();
    }

    pub fn has_appProtocol(&self) -> bool {
        self.appProtocol.is_some()
    }

    // Param is passed by value, moved
    pub fn set_appProtocol(&mut self, v: ::std::string::String) {
        self.appProtocol = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_appProtocol(&mut self) -> &mut ::std::string::String {
        if self.appProtocol.is_none() {
            self.appProtocol.set_default();
        }
        self.appProtocol.as_mut().unwrap()
    }

    // Take field
    pub fn take_appProtocol(&mut self) -> ::std::string::String {
        self.appProtocol.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 port = 3;


    pub fn get_port(&self) -> i32 {
        self.port.unwrap_or(0)
    }
    pub fn clear_port(&mut self) {
        self.port = ::std::option::Option::None;
    }

    pub fn has_port(&self) -> bool {
        self.port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_port(&mut self, v: i32) {
        self.port = ::std::option::Option::Some(v);
    }

    // optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString targetPort = 4;


    pub fn get_targetPort(&self) -> &super::k8s_io_apimachinery_pkg_util_intstr_generated::IntOrString {
        self.targetPort.as_ref().unwrap_or_else(|| <super::k8s_io_apimachinery_pkg_util_intstr_generated::IntOrString as ::protobuf::Message>::default_instance())
    }
    pub fn clear_targetPort(&mut self) {
        self.targetPort.clear();
    }

    pub fn has_targetPort(&self) -> bool {
        self.targetPort.is_some()
    }

    // Param is passed by value, moved
    pub fn set_targetPort(&mut self, v: super::k8s_io_apimachinery_pkg_util_intstr_generated::IntOrString) {
        self.targetPort = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_targetPort(&mut self) -> &mut super::k8s_io_apimachinery_pkg_util_intstr_generated::IntOrString {
        if self.targetPort.is_none() {
            self.targetPort.set_default();
        }
        self.targetPort.as_mut().unwrap()
    }

    // Take field
    pub fn take_targetPort(&mut self) -> super::k8s_io_apimachinery_pkg_util_intstr_generated::IntOrString {
        self.targetPort.take().unwrap_or_else(|| super::k8s_io_apimachinery_pkg_util_intstr_generated::IntOrString::new())
    }

    // optional int32 nodePort = 5;


    pub fn get_nodePort(&self) -> i32 {
        self.nodePort.unwrap_or(0)
    }
    pub fn clear_nodePort(&mut self) {
        self.nodePort = ::std::option::Option::None;
    }

    pub fn has_nodePort(&self) -> bool {
        self.nodePort.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nodePort(&mut self, v: i32) {
        self.nodePort = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ServicePort {
    fn is_initialized(&self) -> bool {
        for v in &self.targetPort {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.protocol)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.appProtocol)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.port = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.targetPort)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.nodePort = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.protocol.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.appProtocol.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.port {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.targetPort.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.nodePort {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.protocol.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.appProtocol.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(v) = self.port {
            os.write_int32(3, v)?;
        }
        if let Some(ref v) = self.targetPort.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.nodePort {
            os.write_int32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ServicePort {
        ServicePort::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &ServicePort| { &m.name },
                |m: &mut ServicePort| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "protocol",
                |m: &ServicePort| { &m.protocol },
                |m: &mut ServicePort| { &mut m.protocol },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "appProtocol",
                |m: &ServicePort| { &m.appProtocol },
                |m: &mut ServicePort| { &mut m.appProtocol },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "port",
                |m: &ServicePort| { &m.port },
                |m: &mut ServicePort| { &mut m.port },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_util_intstr_generated::IntOrString>>(
                "targetPort",
                |m: &ServicePort| { &m.targetPort },
                |m: &mut ServicePort| { &mut m.targetPort },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "nodePort",
                |m: &ServicePort| { &m.nodePort },
                |m: &mut ServicePort| { &mut m.nodePort },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ServicePort>(
                "ServicePort",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ServicePort {
        static instance: ::protobuf::rt::LazyV2<ServicePort> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ServicePort::new)
    }
}

impl ::protobuf::Clear for ServicePort {
    fn clear(&mut self) {
        self.name.clear();
        self.protocol.clear();
        self.appProtocol.clear();
        self.port = ::std::option::Option::None;
        self.targetPort.clear();
        self.nodePort = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ServicePort {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ServicePort {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ServiceProxyOptions {
    // message fields
    path: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ServiceProxyOptions {
    fn default() -> &'a ServiceProxyOptions {
        <ServiceProxyOptions as ::protobuf::Message>::default_instance()
    }
}

impl ServiceProxyOptions {
    pub fn new() -> ServiceProxyOptions {
        ::std::default::Default::default()
    }

    // optional string path = 1;


    pub fn get_path(&self) -> &str {
        match self.path.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_path(&mut self) {
        self.path.clear();
    }

    pub fn has_path(&self) -> bool {
        self.path.is_some()
    }

    // Param is passed by value, moved
    pub fn set_path(&mut self, v: ::std::string::String) {
        self.path = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_path(&mut self) -> &mut ::std::string::String {
        if self.path.is_none() {
            self.path.set_default();
        }
        self.path.as_mut().unwrap()
    }

    // Take field
    pub fn take_path(&mut self) -> ::std::string::String {
        self.path.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for ServiceProxyOptions {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.path)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.path.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.path.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ServiceProxyOptions {
        ServiceProxyOptions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "path",
                |m: &ServiceProxyOptions| { &m.path },
                |m: &mut ServiceProxyOptions| { &mut m.path },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ServiceProxyOptions>(
                "ServiceProxyOptions",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ServiceProxyOptions {
        static instance: ::protobuf::rt::LazyV2<ServiceProxyOptions> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ServiceProxyOptions::new)
    }
}

impl ::protobuf::Clear for ServiceProxyOptions {
    fn clear(&mut self) {
        self.path.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ServiceProxyOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ServiceProxyOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ServiceSpec {
    // message fields
    pub ports: ::protobuf::RepeatedField<ServicePort>,
    pub selector: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    clusterIP: ::protobuf::SingularField<::std::string::String>,
    pub clusterIPs: ::protobuf::RepeatedField<::std::string::String>,
    field_type: ::protobuf::SingularField<::std::string::String>,
    pub externalIPs: ::protobuf::RepeatedField<::std::string::String>,
    sessionAffinity: ::protobuf::SingularField<::std::string::String>,
    loadBalancerIP: ::protobuf::SingularField<::std::string::String>,
    pub loadBalancerSourceRanges: ::protobuf::RepeatedField<::std::string::String>,
    externalName: ::protobuf::SingularField<::std::string::String>,
    externalTrafficPolicy: ::protobuf::SingularField<::std::string::String>,
    healthCheckNodePort: ::std::option::Option<i32>,
    publishNotReadyAddresses: ::std::option::Option<bool>,
    pub sessionAffinityConfig: ::protobuf::SingularPtrField<SessionAffinityConfig>,
    pub topologyKeys: ::protobuf::RepeatedField<::std::string::String>,
    pub ipFamilies: ::protobuf::RepeatedField<::std::string::String>,
    ipFamilyPolicy: ::protobuf::SingularField<::std::string::String>,
    allocateLoadBalancerNodePorts: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ServiceSpec {
    fn default() -> &'a ServiceSpec {
        <ServiceSpec as ::protobuf::Message>::default_instance()
    }
}

impl ServiceSpec {
    pub fn new() -> ServiceSpec {
        ::std::default::Default::default()
    }

    // repeated .k8s.io.api.core.v1.ServicePort ports = 1;


    pub fn get_ports(&self) -> &[ServicePort] {
        &self.ports
    }
    pub fn clear_ports(&mut self) {
        self.ports.clear();
    }

    // Param is passed by value, moved
    pub fn set_ports(&mut self, v: ::protobuf::RepeatedField<ServicePort>) {
        self.ports = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ports(&mut self) -> &mut ::protobuf::RepeatedField<ServicePort> {
        &mut self.ports
    }

    // Take field
    pub fn take_ports(&mut self) -> ::protobuf::RepeatedField<ServicePort> {
        ::std::mem::replace(&mut self.ports, ::protobuf::RepeatedField::new())
    }

    // repeated .k8s.io.api.core.v1.ServiceSpec.SelectorEntry selector = 2;


    pub fn get_selector(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.selector
    }
    pub fn clear_selector(&mut self) {
        self.selector.clear();
    }

    // Param is passed by value, moved
    pub fn set_selector(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.selector = v;
    }

    // Mutable pointer to the field.
    pub fn mut_selector(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.selector
    }

    // Take field
    pub fn take_selector(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.selector, ::std::collections::HashMap::new())
    }

    // optional string clusterIP = 3;


    pub fn get_clusterIP(&self) -> &str {
        match self.clusterIP.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_clusterIP(&mut self) {
        self.clusterIP.clear();
    }

    pub fn has_clusterIP(&self) -> bool {
        self.clusterIP.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clusterIP(&mut self, v: ::std::string::String) {
        self.clusterIP = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_clusterIP(&mut self) -> &mut ::std::string::String {
        if self.clusterIP.is_none() {
            self.clusterIP.set_default();
        }
        self.clusterIP.as_mut().unwrap()
    }

    // Take field
    pub fn take_clusterIP(&mut self) -> ::std::string::String {
        self.clusterIP.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated string clusterIPs = 18;


    pub fn get_clusterIPs(&self) -> &[::std::string::String] {
        &self.clusterIPs
    }
    pub fn clear_clusterIPs(&mut self) {
        self.clusterIPs.clear();
    }

    // Param is passed by value, moved
    pub fn set_clusterIPs(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.clusterIPs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_clusterIPs(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.clusterIPs
    }

    // Take field
    pub fn take_clusterIPs(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.clusterIPs, ::protobuf::RepeatedField::new())
    }

    // optional string type = 4;


    pub fn get_field_type(&self) -> &str {
        match self.field_type.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ::std::string::String) {
        self.field_type = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut ::std::string::String {
        if self.field_type.is_none() {
            self.field_type.set_default();
        }
        self.field_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_field_type(&mut self) -> ::std::string::String {
        self.field_type.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated string externalIPs = 5;


    pub fn get_externalIPs(&self) -> &[::std::string::String] {
        &self.externalIPs
    }
    pub fn clear_externalIPs(&mut self) {
        self.externalIPs.clear();
    }

    // Param is passed by value, moved
    pub fn set_externalIPs(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.externalIPs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_externalIPs(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.externalIPs
    }

    // Take field
    pub fn take_externalIPs(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.externalIPs, ::protobuf::RepeatedField::new())
    }

    // optional string sessionAffinity = 7;


    pub fn get_sessionAffinity(&self) -> &str {
        match self.sessionAffinity.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_sessionAffinity(&mut self) {
        self.sessionAffinity.clear();
    }

    pub fn has_sessionAffinity(&self) -> bool {
        self.sessionAffinity.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sessionAffinity(&mut self, v: ::std::string::String) {
        self.sessionAffinity = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sessionAffinity(&mut self) -> &mut ::std::string::String {
        if self.sessionAffinity.is_none() {
            self.sessionAffinity.set_default();
        }
        self.sessionAffinity.as_mut().unwrap()
    }

    // Take field
    pub fn take_sessionAffinity(&mut self) -> ::std::string::String {
        self.sessionAffinity.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string loadBalancerIP = 8;


    pub fn get_loadBalancerIP(&self) -> &str {
        match self.loadBalancerIP.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_loadBalancerIP(&mut self) {
        self.loadBalancerIP.clear();
    }

    pub fn has_loadBalancerIP(&self) -> bool {
        self.loadBalancerIP.is_some()
    }

    // Param is passed by value, moved
    pub fn set_loadBalancerIP(&mut self, v: ::std::string::String) {
        self.loadBalancerIP = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_loadBalancerIP(&mut self) -> &mut ::std::string::String {
        if self.loadBalancerIP.is_none() {
            self.loadBalancerIP.set_default();
        }
        self.loadBalancerIP.as_mut().unwrap()
    }

    // Take field
    pub fn take_loadBalancerIP(&mut self) -> ::std::string::String {
        self.loadBalancerIP.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated string loadBalancerSourceRanges = 9;


    pub fn get_loadBalancerSourceRanges(&self) -> &[::std::string::String] {
        &self.loadBalancerSourceRanges
    }
    pub fn clear_loadBalancerSourceRanges(&mut self) {
        self.loadBalancerSourceRanges.clear();
    }

    // Param is passed by value, moved
    pub fn set_loadBalancerSourceRanges(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.loadBalancerSourceRanges = v;
    }

    // Mutable pointer to the field.
    pub fn mut_loadBalancerSourceRanges(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.loadBalancerSourceRanges
    }

    // Take field
    pub fn take_loadBalancerSourceRanges(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.loadBalancerSourceRanges, ::protobuf::RepeatedField::new())
    }

    // optional string externalName = 10;


    pub fn get_externalName(&self) -> &str {
        match self.externalName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_externalName(&mut self) {
        self.externalName.clear();
    }

    pub fn has_externalName(&self) -> bool {
        self.externalName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_externalName(&mut self, v: ::std::string::String) {
        self.externalName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_externalName(&mut self) -> &mut ::std::string::String {
        if self.externalName.is_none() {
            self.externalName.set_default();
        }
        self.externalName.as_mut().unwrap()
    }

    // Take field
    pub fn take_externalName(&mut self) -> ::std::string::String {
        self.externalName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string externalTrafficPolicy = 11;


    pub fn get_externalTrafficPolicy(&self) -> &str {
        match self.externalTrafficPolicy.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_externalTrafficPolicy(&mut self) {
        self.externalTrafficPolicy.clear();
    }

    pub fn has_externalTrafficPolicy(&self) -> bool {
        self.externalTrafficPolicy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_externalTrafficPolicy(&mut self, v: ::std::string::String) {
        self.externalTrafficPolicy = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_externalTrafficPolicy(&mut self) -> &mut ::std::string::String {
        if self.externalTrafficPolicy.is_none() {
            self.externalTrafficPolicy.set_default();
        }
        self.externalTrafficPolicy.as_mut().unwrap()
    }

    // Take field
    pub fn take_externalTrafficPolicy(&mut self) -> ::std::string::String {
        self.externalTrafficPolicy.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 healthCheckNodePort = 12;


    pub fn get_healthCheckNodePort(&self) -> i32 {
        self.healthCheckNodePort.unwrap_or(0)
    }
    pub fn clear_healthCheckNodePort(&mut self) {
        self.healthCheckNodePort = ::std::option::Option::None;
    }

    pub fn has_healthCheckNodePort(&self) -> bool {
        self.healthCheckNodePort.is_some()
    }

    // Param is passed by value, moved
    pub fn set_healthCheckNodePort(&mut self, v: i32) {
        self.healthCheckNodePort = ::std::option::Option::Some(v);
    }

    // optional bool publishNotReadyAddresses = 13;


    pub fn get_publishNotReadyAddresses(&self) -> bool {
        self.publishNotReadyAddresses.unwrap_or(false)
    }
    pub fn clear_publishNotReadyAddresses(&mut self) {
        self.publishNotReadyAddresses = ::std::option::Option::None;
    }

    pub fn has_publishNotReadyAddresses(&self) -> bool {
        self.publishNotReadyAddresses.is_some()
    }

    // Param is passed by value, moved
    pub fn set_publishNotReadyAddresses(&mut self, v: bool) {
        self.publishNotReadyAddresses = ::std::option::Option::Some(v);
    }

    // optional .k8s.io.api.core.v1.SessionAffinityConfig sessionAffinityConfig = 14;


    pub fn get_sessionAffinityConfig(&self) -> &SessionAffinityConfig {
        self.sessionAffinityConfig.as_ref().unwrap_or_else(|| <SessionAffinityConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_sessionAffinityConfig(&mut self) {
        self.sessionAffinityConfig.clear();
    }

    pub fn has_sessionAffinityConfig(&self) -> bool {
        self.sessionAffinityConfig.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sessionAffinityConfig(&mut self, v: SessionAffinityConfig) {
        self.sessionAffinityConfig = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sessionAffinityConfig(&mut self) -> &mut SessionAffinityConfig {
        if self.sessionAffinityConfig.is_none() {
            self.sessionAffinityConfig.set_default();
        }
        self.sessionAffinityConfig.as_mut().unwrap()
    }

    // Take field
    pub fn take_sessionAffinityConfig(&mut self) -> SessionAffinityConfig {
        self.sessionAffinityConfig.take().unwrap_or_else(|| SessionAffinityConfig::new())
    }

    // repeated string topologyKeys = 16;


    pub fn get_topologyKeys(&self) -> &[::std::string::String] {
        &self.topologyKeys
    }
    pub fn clear_topologyKeys(&mut self) {
        self.topologyKeys.clear();
    }

    // Param is passed by value, moved
    pub fn set_topologyKeys(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.topologyKeys = v;
    }

    // Mutable pointer to the field.
    pub fn mut_topologyKeys(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.topologyKeys
    }

    // Take field
    pub fn take_topologyKeys(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.topologyKeys, ::protobuf::RepeatedField::new())
    }

    // repeated string ipFamilies = 19;


    pub fn get_ipFamilies(&self) -> &[::std::string::String] {
        &self.ipFamilies
    }
    pub fn clear_ipFamilies(&mut self) {
        self.ipFamilies.clear();
    }

    // Param is passed by value, moved
    pub fn set_ipFamilies(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.ipFamilies = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ipFamilies(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.ipFamilies
    }

    // Take field
    pub fn take_ipFamilies(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.ipFamilies, ::protobuf::RepeatedField::new())
    }

    // optional string ipFamilyPolicy = 17;


    pub fn get_ipFamilyPolicy(&self) -> &str {
        match self.ipFamilyPolicy.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_ipFamilyPolicy(&mut self) {
        self.ipFamilyPolicy.clear();
    }

    pub fn has_ipFamilyPolicy(&self) -> bool {
        self.ipFamilyPolicy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ipFamilyPolicy(&mut self, v: ::std::string::String) {
        self.ipFamilyPolicy = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ipFamilyPolicy(&mut self) -> &mut ::std::string::String {
        if self.ipFamilyPolicy.is_none() {
            self.ipFamilyPolicy.set_default();
        }
        self.ipFamilyPolicy.as_mut().unwrap()
    }

    // Take field
    pub fn take_ipFamilyPolicy(&mut self) -> ::std::string::String {
        self.ipFamilyPolicy.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool allocateLoadBalancerNodePorts = 20;


    pub fn get_allocateLoadBalancerNodePorts(&self) -> bool {
        self.allocateLoadBalancerNodePorts.unwrap_or(false)
    }
    pub fn clear_allocateLoadBalancerNodePorts(&mut self) {
        self.allocateLoadBalancerNodePorts = ::std::option::Option::None;
    }

    pub fn has_allocateLoadBalancerNodePorts(&self) -> bool {
        self.allocateLoadBalancerNodePorts.is_some()
    }

    // Param is passed by value, moved
    pub fn set_allocateLoadBalancerNodePorts(&mut self, v: bool) {
        self.allocateLoadBalancerNodePorts = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ServiceSpec {
    fn is_initialized(&self) -> bool {
        for v in &self.ports {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.sessionAffinityConfig {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.ports)?;
                },
                2 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.selector)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.clusterIP)?;
                },
                18 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.clusterIPs)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.field_type)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.externalIPs)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.sessionAffinity)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.loadBalancerIP)?;
                },
                9 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.loadBalancerSourceRanges)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.externalName)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.externalTrafficPolicy)?;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.healthCheckNodePort = ::std::option::Option::Some(tmp);
                },
                13 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.publishNotReadyAddresses = ::std::option::Option::Some(tmp);
                },
                14 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.sessionAffinityConfig)?;
                },
                16 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.topologyKeys)?;
                },
                19 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.ipFamilies)?;
                },
                17 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.ipFamilyPolicy)?;
                },
                20 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.allocateLoadBalancerNodePorts = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.ports {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(2, &self.selector);
        if let Some(ref v) = self.clusterIP.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        for value in &self.clusterIPs {
            my_size += ::protobuf::rt::string_size(18, &value);
        };
        if let Some(ref v) = self.field_type.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        for value in &self.externalIPs {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        if let Some(ref v) = self.sessionAffinity.as_ref() {
            my_size += ::protobuf::rt::string_size(7, &v);
        }
        if let Some(ref v) = self.loadBalancerIP.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        for value in &self.loadBalancerSourceRanges {
            my_size += ::protobuf::rt::string_size(9, &value);
        };
        if let Some(ref v) = self.externalName.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        if let Some(ref v) = self.externalTrafficPolicy.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        if let Some(v) = self.healthCheckNodePort {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.publishNotReadyAddresses {
            my_size += 2;
        }
        if let Some(ref v) = self.sessionAffinityConfig.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.topologyKeys {
            my_size += ::protobuf::rt::string_size(16, &value);
        };
        for value in &self.ipFamilies {
            my_size += ::protobuf::rt::string_size(19, &value);
        };
        if let Some(ref v) = self.ipFamilyPolicy.as_ref() {
            my_size += ::protobuf::rt::string_size(17, &v);
        }
        if let Some(v) = self.allocateLoadBalancerNodePorts {
            my_size += 3;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.ports {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(2, &self.selector, os)?;
        if let Some(ref v) = self.clusterIP.as_ref() {
            os.write_string(3, &v)?;
        }
        for v in &self.clusterIPs {
            os.write_string(18, &v)?;
        };
        if let Some(ref v) = self.field_type.as_ref() {
            os.write_string(4, &v)?;
        }
        for v in &self.externalIPs {
            os.write_string(5, &v)?;
        };
        if let Some(ref v) = self.sessionAffinity.as_ref() {
            os.write_string(7, &v)?;
        }
        if let Some(ref v) = self.loadBalancerIP.as_ref() {
            os.write_string(8, &v)?;
        }
        for v in &self.loadBalancerSourceRanges {
            os.write_string(9, &v)?;
        };
        if let Some(ref v) = self.externalName.as_ref() {
            os.write_string(10, &v)?;
        }
        if let Some(ref v) = self.externalTrafficPolicy.as_ref() {
            os.write_string(11, &v)?;
        }
        if let Some(v) = self.healthCheckNodePort {
            os.write_int32(12, v)?;
        }
        if let Some(v) = self.publishNotReadyAddresses {
            os.write_bool(13, v)?;
        }
        if let Some(ref v) = self.sessionAffinityConfig.as_ref() {
            os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.topologyKeys {
            os.write_string(16, &v)?;
        };
        for v in &self.ipFamilies {
            os.write_string(19, &v)?;
        };
        if let Some(ref v) = self.ipFamilyPolicy.as_ref() {
            os.write_string(17, &v)?;
        }
        if let Some(v) = self.allocateLoadBalancerNodePorts {
            os.write_bool(20, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ServiceSpec {
        ServiceSpec::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ServicePort>>(
                "ports",
                |m: &ServiceSpec| { &m.ports },
                |m: &mut ServiceSpec| { &mut m.ports },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                "selector",
                |m: &ServiceSpec| { &m.selector },
                |m: &mut ServiceSpec| { &mut m.selector },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "clusterIP",
                |m: &ServiceSpec| { &m.clusterIP },
                |m: &mut ServiceSpec| { &mut m.clusterIP },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "clusterIPs",
                |m: &ServiceSpec| { &m.clusterIPs },
                |m: &mut ServiceSpec| { &mut m.clusterIPs },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "type",
                |m: &ServiceSpec| { &m.field_type },
                |m: &mut ServiceSpec| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "externalIPs",
                |m: &ServiceSpec| { &m.externalIPs },
                |m: &mut ServiceSpec| { &mut m.externalIPs },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "sessionAffinity",
                |m: &ServiceSpec| { &m.sessionAffinity },
                |m: &mut ServiceSpec| { &mut m.sessionAffinity },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "loadBalancerIP",
                |m: &ServiceSpec| { &m.loadBalancerIP },
                |m: &mut ServiceSpec| { &mut m.loadBalancerIP },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "loadBalancerSourceRanges",
                |m: &ServiceSpec| { &m.loadBalancerSourceRanges },
                |m: &mut ServiceSpec| { &mut m.loadBalancerSourceRanges },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "externalName",
                |m: &ServiceSpec| { &m.externalName },
                |m: &mut ServiceSpec| { &mut m.externalName },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "externalTrafficPolicy",
                |m: &ServiceSpec| { &m.externalTrafficPolicy },
                |m: &mut ServiceSpec| { &mut m.externalTrafficPolicy },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "healthCheckNodePort",
                |m: &ServiceSpec| { &m.healthCheckNodePort },
                |m: &mut ServiceSpec| { &mut m.healthCheckNodePort },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "publishNotReadyAddresses",
                |m: &ServiceSpec| { &m.publishNotReadyAddresses },
                |m: &mut ServiceSpec| { &mut m.publishNotReadyAddresses },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SessionAffinityConfig>>(
                "sessionAffinityConfig",
                |m: &ServiceSpec| { &m.sessionAffinityConfig },
                |m: &mut ServiceSpec| { &mut m.sessionAffinityConfig },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "topologyKeys",
                |m: &ServiceSpec| { &m.topologyKeys },
                |m: &mut ServiceSpec| { &mut m.topologyKeys },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "ipFamilies",
                |m: &ServiceSpec| { &m.ipFamilies },
                |m: &mut ServiceSpec| { &mut m.ipFamilies },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "ipFamilyPolicy",
                |m: &ServiceSpec| { &m.ipFamilyPolicy },
                |m: &mut ServiceSpec| { &mut m.ipFamilyPolicy },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "allocateLoadBalancerNodePorts",
                |m: &ServiceSpec| { &m.allocateLoadBalancerNodePorts },
                |m: &mut ServiceSpec| { &mut m.allocateLoadBalancerNodePorts },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ServiceSpec>(
                "ServiceSpec",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ServiceSpec {
        static instance: ::protobuf::rt::LazyV2<ServiceSpec> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ServiceSpec::new)
    }
}

impl ::protobuf::Clear for ServiceSpec {
    fn clear(&mut self) {
        self.ports.clear();
        self.selector.clear();
        self.clusterIP.clear();
        self.clusterIPs.clear();
        self.field_type.clear();
        self.externalIPs.clear();
        self.sessionAffinity.clear();
        self.loadBalancerIP.clear();
        self.loadBalancerSourceRanges.clear();
        self.externalName.clear();
        self.externalTrafficPolicy.clear();
        self.healthCheckNodePort = ::std::option::Option::None;
        self.publishNotReadyAddresses = ::std::option::Option::None;
        self.sessionAffinityConfig.clear();
        self.topologyKeys.clear();
        self.ipFamilies.clear();
        self.ipFamilyPolicy.clear();
        self.allocateLoadBalancerNodePorts = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ServiceSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ServiceSpec {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ServiceStatus {
    // message fields
    pub loadBalancer: ::protobuf::SingularPtrField<LoadBalancerStatus>,
    pub conditions: ::protobuf::RepeatedField<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Condition>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ServiceStatus {
    fn default() -> &'a ServiceStatus {
        <ServiceStatus as ::protobuf::Message>::default_instance()
    }
}

impl ServiceStatus {
    pub fn new() -> ServiceStatus {
        ::std::default::Default::default()
    }

    // optional .k8s.io.api.core.v1.LoadBalancerStatus loadBalancer = 1;


    pub fn get_loadBalancer(&self) -> &LoadBalancerStatus {
        self.loadBalancer.as_ref().unwrap_or_else(|| <LoadBalancerStatus as ::protobuf::Message>::default_instance())
    }
    pub fn clear_loadBalancer(&mut self) {
        self.loadBalancer.clear();
    }

    pub fn has_loadBalancer(&self) -> bool {
        self.loadBalancer.is_some()
    }

    // Param is passed by value, moved
    pub fn set_loadBalancer(&mut self, v: LoadBalancerStatus) {
        self.loadBalancer = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_loadBalancer(&mut self) -> &mut LoadBalancerStatus {
        if self.loadBalancer.is_none() {
            self.loadBalancer.set_default();
        }
        self.loadBalancer.as_mut().unwrap()
    }

    // Take field
    pub fn take_loadBalancer(&mut self) -> LoadBalancerStatus {
        self.loadBalancer.take().unwrap_or_else(|| LoadBalancerStatus::new())
    }

    // repeated .k8s.io.apimachinery.pkg.apis.meta.v1.Condition conditions = 2;


    pub fn get_conditions(&self) -> &[super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Condition] {
        &self.conditions
    }
    pub fn clear_conditions(&mut self) {
        self.conditions.clear();
    }

    // Param is passed by value, moved
    pub fn set_conditions(&mut self, v: ::protobuf::RepeatedField<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Condition>) {
        self.conditions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_conditions(&mut self) -> &mut ::protobuf::RepeatedField<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Condition> {
        &mut self.conditions
    }

    // Take field
    pub fn take_conditions(&mut self) -> ::protobuf::RepeatedField<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Condition> {
        ::std::mem::replace(&mut self.conditions, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ServiceStatus {
    fn is_initialized(&self) -> bool {
        for v in &self.loadBalancer {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.conditions {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.loadBalancer)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.conditions)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.loadBalancer.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.conditions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.loadBalancer.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.conditions {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ServiceStatus {
        ServiceStatus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LoadBalancerStatus>>(
                "loadBalancer",
                |m: &ServiceStatus| { &m.loadBalancer },
                |m: &mut ServiceStatus| { &mut m.loadBalancer },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Condition>>(
                "conditions",
                |m: &ServiceStatus| { &m.conditions },
                |m: &mut ServiceStatus| { &mut m.conditions },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ServiceStatus>(
                "ServiceStatus",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ServiceStatus {
        static instance: ::protobuf::rt::LazyV2<ServiceStatus> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ServiceStatus::new)
    }
}

impl ::protobuf::Clear for ServiceStatus {
    fn clear(&mut self) {
        self.loadBalancer.clear();
        self.conditions.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ServiceStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ServiceStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SessionAffinityConfig {
    // message fields
    pub clientIP: ::protobuf::SingularPtrField<ClientIPConfig>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SessionAffinityConfig {
    fn default() -> &'a SessionAffinityConfig {
        <SessionAffinityConfig as ::protobuf::Message>::default_instance()
    }
}

impl SessionAffinityConfig {
    pub fn new() -> SessionAffinityConfig {
        ::std::default::Default::default()
    }

    // optional .k8s.io.api.core.v1.ClientIPConfig clientIP = 1;


    pub fn get_clientIP(&self) -> &ClientIPConfig {
        self.clientIP.as_ref().unwrap_or_else(|| <ClientIPConfig as ::protobuf::Message>::default_instance())
    }
    pub fn clear_clientIP(&mut self) {
        self.clientIP.clear();
    }

    pub fn has_clientIP(&self) -> bool {
        self.clientIP.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clientIP(&mut self, v: ClientIPConfig) {
        self.clientIP = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_clientIP(&mut self) -> &mut ClientIPConfig {
        if self.clientIP.is_none() {
            self.clientIP.set_default();
        }
        self.clientIP.as_mut().unwrap()
    }

    // Take field
    pub fn take_clientIP(&mut self) -> ClientIPConfig {
        self.clientIP.take().unwrap_or_else(|| ClientIPConfig::new())
    }
}

impl ::protobuf::Message for SessionAffinityConfig {
    fn is_initialized(&self) -> bool {
        for v in &self.clientIP {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.clientIP)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.clientIP.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.clientIP.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SessionAffinityConfig {
        SessionAffinityConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ClientIPConfig>>(
                "clientIP",
                |m: &SessionAffinityConfig| { &m.clientIP },
                |m: &mut SessionAffinityConfig| { &mut m.clientIP },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SessionAffinityConfig>(
                "SessionAffinityConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SessionAffinityConfig {
        static instance: ::protobuf::rt::LazyV2<SessionAffinityConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SessionAffinityConfig::new)
    }
}

impl ::protobuf::Clear for SessionAffinityConfig {
    fn clear(&mut self) {
        self.clientIP.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SessionAffinityConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SessionAffinityConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StorageOSPersistentVolumeSource {
    // message fields
    volumeName: ::protobuf::SingularField<::std::string::String>,
    volumeNamespace: ::protobuf::SingularField<::std::string::String>,
    fsType: ::protobuf::SingularField<::std::string::String>,
    readOnly: ::std::option::Option<bool>,
    pub secretRef: ::protobuf::SingularPtrField<ObjectReference>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StorageOSPersistentVolumeSource {
    fn default() -> &'a StorageOSPersistentVolumeSource {
        <StorageOSPersistentVolumeSource as ::protobuf::Message>::default_instance()
    }
}

impl StorageOSPersistentVolumeSource {
    pub fn new() -> StorageOSPersistentVolumeSource {
        ::std::default::Default::default()
    }

    // optional string volumeName = 1;


    pub fn get_volumeName(&self) -> &str {
        match self.volumeName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_volumeName(&mut self) {
        self.volumeName.clear();
    }

    pub fn has_volumeName(&self) -> bool {
        self.volumeName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_volumeName(&mut self, v: ::std::string::String) {
        self.volumeName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_volumeName(&mut self) -> &mut ::std::string::String {
        if self.volumeName.is_none() {
            self.volumeName.set_default();
        }
        self.volumeName.as_mut().unwrap()
    }

    // Take field
    pub fn take_volumeName(&mut self) -> ::std::string::String {
        self.volumeName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string volumeNamespace = 2;


    pub fn get_volumeNamespace(&self) -> &str {
        match self.volumeNamespace.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_volumeNamespace(&mut self) {
        self.volumeNamespace.clear();
    }

    pub fn has_volumeNamespace(&self) -> bool {
        self.volumeNamespace.is_some()
    }

    // Param is passed by value, moved
    pub fn set_volumeNamespace(&mut self, v: ::std::string::String) {
        self.volumeNamespace = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_volumeNamespace(&mut self) -> &mut ::std::string::String {
        if self.volumeNamespace.is_none() {
            self.volumeNamespace.set_default();
        }
        self.volumeNamespace.as_mut().unwrap()
    }

    // Take field
    pub fn take_volumeNamespace(&mut self) -> ::std::string::String {
        self.volumeNamespace.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string fsType = 3;


    pub fn get_fsType(&self) -> &str {
        match self.fsType.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_fsType(&mut self) {
        self.fsType.clear();
    }

    pub fn has_fsType(&self) -> bool {
        self.fsType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fsType(&mut self, v: ::std::string::String) {
        self.fsType = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fsType(&mut self) -> &mut ::std::string::String {
        if self.fsType.is_none() {
            self.fsType.set_default();
        }
        self.fsType.as_mut().unwrap()
    }

    // Take field
    pub fn take_fsType(&mut self) -> ::std::string::String {
        self.fsType.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool readOnly = 4;


    pub fn get_readOnly(&self) -> bool {
        self.readOnly.unwrap_or(false)
    }
    pub fn clear_readOnly(&mut self) {
        self.readOnly = ::std::option::Option::None;
    }

    pub fn has_readOnly(&self) -> bool {
        self.readOnly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readOnly(&mut self, v: bool) {
        self.readOnly = ::std::option::Option::Some(v);
    }

    // optional .k8s.io.api.core.v1.ObjectReference secretRef = 5;


    pub fn get_secretRef(&self) -> &ObjectReference {
        self.secretRef.as_ref().unwrap_or_else(|| <ObjectReference as ::protobuf::Message>::default_instance())
    }
    pub fn clear_secretRef(&mut self) {
        self.secretRef.clear();
    }

    pub fn has_secretRef(&self) -> bool {
        self.secretRef.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secretRef(&mut self, v: ObjectReference) {
        self.secretRef = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_secretRef(&mut self) -> &mut ObjectReference {
        if self.secretRef.is_none() {
            self.secretRef.set_default();
        }
        self.secretRef.as_mut().unwrap()
    }

    // Take field
    pub fn take_secretRef(&mut self) -> ObjectReference {
        self.secretRef.take().unwrap_or_else(|| ObjectReference::new())
    }
}

impl ::protobuf::Message for StorageOSPersistentVolumeSource {
    fn is_initialized(&self) -> bool {
        for v in &self.secretRef {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.volumeName)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.volumeNamespace)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.fsType)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.readOnly = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.secretRef)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.volumeName.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.volumeNamespace.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.fsType.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.readOnly {
            my_size += 2;
        }
        if let Some(ref v) = self.secretRef.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.volumeName.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.volumeNamespace.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.fsType.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.readOnly {
            os.write_bool(4, v)?;
        }
        if let Some(ref v) = self.secretRef.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StorageOSPersistentVolumeSource {
        StorageOSPersistentVolumeSource::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "volumeName",
                |m: &StorageOSPersistentVolumeSource| { &m.volumeName },
                |m: &mut StorageOSPersistentVolumeSource| { &mut m.volumeName },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "volumeNamespace",
                |m: &StorageOSPersistentVolumeSource| { &m.volumeNamespace },
                |m: &mut StorageOSPersistentVolumeSource| { &mut m.volumeNamespace },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "fsType",
                |m: &StorageOSPersistentVolumeSource| { &m.fsType },
                |m: &mut StorageOSPersistentVolumeSource| { &mut m.fsType },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "readOnly",
                |m: &StorageOSPersistentVolumeSource| { &m.readOnly },
                |m: &mut StorageOSPersistentVolumeSource| { &mut m.readOnly },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ObjectReference>>(
                "secretRef",
                |m: &StorageOSPersistentVolumeSource| { &m.secretRef },
                |m: &mut StorageOSPersistentVolumeSource| { &mut m.secretRef },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StorageOSPersistentVolumeSource>(
                "StorageOSPersistentVolumeSource",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StorageOSPersistentVolumeSource {
        static instance: ::protobuf::rt::LazyV2<StorageOSPersistentVolumeSource> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StorageOSPersistentVolumeSource::new)
    }
}

impl ::protobuf::Clear for StorageOSPersistentVolumeSource {
    fn clear(&mut self) {
        self.volumeName.clear();
        self.volumeNamespace.clear();
        self.fsType.clear();
        self.readOnly = ::std::option::Option::None;
        self.secretRef.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StorageOSPersistentVolumeSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StorageOSPersistentVolumeSource {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StorageOSVolumeSource {
    // message fields
    volumeName: ::protobuf::SingularField<::std::string::String>,
    volumeNamespace: ::protobuf::SingularField<::std::string::String>,
    fsType: ::protobuf::SingularField<::std::string::String>,
    readOnly: ::std::option::Option<bool>,
    pub secretRef: ::protobuf::SingularPtrField<LocalObjectReference>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StorageOSVolumeSource {
    fn default() -> &'a StorageOSVolumeSource {
        <StorageOSVolumeSource as ::protobuf::Message>::default_instance()
    }
}

impl StorageOSVolumeSource {
    pub fn new() -> StorageOSVolumeSource {
        ::std::default::Default::default()
    }

    // optional string volumeName = 1;


    pub fn get_volumeName(&self) -> &str {
        match self.volumeName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_volumeName(&mut self) {
        self.volumeName.clear();
    }

    pub fn has_volumeName(&self) -> bool {
        self.volumeName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_volumeName(&mut self, v: ::std::string::String) {
        self.volumeName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_volumeName(&mut self) -> &mut ::std::string::String {
        if self.volumeName.is_none() {
            self.volumeName.set_default();
        }
        self.volumeName.as_mut().unwrap()
    }

    // Take field
    pub fn take_volumeName(&mut self) -> ::std::string::String {
        self.volumeName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string volumeNamespace = 2;


    pub fn get_volumeNamespace(&self) -> &str {
        match self.volumeNamespace.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_volumeNamespace(&mut self) {
        self.volumeNamespace.clear();
    }

    pub fn has_volumeNamespace(&self) -> bool {
        self.volumeNamespace.is_some()
    }

    // Param is passed by value, moved
    pub fn set_volumeNamespace(&mut self, v: ::std::string::String) {
        self.volumeNamespace = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_volumeNamespace(&mut self) -> &mut ::std::string::String {
        if self.volumeNamespace.is_none() {
            self.volumeNamespace.set_default();
        }
        self.volumeNamespace.as_mut().unwrap()
    }

    // Take field
    pub fn take_volumeNamespace(&mut self) -> ::std::string::String {
        self.volumeNamespace.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string fsType = 3;


    pub fn get_fsType(&self) -> &str {
        match self.fsType.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_fsType(&mut self) {
        self.fsType.clear();
    }

    pub fn has_fsType(&self) -> bool {
        self.fsType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fsType(&mut self, v: ::std::string::String) {
        self.fsType = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fsType(&mut self) -> &mut ::std::string::String {
        if self.fsType.is_none() {
            self.fsType.set_default();
        }
        self.fsType.as_mut().unwrap()
    }

    // Take field
    pub fn take_fsType(&mut self) -> ::std::string::String {
        self.fsType.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool readOnly = 4;


    pub fn get_readOnly(&self) -> bool {
        self.readOnly.unwrap_or(false)
    }
    pub fn clear_readOnly(&mut self) {
        self.readOnly = ::std::option::Option::None;
    }

    pub fn has_readOnly(&self) -> bool {
        self.readOnly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readOnly(&mut self, v: bool) {
        self.readOnly = ::std::option::Option::Some(v);
    }

    // optional .k8s.io.api.core.v1.LocalObjectReference secretRef = 5;


    pub fn get_secretRef(&self) -> &LocalObjectReference {
        self.secretRef.as_ref().unwrap_or_else(|| <LocalObjectReference as ::protobuf::Message>::default_instance())
    }
    pub fn clear_secretRef(&mut self) {
        self.secretRef.clear();
    }

    pub fn has_secretRef(&self) -> bool {
        self.secretRef.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secretRef(&mut self, v: LocalObjectReference) {
        self.secretRef = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_secretRef(&mut self) -> &mut LocalObjectReference {
        if self.secretRef.is_none() {
            self.secretRef.set_default();
        }
        self.secretRef.as_mut().unwrap()
    }

    // Take field
    pub fn take_secretRef(&mut self) -> LocalObjectReference {
        self.secretRef.take().unwrap_or_else(|| LocalObjectReference::new())
    }
}

impl ::protobuf::Message for StorageOSVolumeSource {
    fn is_initialized(&self) -> bool {
        for v in &self.secretRef {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.volumeName)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.volumeNamespace)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.fsType)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.readOnly = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.secretRef)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.volumeName.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.volumeNamespace.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.fsType.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.readOnly {
            my_size += 2;
        }
        if let Some(ref v) = self.secretRef.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.volumeName.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.volumeNamespace.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.fsType.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.readOnly {
            os.write_bool(4, v)?;
        }
        if let Some(ref v) = self.secretRef.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StorageOSVolumeSource {
        StorageOSVolumeSource::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "volumeName",
                |m: &StorageOSVolumeSource| { &m.volumeName },
                |m: &mut StorageOSVolumeSource| { &mut m.volumeName },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "volumeNamespace",
                |m: &StorageOSVolumeSource| { &m.volumeNamespace },
                |m: &mut StorageOSVolumeSource| { &mut m.volumeNamespace },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "fsType",
                |m: &StorageOSVolumeSource| { &m.fsType },
                |m: &mut StorageOSVolumeSource| { &mut m.fsType },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "readOnly",
                |m: &StorageOSVolumeSource| { &m.readOnly },
                |m: &mut StorageOSVolumeSource| { &mut m.readOnly },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LocalObjectReference>>(
                "secretRef",
                |m: &StorageOSVolumeSource| { &m.secretRef },
                |m: &mut StorageOSVolumeSource| { &mut m.secretRef },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StorageOSVolumeSource>(
                "StorageOSVolumeSource",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StorageOSVolumeSource {
        static instance: ::protobuf::rt::LazyV2<StorageOSVolumeSource> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StorageOSVolumeSource::new)
    }
}

impl ::protobuf::Clear for StorageOSVolumeSource {
    fn clear(&mut self) {
        self.volumeName.clear();
        self.volumeNamespace.clear();
        self.fsType.clear();
        self.readOnly = ::std::option::Option::None;
        self.secretRef.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StorageOSVolumeSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StorageOSVolumeSource {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Sysctl {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    value: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Sysctl {
    fn default() -> &'a Sysctl {
        <Sysctl as ::protobuf::Message>::default_instance()
    }
}

impl Sysctl {
    pub fn new() -> Sysctl {
        ::std::default::Default::default()
    }

    // optional string name = 1;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string value = 2;


    pub fn get_value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        if self.value.is_none() {
            self.value.set_default();
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for Sysctl {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.value.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.value.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Sysctl {
        Sysctl::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &Sysctl| { &m.name },
                |m: &mut Sysctl| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "value",
                |m: &Sysctl| { &m.value },
                |m: &mut Sysctl| { &mut m.value },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Sysctl>(
                "Sysctl",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Sysctl {
        static instance: ::protobuf::rt::LazyV2<Sysctl> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Sysctl::new)
    }
}

impl ::protobuf::Clear for Sysctl {
    fn clear(&mut self) {
        self.name.clear();
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Sysctl {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Sysctl {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TCPSocketAction {
    // message fields
    pub port: ::protobuf::SingularPtrField<super::k8s_io_apimachinery_pkg_util_intstr_generated::IntOrString>,
    host: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TCPSocketAction {
    fn default() -> &'a TCPSocketAction {
        <TCPSocketAction as ::protobuf::Message>::default_instance()
    }
}

impl TCPSocketAction {
    pub fn new() -> TCPSocketAction {
        ::std::default::Default::default()
    }

    // optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString port = 1;


    pub fn get_port(&self) -> &super::k8s_io_apimachinery_pkg_util_intstr_generated::IntOrString {
        self.port.as_ref().unwrap_or_else(|| <super::k8s_io_apimachinery_pkg_util_intstr_generated::IntOrString as ::protobuf::Message>::default_instance())
    }
    pub fn clear_port(&mut self) {
        self.port.clear();
    }

    pub fn has_port(&self) -> bool {
        self.port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_port(&mut self, v: super::k8s_io_apimachinery_pkg_util_intstr_generated::IntOrString) {
        self.port = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_port(&mut self) -> &mut super::k8s_io_apimachinery_pkg_util_intstr_generated::IntOrString {
        if self.port.is_none() {
            self.port.set_default();
        }
        self.port.as_mut().unwrap()
    }

    // Take field
    pub fn take_port(&mut self) -> super::k8s_io_apimachinery_pkg_util_intstr_generated::IntOrString {
        self.port.take().unwrap_or_else(|| super::k8s_io_apimachinery_pkg_util_intstr_generated::IntOrString::new())
    }

    // optional string host = 2;


    pub fn get_host(&self) -> &str {
        match self.host.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_host(&mut self) {
        self.host.clear();
    }

    pub fn has_host(&self) -> bool {
        self.host.is_some()
    }

    // Param is passed by value, moved
    pub fn set_host(&mut self, v: ::std::string::String) {
        self.host = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_host(&mut self) -> &mut ::std::string::String {
        if self.host.is_none() {
            self.host.set_default();
        }
        self.host.as_mut().unwrap()
    }

    // Take field
    pub fn take_host(&mut self) -> ::std::string::String {
        self.host.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for TCPSocketAction {
    fn is_initialized(&self) -> bool {
        for v in &self.port {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.port)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.host)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.port.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.host.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.port.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.host.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TCPSocketAction {
        TCPSocketAction::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_util_intstr_generated::IntOrString>>(
                "port",
                |m: &TCPSocketAction| { &m.port },
                |m: &mut TCPSocketAction| { &mut m.port },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "host",
                |m: &TCPSocketAction| { &m.host },
                |m: &mut TCPSocketAction| { &mut m.host },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TCPSocketAction>(
                "TCPSocketAction",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TCPSocketAction {
        static instance: ::protobuf::rt::LazyV2<TCPSocketAction> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TCPSocketAction::new)
    }
}

impl ::protobuf::Clear for TCPSocketAction {
    fn clear(&mut self) {
        self.port.clear();
        self.host.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TCPSocketAction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TCPSocketAction {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Taint {
    // message fields
    key: ::protobuf::SingularField<::std::string::String>,
    value: ::protobuf::SingularField<::std::string::String>,
    effect: ::protobuf::SingularField<::std::string::String>,
    pub timeAdded: ::protobuf::SingularPtrField<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Taint {
    fn default() -> &'a Taint {
        <Taint as ::protobuf::Message>::default_instance()
    }
}

impl Taint {
    pub fn new() -> Taint {
        ::std::default::Default::default()
    }

    // optional string key = 1;


    pub fn get_key(&self) -> &str {
        match self.key.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        if self.key.is_none() {
            self.key.set_default();
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        self.key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string value = 2;


    pub fn get_value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        if self.value.is_none() {
            self.value.set_default();
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string effect = 3;


    pub fn get_effect(&self) -> &str {
        match self.effect.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_effect(&mut self) {
        self.effect.clear();
    }

    pub fn has_effect(&self) -> bool {
        self.effect.is_some()
    }

    // Param is passed by value, moved
    pub fn set_effect(&mut self, v: ::std::string::String) {
        self.effect = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_effect(&mut self) -> &mut ::std::string::String {
        if self.effect.is_none() {
            self.effect.set_default();
        }
        self.effect.as_mut().unwrap()
    }

    // Take field
    pub fn take_effect(&mut self) -> ::std::string::String {
        self.effect.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time timeAdded = 4;


    pub fn get_timeAdded(&self) -> &super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time {
        self.timeAdded.as_ref().unwrap_or_else(|| <super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time as ::protobuf::Message>::default_instance())
    }
    pub fn clear_timeAdded(&mut self) {
        self.timeAdded.clear();
    }

    pub fn has_timeAdded(&self) -> bool {
        self.timeAdded.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timeAdded(&mut self, v: super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time) {
        self.timeAdded = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_timeAdded(&mut self) -> &mut super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time {
        if self.timeAdded.is_none() {
            self.timeAdded.set_default();
        }
        self.timeAdded.as_mut().unwrap()
    }

    // Take field
    pub fn take_timeAdded(&mut self) -> super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time {
        self.timeAdded.take().unwrap_or_else(|| super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time::new())
    }
}

impl ::protobuf::Message for Taint {
    fn is_initialized(&self) -> bool {
        for v in &self.timeAdded {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.value)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.effect)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.timeAdded)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.key.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.value.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.effect.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.timeAdded.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.key.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.value.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.effect.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.timeAdded.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Taint {
        Taint::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "key",
                |m: &Taint| { &m.key },
                |m: &mut Taint| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "value",
                |m: &Taint| { &m.value },
                |m: &mut Taint| { &mut m.value },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "effect",
                |m: &Taint| { &m.effect },
                |m: &mut Taint| { &mut m.effect },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::Time>>(
                "timeAdded",
                |m: &Taint| { &m.timeAdded },
                |m: &mut Taint| { &mut m.timeAdded },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Taint>(
                "Taint",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Taint {
        static instance: ::protobuf::rt::LazyV2<Taint> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Taint::new)
    }
}

impl ::protobuf::Clear for Taint {
    fn clear(&mut self) {
        self.key.clear();
        self.value.clear();
        self.effect.clear();
        self.timeAdded.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Taint {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Taint {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Toleration {
    // message fields
    key: ::protobuf::SingularField<::std::string::String>,
    operator: ::protobuf::SingularField<::std::string::String>,
    value: ::protobuf::SingularField<::std::string::String>,
    effect: ::protobuf::SingularField<::std::string::String>,
    tolerationSeconds: ::std::option::Option<i64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Toleration {
    fn default() -> &'a Toleration {
        <Toleration as ::protobuf::Message>::default_instance()
    }
}

impl Toleration {
    pub fn new() -> Toleration {
        ::std::default::Default::default()
    }

    // optional string key = 1;


    pub fn get_key(&self) -> &str {
        match self.key.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        if self.key.is_none() {
            self.key.set_default();
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        self.key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string operator = 2;


    pub fn get_operator(&self) -> &str {
        match self.operator.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_operator(&mut self) {
        self.operator.clear();
    }

    pub fn has_operator(&self) -> bool {
        self.operator.is_some()
    }

    // Param is passed by value, moved
    pub fn set_operator(&mut self, v: ::std::string::String) {
        self.operator = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_operator(&mut self) -> &mut ::std::string::String {
        if self.operator.is_none() {
            self.operator.set_default();
        }
        self.operator.as_mut().unwrap()
    }

    // Take field
    pub fn take_operator(&mut self) -> ::std::string::String {
        self.operator.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string value = 3;


    pub fn get_value(&self) -> &str {
        match self.value.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    pub fn has_value(&self) -> bool {
        self.value.is_some()
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::string::String) {
        self.value = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::string::String {
        if self.value.is_none() {
            self.value.set_default();
        }
        self.value.as_mut().unwrap()
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::string::String {
        self.value.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string effect = 4;


    pub fn get_effect(&self) -> &str {
        match self.effect.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_effect(&mut self) {
        self.effect.clear();
    }

    pub fn has_effect(&self) -> bool {
        self.effect.is_some()
    }

    // Param is passed by value, moved
    pub fn set_effect(&mut self, v: ::std::string::String) {
        self.effect = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_effect(&mut self) -> &mut ::std::string::String {
        if self.effect.is_none() {
            self.effect.set_default();
        }
        self.effect.as_mut().unwrap()
    }

    // Take field
    pub fn take_effect(&mut self) -> ::std::string::String {
        self.effect.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int64 tolerationSeconds = 5;


    pub fn get_tolerationSeconds(&self) -> i64 {
        self.tolerationSeconds.unwrap_or(0)
    }
    pub fn clear_tolerationSeconds(&mut self) {
        self.tolerationSeconds = ::std::option::Option::None;
    }

    pub fn has_tolerationSeconds(&self) -> bool {
        self.tolerationSeconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tolerationSeconds(&mut self, v: i64) {
        self.tolerationSeconds = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for Toleration {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.operator)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.value)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.effect)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.tolerationSeconds = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.key.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.operator.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.value.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.effect.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.tolerationSeconds {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.key.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.operator.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.value.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.effect.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(v) = self.tolerationSeconds {
            os.write_int64(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Toleration {
        Toleration::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "key",
                |m: &Toleration| { &m.key },
                |m: &mut Toleration| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "operator",
                |m: &Toleration| { &m.operator },
                |m: &mut Toleration| { &mut m.operator },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "value",
                |m: &Toleration| { &m.value },
                |m: &mut Toleration| { &mut m.value },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "effect",
                |m: &Toleration| { &m.effect },
                |m: &mut Toleration| { &mut m.effect },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "tolerationSeconds",
                |m: &Toleration| { &m.tolerationSeconds },
                |m: &mut Toleration| { &mut m.tolerationSeconds },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Toleration>(
                "Toleration",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Toleration {
        static instance: ::protobuf::rt::LazyV2<Toleration> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Toleration::new)
    }
}

impl ::protobuf::Clear for Toleration {
    fn clear(&mut self) {
        self.key.clear();
        self.operator.clear();
        self.value.clear();
        self.effect.clear();
        self.tolerationSeconds = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Toleration {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Toleration {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TopologySelectorLabelRequirement {
    // message fields
    key: ::protobuf::SingularField<::std::string::String>,
    pub values: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TopologySelectorLabelRequirement {
    fn default() -> &'a TopologySelectorLabelRequirement {
        <TopologySelectorLabelRequirement as ::protobuf::Message>::default_instance()
    }
}

impl TopologySelectorLabelRequirement {
    pub fn new() -> TopologySelectorLabelRequirement {
        ::std::default::Default::default()
    }

    // optional string key = 1;


    pub fn get_key(&self) -> &str {
        match self.key.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        if self.key.is_none() {
            self.key.set_default();
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        self.key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated string values = 2;


    pub fn get_values(&self) -> &[::std::string::String] {
        &self.values
    }
    pub fn clear_values(&mut self) {
        self.values.clear();
    }

    // Param is passed by value, moved
    pub fn set_values(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.values = v;
    }

    // Mutable pointer to the field.
    pub fn mut_values(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.values
    }

    // Take field
    pub fn take_values(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.values, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for TopologySelectorLabelRequirement {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.values)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.key.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.values {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.key.as_ref() {
            os.write_string(1, &v)?;
        }
        for v in &self.values {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TopologySelectorLabelRequirement {
        TopologySelectorLabelRequirement::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "key",
                |m: &TopologySelectorLabelRequirement| { &m.key },
                |m: &mut TopologySelectorLabelRequirement| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "values",
                |m: &TopologySelectorLabelRequirement| { &m.values },
                |m: &mut TopologySelectorLabelRequirement| { &mut m.values },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TopologySelectorLabelRequirement>(
                "TopologySelectorLabelRequirement",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TopologySelectorLabelRequirement {
        static instance: ::protobuf::rt::LazyV2<TopologySelectorLabelRequirement> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TopologySelectorLabelRequirement::new)
    }
}

impl ::protobuf::Clear for TopologySelectorLabelRequirement {
    fn clear(&mut self) {
        self.key.clear();
        self.values.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TopologySelectorLabelRequirement {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TopologySelectorLabelRequirement {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TopologySelectorTerm {
    // message fields
    pub matchLabelExpressions: ::protobuf::RepeatedField<TopologySelectorLabelRequirement>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TopologySelectorTerm {
    fn default() -> &'a TopologySelectorTerm {
        <TopologySelectorTerm as ::protobuf::Message>::default_instance()
    }
}

impl TopologySelectorTerm {
    pub fn new() -> TopologySelectorTerm {
        ::std::default::Default::default()
    }

    // repeated .k8s.io.api.core.v1.TopologySelectorLabelRequirement matchLabelExpressions = 1;


    pub fn get_matchLabelExpressions(&self) -> &[TopologySelectorLabelRequirement] {
        &self.matchLabelExpressions
    }
    pub fn clear_matchLabelExpressions(&mut self) {
        self.matchLabelExpressions.clear();
    }

    // Param is passed by value, moved
    pub fn set_matchLabelExpressions(&mut self, v: ::protobuf::RepeatedField<TopologySelectorLabelRequirement>) {
        self.matchLabelExpressions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_matchLabelExpressions(&mut self) -> &mut ::protobuf::RepeatedField<TopologySelectorLabelRequirement> {
        &mut self.matchLabelExpressions
    }

    // Take field
    pub fn take_matchLabelExpressions(&mut self) -> ::protobuf::RepeatedField<TopologySelectorLabelRequirement> {
        ::std::mem::replace(&mut self.matchLabelExpressions, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for TopologySelectorTerm {
    fn is_initialized(&self) -> bool {
        for v in &self.matchLabelExpressions {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.matchLabelExpressions)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.matchLabelExpressions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.matchLabelExpressions {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TopologySelectorTerm {
        TopologySelectorTerm::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TopologySelectorLabelRequirement>>(
                "matchLabelExpressions",
                |m: &TopologySelectorTerm| { &m.matchLabelExpressions },
                |m: &mut TopologySelectorTerm| { &mut m.matchLabelExpressions },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TopologySelectorTerm>(
                "TopologySelectorTerm",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TopologySelectorTerm {
        static instance: ::protobuf::rt::LazyV2<TopologySelectorTerm> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TopologySelectorTerm::new)
    }
}

impl ::protobuf::Clear for TopologySelectorTerm {
    fn clear(&mut self) {
        self.matchLabelExpressions.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TopologySelectorTerm {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TopologySelectorTerm {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TopologySpreadConstraint {
    // message fields
    maxSkew: ::std::option::Option<i32>,
    topologyKey: ::protobuf::SingularField<::std::string::String>,
    whenUnsatisfiable: ::protobuf::SingularField<::std::string::String>,
    pub labelSelector: ::protobuf::SingularPtrField<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::LabelSelector>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TopologySpreadConstraint {
    fn default() -> &'a TopologySpreadConstraint {
        <TopologySpreadConstraint as ::protobuf::Message>::default_instance()
    }
}

impl TopologySpreadConstraint {
    pub fn new() -> TopologySpreadConstraint {
        ::std::default::Default::default()
    }

    // optional int32 maxSkew = 1;


    pub fn get_maxSkew(&self) -> i32 {
        self.maxSkew.unwrap_or(0)
    }
    pub fn clear_maxSkew(&mut self) {
        self.maxSkew = ::std::option::Option::None;
    }

    pub fn has_maxSkew(&self) -> bool {
        self.maxSkew.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maxSkew(&mut self, v: i32) {
        self.maxSkew = ::std::option::Option::Some(v);
    }

    // optional string topologyKey = 2;


    pub fn get_topologyKey(&self) -> &str {
        match self.topologyKey.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_topologyKey(&mut self) {
        self.topologyKey.clear();
    }

    pub fn has_topologyKey(&self) -> bool {
        self.topologyKey.is_some()
    }

    // Param is passed by value, moved
    pub fn set_topologyKey(&mut self, v: ::std::string::String) {
        self.topologyKey = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_topologyKey(&mut self) -> &mut ::std::string::String {
        if self.topologyKey.is_none() {
            self.topologyKey.set_default();
        }
        self.topologyKey.as_mut().unwrap()
    }

    // Take field
    pub fn take_topologyKey(&mut self) -> ::std::string::String {
        self.topologyKey.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string whenUnsatisfiable = 3;


    pub fn get_whenUnsatisfiable(&self) -> &str {
        match self.whenUnsatisfiable.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_whenUnsatisfiable(&mut self) {
        self.whenUnsatisfiable.clear();
    }

    pub fn has_whenUnsatisfiable(&self) -> bool {
        self.whenUnsatisfiable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_whenUnsatisfiable(&mut self, v: ::std::string::String) {
        self.whenUnsatisfiable = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_whenUnsatisfiable(&mut self) -> &mut ::std::string::String {
        if self.whenUnsatisfiable.is_none() {
            self.whenUnsatisfiable.set_default();
        }
        self.whenUnsatisfiable.as_mut().unwrap()
    }

    // Take field
    pub fn take_whenUnsatisfiable(&mut self) -> ::std::string::String {
        self.whenUnsatisfiable.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector labelSelector = 4;


    pub fn get_labelSelector(&self) -> &super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::LabelSelector {
        self.labelSelector.as_ref().unwrap_or_else(|| <super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::LabelSelector as ::protobuf::Message>::default_instance())
    }
    pub fn clear_labelSelector(&mut self) {
        self.labelSelector.clear();
    }

    pub fn has_labelSelector(&self) -> bool {
        self.labelSelector.is_some()
    }

    // Param is passed by value, moved
    pub fn set_labelSelector(&mut self, v: super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::LabelSelector) {
        self.labelSelector = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_labelSelector(&mut self) -> &mut super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::LabelSelector {
        if self.labelSelector.is_none() {
            self.labelSelector.set_default();
        }
        self.labelSelector.as_mut().unwrap()
    }

    // Take field
    pub fn take_labelSelector(&mut self) -> super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::LabelSelector {
        self.labelSelector.take().unwrap_or_else(|| super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::LabelSelector::new())
    }
}

impl ::protobuf::Message for TopologySpreadConstraint {
    fn is_initialized(&self) -> bool {
        for v in &self.labelSelector {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.maxSkew = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.topologyKey)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.whenUnsatisfiable)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.labelSelector)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.maxSkew {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.topologyKey.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.whenUnsatisfiable.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.labelSelector.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.maxSkew {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.topologyKey.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.whenUnsatisfiable.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.labelSelector.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TopologySpreadConstraint {
        TopologySpreadConstraint::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "maxSkew",
                |m: &TopologySpreadConstraint| { &m.maxSkew },
                |m: &mut TopologySpreadConstraint| { &mut m.maxSkew },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "topologyKey",
                |m: &TopologySpreadConstraint| { &m.topologyKey },
                |m: &mut TopologySpreadConstraint| { &mut m.topologyKey },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "whenUnsatisfiable",
                |m: &TopologySpreadConstraint| { &m.whenUnsatisfiable },
                |m: &mut TopologySpreadConstraint| { &mut m.whenUnsatisfiable },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::k8s_io_apimachinery_pkg_apis_meta_v1_generated::LabelSelector>>(
                "labelSelector",
                |m: &TopologySpreadConstraint| { &m.labelSelector },
                |m: &mut TopologySpreadConstraint| { &mut m.labelSelector },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TopologySpreadConstraint>(
                "TopologySpreadConstraint",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TopologySpreadConstraint {
        static instance: ::protobuf::rt::LazyV2<TopologySpreadConstraint> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TopologySpreadConstraint::new)
    }
}

impl ::protobuf::Clear for TopologySpreadConstraint {
    fn clear(&mut self) {
        self.maxSkew = ::std::option::Option::None;
        self.topologyKey.clear();
        self.whenUnsatisfiable.clear();
        self.labelSelector.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TopologySpreadConstraint {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TopologySpreadConstraint {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TypedLocalObjectReference {
    // message fields
    apiGroup: ::protobuf::SingularField<::std::string::String>,
    kind: ::protobuf::SingularField<::std::string::String>,
    name: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TypedLocalObjectReference {
    fn default() -> &'a TypedLocalObjectReference {
        <TypedLocalObjectReference as ::protobuf::Message>::default_instance()
    }
}

impl TypedLocalObjectReference {
    pub fn new() -> TypedLocalObjectReference {
        ::std::default::Default::default()
    }

    // optional string apiGroup = 1;


    pub fn get_apiGroup(&self) -> &str {
        match self.apiGroup.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_apiGroup(&mut self) {
        self.apiGroup.clear();
    }

    pub fn has_apiGroup(&self) -> bool {
        self.apiGroup.is_some()
    }

    // Param is passed by value, moved
    pub fn set_apiGroup(&mut self, v: ::std::string::String) {
        self.apiGroup = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_apiGroup(&mut self) -> &mut ::std::string::String {
        if self.apiGroup.is_none() {
            self.apiGroup.set_default();
        }
        self.apiGroup.as_mut().unwrap()
    }

    // Take field
    pub fn take_apiGroup(&mut self) -> ::std::string::String {
        self.apiGroup.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string kind = 2;


    pub fn get_kind(&self) -> &str {
        match self.kind.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_kind(&mut self) {
        self.kind.clear();
    }

    pub fn has_kind(&self) -> bool {
        self.kind.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kind(&mut self, v: ::std::string::String) {
        self.kind = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kind(&mut self) -> &mut ::std::string::String {
        if self.kind.is_none() {
            self.kind.set_default();
        }
        self.kind.as_mut().unwrap()
    }

    // Take field
    pub fn take_kind(&mut self) -> ::std::string::String {
        self.kind.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string name = 3;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for TypedLocalObjectReference {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.apiGroup)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.kind)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.apiGroup.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.kind.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.apiGroup.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.kind.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TypedLocalObjectReference {
        TypedLocalObjectReference::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "apiGroup",
                |m: &TypedLocalObjectReference| { &m.apiGroup },
                |m: &mut TypedLocalObjectReference| { &mut m.apiGroup },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "kind",
                |m: &TypedLocalObjectReference| { &m.kind },
                |m: &mut TypedLocalObjectReference| { &mut m.kind },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &TypedLocalObjectReference| { &m.name },
                |m: &mut TypedLocalObjectReference| { &mut m.name },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TypedLocalObjectReference>(
                "TypedLocalObjectReference",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TypedLocalObjectReference {
        static instance: ::protobuf::rt::LazyV2<TypedLocalObjectReference> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TypedLocalObjectReference::new)
    }
}

impl ::protobuf::Clear for TypedLocalObjectReference {
    fn clear(&mut self) {
        self.apiGroup.clear();
        self.kind.clear();
        self.name.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TypedLocalObjectReference {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TypedLocalObjectReference {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Volume {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    pub volumeSource: ::protobuf::SingularPtrField<VolumeSource>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Volume {
    fn default() -> &'a Volume {
        <Volume as ::protobuf::Message>::default_instance()
    }
}

impl Volume {
    pub fn new() -> Volume {
        ::std::default::Default::default()
    }

    // optional string name = 1;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .k8s.io.api.core.v1.VolumeSource volumeSource = 2;


    pub fn get_volumeSource(&self) -> &VolumeSource {
        self.volumeSource.as_ref().unwrap_or_else(|| <VolumeSource as ::protobuf::Message>::default_instance())
    }
    pub fn clear_volumeSource(&mut self) {
        self.volumeSource.clear();
    }

    pub fn has_volumeSource(&self) -> bool {
        self.volumeSource.is_some()
    }

    // Param is passed by value, moved
    pub fn set_volumeSource(&mut self, v: VolumeSource) {
        self.volumeSource = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_volumeSource(&mut self) -> &mut VolumeSource {
        if self.volumeSource.is_none() {
            self.volumeSource.set_default();
        }
        self.volumeSource.as_mut().unwrap()
    }

    // Take field
    pub fn take_volumeSource(&mut self) -> VolumeSource {
        self.volumeSource.take().unwrap_or_else(|| VolumeSource::new())
    }
}

impl ::protobuf::Message for Volume {
    fn is_initialized(&self) -> bool {
        for v in &self.volumeSource {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.volumeSource)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.volumeSource.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.volumeSource.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Volume {
        Volume::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &Volume| { &m.name },
                |m: &mut Volume| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<VolumeSource>>(
                "volumeSource",
                |m: &Volume| { &m.volumeSource },
                |m: &mut Volume| { &mut m.volumeSource },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Volume>(
                "Volume",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Volume {
        static instance: ::protobuf::rt::LazyV2<Volume> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Volume::new)
    }
}

impl ::protobuf::Clear for Volume {
    fn clear(&mut self) {
        self.name.clear();
        self.volumeSource.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Volume {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Volume {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VolumeDevice {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    devicePath: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VolumeDevice {
    fn default() -> &'a VolumeDevice {
        <VolumeDevice as ::protobuf::Message>::default_instance()
    }
}

impl VolumeDevice {
    pub fn new() -> VolumeDevice {
        ::std::default::Default::default()
    }

    // optional string name = 1;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string devicePath = 2;


    pub fn get_devicePath(&self) -> &str {
        match self.devicePath.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_devicePath(&mut self) {
        self.devicePath.clear();
    }

    pub fn has_devicePath(&self) -> bool {
        self.devicePath.is_some()
    }

    // Param is passed by value, moved
    pub fn set_devicePath(&mut self, v: ::std::string::String) {
        self.devicePath = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_devicePath(&mut self) -> &mut ::std::string::String {
        if self.devicePath.is_none() {
            self.devicePath.set_default();
        }
        self.devicePath.as_mut().unwrap()
    }

    // Take field
    pub fn take_devicePath(&mut self) -> ::std::string::String {
        self.devicePath.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for VolumeDevice {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.devicePath)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.devicePath.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.devicePath.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VolumeDevice {
        VolumeDevice::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &VolumeDevice| { &m.name },
                |m: &mut VolumeDevice| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "devicePath",
                |m: &VolumeDevice| { &m.devicePath },
                |m: &mut VolumeDevice| { &mut m.devicePath },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VolumeDevice>(
                "VolumeDevice",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VolumeDevice {
        static instance: ::protobuf::rt::LazyV2<VolumeDevice> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VolumeDevice::new)
    }
}

impl ::protobuf::Clear for VolumeDevice {
    fn clear(&mut self) {
        self.name.clear();
        self.devicePath.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VolumeDevice {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VolumeDevice {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VolumeMount {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    readOnly: ::std::option::Option<bool>,
    mountPath: ::protobuf::SingularField<::std::string::String>,
    subPath: ::protobuf::SingularField<::std::string::String>,
    mountPropagation: ::protobuf::SingularField<::std::string::String>,
    subPathExpr: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VolumeMount {
    fn default() -> &'a VolumeMount {
        <VolumeMount as ::protobuf::Message>::default_instance()
    }
}

impl VolumeMount {
    pub fn new() -> VolumeMount {
        ::std::default::Default::default()
    }

    // optional string name = 1;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool readOnly = 2;


    pub fn get_readOnly(&self) -> bool {
        self.readOnly.unwrap_or(false)
    }
    pub fn clear_readOnly(&mut self) {
        self.readOnly = ::std::option::Option::None;
    }

    pub fn has_readOnly(&self) -> bool {
        self.readOnly.is_some()
    }

    // Param is passed by value, moved
    pub fn set_readOnly(&mut self, v: bool) {
        self.readOnly = ::std::option::Option::Some(v);
    }

    // optional string mountPath = 3;


    pub fn get_mountPath(&self) -> &str {
        match self.mountPath.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_mountPath(&mut self) {
        self.mountPath.clear();
    }

    pub fn has_mountPath(&self) -> bool {
        self.mountPath.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mountPath(&mut self, v: ::std::string::String) {
        self.mountPath = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mountPath(&mut self) -> &mut ::std::string::String {
        if self.mountPath.is_none() {
            self.mountPath.set_default();
        }
        self.mountPath.as_mut().unwrap()
    }

    // Take field
    pub fn take_mountPath(&mut self) -> ::std::string::String {
        self.mountPath.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string subPath = 4;


    pub fn get_subPath(&self) -> &str {
        match self.subPath.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_subPath(&mut self) {
        self.subPath.clear();
    }

    pub fn has_subPath(&self) -> bool {
        self.subPath.is_some()
    }

    // Param is passed by value, moved
    pub fn set_subPath(&mut self, v: ::std::string::String) {
        self.subPath = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subPath(&mut self) -> &mut ::std::string::String {
        if self.subPath.is_none() {
            self.subPath.set_default();
        }
        self.subPath.as_mut().unwrap()
    }

    // Take field
    pub fn take_subPath(&mut self) -> ::std::string::String {
        self.subPath.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string mountPropagation = 5;


    pub fn get_mountPropagation(&self) -> &str {
        match self.mountPropagation.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_mountPropagation(&mut self) {
        self.mountPropagation.clear();
    }

    pub fn has_mountPropagation(&self) -> bool {
        self.mountPropagation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mountPropagation(&mut self, v: ::std::string::String) {
        self.mountPropagation = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mountPropagation(&mut self) -> &mut ::std::string::String {
        if self.mountPropagation.is_none() {
            self.mountPropagation.set_default();
        }
        self.mountPropagation.as_mut().unwrap()
    }

    // Take field
    pub fn take_mountPropagation(&mut self) -> ::std::string::String {
        self.mountPropagation.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string subPathExpr = 6;


    pub fn get_subPathExpr(&self) -> &str {
        match self.subPathExpr.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_subPathExpr(&mut self) {
        self.subPathExpr.clear();
    }

    pub fn has_subPathExpr(&self) -> bool {
        self.subPathExpr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_subPathExpr(&mut self, v: ::std::string::String) {
        self.subPathExpr = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subPathExpr(&mut self) -> &mut ::std::string::String {
        if self.subPathExpr.is_none() {
            self.subPathExpr.set_default();
        }
        self.subPathExpr.as_mut().unwrap()
    }

    // Take field
    pub fn take_subPathExpr(&mut self) -> ::std::string::String {
        self.subPathExpr.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for VolumeMount {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.readOnly = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.mountPath)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.subPath)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.mountPropagation)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.subPathExpr)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.readOnly {
            my_size += 2;
        }
        if let Some(ref v) = self.mountPath.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.subPath.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.mountPropagation.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.subPathExpr.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.readOnly {
            os.write_bool(2, v)?;
        }
        if let Some(ref v) = self.mountPath.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.subPath.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.mountPropagation.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.subPathExpr.as_ref() {
            os.write_string(6, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VolumeMount {
        VolumeMount::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &VolumeMount| { &m.name },
                |m: &mut VolumeMount| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "readOnly",
                |m: &VolumeMount| { &m.readOnly },
                |m: &mut VolumeMount| { &mut m.readOnly },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "mountPath",
                |m: &VolumeMount| { &m.mountPath },
                |m: &mut VolumeMount| { &mut m.mountPath },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "subPath",
                |m: &VolumeMount| { &m.subPath },
                |m: &mut VolumeMount| { &mut m.subPath },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "mountPropagation",
                |m: &VolumeMount| { &m.mountPropagation },
                |m: &mut VolumeMount| { &mut m.mountPropagation },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "subPathExpr",
                |m: &VolumeMount| { &m.subPathExpr },
                |m: &mut VolumeMount| { &mut m.subPathExpr },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VolumeMount>(
                "VolumeMount",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VolumeMount {
        static instance: ::protobuf::rt::LazyV2<VolumeMount> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VolumeMount::new)
    }
}

impl ::protobuf::Clear for VolumeMount {
    fn clear(&mut self) {
        self.name.clear();
        self.readOnly = ::std::option::Option::None;
        self.mountPath.clear();
        self.subPath.clear();
        self.mountPropagation.clear();
        self.subPathExpr.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VolumeMount {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VolumeMount {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VolumeNodeAffinity {
    // message fields
    pub required: ::protobuf::SingularPtrField<NodeSelector>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VolumeNodeAffinity {
    fn default() -> &'a VolumeNodeAffinity {
        <VolumeNodeAffinity as ::protobuf::Message>::default_instance()
    }
}

impl VolumeNodeAffinity {
    pub fn new() -> VolumeNodeAffinity {
        ::std::default::Default::default()
    }

    // optional .k8s.io.api.core.v1.NodeSelector required = 1;


    pub fn get_required(&self) -> &NodeSelector {
        self.required.as_ref().unwrap_or_else(|| <NodeSelector as ::protobuf::Message>::default_instance())
    }
    pub fn clear_required(&mut self) {
        self.required.clear();
    }

    pub fn has_required(&self) -> bool {
        self.required.is_some()
    }

    // Param is passed by value, moved
    pub fn set_required(&mut self, v: NodeSelector) {
        self.required = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_required(&mut self) -> &mut NodeSelector {
        if self.required.is_none() {
            self.required.set_default();
        }
        self.required.as_mut().unwrap()
    }

    // Take field
    pub fn take_required(&mut self) -> NodeSelector {
        self.required.take().unwrap_or_else(|| NodeSelector::new())
    }
}

impl ::protobuf::Message for VolumeNodeAffinity {
    fn is_initialized(&self) -> bool {
        for v in &self.required {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.required)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.required.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.required.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VolumeNodeAffinity {
        VolumeNodeAffinity::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NodeSelector>>(
                "required",
                |m: &VolumeNodeAffinity| { &m.required },
                |m: &mut VolumeNodeAffinity| { &mut m.required },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VolumeNodeAffinity>(
                "VolumeNodeAffinity",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VolumeNodeAffinity {
        static instance: ::protobuf::rt::LazyV2<VolumeNodeAffinity> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VolumeNodeAffinity::new)
    }
}

impl ::protobuf::Clear for VolumeNodeAffinity {
    fn clear(&mut self) {
        self.required.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VolumeNodeAffinity {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VolumeNodeAffinity {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VolumeProjection {
    // message fields
    pub secret: ::protobuf::SingularPtrField<SecretProjection>,
    pub downwardAPI: ::protobuf::SingularPtrField<DownwardAPIProjection>,
    pub configMap: ::protobuf::SingularPtrField<ConfigMapProjection>,
    pub serviceAccountToken: ::protobuf::SingularPtrField<ServiceAccountTokenProjection>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VolumeProjection {
    fn default() -> &'a VolumeProjection {
        <VolumeProjection as ::protobuf::Message>::default_instance()
    }
}

impl VolumeProjection {
    pub fn new() -> VolumeProjection {
        ::std::default::Default::default()
    }

    // optional .k8s.io.api.core.v1.SecretProjection secret = 1;


    pub fn get_secret(&self) -> &SecretProjection {
        self.secret.as_ref().unwrap_or_else(|| <SecretProjection as ::protobuf::Message>::default_instance())
    }
    pub fn clear_secret(&mut self) {
        self.secret.clear();
    }

    pub fn has_secret(&self) -> bool {
        self.secret.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secret(&mut self, v: SecretProjection) {
        self.secret = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_secret(&mut self) -> &mut SecretProjection {
        if self.secret.is_none() {
            self.secret.set_default();
        }
        self.secret.as_mut().unwrap()
    }

    // Take field
    pub fn take_secret(&mut self) -> SecretProjection {
        self.secret.take().unwrap_or_else(|| SecretProjection::new())
    }

    // optional .k8s.io.api.core.v1.DownwardAPIProjection downwardAPI = 2;


    pub fn get_downwardAPI(&self) -> &DownwardAPIProjection {
        self.downwardAPI.as_ref().unwrap_or_else(|| <DownwardAPIProjection as ::protobuf::Message>::default_instance())
    }
    pub fn clear_downwardAPI(&mut self) {
        self.downwardAPI.clear();
    }

    pub fn has_downwardAPI(&self) -> bool {
        self.downwardAPI.is_some()
    }

    // Param is passed by value, moved
    pub fn set_downwardAPI(&mut self, v: DownwardAPIProjection) {
        self.downwardAPI = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_downwardAPI(&mut self) -> &mut DownwardAPIProjection {
        if self.downwardAPI.is_none() {
            self.downwardAPI.set_default();
        }
        self.downwardAPI.as_mut().unwrap()
    }

    // Take field
    pub fn take_downwardAPI(&mut self) -> DownwardAPIProjection {
        self.downwardAPI.take().unwrap_or_else(|| DownwardAPIProjection::new())
    }

    // optional .k8s.io.api.core.v1.ConfigMapProjection configMap = 3;


    pub fn get_configMap(&self) -> &ConfigMapProjection {
        self.configMap.as_ref().unwrap_or_else(|| <ConfigMapProjection as ::protobuf::Message>::default_instance())
    }
    pub fn clear_configMap(&mut self) {
        self.configMap.clear();
    }

    pub fn has_configMap(&self) -> bool {
        self.configMap.is_some()
    }

    // Param is passed by value, moved
    pub fn set_configMap(&mut self, v: ConfigMapProjection) {
        self.configMap = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_configMap(&mut self) -> &mut ConfigMapProjection {
        if self.configMap.is_none() {
            self.configMap.set_default();
        }
        self.configMap.as_mut().unwrap()
    }

    // Take field
    pub fn take_configMap(&mut self) -> ConfigMapProjection {
        self.configMap.take().unwrap_or_else(|| ConfigMapProjection::new())
    }

    // optional .k8s.io.api.core.v1.ServiceAccountTokenProjection serviceAccountToken = 4;


    pub fn get_serviceAccountToken(&self) -> &ServiceAccountTokenProjection {
        self.serviceAccountToken.as_ref().unwrap_or_else(|| <ServiceAccountTokenProjection as ::protobuf::Message>::default_instance())
    }
    pub fn clear_serviceAccountToken(&mut self) {
        self.serviceAccountToken.clear();
    }

    pub fn has_serviceAccountToken(&self) -> bool {
        self.serviceAccountToken.is_some()
    }

    // Param is passed by value, moved
    pub fn set_serviceAccountToken(&mut self, v: ServiceAccountTokenProjection) {
        self.serviceAccountToken = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_serviceAccountToken(&mut self) -> &mut ServiceAccountTokenProjection {
        if self.serviceAccountToken.is_none() {
            self.serviceAccountToken.set_default();
        }
        self.serviceAccountToken.as_mut().unwrap()
    }

    // Take field
    pub fn take_serviceAccountToken(&mut self) -> ServiceAccountTokenProjection {
        self.serviceAccountToken.take().unwrap_or_else(|| ServiceAccountTokenProjection::new())
    }
}

impl ::protobuf::Message for VolumeProjection {
    fn is_initialized(&self) -> bool {
        for v in &self.secret {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.downwardAPI {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.configMap {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.serviceAccountToken {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.secret)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.downwardAPI)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.configMap)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.serviceAccountToken)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.secret.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.downwardAPI.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.configMap.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.serviceAccountToken.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.secret.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.downwardAPI.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.configMap.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.serviceAccountToken.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VolumeProjection {
        VolumeProjection::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SecretProjection>>(
                "secret",
                |m: &VolumeProjection| { &m.secret },
                |m: &mut VolumeProjection| { &mut m.secret },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DownwardAPIProjection>>(
                "downwardAPI",
                |m: &VolumeProjection| { &m.downwardAPI },
                |m: &mut VolumeProjection| { &mut m.downwardAPI },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ConfigMapProjection>>(
                "configMap",
                |m: &VolumeProjection| { &m.configMap },
                |m: &mut VolumeProjection| { &mut m.configMap },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ServiceAccountTokenProjection>>(
                "serviceAccountToken",
                |m: &VolumeProjection| { &m.serviceAccountToken },
                |m: &mut VolumeProjection| { &mut m.serviceAccountToken },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VolumeProjection>(
                "VolumeProjection",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VolumeProjection {
        static instance: ::protobuf::rt::LazyV2<VolumeProjection> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VolumeProjection::new)
    }
}

impl ::protobuf::Clear for VolumeProjection {
    fn clear(&mut self) {
        self.secret.clear();
        self.downwardAPI.clear();
        self.configMap.clear();
        self.serviceAccountToken.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VolumeProjection {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VolumeProjection {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VolumeSource {
    // message fields
    pub hostPath: ::protobuf::SingularPtrField<HostPathVolumeSource>,
    pub emptyDir: ::protobuf::SingularPtrField<EmptyDirVolumeSource>,
    pub gcePersistentDisk: ::protobuf::SingularPtrField<GCEPersistentDiskVolumeSource>,
    pub awsElasticBlockStore: ::protobuf::SingularPtrField<AWSElasticBlockStoreVolumeSource>,
    pub gitRepo: ::protobuf::SingularPtrField<GitRepoVolumeSource>,
    pub secret: ::protobuf::SingularPtrField<SecretVolumeSource>,
    pub nfs: ::protobuf::SingularPtrField<NFSVolumeSource>,
    pub iscsi: ::protobuf::SingularPtrField<ISCSIVolumeSource>,
    pub glusterfs: ::protobuf::SingularPtrField<GlusterfsVolumeSource>,
    pub persistentVolumeClaim: ::protobuf::SingularPtrField<PersistentVolumeClaimVolumeSource>,
    pub rbd: ::protobuf::SingularPtrField<RBDVolumeSource>,
    pub flexVolume: ::protobuf::SingularPtrField<FlexVolumeSource>,
    pub cinder: ::protobuf::SingularPtrField<CinderVolumeSource>,
    pub cephfs: ::protobuf::SingularPtrField<CephFSVolumeSource>,
    pub flocker: ::protobuf::SingularPtrField<FlockerVolumeSource>,
    pub downwardAPI: ::protobuf::SingularPtrField<DownwardAPIVolumeSource>,
    pub fc: ::protobuf::SingularPtrField<FCVolumeSource>,
    pub azureFile: ::protobuf::SingularPtrField<AzureFileVolumeSource>,
    pub configMap: ::protobuf::SingularPtrField<ConfigMapVolumeSource>,
    pub vsphereVolume: ::protobuf::SingularPtrField<VsphereVirtualDiskVolumeSource>,
    pub quobyte: ::protobuf::SingularPtrField<QuobyteVolumeSource>,
    pub azureDisk: ::protobuf::SingularPtrField<AzureDiskVolumeSource>,
    pub photonPersistentDisk: ::protobuf::SingularPtrField<PhotonPersistentDiskVolumeSource>,
    pub projected: ::protobuf::SingularPtrField<ProjectedVolumeSource>,
    pub portworxVolume: ::protobuf::SingularPtrField<PortworxVolumeSource>,
    pub scaleIO: ::protobuf::SingularPtrField<ScaleIOVolumeSource>,
    pub storageos: ::protobuf::SingularPtrField<StorageOSVolumeSource>,
    pub csi: ::protobuf::SingularPtrField<CSIVolumeSource>,
    pub ephemeral: ::protobuf::SingularPtrField<EphemeralVolumeSource>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VolumeSource {
    fn default() -> &'a VolumeSource {
        <VolumeSource as ::protobuf::Message>::default_instance()
    }
}

impl VolumeSource {
    pub fn new() -> VolumeSource {
        ::std::default::Default::default()
    }

    // optional .k8s.io.api.core.v1.HostPathVolumeSource hostPath = 1;


    pub fn get_hostPath(&self) -> &HostPathVolumeSource {
        self.hostPath.as_ref().unwrap_or_else(|| <HostPathVolumeSource as ::protobuf::Message>::default_instance())
    }
    pub fn clear_hostPath(&mut self) {
        self.hostPath.clear();
    }

    pub fn has_hostPath(&self) -> bool {
        self.hostPath.is_some()
    }

    // Param is passed by value, moved
    pub fn set_hostPath(&mut self, v: HostPathVolumeSource) {
        self.hostPath = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hostPath(&mut self) -> &mut HostPathVolumeSource {
        if self.hostPath.is_none() {
            self.hostPath.set_default();
        }
        self.hostPath.as_mut().unwrap()
    }

    // Take field
    pub fn take_hostPath(&mut self) -> HostPathVolumeSource {
        self.hostPath.take().unwrap_or_else(|| HostPathVolumeSource::new())
    }

    // optional .k8s.io.api.core.v1.EmptyDirVolumeSource emptyDir = 2;


    pub fn get_emptyDir(&self) -> &EmptyDirVolumeSource {
        self.emptyDir.as_ref().unwrap_or_else(|| <EmptyDirVolumeSource as ::protobuf::Message>::default_instance())
    }
    pub fn clear_emptyDir(&mut self) {
        self.emptyDir.clear();
    }

    pub fn has_emptyDir(&self) -> bool {
        self.emptyDir.is_some()
    }

    // Param is passed by value, moved
    pub fn set_emptyDir(&mut self, v: EmptyDirVolumeSource) {
        self.emptyDir = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_emptyDir(&mut self) -> &mut EmptyDirVolumeSource {
        if self.emptyDir.is_none() {
            self.emptyDir.set_default();
        }
        self.emptyDir.as_mut().unwrap()
    }

    // Take field
    pub fn take_emptyDir(&mut self) -> EmptyDirVolumeSource {
        self.emptyDir.take().unwrap_or_else(|| EmptyDirVolumeSource::new())
    }

    // optional .k8s.io.api.core.v1.GCEPersistentDiskVolumeSource gcePersistentDisk = 3;


    pub fn get_gcePersistentDisk(&self) -> &GCEPersistentDiskVolumeSource {
        self.gcePersistentDisk.as_ref().unwrap_or_else(|| <GCEPersistentDiskVolumeSource as ::protobuf::Message>::default_instance())
    }
    pub fn clear_gcePersistentDisk(&mut self) {
        self.gcePersistentDisk.clear();
    }

    pub fn has_gcePersistentDisk(&self) -> bool {
        self.gcePersistentDisk.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gcePersistentDisk(&mut self, v: GCEPersistentDiskVolumeSource) {
        self.gcePersistentDisk = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gcePersistentDisk(&mut self) -> &mut GCEPersistentDiskVolumeSource {
        if self.gcePersistentDisk.is_none() {
            self.gcePersistentDisk.set_default();
        }
        self.gcePersistentDisk.as_mut().unwrap()
    }

    // Take field
    pub fn take_gcePersistentDisk(&mut self) -> GCEPersistentDiskVolumeSource {
        self.gcePersistentDisk.take().unwrap_or_else(|| GCEPersistentDiskVolumeSource::new())
    }

    // optional .k8s.io.api.core.v1.AWSElasticBlockStoreVolumeSource awsElasticBlockStore = 4;


    pub fn get_awsElasticBlockStore(&self) -> &AWSElasticBlockStoreVolumeSource {
        self.awsElasticBlockStore.as_ref().unwrap_or_else(|| <AWSElasticBlockStoreVolumeSource as ::protobuf::Message>::default_instance())
    }
    pub fn clear_awsElasticBlockStore(&mut self) {
        self.awsElasticBlockStore.clear();
    }

    pub fn has_awsElasticBlockStore(&self) -> bool {
        self.awsElasticBlockStore.is_some()
    }

    // Param is passed by value, moved
    pub fn set_awsElasticBlockStore(&mut self, v: AWSElasticBlockStoreVolumeSource) {
        self.awsElasticBlockStore = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_awsElasticBlockStore(&mut self) -> &mut AWSElasticBlockStoreVolumeSource {
        if self.awsElasticBlockStore.is_none() {
            self.awsElasticBlockStore.set_default();
        }
        self.awsElasticBlockStore.as_mut().unwrap()
    }

    // Take field
    pub fn take_awsElasticBlockStore(&mut self) -> AWSElasticBlockStoreVolumeSource {
        self.awsElasticBlockStore.take().unwrap_or_else(|| AWSElasticBlockStoreVolumeSource::new())
    }

    // optional .k8s.io.api.core.v1.GitRepoVolumeSource gitRepo = 5;


    pub fn get_gitRepo(&self) -> &GitRepoVolumeSource {
        self.gitRepo.as_ref().unwrap_or_else(|| <GitRepoVolumeSource as ::protobuf::Message>::default_instance())
    }
    pub fn clear_gitRepo(&mut self) {
        self.gitRepo.clear();
    }

    pub fn has_gitRepo(&self) -> bool {
        self.gitRepo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gitRepo(&mut self, v: GitRepoVolumeSource) {
        self.gitRepo = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gitRepo(&mut self) -> &mut GitRepoVolumeSource {
        if self.gitRepo.is_none() {
            self.gitRepo.set_default();
        }
        self.gitRepo.as_mut().unwrap()
    }

    // Take field
    pub fn take_gitRepo(&mut self) -> GitRepoVolumeSource {
        self.gitRepo.take().unwrap_or_else(|| GitRepoVolumeSource::new())
    }

    // optional .k8s.io.api.core.v1.SecretVolumeSource secret = 6;


    pub fn get_secret(&self) -> &SecretVolumeSource {
        self.secret.as_ref().unwrap_or_else(|| <SecretVolumeSource as ::protobuf::Message>::default_instance())
    }
    pub fn clear_secret(&mut self) {
        self.secret.clear();
    }

    pub fn has_secret(&self) -> bool {
        self.secret.is_some()
    }

    // Param is passed by value, moved
    pub fn set_secret(&mut self, v: SecretVolumeSource) {
        self.secret = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_secret(&mut self) -> &mut SecretVolumeSource {
        if self.secret.is_none() {
            self.secret.set_default();
        }
        self.secret.as_mut().unwrap()
    }

    // Take field
    pub fn take_secret(&mut self) -> SecretVolumeSource {
        self.secret.take().unwrap_or_else(|| SecretVolumeSource::new())
    }

    // optional .k8s.io.api.core.v1.NFSVolumeSource nfs = 7;


    pub fn get_nfs(&self) -> &NFSVolumeSource {
        self.nfs.as_ref().unwrap_or_else(|| <NFSVolumeSource as ::protobuf::Message>::default_instance())
    }
    pub fn clear_nfs(&mut self) {
        self.nfs.clear();
    }

    pub fn has_nfs(&self) -> bool {
        self.nfs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nfs(&mut self, v: NFSVolumeSource) {
        self.nfs = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nfs(&mut self) -> &mut NFSVolumeSource {
        if self.nfs.is_none() {
            self.nfs.set_default();
        }
        self.nfs.as_mut().unwrap()
    }

    // Take field
    pub fn take_nfs(&mut self) -> NFSVolumeSource {
        self.nfs.take().unwrap_or_else(|| NFSVolumeSource::new())
    }

    // optional .k8s.io.api.core.v1.ISCSIVolumeSource iscsi = 8;


    pub fn get_iscsi(&self) -> &ISCSIVolumeSource {
        self.iscsi.as_ref().unwrap_or_else(|| <ISCSIVolumeSource as ::protobuf::Message>::default_instance())
    }
    pub fn clear_iscsi(&mut self) {
        self.iscsi.clear();
    }

    pub fn has_iscsi(&self) -> bool {
        self.iscsi.is_some()
    }

    // Param is passed by value, moved
    pub fn set_iscsi(&mut self, v: ISCSIVolumeSource) {
        self.iscsi = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_iscsi(&mut self) -> &mut ISCSIVolumeSource {
        if self.iscsi.is_none() {
            self.iscsi.set_default();
        }
        self.iscsi.as_mut().unwrap()
    }

    // Take field
    pub fn take_iscsi(&mut self) -> ISCSIVolumeSource {
        self.iscsi.take().unwrap_or_else(|| ISCSIVolumeSource::new())
    }

    // optional .k8s.io.api.core.v1.GlusterfsVolumeSource glusterfs = 9;


    pub fn get_glusterfs(&self) -> &GlusterfsVolumeSource {
        self.glusterfs.as_ref().unwrap_or_else(|| <GlusterfsVolumeSource as ::protobuf::Message>::default_instance())
    }
    pub fn clear_glusterfs(&mut self) {
        self.glusterfs.clear();
    }

    pub fn has_glusterfs(&self) -> bool {
        self.glusterfs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_glusterfs(&mut self, v: GlusterfsVolumeSource) {
        self.glusterfs = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_glusterfs(&mut self) -> &mut GlusterfsVolumeSource {
        if self.glusterfs.is_none() {
            self.glusterfs.set_default();
        }
        self.glusterfs.as_mut().unwrap()
    }

    // Take field
    pub fn take_glusterfs(&mut self) -> GlusterfsVolumeSource {
        self.glusterfs.take().unwrap_or_else(|| GlusterfsVolumeSource::new())
    }

    // optional .k8s.io.api.core.v1.PersistentVolumeClaimVolumeSource persistentVolumeClaim = 10;


    pub fn get_persistentVolumeClaim(&self) -> &PersistentVolumeClaimVolumeSource {
        self.persistentVolumeClaim.as_ref().unwrap_or_else(|| <PersistentVolumeClaimVolumeSource as ::protobuf::Message>::default_instance())
    }
    pub fn clear_persistentVolumeClaim(&mut self) {
        self.persistentVolumeClaim.clear();
    }

    pub fn has_persistentVolumeClaim(&self) -> bool {
        self.persistentVolumeClaim.is_some()
    }

    // Param is passed by value, moved
    pub fn set_persistentVolumeClaim(&mut self, v: PersistentVolumeClaimVolumeSource) {
        self.persistentVolumeClaim = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_persistentVolumeClaim(&mut self) -> &mut PersistentVolumeClaimVolumeSource {
        if self.persistentVolumeClaim.is_none() {
            self.persistentVolumeClaim.set_default();
        }
        self.persistentVolumeClaim.as_mut().unwrap()
    }

    // Take field
    pub fn take_persistentVolumeClaim(&mut self) -> PersistentVolumeClaimVolumeSource {
        self.persistentVolumeClaim.take().unwrap_or_else(|| PersistentVolumeClaimVolumeSource::new())
    }

    // optional .k8s.io.api.core.v1.RBDVolumeSource rbd = 11;


    pub fn get_rbd(&self) -> &RBDVolumeSource {
        self.rbd.as_ref().unwrap_or_else(|| <RBDVolumeSource as ::protobuf::Message>::default_instance())
    }
    pub fn clear_rbd(&mut self) {
        self.rbd.clear();
    }

    pub fn has_rbd(&self) -> bool {
        self.rbd.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rbd(&mut self, v: RBDVolumeSource) {
        self.rbd = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rbd(&mut self) -> &mut RBDVolumeSource {
        if self.rbd.is_none() {
            self.rbd.set_default();
        }
        self.rbd.as_mut().unwrap()
    }

    // Take field
    pub fn take_rbd(&mut self) -> RBDVolumeSource {
        self.rbd.take().unwrap_or_else(|| RBDVolumeSource::new())
    }

    // optional .k8s.io.api.core.v1.FlexVolumeSource flexVolume = 12;


    pub fn get_flexVolume(&self) -> &FlexVolumeSource {
        self.flexVolume.as_ref().unwrap_or_else(|| <FlexVolumeSource as ::protobuf::Message>::default_instance())
    }
    pub fn clear_flexVolume(&mut self) {
        self.flexVolume.clear();
    }

    pub fn has_flexVolume(&self) -> bool {
        self.flexVolume.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flexVolume(&mut self, v: FlexVolumeSource) {
        self.flexVolume = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_flexVolume(&mut self) -> &mut FlexVolumeSource {
        if self.flexVolume.is_none() {
            self.flexVolume.set_default();
        }
        self.flexVolume.as_mut().unwrap()
    }

    // Take field
    pub fn take_flexVolume(&mut self) -> FlexVolumeSource {
        self.flexVolume.take().unwrap_or_else(|| FlexVolumeSource::new())
    }

    // optional .k8s.io.api.core.v1.CinderVolumeSource cinder = 13;


    pub fn get_cinder(&self) -> &CinderVolumeSource {
        self.cinder.as_ref().unwrap_or_else(|| <CinderVolumeSource as ::protobuf::Message>::default_instance())
    }
    pub fn clear_cinder(&mut self) {
        self.cinder.clear();
    }

    pub fn has_cinder(&self) -> bool {
        self.cinder.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cinder(&mut self, v: CinderVolumeSource) {
        self.cinder = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cinder(&mut self) -> &mut CinderVolumeSource {
        if self.cinder.is_none() {
            self.cinder.set_default();
        }
        self.cinder.as_mut().unwrap()
    }

    // Take field
    pub fn take_cinder(&mut self) -> CinderVolumeSource {
        self.cinder.take().unwrap_or_else(|| CinderVolumeSource::new())
    }

    // optional .k8s.io.api.core.v1.CephFSVolumeSource cephfs = 14;


    pub fn get_cephfs(&self) -> &CephFSVolumeSource {
        self.cephfs.as_ref().unwrap_or_else(|| <CephFSVolumeSource as ::protobuf::Message>::default_instance())
    }
    pub fn clear_cephfs(&mut self) {
        self.cephfs.clear();
    }

    pub fn has_cephfs(&self) -> bool {
        self.cephfs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cephfs(&mut self, v: CephFSVolumeSource) {
        self.cephfs = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cephfs(&mut self) -> &mut CephFSVolumeSource {
        if self.cephfs.is_none() {
            self.cephfs.set_default();
        }
        self.cephfs.as_mut().unwrap()
    }

    // Take field
    pub fn take_cephfs(&mut self) -> CephFSVolumeSource {
        self.cephfs.take().unwrap_or_else(|| CephFSVolumeSource::new())
    }

    // optional .k8s.io.api.core.v1.FlockerVolumeSource flocker = 15;


    pub fn get_flocker(&self) -> &FlockerVolumeSource {
        self.flocker.as_ref().unwrap_or_else(|| <FlockerVolumeSource as ::protobuf::Message>::default_instance())
    }
    pub fn clear_flocker(&mut self) {
        self.flocker.clear();
    }

    pub fn has_flocker(&self) -> bool {
        self.flocker.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flocker(&mut self, v: FlockerVolumeSource) {
        self.flocker = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_flocker(&mut self) -> &mut FlockerVolumeSource {
        if self.flocker.is_none() {
            self.flocker.set_default();
        }
        self.flocker.as_mut().unwrap()
    }

    // Take field
    pub fn take_flocker(&mut self) -> FlockerVolumeSource {
        self.flocker.take().unwrap_or_else(|| FlockerVolumeSource::new())
    }

    // optional .k8s.io.api.core.v1.DownwardAPIVolumeSource downwardAPI = 16;


    pub fn get_downwardAPI(&self) -> &DownwardAPIVolumeSource {
        self.downwardAPI.as_ref().unwrap_or_else(|| <DownwardAPIVolumeSource as ::protobuf::Message>::default_instance())
    }
    pub fn clear_downwardAPI(&mut self) {
        self.downwardAPI.clear();
    }

    pub fn has_downwardAPI(&self) -> bool {
        self.downwardAPI.is_some()
    }

    // Param is passed by value, moved
    pub fn set_downwardAPI(&mut self, v: DownwardAPIVolumeSource) {
        self.downwardAPI = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_downwardAPI(&mut self) -> &mut DownwardAPIVolumeSource {
        if self.downwardAPI.is_none() {
            self.downwardAPI.set_default();
        }
        self.downwardAPI.as_mut().unwrap()
    }

    // Take field
    pub fn take_downwardAPI(&mut self) -> DownwardAPIVolumeSource {
        self.downwardAPI.take().unwrap_or_else(|| DownwardAPIVolumeSource::new())
    }

    // optional .k8s.io.api.core.v1.FCVolumeSource fc = 17;


    pub fn get_fc(&self) -> &FCVolumeSource {
        self.fc.as_ref().unwrap_or_else(|| <FCVolumeSource as ::protobuf::Message>::default_instance())
    }
    pub fn clear_fc(&mut self) {
        self.fc.clear();
    }

    pub fn has_fc(&self) -> bool {
        self.fc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fc(&mut self, v: FCVolumeSource) {
        self.fc = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fc(&mut self) -> &mut FCVolumeSource {
        if self.fc.is_none() {
            self.fc.set_default();
        }
        self.fc.as_mut().unwrap()
    }

    // Take field
    pub fn take_fc(&mut self) -> FCVolumeSource {
        self.fc.take().unwrap_or_else(|| FCVolumeSource::new())
    }

    // optional .k8s.io.api.core.v1.AzureFileVolumeSource azureFile = 18;


    pub fn get_azureFile(&self) -> &AzureFileVolumeSource {
        self.azureFile.as_ref().unwrap_or_else(|| <AzureFileVolumeSource as ::protobuf::Message>::default_instance())
    }
    pub fn clear_azureFile(&mut self) {
        self.azureFile.clear();
    }

    pub fn has_azureFile(&self) -> bool {
        self.azureFile.is_some()
    }

    // Param is passed by value, moved
    pub fn set_azureFile(&mut self, v: AzureFileVolumeSource) {
        self.azureFile = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_azureFile(&mut self) -> &mut AzureFileVolumeSource {
        if self.azureFile.is_none() {
            self.azureFile.set_default();
        }
        self.azureFile.as_mut().unwrap()
    }

    // Take field
    pub fn take_azureFile(&mut self) -> AzureFileVolumeSource {
        self.azureFile.take().unwrap_or_else(|| AzureFileVolumeSource::new())
    }

    // optional .k8s.io.api.core.v1.ConfigMapVolumeSource configMap = 19;


    pub fn get_configMap(&self) -> &ConfigMapVolumeSource {
        self.configMap.as_ref().unwrap_or_else(|| <ConfigMapVolumeSource as ::protobuf::Message>::default_instance())
    }
    pub fn clear_configMap(&mut self) {
        self.configMap.clear();
    }

    pub fn has_configMap(&self) -> bool {
        self.configMap.is_some()
    }

    // Param is passed by value, moved
    pub fn set_configMap(&mut self, v: ConfigMapVolumeSource) {
        self.configMap = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_configMap(&mut self) -> &mut ConfigMapVolumeSource {
        if self.configMap.is_none() {
            self.configMap.set_default();
        }
        self.configMap.as_mut().unwrap()
    }

    // Take field
    pub fn take_configMap(&mut self) -> ConfigMapVolumeSource {
        self.configMap.take().unwrap_or_else(|| ConfigMapVolumeSource::new())
    }

    // optional .k8s.io.api.core.v1.VsphereVirtualDiskVolumeSource vsphereVolume = 20;


    pub fn get_vsphereVolume(&self) -> &VsphereVirtualDiskVolumeSource {
        self.vsphereVolume.as_ref().unwrap_or_else(|| <VsphereVirtualDiskVolumeSource as ::protobuf::Message>::default_instance())
    }
    pub fn clear_vsphereVolume(&mut self) {
        self.vsphereVolume.clear();
    }

    pub fn has_vsphereVolume(&self) -> bool {
        self.vsphereVolume.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vsphereVolume(&mut self, v: VsphereVirtualDiskVolumeSource) {
        self.vsphereVolume = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vsphereVolume(&mut self) -> &mut VsphereVirtualDiskVolumeSource {
        if self.vsphereVolume.is_none() {
            self.vsphereVolume.set_default();
        }
        self.vsphereVolume.as_mut().unwrap()
    }

    // Take field
    pub fn take_vsphereVolume(&mut self) -> VsphereVirtualDiskVolumeSource {
        self.vsphereVolume.take().unwrap_or_else(|| VsphereVirtualDiskVolumeSource::new())
    }

    // optional .k8s.io.api.core.v1.QuobyteVolumeSource quobyte = 21;


    pub fn get_quobyte(&self) -> &QuobyteVolumeSource {
        self.quobyte.as_ref().unwrap_or_else(|| <QuobyteVolumeSource as ::protobuf::Message>::default_instance())
    }
    pub fn clear_quobyte(&mut self) {
        self.quobyte.clear();
    }

    pub fn has_quobyte(&self) -> bool {
        self.quobyte.is_some()
    }

    // Param is passed by value, moved
    pub fn set_quobyte(&mut self, v: QuobyteVolumeSource) {
        self.quobyte = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_quobyte(&mut self) -> &mut QuobyteVolumeSource {
        if self.quobyte.is_none() {
            self.quobyte.set_default();
        }
        self.quobyte.as_mut().unwrap()
    }

    // Take field
    pub fn take_quobyte(&mut self) -> QuobyteVolumeSource {
        self.quobyte.take().unwrap_or_else(|| QuobyteVolumeSource::new())
    }

    // optional .k8s.io.api.core.v1.AzureDiskVolumeSource azureDisk = 22;


    pub fn get_azureDisk(&self) -> &AzureDiskVolumeSource {
        self.azureDisk.as_ref().unwrap_or_else(|| <AzureDiskVolumeSource as ::protobuf::Message>::default_instance())
    }
    pub fn clear_azureDisk(&mut self) {
        self.azureDisk.clear();
    }

    pub fn has_azureDisk(&self) -> bool {
        self.azureDisk.is_some()
    }

    // Param is passed by value, moved
    pub fn set_azureDisk(&mut self, v: AzureDiskVolumeSource) {
        self.azureDisk = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_azureDisk(&mut self) -> &mut AzureDiskVolumeSource {
        if self.azureDisk.is_none() {
            self.azureDisk.set_default();
        }
        self.azureDisk.as_mut().unwrap()
    }

    // Take field
    pub fn take_azureDisk(&mut self) -> AzureDiskVolumeSource {
        self.azureDisk.take().unwrap_or_else(|| AzureDiskVolumeSource::new())
    }

    // optional .k8s.io.api.core.v1.PhotonPersistentDiskVolumeSource photonPersistentDisk = 23;


    pub fn get_photonPersistentDisk(&self) -> &PhotonPersistentDiskVolumeSource {
        self.photonPersistentDisk.as_ref().unwrap_or_else(|| <PhotonPersistentDiskVolumeSource as ::protobuf::Message>::default_instance())
    }
    pub fn clear_photonPersistentDisk(&mut self) {
        self.photonPersistentDisk.clear();
    }

    pub fn has_photonPersistentDisk(&self) -> bool {
        self.photonPersistentDisk.is_some()
    }

    // Param is passed by value, moved
    pub fn set_photonPersistentDisk(&mut self, v: PhotonPersistentDiskVolumeSource) {
        self.photonPersistentDisk = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_photonPersistentDisk(&mut self) -> &mut PhotonPersistentDiskVolumeSource {
        if self.photonPersistentDisk.is_none() {
            self.photonPersistentDisk.set_default();
        }
        self.photonPersistentDisk.as_mut().unwrap()
    }

    // Take field
    pub fn take_photonPersistentDisk(&mut self) -> PhotonPersistentDiskVolumeSource {
        self.photonPersistentDisk.take().unwrap_or_else(|| PhotonPersistentDiskVolumeSource::new())
    }

    // optional .k8s.io.api.core.v1.ProjectedVolumeSource projected = 26;


    pub fn get_projected(&self) -> &ProjectedVolumeSource {
        self.projected.as_ref().unwrap_or_else(|| <ProjectedVolumeSource as ::protobuf::Message>::default_instance())
    }
    pub fn clear_projected(&mut self) {
        self.projected.clear();
    }

    pub fn has_projected(&self) -> bool {
        self.projected.is_some()
    }

    // Param is passed by value, moved
    pub fn set_projected(&mut self, v: ProjectedVolumeSource) {
        self.projected = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_projected(&mut self) -> &mut ProjectedVolumeSource {
        if self.projected.is_none() {
            self.projected.set_default();
        }
        self.projected.as_mut().unwrap()
    }

    // Take field
    pub fn take_projected(&mut self) -> ProjectedVolumeSource {
        self.projected.take().unwrap_or_else(|| ProjectedVolumeSource::new())
    }

    // optional .k8s.io.api.core.v1.PortworxVolumeSource portworxVolume = 24;


    pub fn get_portworxVolume(&self) -> &PortworxVolumeSource {
        self.portworxVolume.as_ref().unwrap_or_else(|| <PortworxVolumeSource as ::protobuf::Message>::default_instance())
    }
    pub fn clear_portworxVolume(&mut self) {
        self.portworxVolume.clear();
    }

    pub fn has_portworxVolume(&self) -> bool {
        self.portworxVolume.is_some()
    }

    // Param is passed by value, moved
    pub fn set_portworxVolume(&mut self, v: PortworxVolumeSource) {
        self.portworxVolume = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_portworxVolume(&mut self) -> &mut PortworxVolumeSource {
        if self.portworxVolume.is_none() {
            self.portworxVolume.set_default();
        }
        self.portworxVolume.as_mut().unwrap()
    }

    // Take field
    pub fn take_portworxVolume(&mut self) -> PortworxVolumeSource {
        self.portworxVolume.take().unwrap_or_else(|| PortworxVolumeSource::new())
    }

    // optional .k8s.io.api.core.v1.ScaleIOVolumeSource scaleIO = 25;


    pub fn get_scaleIO(&self) -> &ScaleIOVolumeSource {
        self.scaleIO.as_ref().unwrap_or_else(|| <ScaleIOVolumeSource as ::protobuf::Message>::default_instance())
    }
    pub fn clear_scaleIO(&mut self) {
        self.scaleIO.clear();
    }

    pub fn has_scaleIO(&self) -> bool {
        self.scaleIO.is_some()
    }

    // Param is passed by value, moved
    pub fn set_scaleIO(&mut self, v: ScaleIOVolumeSource) {
        self.scaleIO = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_scaleIO(&mut self) -> &mut ScaleIOVolumeSource {
        if self.scaleIO.is_none() {
            self.scaleIO.set_default();
        }
        self.scaleIO.as_mut().unwrap()
    }

    // Take field
    pub fn take_scaleIO(&mut self) -> ScaleIOVolumeSource {
        self.scaleIO.take().unwrap_or_else(|| ScaleIOVolumeSource::new())
    }

    // optional .k8s.io.api.core.v1.StorageOSVolumeSource storageos = 27;


    pub fn get_storageos(&self) -> &StorageOSVolumeSource {
        self.storageos.as_ref().unwrap_or_else(|| <StorageOSVolumeSource as ::protobuf::Message>::default_instance())
    }
    pub fn clear_storageos(&mut self) {
        self.storageos.clear();
    }

    pub fn has_storageos(&self) -> bool {
        self.storageos.is_some()
    }

    // Param is passed by value, moved
    pub fn set_storageos(&mut self, v: StorageOSVolumeSource) {
        self.storageos = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_storageos(&mut self) -> &mut StorageOSVolumeSource {
        if self.storageos.is_none() {
            self.storageos.set_default();
        }
        self.storageos.as_mut().unwrap()
    }

    // Take field
    pub fn take_storageos(&mut self) -> StorageOSVolumeSource {
        self.storageos.take().unwrap_or_else(|| StorageOSVolumeSource::new())
    }

    // optional .k8s.io.api.core.v1.CSIVolumeSource csi = 28;


    pub fn get_csi(&self) -> &CSIVolumeSource {
        self.csi.as_ref().unwrap_or_else(|| <CSIVolumeSource as ::protobuf::Message>::default_instance())
    }
    pub fn clear_csi(&mut self) {
        self.csi.clear();
    }

    pub fn has_csi(&self) -> bool {
        self.csi.is_some()
    }

    // Param is passed by value, moved
    pub fn set_csi(&mut self, v: CSIVolumeSource) {
        self.csi = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_csi(&mut self) -> &mut CSIVolumeSource {
        if self.csi.is_none() {
            self.csi.set_default();
        }
        self.csi.as_mut().unwrap()
    }

    // Take field
    pub fn take_csi(&mut self) -> CSIVolumeSource {
        self.csi.take().unwrap_or_else(|| CSIVolumeSource::new())
    }

    // optional .k8s.io.api.core.v1.EphemeralVolumeSource ephemeral = 29;


    pub fn get_ephemeral(&self) -> &EphemeralVolumeSource {
        self.ephemeral.as_ref().unwrap_or_else(|| <EphemeralVolumeSource as ::protobuf::Message>::default_instance())
    }
    pub fn clear_ephemeral(&mut self) {
        self.ephemeral.clear();
    }

    pub fn has_ephemeral(&self) -> bool {
        self.ephemeral.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ephemeral(&mut self, v: EphemeralVolumeSource) {
        self.ephemeral = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ephemeral(&mut self) -> &mut EphemeralVolumeSource {
        if self.ephemeral.is_none() {
            self.ephemeral.set_default();
        }
        self.ephemeral.as_mut().unwrap()
    }

    // Take field
    pub fn take_ephemeral(&mut self) -> EphemeralVolumeSource {
        self.ephemeral.take().unwrap_or_else(|| EphemeralVolumeSource::new())
    }
}

impl ::protobuf::Message for VolumeSource {
    fn is_initialized(&self) -> bool {
        for v in &self.hostPath {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.emptyDir {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.gcePersistentDisk {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.awsElasticBlockStore {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.gitRepo {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.secret {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.nfs {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.iscsi {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.glusterfs {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.persistentVolumeClaim {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.rbd {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.flexVolume {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.cinder {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.cephfs {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.flocker {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.downwardAPI {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.fc {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.azureFile {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.configMap {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.vsphereVolume {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.quobyte {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.azureDisk {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.photonPersistentDisk {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.projected {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.portworxVolume {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.scaleIO {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.storageos {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.csi {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ephemeral {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.hostPath)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.emptyDir)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.gcePersistentDisk)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.awsElasticBlockStore)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.gitRepo)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.secret)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.nfs)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.iscsi)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.glusterfs)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.persistentVolumeClaim)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.rbd)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.flexVolume)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.cinder)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.cephfs)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.flocker)?;
                },
                16 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.downwardAPI)?;
                },
                17 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.fc)?;
                },
                18 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.azureFile)?;
                },
                19 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.configMap)?;
                },
                20 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.vsphereVolume)?;
                },
                21 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.quobyte)?;
                },
                22 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.azureDisk)?;
                },
                23 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.photonPersistentDisk)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.projected)?;
                },
                24 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.portworxVolume)?;
                },
                25 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.scaleIO)?;
                },
                27 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.storageos)?;
                },
                28 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.csi)?;
                },
                29 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ephemeral)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.hostPath.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.emptyDir.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.gcePersistentDisk.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.awsElasticBlockStore.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.gitRepo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.secret.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.nfs.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.iscsi.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.glusterfs.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.persistentVolumeClaim.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.rbd.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.flexVolume.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.cinder.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.cephfs.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.flocker.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.downwardAPI.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.fc.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.azureFile.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.configMap.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.vsphereVolume.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.quobyte.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.azureDisk.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.photonPersistentDisk.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.projected.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.portworxVolume.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.scaleIO.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.storageos.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.csi.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.ephemeral.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.hostPath.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.emptyDir.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.gcePersistentDisk.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.awsElasticBlockStore.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.gitRepo.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.secret.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.nfs.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.iscsi.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.glusterfs.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.persistentVolumeClaim.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.rbd.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.flexVolume.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.cinder.as_ref() {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.cephfs.as_ref() {
            os.write_tag(14, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.flocker.as_ref() {
            os.write_tag(15, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.downwardAPI.as_ref() {
            os.write_tag(16, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.fc.as_ref() {
            os.write_tag(17, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.azureFile.as_ref() {
            os.write_tag(18, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.configMap.as_ref() {
            os.write_tag(19, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.vsphereVolume.as_ref() {
            os.write_tag(20, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.quobyte.as_ref() {
            os.write_tag(21, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.azureDisk.as_ref() {
            os.write_tag(22, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.photonPersistentDisk.as_ref() {
            os.write_tag(23, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.projected.as_ref() {
            os.write_tag(26, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.portworxVolume.as_ref() {
            os.write_tag(24, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.scaleIO.as_ref() {
            os.write_tag(25, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.storageos.as_ref() {
            os.write_tag(27, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.csi.as_ref() {
            os.write_tag(28, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.ephemeral.as_ref() {
            os.write_tag(29, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VolumeSource {
        VolumeSource::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<HostPathVolumeSource>>(
                "hostPath",
                |m: &VolumeSource| { &m.hostPath },
                |m: &mut VolumeSource| { &mut m.hostPath },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EmptyDirVolumeSource>>(
                "emptyDir",
                |m: &VolumeSource| { &m.emptyDir },
                |m: &mut VolumeSource| { &mut m.emptyDir },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GCEPersistentDiskVolumeSource>>(
                "gcePersistentDisk",
                |m: &VolumeSource| { &m.gcePersistentDisk },
                |m: &mut VolumeSource| { &mut m.gcePersistentDisk },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AWSElasticBlockStoreVolumeSource>>(
                "awsElasticBlockStore",
                |m: &VolumeSource| { &m.awsElasticBlockStore },
                |m: &mut VolumeSource| { &mut m.awsElasticBlockStore },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GitRepoVolumeSource>>(
                "gitRepo",
                |m: &VolumeSource| { &m.gitRepo },
                |m: &mut VolumeSource| { &mut m.gitRepo },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SecretVolumeSource>>(
                "secret",
                |m: &VolumeSource| { &m.secret },
                |m: &mut VolumeSource| { &mut m.secret },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NFSVolumeSource>>(
                "nfs",
                |m: &VolumeSource| { &m.nfs },
                |m: &mut VolumeSource| { &mut m.nfs },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ISCSIVolumeSource>>(
                "iscsi",
                |m: &VolumeSource| { &m.iscsi },
                |m: &mut VolumeSource| { &mut m.iscsi },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GlusterfsVolumeSource>>(
                "glusterfs",
                |m: &VolumeSource| { &m.glusterfs },
                |m: &mut VolumeSource| { &mut m.glusterfs },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PersistentVolumeClaimVolumeSource>>(
                "persistentVolumeClaim",
                |m: &VolumeSource| { &m.persistentVolumeClaim },
                |m: &mut VolumeSource| { &mut m.persistentVolumeClaim },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RBDVolumeSource>>(
                "rbd",
                |m: &VolumeSource| { &m.rbd },
                |m: &mut VolumeSource| { &mut m.rbd },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FlexVolumeSource>>(
                "flexVolume",
                |m: &VolumeSource| { &m.flexVolume },
                |m: &mut VolumeSource| { &mut m.flexVolume },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CinderVolumeSource>>(
                "cinder",
                |m: &VolumeSource| { &m.cinder },
                |m: &mut VolumeSource| { &mut m.cinder },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CephFSVolumeSource>>(
                "cephfs",
                |m: &VolumeSource| { &m.cephfs },
                |m: &mut VolumeSource| { &mut m.cephfs },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FlockerVolumeSource>>(
                "flocker",
                |m: &VolumeSource| { &m.flocker },
                |m: &mut VolumeSource| { &mut m.flocker },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DownwardAPIVolumeSource>>(
                "downwardAPI",
                |m: &VolumeSource| { &m.downwardAPI },
                |m: &mut VolumeSource| { &mut m.downwardAPI },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FCVolumeSource>>(
                "fc",
                |m: &VolumeSource| { &m.fc },
                |m: &mut VolumeSource| { &mut m.fc },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AzureFileVolumeSource>>(
                "azureFile",
                |m: &VolumeSource| { &m.azureFile },
                |m: &mut VolumeSource| { &mut m.azureFile },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ConfigMapVolumeSource>>(
                "configMap",
                |m: &VolumeSource| { &m.configMap },
                |m: &mut VolumeSource| { &mut m.configMap },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<VsphereVirtualDiskVolumeSource>>(
                "vsphereVolume",
                |m: &VolumeSource| { &m.vsphereVolume },
                |m: &mut VolumeSource| { &mut m.vsphereVolume },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<QuobyteVolumeSource>>(
                "quobyte",
                |m: &VolumeSource| { &m.quobyte },
                |m: &mut VolumeSource| { &mut m.quobyte },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AzureDiskVolumeSource>>(
                "azureDisk",
                |m: &VolumeSource| { &m.azureDisk },
                |m: &mut VolumeSource| { &mut m.azureDisk },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PhotonPersistentDiskVolumeSource>>(
                "photonPersistentDisk",
                |m: &VolumeSource| { &m.photonPersistentDisk },
                |m: &mut VolumeSource| { &mut m.photonPersistentDisk },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ProjectedVolumeSource>>(
                "projected",
                |m: &VolumeSource| { &m.projected },
                |m: &mut VolumeSource| { &mut m.projected },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PortworxVolumeSource>>(
                "portworxVolume",
                |m: &VolumeSource| { &m.portworxVolume },
                |m: &mut VolumeSource| { &mut m.portworxVolume },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ScaleIOVolumeSource>>(
                "scaleIO",
                |m: &VolumeSource| { &m.scaleIO },
                |m: &mut VolumeSource| { &mut m.scaleIO },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StorageOSVolumeSource>>(
                "storageos",
                |m: &VolumeSource| { &m.storageos },
                |m: &mut VolumeSource| { &mut m.storageos },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CSIVolumeSource>>(
                "csi",
                |m: &VolumeSource| { &m.csi },
                |m: &mut VolumeSource| { &mut m.csi },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EphemeralVolumeSource>>(
                "ephemeral",
                |m: &VolumeSource| { &m.ephemeral },
                |m: &mut VolumeSource| { &mut m.ephemeral },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VolumeSource>(
                "VolumeSource",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VolumeSource {
        static instance: ::protobuf::rt::LazyV2<VolumeSource> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VolumeSource::new)
    }
}

impl ::protobuf::Clear for VolumeSource {
    fn clear(&mut self) {
        self.hostPath.clear();
        self.emptyDir.clear();
        self.gcePersistentDisk.clear();
        self.awsElasticBlockStore.clear();
        self.gitRepo.clear();
        self.secret.clear();
        self.nfs.clear();
        self.iscsi.clear();
        self.glusterfs.clear();
        self.persistentVolumeClaim.clear();
        self.rbd.clear();
        self.flexVolume.clear();
        self.cinder.clear();
        self.cephfs.clear();
        self.flocker.clear();
        self.downwardAPI.clear();
        self.fc.clear();
        self.azureFile.clear();
        self.configMap.clear();
        self.vsphereVolume.clear();
        self.quobyte.clear();
        self.azureDisk.clear();
        self.photonPersistentDisk.clear();
        self.projected.clear();
        self.portworxVolume.clear();
        self.scaleIO.clear();
        self.storageos.clear();
        self.csi.clear();
        self.ephemeral.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VolumeSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VolumeSource {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VsphereVirtualDiskVolumeSource {
    // message fields
    volumePath: ::protobuf::SingularField<::std::string::String>,
    fsType: ::protobuf::SingularField<::std::string::String>,
    storagePolicyName: ::protobuf::SingularField<::std::string::String>,
    storagePolicyID: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VsphereVirtualDiskVolumeSource {
    fn default() -> &'a VsphereVirtualDiskVolumeSource {
        <VsphereVirtualDiskVolumeSource as ::protobuf::Message>::default_instance()
    }
}

impl VsphereVirtualDiskVolumeSource {
    pub fn new() -> VsphereVirtualDiskVolumeSource {
        ::std::default::Default::default()
    }

    // optional string volumePath = 1;


    pub fn get_volumePath(&self) -> &str {
        match self.volumePath.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_volumePath(&mut self) {
        self.volumePath.clear();
    }

    pub fn has_volumePath(&self) -> bool {
        self.volumePath.is_some()
    }

    // Param is passed by value, moved
    pub fn set_volumePath(&mut self, v: ::std::string::String) {
        self.volumePath = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_volumePath(&mut self) -> &mut ::std::string::String {
        if self.volumePath.is_none() {
            self.volumePath.set_default();
        }
        self.volumePath.as_mut().unwrap()
    }

    // Take field
    pub fn take_volumePath(&mut self) -> ::std::string::String {
        self.volumePath.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string fsType = 2;


    pub fn get_fsType(&self) -> &str {
        match self.fsType.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_fsType(&mut self) {
        self.fsType.clear();
    }

    pub fn has_fsType(&self) -> bool {
        self.fsType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fsType(&mut self, v: ::std::string::String) {
        self.fsType = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fsType(&mut self) -> &mut ::std::string::String {
        if self.fsType.is_none() {
            self.fsType.set_default();
        }
        self.fsType.as_mut().unwrap()
    }

    // Take field
    pub fn take_fsType(&mut self) -> ::std::string::String {
        self.fsType.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string storagePolicyName = 3;


    pub fn get_storagePolicyName(&self) -> &str {
        match self.storagePolicyName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_storagePolicyName(&mut self) {
        self.storagePolicyName.clear();
    }

    pub fn has_storagePolicyName(&self) -> bool {
        self.storagePolicyName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_storagePolicyName(&mut self, v: ::std::string::String) {
        self.storagePolicyName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_storagePolicyName(&mut self) -> &mut ::std::string::String {
        if self.storagePolicyName.is_none() {
            self.storagePolicyName.set_default();
        }
        self.storagePolicyName.as_mut().unwrap()
    }

    // Take field
    pub fn take_storagePolicyName(&mut self) -> ::std::string::String {
        self.storagePolicyName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string storagePolicyID = 4;


    pub fn get_storagePolicyID(&self) -> &str {
        match self.storagePolicyID.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_storagePolicyID(&mut self) {
        self.storagePolicyID.clear();
    }

    pub fn has_storagePolicyID(&self) -> bool {
        self.storagePolicyID.is_some()
    }

    // Param is passed by value, moved
    pub fn set_storagePolicyID(&mut self, v: ::std::string::String) {
        self.storagePolicyID = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_storagePolicyID(&mut self) -> &mut ::std::string::String {
        if self.storagePolicyID.is_none() {
            self.storagePolicyID.set_default();
        }
        self.storagePolicyID.as_mut().unwrap()
    }

    // Take field
    pub fn take_storagePolicyID(&mut self) -> ::std::string::String {
        self.storagePolicyID.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for VsphereVirtualDiskVolumeSource {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.volumePath)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.fsType)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.storagePolicyName)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.storagePolicyID)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.volumePath.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.fsType.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.storagePolicyName.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.storagePolicyID.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.volumePath.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.fsType.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.storagePolicyName.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.storagePolicyID.as_ref() {
            os.write_string(4, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VsphereVirtualDiskVolumeSource {
        VsphereVirtualDiskVolumeSource::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "volumePath",
                |m: &VsphereVirtualDiskVolumeSource| { &m.volumePath },
                |m: &mut VsphereVirtualDiskVolumeSource| { &mut m.volumePath },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "fsType",
                |m: &VsphereVirtualDiskVolumeSource| { &m.fsType },
                |m: &mut VsphereVirtualDiskVolumeSource| { &mut m.fsType },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "storagePolicyName",
                |m: &VsphereVirtualDiskVolumeSource| { &m.storagePolicyName },
                |m: &mut VsphereVirtualDiskVolumeSource| { &mut m.storagePolicyName },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "storagePolicyID",
                |m: &VsphereVirtualDiskVolumeSource| { &m.storagePolicyID },
                |m: &mut VsphereVirtualDiskVolumeSource| { &mut m.storagePolicyID },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VsphereVirtualDiskVolumeSource>(
                "VsphereVirtualDiskVolumeSource",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VsphereVirtualDiskVolumeSource {
        static instance: ::protobuf::rt::LazyV2<VsphereVirtualDiskVolumeSource> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VsphereVirtualDiskVolumeSource::new)
    }
}

impl ::protobuf::Clear for VsphereVirtualDiskVolumeSource {
    fn clear(&mut self) {
        self.volumePath.clear();
        self.fsType.clear();
        self.storagePolicyName.clear();
        self.storagePolicyID.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VsphereVirtualDiskVolumeSource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VsphereVirtualDiskVolumeSource {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WeightedPodAffinityTerm {
    // message fields
    weight: ::std::option::Option<i32>,
    pub podAffinityTerm: ::protobuf::SingularPtrField<PodAffinityTerm>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WeightedPodAffinityTerm {
    fn default() -> &'a WeightedPodAffinityTerm {
        <WeightedPodAffinityTerm as ::protobuf::Message>::default_instance()
    }
}

impl WeightedPodAffinityTerm {
    pub fn new() -> WeightedPodAffinityTerm {
        ::std::default::Default::default()
    }

    // optional int32 weight = 1;


    pub fn get_weight(&self) -> i32 {
        self.weight.unwrap_or(0)
    }
    pub fn clear_weight(&mut self) {
        self.weight = ::std::option::Option::None;
    }

    pub fn has_weight(&self) -> bool {
        self.weight.is_some()
    }

    // Param is passed by value, moved
    pub fn set_weight(&mut self, v: i32) {
        self.weight = ::std::option::Option::Some(v);
    }

    // optional .k8s.io.api.core.v1.PodAffinityTerm podAffinityTerm = 2;


    pub fn get_podAffinityTerm(&self) -> &PodAffinityTerm {
        self.podAffinityTerm.as_ref().unwrap_or_else(|| <PodAffinityTerm as ::protobuf::Message>::default_instance())
    }
    pub fn clear_podAffinityTerm(&mut self) {
        self.podAffinityTerm.clear();
    }

    pub fn has_podAffinityTerm(&self) -> bool {
        self.podAffinityTerm.is_some()
    }

    // Param is passed by value, moved
    pub fn set_podAffinityTerm(&mut self, v: PodAffinityTerm) {
        self.podAffinityTerm = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_podAffinityTerm(&mut self) -> &mut PodAffinityTerm {
        if self.podAffinityTerm.is_none() {
            self.podAffinityTerm.set_default();
        }
        self.podAffinityTerm.as_mut().unwrap()
    }

    // Take field
    pub fn take_podAffinityTerm(&mut self) -> PodAffinityTerm {
        self.podAffinityTerm.take().unwrap_or_else(|| PodAffinityTerm::new())
    }
}

impl ::protobuf::Message for WeightedPodAffinityTerm {
    fn is_initialized(&self) -> bool {
        for v in &self.podAffinityTerm {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.weight = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.podAffinityTerm)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.weight {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.podAffinityTerm.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.weight {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.podAffinityTerm.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WeightedPodAffinityTerm {
        WeightedPodAffinityTerm::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "weight",
                |m: &WeightedPodAffinityTerm| { &m.weight },
                |m: &mut WeightedPodAffinityTerm| { &mut m.weight },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PodAffinityTerm>>(
                "podAffinityTerm",
                |m: &WeightedPodAffinityTerm| { &m.podAffinityTerm },
                |m: &mut WeightedPodAffinityTerm| { &mut m.podAffinityTerm },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<WeightedPodAffinityTerm>(
                "WeightedPodAffinityTerm",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static WeightedPodAffinityTerm {
        static instance: ::protobuf::rt::LazyV2<WeightedPodAffinityTerm> = ::protobuf::rt::LazyV2::INIT;
        instance.get(WeightedPodAffinityTerm::new)
    }
}

impl ::protobuf::Clear for WeightedPodAffinityTerm {
    fn clear(&mut self) {
        self.weight = ::std::option::Option::None;
        self.podAffinityTerm.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WeightedPodAffinityTerm {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WeightedPodAffinityTerm {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WindowsSecurityContextOptions {
    // message fields
    gmsaCredentialSpecName: ::protobuf::SingularField<::std::string::String>,
    gmsaCredentialSpec: ::protobuf::SingularField<::std::string::String>,
    runAsUserName: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WindowsSecurityContextOptions {
    fn default() -> &'a WindowsSecurityContextOptions {
        <WindowsSecurityContextOptions as ::protobuf::Message>::default_instance()
    }
}

impl WindowsSecurityContextOptions {
    pub fn new() -> WindowsSecurityContextOptions {
        ::std::default::Default::default()
    }

    // optional string gmsaCredentialSpecName = 1;


    pub fn get_gmsaCredentialSpecName(&self) -> &str {
        match self.gmsaCredentialSpecName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_gmsaCredentialSpecName(&mut self) {
        self.gmsaCredentialSpecName.clear();
    }

    pub fn has_gmsaCredentialSpecName(&self) -> bool {
        self.gmsaCredentialSpecName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gmsaCredentialSpecName(&mut self, v: ::std::string::String) {
        self.gmsaCredentialSpecName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gmsaCredentialSpecName(&mut self) -> &mut ::std::string::String {
        if self.gmsaCredentialSpecName.is_none() {
            self.gmsaCredentialSpecName.set_default();
        }
        self.gmsaCredentialSpecName.as_mut().unwrap()
    }

    // Take field
    pub fn take_gmsaCredentialSpecName(&mut self) -> ::std::string::String {
        self.gmsaCredentialSpecName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string gmsaCredentialSpec = 2;


    pub fn get_gmsaCredentialSpec(&self) -> &str {
        match self.gmsaCredentialSpec.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_gmsaCredentialSpec(&mut self) {
        self.gmsaCredentialSpec.clear();
    }

    pub fn has_gmsaCredentialSpec(&self) -> bool {
        self.gmsaCredentialSpec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gmsaCredentialSpec(&mut self, v: ::std::string::String) {
        self.gmsaCredentialSpec = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gmsaCredentialSpec(&mut self) -> &mut ::std::string::String {
        if self.gmsaCredentialSpec.is_none() {
            self.gmsaCredentialSpec.set_default();
        }
        self.gmsaCredentialSpec.as_mut().unwrap()
    }

    // Take field
    pub fn take_gmsaCredentialSpec(&mut self) -> ::std::string::String {
        self.gmsaCredentialSpec.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string runAsUserName = 3;


    pub fn get_runAsUserName(&self) -> &str {
        match self.runAsUserName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_runAsUserName(&mut self) {
        self.runAsUserName.clear();
    }

    pub fn has_runAsUserName(&self) -> bool {
        self.runAsUserName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_runAsUserName(&mut self, v: ::std::string::String) {
        self.runAsUserName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_runAsUserName(&mut self) -> &mut ::std::string::String {
        if self.runAsUserName.is_none() {
            self.runAsUserName.set_default();
        }
        self.runAsUserName.as_mut().unwrap()
    }

    // Take field
    pub fn take_runAsUserName(&mut self) -> ::std::string::String {
        self.runAsUserName.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for WindowsSecurityContextOptions {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.gmsaCredentialSpecName)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.gmsaCredentialSpec)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.runAsUserName)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.gmsaCredentialSpecName.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.gmsaCredentialSpec.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.runAsUserName.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.gmsaCredentialSpecName.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.gmsaCredentialSpec.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.runAsUserName.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WindowsSecurityContextOptions {
        WindowsSecurityContextOptions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "gmsaCredentialSpecName",
                |m: &WindowsSecurityContextOptions| { &m.gmsaCredentialSpecName },
                |m: &mut WindowsSecurityContextOptions| { &mut m.gmsaCredentialSpecName },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "gmsaCredentialSpec",
                |m: &WindowsSecurityContextOptions| { &m.gmsaCredentialSpec },
                |m: &mut WindowsSecurityContextOptions| { &mut m.gmsaCredentialSpec },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "runAsUserName",
                |m: &WindowsSecurityContextOptions| { &m.runAsUserName },
                |m: &mut WindowsSecurityContextOptions| { &mut m.runAsUserName },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<WindowsSecurityContextOptions>(
                "WindowsSecurityContextOptions",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static WindowsSecurityContextOptions {
        static instance: ::protobuf::rt::LazyV2<WindowsSecurityContextOptions> = ::protobuf::rt::LazyV2::INIT;
        instance.get(WindowsSecurityContextOptions::new)
    }
}

impl ::protobuf::Clear for WindowsSecurityContextOptions {
    fn clear(&mut self) {
        self.gmsaCredentialSpecName.clear();
        self.gmsaCredentialSpec.clear();
        self.runAsUserName.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WindowsSecurityContextOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WindowsSecurityContextOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\"k8s.io_api_core_v1_generated.proto\x12\x12k8s.io.api.core.v1\x1a4k8s\
    .io_apimachinery_pkg_api_resource_generated.proto\x1a4k8s.io_apimachiner\
    y_pkg_apis_meta_v1_generated.proto\x1a/k8s.io_apimachinery_pkg_runtime_g\
    enerated.proto\x1a6k8s.io_apimachinery_pkg_runtime_schema_generated.prot\
    o\x1a3k8s.io_apimachinery_pkg_util_intstr_generated.proto\"\x90\x01\n\
    \x20AWSElasticBlockStoreVolumeSource\x12\x1a\n\x08volumeID\x18\x01\x20\
    \x01(\tR\x08volumeID\x12\x16\n\x06fsType\x18\x02\x20\x01(\tR\x06fsType\
    \x12\x1c\n\tpartition\x18\x03\x20\x01(\x05R\tpartition\x12\x1a\n\x08read\
    Only\x18\x04\x20\x01(\x08R\x08readOnly\"\xe2\x01\n\x08Affinity\x12D\n\
    \x0cnodeAffinity\x18\x01\x20\x01(\x0b2\x20.k8s.io.api.core.v1.NodeAffini\
    tyR\x0cnodeAffinity\x12A\n\x0bpodAffinity\x18\x02\x20\x01(\x0b2\x1f.k8s.\
    io.api.core.v1.PodAffinityR\x0bpodAffinity\x12M\n\x0fpodAntiAffinity\x18\
    \x03\x20\x01(\x0b2#.k8s.io.api.core.v1.PodAntiAffinityR\x0fpodAntiAffini\
    ty\"D\n\x0eAttachedVolume\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\
    \x12\x1e\n\ndevicePath\x18\x02\x20\x01(\tR\ndevicePath\"_\n\tAvoidPods\
    \x12R\n\x0fpreferAvoidPods\x18\x01\x20\x03(\x0b2(.k8s.io.api.core.v1.Pre\
    ferAvoidPodsEntryR\x0fpreferAvoidPods\"\xb7\x01\n\x15AzureDiskVolumeSour\
    ce\x12\x1a\n\x08diskName\x18\x01\x20\x01(\tR\x08diskName\x12\x18\n\x07di\
    skURI\x18\x02\x20\x01(\tR\x07diskURI\x12\x20\n\x0bcachingMode\x18\x03\
    \x20\x01(\tR\x0bcachingMode\x12\x16\n\x06fsType\x18\x04\x20\x01(\tR\x06f\
    sType\x12\x1a\n\x08readOnly\x18\x05\x20\x01(\x08R\x08readOnly\x12\x12\n\
    \x04kind\x18\x06\x20\x01(\tR\x04kind\"\xa5\x01\n\x1fAzureFilePersistentV\
    olumeSource\x12\x1e\n\nsecretName\x18\x01\x20\x01(\tR\nsecretName\x12\
    \x1c\n\tshareName\x18\x02\x20\x01(\tR\tshareName\x12\x1a\n\x08readOnly\
    \x18\x03\x20\x01(\x08R\x08readOnly\x12(\n\x0fsecretNamespace\x18\x04\x20\
    \x01(\tR\x0fsecretNamespace\"q\n\x15AzureFileVolumeSource\x12\x1e\n\nsec\
    retName\x18\x01\x20\x01(\tR\nsecretName\x12\x1c\n\tshareName\x18\x02\x20\
    \x01(\tR\tshareName\x12\x1a\n\x08readOnly\x18\x03\x20\x01(\x08R\x08readO\
    nly\"\x94\x01\n\x07Binding\x12L\n\x08metadata\x18\x01\x20\x01(\x0b20.k8s\
    .io.apimachinery.pkg.apis.meta.v1.ObjectMetaR\x08metadata\x12;\n\x06targ\
    et\x18\x02\x20\x01(\x0b2#.k8s.io.api.core.v1.ObjectReferenceR\x06target\
    \"\xb7\x05\n\x19CSIPersistentVolumeSource\x12\x16\n\x06driver\x18\x01\
    \x20\x01(\tR\x06driver\x12\"\n\x0cvolumeHandle\x18\x02\x20\x01(\tR\x0cvo\
    lumeHandle\x12\x1a\n\x08readOnly\x18\x03\x20\x01(\x08R\x08readOnly\x12\
    \x16\n\x06fsType\x18\x04\x20\x01(\tR\x06fsType\x12o\n\x10volumeAttribute\
    s\x18\x05\x20\x03(\x0b2C.k8s.io.api.core.v1.CSIPersistentVolumeSource.Vo\
    lumeAttributesEntryR\x10volumeAttributes\x12c\n\x1acontrollerPublishSecr\
    etRef\x18\x06\x20\x01(\x0b2#.k8s.io.api.core.v1.SecretReferenceR\x1acont\
    rollerPublishSecretRef\x12S\n\x12nodeStageSecretRef\x18\x07\x20\x01(\x0b\
    2#.k8s.io.api.core.v1.SecretReferenceR\x12nodeStageSecretRef\x12W\n\x14n\
    odePublishSecretRef\x18\x08\x20\x01(\x0b2#.k8s.io.api.core.v1.SecretRefe\
    renceR\x14nodePublishSecretRef\x12a\n\x19controllerExpandSecretRef\x18\t\
    \x20\x01(\x0b2#.k8s.io.api.core.v1.SecretReferenceR\x19controllerExpandS\
    ecretRef\x1aC\n\x15VolumeAttributesEntry\x12\x10\n\x03key\x18\x01\x20\
    \x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\
    \x01\"\xe7\x02\n\x0fCSIVolumeSource\x12\x16\n\x06driver\x18\x01\x20\x01(\
    \tR\x06driver\x12\x1a\n\x08readOnly\x18\x02\x20\x01(\x08R\x08readOnly\
    \x12\x16\n\x06fsType\x18\x03\x20\x01(\tR\x06fsType\x12e\n\x10volumeAttri\
    butes\x18\x04\x20\x03(\x0b29.k8s.io.api.core.v1.CSIVolumeSource.VolumeAt\
    tributesEntryR\x10volumeAttributes\x12\\\n\x14nodePublishSecretRef\x18\
    \x05\x20\x01(\x0b2(.k8s.io.api.core.v1.LocalObjectReferenceR\x14nodePubl\
    ishSecretRef\x1aC\n\x15VolumeAttributesEntry\x12\x10\n\x03key\x18\x01\
    \x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x02\
    8\x01\"4\n\x0cCapabilities\x12\x10\n\x03add\x18\x01\x20\x03(\tR\x03add\
    \x12\x12\n\x04drop\x18\x02\x20\x03(\tR\x04drop\"\xe1\x01\n\x1cCephFSPers\
    istentVolumeSource\x12\x1a\n\x08monitors\x18\x01\x20\x03(\tR\x08monitors\
    \x12\x12\n\x04path\x18\x02\x20\x01(\tR\x04path\x12\x12\n\x04user\x18\x03\
    \x20\x01(\tR\x04user\x12\x1e\n\nsecretFile\x18\x04\x20\x01(\tR\nsecretFi\
    le\x12A\n\tsecretRef\x18\x05\x20\x01(\x0b2#.k8s.io.api.core.v1.SecretRef\
    erenceR\tsecretRef\x12\x1a\n\x08readOnly\x18\x06\x20\x01(\x08R\x08readOn\
    ly\"\xdc\x01\n\x12CephFSVolumeSource\x12\x1a\n\x08monitors\x18\x01\x20\
    \x03(\tR\x08monitors\x12\x12\n\x04path\x18\x02\x20\x01(\tR\x04path\x12\
    \x12\n\x04user\x18\x03\x20\x01(\tR\x04user\x12\x1e\n\nsecretFile\x18\x04\
    \x20\x01(\tR\nsecretFile\x12F\n\tsecretRef\x18\x05\x20\x01(\x0b2(.k8s.io\
    .api.core.v1.LocalObjectReferenceR\tsecretRef\x12\x1a\n\x08readOnly\x18\
    \x06\x20\x01(\x08R\x08readOnly\"\xb1\x01\n\x1cCinderPersistentVolumeSour\
    ce\x12\x1a\n\x08volumeID\x18\x01\x20\x01(\tR\x08volumeID\x12\x16\n\x06fs\
    Type\x18\x02\x20\x01(\tR\x06fsType\x12\x1a\n\x08readOnly\x18\x03\x20\x01\
    (\x08R\x08readOnly\x12A\n\tsecretRef\x18\x04\x20\x01(\x0b2#.k8s.io.api.c\
    ore.v1.SecretReferenceR\tsecretRef\"\xac\x01\n\x12CinderVolumeSource\x12\
    \x1a\n\x08volumeID\x18\x01\x20\x01(\tR\x08volumeID\x12\x16\n\x06fsType\
    \x18\x02\x20\x01(\tR\x06fsType\x12\x1a\n\x08readOnly\x18\x03\x20\x01(\
    \x08R\x08readOnly\x12F\n\tsecretRef\x18\x04\x20\x01(\x0b2(.k8s.io.api.co\
    re.v1.LocalObjectReferenceR\tsecretRef\"8\n\x0eClientIPConfig\x12&\n\x0e\
    timeoutSeconds\x18\x01\x20\x01(\x05R\x0etimeoutSeconds\"p\n\x12Component\
    Condition\x12\x12\n\x04type\x18\x01\x20\x01(\tR\x04type\x12\x16\n\x06sta\
    tus\x18\x02\x20\x01(\tR\x06status\x12\x18\n\x07message\x18\x03\x20\x01(\
    \tR\x07message\x12\x14\n\x05error\x18\x04\x20\x01(\tR\x05error\"\xa7\x01\
    \n\x0fComponentStatus\x12L\n\x08metadata\x18\x01\x20\x01(\x0b20.k8s.io.a\
    pimachinery.pkg.apis.meta.v1.ObjectMetaR\x08metadata\x12F\n\nconditions\
    \x18\x02\x20\x03(\x0b2&.k8s.io.api.core.v1.ComponentConditionR\nconditio\
    ns\"\x9c\x01\n\x13ComponentStatusList\x12J\n\x08metadata\x18\x01\x20\x01\
    (\x0b2..k8s.io.apimachinery.pkg.apis.meta.v1.ListMetaR\x08metadata\x129\
    \n\x05items\x18\x02\x20\x03(\x0b2#.k8s.io.api.core.v1.ComponentStatusR\
    \x05items\"\xfb\x02\n\tConfigMap\x12L\n\x08metadata\x18\x01\x20\x01(\x0b\
    20.k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMetaR\x08metadata\x12\x1c\
    \n\timmutable\x18\x04\x20\x01(\x08R\timmutable\x12;\n\x04data\x18\x02\
    \x20\x03(\x0b2'.k8s.io.api.core.v1.ConfigMap.DataEntryR\x04data\x12M\n\n\
    binaryData\x18\x03\x20\x03(\x0b2-.k8s.io.api.core.v1.ConfigMap.BinaryDat\
    aEntryR\nbinaryData\x1a7\n\tDataEntry\x12\x10\n\x03key\x18\x01\x20\x01(\
    \tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\x1a\
    =\n\x0fBinaryDataEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\
    \x14\n\x05value\x18\x02\x20\x01(\x0cR\x05value:\x028\x01\"\x8e\x01\n\x12\
    ConfigMapEnvSource\x12\\\n\x14localObjectReference\x18\x01\x20\x01(\x0b2\
    (.k8s.io.api.core.v1.LocalObjectReferenceR\x14localObjectReference\x12\
    \x1a\n\x08optional\x18\x02\x20\x01(\x08R\x08optional\"\xa2\x01\n\x14Conf\
    igMapKeySelector\x12\\\n\x14localObjectReference\x18\x01\x20\x01(\x0b2(.\
    k8s.io.api.core.v1.LocalObjectReferenceR\x14localObjectReference\x12\x10\
    \n\x03key\x18\x02\x20\x01(\tR\x03key\x12\x1a\n\x08optional\x18\x03\x20\
    \x01(\x08R\x08optional\"\x90\x01\n\rConfigMapList\x12J\n\x08metadata\x18\
    \x01\x20\x01(\x0b2..k8s.io.apimachinery.pkg.apis.meta.v1.ListMetaR\x08me\
    tadata\x123\n\x05items\x18\x02\x20\x03(\x0b2\x1d.k8s.io.api.core.v1.Conf\
    igMapR\x05items\"\xb5\x01\n\x19ConfigMapNodeConfigSource\x12\x1c\n\tname\
    space\x18\x01\x20\x01(\tR\tnamespace\x12\x12\n\x04name\x18\x02\x20\x01(\
    \tR\x04name\x12\x10\n\x03uid\x18\x03\x20\x01(\tR\x03uid\x12(\n\x0fresour\
    ceVersion\x18\x04\x20\x01(\tR\x0fresourceVersion\x12*\n\x10kubeletConfig\
    Key\x18\x05\x20\x01(\tR\x10kubeletConfigKey\"\xc4\x01\n\x13ConfigMapProj\
    ection\x12\\\n\x14localObjectReference\x18\x01\x20\x01(\x0b2(.k8s.io.api\
    .core.v1.LocalObjectReferenceR\x14localObjectReference\x123\n\x05items\
    \x18\x02\x20\x03(\x0b2\x1d.k8s.io.api.core.v1.KeyToPathR\x05items\x12\
    \x1a\n\x08optional\x18\x04\x20\x01(\x08R\x08optional\"\xe8\x01\n\x15Conf\
    igMapVolumeSource\x12\\\n\x14localObjectReference\x18\x01\x20\x01(\x0b2(\
    .k8s.io.api.core.v1.LocalObjectReferenceR\x14localObjectReference\x123\n\
    \x05items\x18\x02\x20\x03(\x0b2\x1d.k8s.io.api.core.v1.KeyToPathR\x05ite\
    ms\x12\x20\n\x0bdefaultMode\x18\x03\x20\x01(\x05R\x0bdefaultMode\x12\x1a\
    \n\x08optional\x18\x04\x20\x01(\x08R\x08optional\"\xaf\x08\n\tContainer\
    \x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\x14\n\x05image\x18\
    \x02\x20\x01(\tR\x05image\x12\x18\n\x07command\x18\x03\x20\x03(\tR\x07co\
    mmand\x12\x12\n\x04args\x18\x04\x20\x03(\tR\x04args\x12\x1e\n\nworkingDi\
    r\x18\x05\x20\x01(\tR\nworkingDir\x127\n\x05ports\x18\x06\x20\x03(\x0b2!\
    .k8s.io.api.core.v1.ContainerPortR\x05ports\x12;\n\x07envFrom\x18\x13\
    \x20\x03(\x0b2!.k8s.io.api.core.v1.EnvFromSourceR\x07envFrom\x12,\n\x03e\
    nv\x18\x07\x20\x03(\x0b2\x1a.k8s.io.api.core.v1.EnvVarR\x03env\x12F\n\tr\
    esources\x18\x08\x20\x01(\x0b2(.k8s.io.api.core.v1.ResourceRequirementsR\
    \tresources\x12C\n\x0cvolumeMounts\x18\t\x20\x03(\x0b2\x1f.k8s.io.api.co\
    re.v1.VolumeMountR\x0cvolumeMounts\x12F\n\rvolumeDevices\x18\x15\x20\x03\
    (\x0b2\x20.k8s.io.api.core.v1.VolumeDeviceR\rvolumeDevices\x12?\n\rliven\
    essProbe\x18\n\x20\x01(\x0b2\x19.k8s.io.api.core.v1.ProbeR\rlivenessProb\
    e\x12A\n\x0ereadinessProbe\x18\x0b\x20\x01(\x0b2\x19.k8s.io.api.core.v1.\
    ProbeR\x0ereadinessProbe\x12=\n\x0cstartupProbe\x18\x16\x20\x01(\x0b2\
    \x19.k8s.io.api.core.v1.ProbeR\x0cstartupProbe\x12;\n\tlifecycle\x18\x0c\
    \x20\x01(\x0b2\x1d.k8s.io.api.core.v1.LifecycleR\tlifecycle\x126\n\x16te\
    rminationMessagePath\x18\r\x20\x01(\tR\x16terminationMessagePath\x12:\n\
    \x18terminationMessagePolicy\x18\x14\x20\x01(\tR\x18terminationMessagePo\
    licy\x12(\n\x0fimagePullPolicy\x18\x0e\x20\x01(\tR\x0fimagePullPolicy\
    \x12M\n\x0fsecurityContext\x18\x0f\x20\x01(\x0b2#.k8s.io.api.core.v1.Sec\
    urityContextR\x0fsecurityContext\x12\x14\n\x05stdin\x18\x10\x20\x01(\x08\
    R\x05stdin\x12\x1c\n\tstdinOnce\x18\x11\x20\x01(\x08R\tstdinOnce\x12\x10\
    \n\x03tty\x18\x12\x20\x01(\x08R\x03tty\"D\n\x0eContainerImage\x12\x14\n\
    \x05names\x18\x01\x20\x03(\tR\x05names\x12\x1c\n\tsizeBytes\x18\x02\x20\
    \x01(\x03R\tsizeBytes\"\x99\x01\n\rContainerPort\x12\x12\n\x04name\x18\
    \x01\x20\x01(\tR\x04name\x12\x1a\n\x08hostPort\x18\x02\x20\x01(\x05R\x08\
    hostPort\x12$\n\rcontainerPort\x18\x03\x20\x01(\x05R\rcontainerPort\x12\
    \x1a\n\x08protocol\x18\x04\x20\x01(\tR\x08protocol\x12\x16\n\x06hostIP\
    \x18\x05\x20\x01(\tR\x06hostIP\"\xe8\x01\n\x0eContainerState\x12C\n\x07w\
    aiting\x18\x01\x20\x01(\x0b2).k8s.io.api.core.v1.ContainerStateWaitingR\
    \x07waiting\x12C\n\x07running\x18\x02\x20\x01(\x0b2).k8s.io.api.core.v1.\
    ContainerStateRunningR\x07running\x12L\n\nterminated\x18\x03\x20\x01(\
    \x0b2,.k8s.io.api.core.v1.ContainerStateTerminatedR\nterminated\"a\n\x15\
    ContainerStateRunning\x12H\n\tstartedAt\x18\x01\x20\x01(\x0b2*.k8s.io.ap\
    imachinery.pkg.apis.meta.v1.TimeR\tstartedAt\"\xb8\x02\n\x18ContainerSta\
    teTerminated\x12\x1a\n\x08exitCode\x18\x01\x20\x01(\x05R\x08exitCode\x12\
    \x16\n\x06signal\x18\x02\x20\x01(\x05R\x06signal\x12\x16\n\x06reason\x18\
    \x03\x20\x01(\tR\x06reason\x12\x18\n\x07message\x18\x04\x20\x01(\tR\x07m\
    essage\x12H\n\tstartedAt\x18\x05\x20\x01(\x0b2*.k8s.io.apimachinery.pkg.\
    apis.meta.v1.TimeR\tstartedAt\x12J\n\nfinishedAt\x18\x06\x20\x01(\x0b2*.\
    k8s.io.apimachinery.pkg.apis.meta.v1.TimeR\nfinishedAt\x12\x20\n\x0bcont\
    ainerID\x18\x07\x20\x01(\tR\x0bcontainerID\"I\n\x15ContainerStateWaiting\
    \x12\x16\n\x06reason\x18\x01\x20\x01(\tR\x06reason\x12\x18\n\x07message\
    \x18\x02\x20\x01(\tR\x07message\"\xc7\x02\n\x0fContainerStatus\x12\x12\n\
    \x04name\x18\x01\x20\x01(\tR\x04name\x128\n\x05state\x18\x02\x20\x01(\
    \x0b2\".k8s.io.api.core.v1.ContainerStateR\x05state\x12@\n\tlastState\
    \x18\x03\x20\x01(\x0b2\".k8s.io.api.core.v1.ContainerStateR\tlastState\
    \x12\x14\n\x05ready\x18\x04\x20\x01(\x08R\x05ready\x12\"\n\x0crestartCou\
    nt\x18\x05\x20\x01(\x05R\x0crestartCount\x12\x14\n\x05image\x18\x06\x20\
    \x01(\tR\x05image\x12\x18\n\x07imageID\x18\x07\x20\x01(\tR\x07imageID\
    \x12\x20\n\x0bcontainerID\x18\x08\x20\x01(\tR\x0bcontainerID\x12\x18\n\
    \x07started\x18\t\x20\x01(\x08R\x07started\"$\n\x0eDaemonEndpoint\x12\
    \x12\n\x04Port\x18\x01\x20\x01(\x05R\x04Port\"X\n\x15DownwardAPIProjecti\
    on\x12?\n\x05items\x18\x01\x20\x03(\x0b2).k8s.io.api.core.v1.DownwardAPI\
    VolumeFileR\x05items\"\xdb\x01\n\x15DownwardAPIVolumeFile\x12\x12\n\x04p\
    ath\x18\x01\x20\x01(\tR\x04path\x12C\n\x08fieldRef\x18\x02\x20\x01(\x0b2\
    '.k8s.io.api.core.v1.ObjectFieldSelectorR\x08fieldRef\x12U\n\x10resource\
    FieldRef\x18\x03\x20\x01(\x0b2).k8s.io.api.core.v1.ResourceFieldSelector\
    R\x10resourceFieldRef\x12\x12\n\x04mode\x18\x04\x20\x01(\x05R\x04mode\"|\
    \n\x17DownwardAPIVolumeSource\x12?\n\x05items\x18\x01\x20\x03(\x0b2).k8s\
    .io.api.core.v1.DownwardAPIVolumeFileR\x05items\x12\x20\n\x0bdefaultMode\
    \x18\x02\x20\x01(\x05R\x0bdefaultMode\"|\n\x14EmptyDirVolumeSource\x12\
    \x16\n\x06medium\x18\x01\x20\x01(\tR\x06medium\x12L\n\tsizeLimit\x18\x02\
    \x20\x01(\x0b2..k8s.io.apimachinery.pkg.api.resource.QuantityR\tsizeLimi\
    t\"\x9c\x01\n\x0fEndpointAddress\x12\x0e\n\x02ip\x18\x01\x20\x01(\tR\x02\
    ip\x12\x1a\n\x08hostname\x18\x03\x20\x01(\tR\x08hostname\x12\x1a\n\x08no\
    deName\x18\x04\x20\x01(\tR\x08nodeName\x12A\n\ttargetRef\x18\x02\x20\x01\
    (\x0b2#.k8s.io.api.core.v1.ObjectReferenceR\ttargetRef\"t\n\x0cEndpointP\
    ort\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\x12\n\x04port\x18\
    \x02\x20\x01(\x05R\x04port\x12\x1a\n\x08protocol\x18\x03\x20\x01(\tR\x08\
    protocol\x12\x20\n\x0bappProtocol\x18\x04\x20\x01(\tR\x0bappProtocol\"\
    \xde\x01\n\x0eEndpointSubset\x12A\n\taddresses\x18\x01\x20\x03(\x0b2#.k8\
    s.io.api.core.v1.EndpointAddressR\taddresses\x12Q\n\x11notReadyAddresses\
    \x18\x02\x20\x03(\x0b2#.k8s.io.api.core.v1.EndpointAddressR\x11notReadyA\
    ddresses\x126\n\x05ports\x18\x03\x20\x03(\x0b2\x20.k8s.io.api.core.v1.En\
    dpointPortR\x05ports\"\x97\x01\n\tEndpoints\x12L\n\x08metadata\x18\x01\
    \x20\x01(\x0b20.k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMetaR\x08meta\
    data\x12<\n\x07subsets\x18\x02\x20\x03(\x0b2\".k8s.io.api.core.v1.Endpoi\
    ntSubsetR\x07subsets\"\x90\x01\n\rEndpointsList\x12J\n\x08metadata\x18\
    \x01\x20\x01(\x0b2..k8s.io.apimachinery.pkg.apis.meta.v1.ListMetaR\x08me\
    tadata\x123\n\x05items\x18\x02\x20\x03(\x0b2\x1d.k8s.io.api.core.v1.Endp\
    ointsR\x05items\"\xb6\x01\n\rEnvFromSource\x12\x16\n\x06prefix\x18\x01\
    \x20\x01(\tR\x06prefix\x12J\n\x0cconfigMapRef\x18\x02\x20\x01(\x0b2&.k8s\
    .io.api.core.v1.ConfigMapEnvSourceR\x0cconfigMapRef\x12A\n\tsecretRef\
    \x18\x03\x20\x01(\x0b2#.k8s.io.api.core.v1.SecretEnvSourceR\tsecretRef\"\
    r\n\x06EnvVar\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\x14\n\
    \x05value\x18\x02\x20\x01(\tR\x05value\x12>\n\tvalueFrom\x18\x03\x20\x01\
    (\x0b2\x20.k8s.io.api.core.v1.EnvVarSourceR\tvalueFrom\"\xc9\x02\n\x0cEn\
    vVarSource\x12C\n\x08fieldRef\x18\x01\x20\x01(\x0b2'.k8s.io.api.core.v1.\
    ObjectFieldSelectorR\x08fieldRef\x12U\n\x10resourceFieldRef\x18\x02\x20\
    \x01(\x0b2).k8s.io.api.core.v1.ResourceFieldSelectorR\x10resourceFieldRe\
    f\x12R\n\x0fconfigMapKeyRef\x18\x03\x20\x01(\x0b2(.k8s.io.api.core.v1.Co\
    nfigMapKeySelectorR\x0fconfigMapKeyRef\x12I\n\x0csecretKeyRef\x18\x04\
    \x20\x01(\x0b2%.k8s.io.api.core.v1.SecretKeySelectorR\x0csecretKeyRef\"\
    \xb0\x01\n\x12EphemeralContainer\x12h\n\x18ephemeralContainerCommon\x18\
    \x01\x20\x01(\x0b2,.k8s.io.api.core.v1.EphemeralContainerCommonR\x18ephe\
    meralContainerCommon\x120\n\x13targetContainerName\x18\x02\x20\x01(\tR\
    \x13targetContainerName\"\xbe\x08\n\x18EphemeralContainerCommon\x12\x12\
    \n\x04name\x18\x01\x20\x01(\tR\x04name\x12\x14\n\x05image\x18\x02\x20\
    \x01(\tR\x05image\x12\x18\n\x07command\x18\x03\x20\x03(\tR\x07command\
    \x12\x12\n\x04args\x18\x04\x20\x03(\tR\x04args\x12\x1e\n\nworkingDir\x18\
    \x05\x20\x01(\tR\nworkingDir\x127\n\x05ports\x18\x06\x20\x03(\x0b2!.k8s.\
    io.api.core.v1.ContainerPortR\x05ports\x12;\n\x07envFrom\x18\x13\x20\x03\
    (\x0b2!.k8s.io.api.core.v1.EnvFromSourceR\x07envFrom\x12,\n\x03env\x18\
    \x07\x20\x03(\x0b2\x1a.k8s.io.api.core.v1.EnvVarR\x03env\x12F\n\tresourc\
    es\x18\x08\x20\x01(\x0b2(.k8s.io.api.core.v1.ResourceRequirementsR\treso\
    urces\x12C\n\x0cvolumeMounts\x18\t\x20\x03(\x0b2\x1f.k8s.io.api.core.v1.\
    VolumeMountR\x0cvolumeMounts\x12F\n\rvolumeDevices\x18\x15\x20\x03(\x0b2\
    \x20.k8s.io.api.core.v1.VolumeDeviceR\rvolumeDevices\x12?\n\rlivenessPro\
    be\x18\n\x20\x01(\x0b2\x19.k8s.io.api.core.v1.ProbeR\rlivenessProbe\x12A\
    \n\x0ereadinessProbe\x18\x0b\x20\x01(\x0b2\x19.k8s.io.api.core.v1.ProbeR\
    \x0ereadinessProbe\x12=\n\x0cstartupProbe\x18\x16\x20\x01(\x0b2\x19.k8s.\
    io.api.core.v1.ProbeR\x0cstartupProbe\x12;\n\tlifecycle\x18\x0c\x20\x01(\
    \x0b2\x1d.k8s.io.api.core.v1.LifecycleR\tlifecycle\x126\n\x16termination\
    MessagePath\x18\r\x20\x01(\tR\x16terminationMessagePath\x12:\n\x18termin\
    ationMessagePolicy\x18\x14\x20\x01(\tR\x18terminationMessagePolicy\x12(\
    \n\x0fimagePullPolicy\x18\x0e\x20\x01(\tR\x0fimagePullPolicy\x12M\n\x0fs\
    ecurityContext\x18\x0f\x20\x01(\x0b2#.k8s.io.api.core.v1.SecurityContext\
    R\x0fsecurityContext\x12\x14\n\x05stdin\x18\x10\x20\x01(\x08R\x05stdin\
    \x12\x1c\n\tstdinOnce\x18\x11\x20\x01(\x08R\tstdinOnce\x12\x10\n\x03tty\
    \x18\x12\x20\x01(\x08R\x03tty\"\xbd\x01\n\x13EphemeralContainers\x12L\n\
    \x08metadata\x18\x01\x20\x01(\x0b20.k8s.io.apimachinery.pkg.apis.meta.v1\
    .ObjectMetaR\x08metadata\x12X\n\x13ephemeralContainers\x18\x02\x20\x03(\
    \x0b2&.k8s.io.api.core.v1.EphemeralContainerR\x13ephemeralContainers\"\
    \x98\x01\n\x15EphemeralVolumeSource\x12c\n\x13volumeClaimTemplate\x18\
    \x01\x20\x01(\x0b21.k8s.io.api.core.v1.PersistentVolumeClaimTemplateR\
    \x13volumeClaimTemplate\x12\x1a\n\x08readOnly\x18\x02\x20\x01(\x08R\x08r\
    eadOnly\"\x9a\x06\n\x05Event\x12L\n\x08metadata\x18\x01\x20\x01(\x0b20.k\
    8s.io.apimachinery.pkg.apis.meta.v1.ObjectMetaR\x08metadata\x12K\n\x0ein\
    volvedObject\x18\x02\x20\x01(\x0b2#.k8s.io.api.core.v1.ObjectReferenceR\
    \x0einvolvedObject\x12\x16\n\x06reason\x18\x03\x20\x01(\tR\x06reason\x12\
    \x18\n\x07message\x18\x04\x20\x01(\tR\x07message\x127\n\x06source\x18\
    \x05\x20\x01(\x0b2\x1f.k8s.io.api.core.v1.EventSourceR\x06source\x12R\n\
    \x0efirstTimestamp\x18\x06\x20\x01(\x0b2*.k8s.io.apimachinery.pkg.apis.m\
    eta.v1.TimeR\x0efirstTimestamp\x12P\n\rlastTimestamp\x18\x07\x20\x01(\
    \x0b2*.k8s.io.apimachinery.pkg.apis.meta.v1.TimeR\rlastTimestamp\x12\x14\
    \n\x05count\x18\x08\x20\x01(\x05R\x05count\x12\x12\n\x04type\x18\t\x20\
    \x01(\tR\x04type\x12M\n\teventTime\x18\n\x20\x01(\x0b2/.k8s.io.apimachin\
    ery.pkg.apis.meta.v1.MicroTimeR\teventTime\x127\n\x06series\x18\x0b\x20\
    \x01(\x0b2\x1f.k8s.io.api.core.v1.EventSeriesR\x06series\x12\x16\n\x06ac\
    tion\x18\x0c\x20\x01(\tR\x06action\x12=\n\x07related\x18\r\x20\x01(\x0b2\
    #.k8s.io.api.core.v1.ObjectReferenceR\x07related\x12.\n\x12reportingComp\
    onent\x18\x0e\x20\x01(\tR\x12reportingComponent\x12,\n\x11reportingInsta\
    nce\x18\x0f\x20\x01(\tR\x11reportingInstance\"\x88\x01\n\tEventList\x12J\
    \n\x08metadata\x18\x01\x20\x01(\x0b2..k8s.io.apimachinery.pkg.apis.meta.\
    v1.ListMetaR\x08metadata\x12/\n\x05items\x18\x02\x20\x03(\x0b2\x19.k8s.i\
    o.api.core.v1.EventR\x05items\"\x80\x01\n\x0bEventSeries\x12\x14\n\x05co\
    unt\x18\x01\x20\x01(\x05R\x05count\x12[\n\x10lastObservedTime\x18\x02\
    \x20\x01(\x0b2/.k8s.io.apimachinery.pkg.apis.meta.v1.MicroTimeR\x10lastO\
    bservedTime\"?\n\x0bEventSource\x12\x1c\n\tcomponent\x18\x01\x20\x01(\tR\
    \tcomponent\x12\x12\n\x04host\x18\x02\x20\x01(\tR\x04host\"&\n\nExecActi\
    on\x12\x18\n\x07command\x18\x01\x20\x03(\tR\x07command\"\x8c\x01\n\x0eFC\
    VolumeSource\x12\x1e\n\ntargetWWNs\x18\x01\x20\x03(\tR\ntargetWWNs\x12\
    \x10\n\x03lun\x18\x02\x20\x01(\x05R\x03lun\x12\x16\n\x06fsType\x18\x03\
    \x20\x01(\tR\x06fsType\x12\x1a\n\x08readOnly\x18\x04\x20\x01(\x08R\x08re\
    adOnly\x12\x14\n\x05wwids\x18\x05\x20\x03(\tR\x05wwids\"\xbe\x02\n\x1aFl\
    exPersistentVolumeSource\x12\x16\n\x06driver\x18\x01\x20\x01(\tR\x06driv\
    er\x12\x16\n\x06fsType\x18\x02\x20\x01(\tR\x06fsType\x12A\n\tsecretRef\
    \x18\x03\x20\x01(\x0b2#.k8s.io.api.core.v1.SecretReferenceR\tsecretRef\
    \x12\x1a\n\x08readOnly\x18\x04\x20\x01(\x08R\x08readOnly\x12U\n\x07optio\
    ns\x18\x05\x20\x03(\x0b2;.k8s.io.api.core.v1.FlexPersistentVolumeSource.\
    OptionsEntryR\x07options\x1a:\n\x0cOptionsEntry\x12\x10\n\x03key\x18\x01\
    \x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x02\
    8\x01\"\xaf\x02\n\x10FlexVolumeSource\x12\x16\n\x06driver\x18\x01\x20\
    \x01(\tR\x06driver\x12\x16\n\x06fsType\x18\x02\x20\x01(\tR\x06fsType\x12\
    F\n\tsecretRef\x18\x03\x20\x01(\x0b2(.k8s.io.api.core.v1.LocalObjectRefe\
    renceR\tsecretRef\x12\x1a\n\x08readOnly\x18\x04\x20\x01(\x08R\x08readOnl\
    y\x12K\n\x07options\x18\x05\x20\x03(\x0b21.k8s.io.api.core.v1.FlexVolume\
    Source.OptionsEntryR\x07options\x1a:\n\x0cOptionsEntry\x12\x10\n\x03key\
    \x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05va\
    lue:\x028\x01\"Y\n\x13FlockerVolumeSource\x12\x20\n\x0bdatasetName\x18\
    \x01\x20\x01(\tR\x0bdatasetName\x12\x20\n\x0bdatasetUUID\x18\x02\x20\x01\
    (\tR\x0bdatasetUUID\"\x89\x01\n\x1dGCEPersistentDiskVolumeSource\x12\x16\
    \n\x06pdName\x18\x01\x20\x01(\tR\x06pdName\x12\x16\n\x06fsType\x18\x02\
    \x20\x01(\tR\x06fsType\x12\x1c\n\tpartition\x18\x03\x20\x01(\x05R\tparti\
    tion\x12\x1a\n\x08readOnly\x18\x04\x20\x01(\x08R\x08readOnly\"o\n\x13Git\
    RepoVolumeSource\x12\x1e\n\nrepository\x18\x01\x20\x01(\tR\nrepository\
    \x12\x1a\n\x08revision\x18\x02\x20\x01(\tR\x08revision\x12\x1c\n\tdirect\
    ory\x18\x03\x20\x01(\tR\tdirectory\"\x9f\x01\n\x1fGlusterfsPersistentVol\
    umeSource\x12\x1c\n\tendpoints\x18\x01\x20\x01(\tR\tendpoints\x12\x12\n\
    \x04path\x18\x02\x20\x01(\tR\x04path\x12\x1a\n\x08readOnly\x18\x03\x20\
    \x01(\x08R\x08readOnly\x12.\n\x12endpointsNamespace\x18\x04\x20\x01(\tR\
    \x12endpointsNamespace\"e\n\x15GlusterfsVolumeSource\x12\x1c\n\tendpoint\
    s\x18\x01\x20\x01(\tR\tendpoints\x12\x12\n\x04path\x18\x02\x20\x01(\tR\
    \x04path\x12\x1a\n\x08readOnly\x18\x03\x20\x01(\x08R\x08readOnly\"\xd7\
    \x01\n\rHTTPGetAction\x12\x12\n\x04path\x18\x01\x20\x01(\tR\x04path\x12D\
    \n\x04port\x18\x02\x20\x01(\x0b20.k8s.io.apimachinery.pkg.util.intstr.In\
    tOrStringR\x04port\x12\x12\n\x04host\x18\x03\x20\x01(\tR\x04host\x12\x16\
    \n\x06scheme\x18\x04\x20\x01(\tR\x06scheme\x12@\n\x0bhttpHeaders\x18\x05\
    \x20\x03(\x0b2\x1e.k8s.io.api.core.v1.HTTPHeaderR\x0bhttpHeaders\"6\n\nH\
    TTPHeader\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\x14\n\x05val\
    ue\x18\x02\x20\x01(\tR\x05value\"\xbd\x01\n\x07Handler\x122\n\x04exec\
    \x18\x01\x20\x01(\x0b2\x1e.k8s.io.api.core.v1.ExecActionR\x04exec\x12;\n\
    \x07httpGet\x18\x02\x20\x01(\x0b2!.k8s.io.api.core.v1.HTTPGetActionR\x07\
    httpGet\x12A\n\ttcpSocket\x18\x03\x20\x01(\x0b2#.k8s.io.api.core.v1.TCPS\
    ocketActionR\ttcpSocket\"9\n\tHostAlias\x12\x0e\n\x02ip\x18\x01\x20\x01(\
    \tR\x02ip\x12\x1c\n\thostnames\x18\x02\x20\x03(\tR\thostnames\">\n\x14Ho\
    stPathVolumeSource\x12\x12\n\x04path\x18\x01\x20\x01(\tR\x04path\x12\x12\
    \n\x04type\x18\x02\x20\x01(\tR\x04type\"\x9c\x03\n\x1bISCSIPersistentVol\
    umeSource\x12\"\n\x0ctargetPortal\x18\x01\x20\x01(\tR\x0ctargetPortal\
    \x12\x10\n\x03iqn\x18\x02\x20\x01(\tR\x03iqn\x12\x10\n\x03lun\x18\x03\
    \x20\x01(\x05R\x03lun\x12&\n\x0eiscsiInterface\x18\x04\x20\x01(\tR\x0eis\
    csiInterface\x12\x16\n\x06fsType\x18\x05\x20\x01(\tR\x06fsType\x12\x1a\n\
    \x08readOnly\x18\x06\x20\x01(\x08R\x08readOnly\x12\x18\n\x07portals\x18\
    \x07\x20\x03(\tR\x07portals\x12,\n\x11chapAuthDiscovery\x18\x08\x20\x01(\
    \x08R\x11chapAuthDiscovery\x12(\n\x0fchapAuthSession\x18\x0b\x20\x01(\
    \x08R\x0fchapAuthSession\x12A\n\tsecretRef\x18\n\x20\x01(\x0b2#.k8s.io.a\
    pi.core.v1.SecretReferenceR\tsecretRef\x12$\n\rinitiatorName\x18\x0c\x20\
    \x01(\tR\rinitiatorName\"\x97\x03\n\x11ISCSIVolumeSource\x12\"\n\x0ctarg\
    etPortal\x18\x01\x20\x01(\tR\x0ctargetPortal\x12\x10\n\x03iqn\x18\x02\
    \x20\x01(\tR\x03iqn\x12\x10\n\x03lun\x18\x03\x20\x01(\x05R\x03lun\x12&\n\
    \x0eiscsiInterface\x18\x04\x20\x01(\tR\x0eiscsiInterface\x12\x16\n\x06fs\
    Type\x18\x05\x20\x01(\tR\x06fsType\x12\x1a\n\x08readOnly\x18\x06\x20\x01\
    (\x08R\x08readOnly\x12\x18\n\x07portals\x18\x07\x20\x03(\tR\x07portals\
    \x12,\n\x11chapAuthDiscovery\x18\x08\x20\x01(\x08R\x11chapAuthDiscovery\
    \x12(\n\x0fchapAuthSession\x18\x0b\x20\x01(\x08R\x0fchapAuthSession\x12F\
    \n\tsecretRef\x18\n\x20\x01(\x0b2(.k8s.io.api.core.v1.LocalObjectReferen\
    ceR\tsecretRef\x12$\n\rinitiatorName\x18\x0c\x20\x01(\tR\rinitiatorName\
    \"E\n\tKeyToPath\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x12\n\
    \x04path\x18\x02\x20\x01(\tR\x04path\x12\x12\n\x04mode\x18\x03\x20\x01(\
    \x05R\x04mode\"}\n\tLifecycle\x129\n\tpostStart\x18\x01\x20\x01(\x0b2\
    \x1b.k8s.io.api.core.v1.HandlerR\tpostStart\x125\n\x07preStop\x18\x02\
    \x20\x01(\x0b2\x1b.k8s.io.api.core.v1.HandlerR\x07preStop\"\x92\x01\n\nL\
    imitRange\x12L\n\x08metadata\x18\x01\x20\x01(\x0b20.k8s.io.apimachinery.\
    pkg.apis.meta.v1.ObjectMetaR\x08metadata\x126\n\x04spec\x18\x02\x20\x01(\
    \x0b2\".k8s.io.api.core.v1.LimitRangeSpecR\x04spec\"\xe7\x07\n\x0eLimitR\
    angeItem\x12\x12\n\x04type\x18\x01\x20\x01(\tR\x04type\x12=\n\x03max\x18\
    \x02\x20\x03(\x0b2+.k8s.io.api.core.v1.LimitRangeItem.MaxEntryR\x03max\
    \x12=\n\x03min\x18\x03\x20\x03(\x0b2+.k8s.io.api.core.v1.LimitRangeItem.\
    MinEntryR\x03min\x12I\n\x07default\x18\x04\x20\x03(\x0b2/.k8s.io.api.cor\
    e.v1.LimitRangeItem.DefaultEntryR\x07default\x12^\n\x0edefaultRequest\
    \x18\x05\x20\x03(\x0b26.k8s.io.api.core.v1.LimitRangeItem.DefaultRequest\
    EntryR\x0edefaultRequest\x12p\n\x14maxLimitRequestRatio\x18\x06\x20\x03(\
    \x0b2<.k8s.io.api.core.v1.LimitRangeItem.MaxLimitRequestRatioEntryR\x14m\
    axLimitRequestRatio\x1af\n\x08MaxEntry\x12\x10\n\x03key\x18\x01\x20\x01(\
    \tR\x03key\x12D\n\x05value\x18\x02\x20\x01(\x0b2..k8s.io.apimachinery.pk\
    g.api.resource.QuantityR\x05value:\x028\x01\x1af\n\x08MinEntry\x12\x10\n\
    \x03key\x18\x01\x20\x01(\tR\x03key\x12D\n\x05value\x18\x02\x20\x01(\x0b2\
    ..k8s.io.apimachinery.pkg.api.resource.QuantityR\x05value:\x028\x01\x1aj\
    \n\x0cDefaultEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12D\n\
    \x05value\x18\x02\x20\x01(\x0b2..k8s.io.apimachinery.pkg.api.resource.Qu\
    antityR\x05value:\x028\x01\x1aq\n\x13DefaultRequestEntry\x12\x10\n\x03ke\
    y\x18\x01\x20\x01(\tR\x03key\x12D\n\x05value\x18\x02\x20\x01(\x0b2..k8s.\
    io.apimachinery.pkg.api.resource.QuantityR\x05value:\x028\x01\x1aw\n\x19\
    MaxLimitRequestRatioEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\
    \x12D\n\x05value\x18\x02\x20\x01(\x0b2..k8s.io.apimachinery.pkg.api.reso\
    urce.QuantityR\x05value:\x028\x01\"\x92\x01\n\x0eLimitRangeList\x12J\n\
    \x08metadata\x18\x01\x20\x01(\x0b2..k8s.io.apimachinery.pkg.apis.meta.v1\
    .ListMetaR\x08metadata\x124\n\x05items\x18\x02\x20\x03(\x0b2\x1e.k8s.io.\
    api.core.v1.LimitRangeR\x05items\"L\n\x0eLimitRangeSpec\x12:\n\x06limits\
    \x18\x01\x20\x03(\x0b2\".k8s.io.api.core.v1.LimitRangeItemR\x06limits\"\
    \x97\x01\n\x04List\x12J\n\x08metadata\x18\x01\x20\x01(\x0b2..k8s.io.apim\
    achinery.pkg.apis.meta.v1.ListMetaR\x08metadata\x12C\n\x05items\x18\x02\
    \x20\x03(\x0b2-.k8s.io.apimachinery.pkg.runtime.RawExtensionR\x05items\"\
    w\n\x13LoadBalancerIngress\x12\x0e\n\x02ip\x18\x01\x20\x01(\tR\x02ip\x12\
    \x1a\n\x08hostname\x18\x02\x20\x01(\tR\x08hostname\x124\n\x05ports\x18\
    \x04\x20\x03(\x0b2\x1e.k8s.io.api.core.v1.PortStatusR\x05ports\"W\n\x12L\
    oadBalancerStatus\x12A\n\x07ingress\x18\x01\x20\x03(\x0b2'.k8s.io.api.co\
    re.v1.LoadBalancerIngressR\x07ingress\"*\n\x14LocalObjectReference\x12\
    \x12\n\x04name\x18\x01\x20\x01(\tR\x04name\"?\n\x11LocalVolumeSource\x12\
    \x12\n\x04path\x18\x01\x20\x01(\tR\x04path\x12\x16\n\x06fsType\x18\x02\
    \x20\x01(\tR\x06fsType\"Y\n\x0fNFSVolumeSource\x12\x16\n\x06server\x18\
    \x01\x20\x01(\tR\x06server\x12\x12\n\x04path\x18\x02\x20\x01(\tR\x04path\
    \x12\x1a\n\x08readOnly\x18\x03\x20\x01(\x08R\x08readOnly\"\xcd\x01\n\tNa\
    mespace\x12L\n\x08metadata\x18\x01\x20\x01(\x0b20.k8s.io.apimachinery.pk\
    g.apis.meta.v1.ObjectMetaR\x08metadata\x125\n\x04spec\x18\x02\x20\x01(\
    \x0b2!.k8s.io.api.core.v1.NamespaceSpecR\x04spec\x12;\n\x06status\x18\
    \x03\x20\x01(\x0b2#.k8s.io.api.core.v1.NamespaceStatusR\x06status\"\xce\
    \x01\n\x12NamespaceCondition\x12\x12\n\x04type\x18\x01\x20\x01(\tR\x04ty\
    pe\x12\x16\n\x06status\x18\x02\x20\x01(\tR\x06status\x12Z\n\x12lastTrans\
    itionTime\x18\x04\x20\x01(\x0b2*.k8s.io.apimachinery.pkg.apis.meta.v1.Ti\
    meR\x12lastTransitionTime\x12\x16\n\x06reason\x18\x05\x20\x01(\tR\x06rea\
    son\x12\x18\n\x07message\x18\x06\x20\x01(\tR\x07message\"\x90\x01\n\rNam\
    espaceList\x12J\n\x08metadata\x18\x01\x20\x01(\x0b2..k8s.io.apimachinery\
    .pkg.apis.meta.v1.ListMetaR\x08metadata\x123\n\x05items\x18\x02\x20\x03(\
    \x0b2\x1d.k8s.io.api.core.v1.NamespaceR\x05items\"/\n\rNamespaceSpec\x12\
    \x1e\n\nfinalizers\x18\x01\x20\x03(\tR\nfinalizers\"o\n\x0fNamespaceStat\
    us\x12\x14\n\x05phase\x18\x01\x20\x01(\tR\x05phase\x12F\n\nconditions\
    \x18\x02\x20\x03(\x0b2&.k8s.io.api.core.v1.NamespaceConditionR\nconditio\
    ns\"\xbe\x01\n\x04Node\x12L\n\x08metadata\x18\x01\x20\x01(\x0b20.k8s.io.\
    apimachinery.pkg.apis.meta.v1.ObjectMetaR\x08metadata\x120\n\x04spec\x18\
    \x02\x20\x01(\x0b2\x1c.k8s.io.api.core.v1.NodeSpecR\x04spec\x126\n\x06st\
    atus\x18\x03\x20\x01(\x0b2\x1e.k8s.io.api.core.v1.NodeStatusR\x06status\
    \";\n\x0bNodeAddress\x12\x12\n\x04type\x18\x01\x20\x01(\tR\x04type\x12\
    \x18\n\x07address\x18\x02\x20\x01(\tR\x07address\"\xb1\x02\n\x0cNodeAffi\
    nity\x12\x88\x01\n.requiredDuringSchedulingIgnoredDuringExecution\x18\
    \x01\x20\x01(\x0b2\x20.k8s.io.api.core.v1.NodeSelectorR.requiredDuringSc\
    hedulingIgnoredDuringExecution\x12\x95\x01\n/preferredDuringSchedulingIg\
    noredDuringExecution\x18\x02\x20\x03(\x0b2+.k8s.io.api.core.v1.Preferred\
    SchedulingTermR/preferredDuringSchedulingIgnoredDuringExecution\"\xa3\
    \x02\n\rNodeCondition\x12\x12\n\x04type\x18\x01\x20\x01(\tR\x04type\x12\
    \x16\n\x06status\x18\x02\x20\x01(\tR\x06status\x12X\n\x11lastHeartbeatTi\
    me\x18\x03\x20\x01(\x0b2*.k8s.io.apimachinery.pkg.apis.meta.v1.TimeR\x11\
    lastHeartbeatTime\x12Z\n\x12lastTransitionTime\x18\x04\x20\x01(\x0b2*.k8\
    s.io.apimachinery.pkg.apis.meta.v1.TimeR\x12lastTransitionTime\x12\x16\n\
    \x06reason\x18\x05\x20\x01(\tR\x06reason\x12\x18\n\x07message\x18\x06\
    \x20\x01(\tR\x07message\"_\n\x10NodeConfigSource\x12K\n\tconfigMap\x18\
    \x02\x20\x01(\x0b2-.k8s.io.api.core.v1.ConfigMapNodeConfigSourceR\tconfi\
    gMap\"\xf4\x01\n\x10NodeConfigStatus\x12@\n\x08assigned\x18\x01\x20\x01(\
    \x0b2$.k8s.io.api.core.v1.NodeConfigSourceR\x08assigned\x12<\n\x06active\
    \x18\x02\x20\x01(\x0b2$.k8s.io.api.core.v1.NodeConfigSourceR\x06active\
    \x12J\n\rlastKnownGood\x18\x03\x20\x01(\x0b2$.k8s.io.api.core.v1.NodeCon\
    figSourceR\rlastKnownGood\x12\x14\n\x05error\x18\x04\x20\x01(\tR\x05erro\
    r\"c\n\x13NodeDaemonEndpoints\x12L\n\x0fkubeletEndpoint\x18\x01\x20\x01(\
    \x0b2\".k8s.io.api.core.v1.DaemonEndpointR\x0fkubeletEndpoint\"\x86\x01\
    \n\x08NodeList\x12J\n\x08metadata\x18\x01\x20\x01(\x0b2..k8s.io.apimachi\
    nery.pkg.apis.meta.v1.ListMetaR\x08metadata\x12.\n\x05items\x18\x02\x20\
    \x03(\x0b2\x18.k8s.io.api.core.v1.NodeR\x05items\"&\n\x10NodeProxyOption\
    s\x12\x12\n\x04path\x18\x01\x20\x01(\tR\x04path\"\xc9\x01\n\rNodeResourc\
    es\x12K\n\x08capacity\x18\x01\x20\x03(\x0b2/.k8s.io.api.core.v1.NodeReso\
    urces.CapacityEntryR\x08capacity\x1ak\n\rCapacityEntry\x12\x10\n\x03key\
    \x18\x01\x20\x01(\tR\x03key\x12D\n\x05value\x18\x02\x20\x01(\x0b2..k8s.i\
    o.apimachinery.pkg.api.resource.QuantityR\x05value:\x028\x01\"b\n\x0cNod\
    eSelector\x12R\n\x11nodeSelectorTerms\x18\x01\x20\x03(\x0b2$.k8s.io.api.\
    core.v1.NodeSelectorTermR\x11nodeSelectorTerms\"_\n\x17NodeSelectorRequi\
    rement\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x1a\n\x08operator\
    \x18\x02\x20\x01(\tR\x08operator\x12\x16\n\x06values\x18\x03\x20\x03(\tR\
    \x06values\"\xba\x01\n\x10NodeSelectorTerm\x12W\n\x10matchExpressions\
    \x18\x01\x20\x03(\x0b2+.k8s.io.api.core.v1.NodeSelectorRequirementR\x10m\
    atchExpressions\x12M\n\x0bmatchFields\x18\x02\x20\x03(\x0b2+.k8s.io.api.\
    core.v1.NodeSelectorRequirementR\x0bmatchFields\"\xa3\x02\n\x08NodeSpec\
    \x12\x18\n\x07podCIDR\x18\x01\x20\x01(\tR\x07podCIDR\x12\x1a\n\x08podCID\
    Rs\x18\x07\x20\x03(\tR\x08podCIDRs\x12\x1e\n\nproviderID\x18\x03\x20\x01\
    (\tR\nproviderID\x12$\n\runschedulable\x18\x04\x20\x01(\x08R\runschedula\
    ble\x121\n\x06taints\x18\x05\x20\x03(\x0b2\x19.k8s.io.api.core.v1.TaintR\
    \x06taints\x12H\n\x0cconfigSource\x18\x06\x20\x01(\x0b2$.k8s.io.api.core\
    .v1.NodeConfigSourceR\x0cconfigSource\x12\x1e\n\nexternalID\x18\x02\x20\
    \x01(\tR\nexternalID\"\x9d\x07\n\nNodeStatus\x12H\n\x08capacity\x18\x01\
    \x20\x03(\x0b2,.k8s.io.api.core.v1.NodeStatus.CapacityEntryR\x08capacity\
    \x12Q\n\x0ballocatable\x18\x02\x20\x03(\x0b2/.k8s.io.api.core.v1.NodeSta\
    tus.AllocatableEntryR\x0ballocatable\x12\x14\n\x05phase\x18\x03\x20\x01(\
    \tR\x05phase\x12A\n\nconditions\x18\x04\x20\x03(\x0b2!.k8s.io.api.core.v\
    1.NodeConditionR\nconditions\x12=\n\taddresses\x18\x05\x20\x03(\x0b2\x1f\
    .k8s.io.api.core.v1.NodeAddressR\taddresses\x12Q\n\x0fdaemonEndpoints\
    \x18\x06\x20\x01(\x0b2'.k8s.io.api.core.v1.NodeDaemonEndpointsR\x0fdaemo\
    nEndpoints\x12>\n\x08nodeInfo\x18\x07\x20\x01(\x0b2\".k8s.io.api.core.v1\
    .NodeSystemInfoR\x08nodeInfo\x12:\n\x06images\x18\x08\x20\x03(\x0b2\".k8\
    s.io.api.core.v1.ContainerImageR\x06images\x12\"\n\x0cvolumesInUse\x18\t\
    \x20\x03(\tR\x0cvolumesInUse\x12L\n\x0fvolumesAttached\x18\n\x20\x03(\
    \x0b2\".k8s.io.api.core.v1.AttachedVolumeR\x0fvolumesAttached\x12<\n\x06\
    config\x18\x0b\x20\x01(\x0b2$.k8s.io.api.core.v1.NodeConfigStatusR\x06co\
    nfig\x1ak\n\rCapacityEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\
    \x12D\n\x05value\x18\x02\x20\x01(\x0b2..k8s.io.apimachinery.pkg.api.reso\
    urce.QuantityR\x05value:\x028\x01\x1an\n\x10AllocatableEntry\x12\x10\n\
    \x03key\x18\x01\x20\x01(\tR\x03key\x12D\n\x05value\x18\x02\x20\x01(\x0b2\
    ..k8s.io.apimachinery.pkg.api.resource.QuantityR\x05value:\x028\x01\"\
    \x82\x03\n\x0eNodeSystemInfo\x12\x1c\n\tmachineID\x18\x01\x20\x01(\tR\tm\
    achineID\x12\x1e\n\nsystemUUID\x18\x02\x20\x01(\tR\nsystemUUID\x12\x16\n\
    \x06bootID\x18\x03\x20\x01(\tR\x06bootID\x12$\n\rkernelVersion\x18\x04\
    \x20\x01(\tR\rkernelVersion\x12\x18\n\x07osImage\x18\x05\x20\x01(\tR\x07\
    osImage\x128\n\x17containerRuntimeVersion\x18\x06\x20\x01(\tR\x17contain\
    erRuntimeVersion\x12&\n\x0ekubeletVersion\x18\x07\x20\x01(\tR\x0ekubelet\
    Version\x12*\n\x10kubeProxyVersion\x18\x08\x20\x01(\tR\x10kubeProxyVersi\
    on\x12(\n\x0foperatingSystem\x18\t\x20\x01(\tR\x0foperatingSystem\x12\"\
    \n\x0carchitecture\x18\n\x20\x01(\tR\x0carchitecture\"S\n\x13ObjectField\
    Selector\x12\x1e\n\napiVersion\x18\x01\x20\x01(\tR\napiVersion\x12\x1c\n\
    \tfieldPath\x18\x02\x20\x01(\tR\tfieldPath\"\xd1\x01\n\x0fObjectReferenc\
    e\x12\x12\n\x04kind\x18\x01\x20\x01(\tR\x04kind\x12\x1c\n\tnamespace\x18\
    \x02\x20\x01(\tR\tnamespace\x12\x12\n\x04name\x18\x03\x20\x01(\tR\x04nam\
    e\x12\x10\n\x03uid\x18\x04\x20\x01(\tR\x03uid\x12\x1e\n\napiVersion\x18\
    \x05\x20\x01(\tR\napiVersion\x12(\n\x0fresourceVersion\x18\x06\x20\x01(\
    \tR\x0fresourceVersion\x12\x1c\n\tfieldPath\x18\x07\x20\x01(\tR\tfieldPa\
    th\"\xe2\x01\n\x10PersistentVolume\x12L\n\x08metadata\x18\x01\x20\x01(\
    \x0b20.k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMetaR\x08metadata\x12<\
    \n\x04spec\x18\x02\x20\x01(\x0b2(.k8s.io.api.core.v1.PersistentVolumeSpe\
    cR\x04spec\x12B\n\x06status\x18\x03\x20\x01(\x0b2*.k8s.io.api.core.v1.Pe\
    rsistentVolumeStatusR\x06status\"\xf1\x01\n\x15PersistentVolumeClaim\x12\
    L\n\x08metadata\x18\x01\x20\x01(\x0b20.k8s.io.apimachinery.pkg.apis.meta\
    .v1.ObjectMetaR\x08metadata\x12A\n\x04spec\x18\x02\x20\x01(\x0b2-.k8s.io\
    .api.core.v1.PersistentVolumeClaimSpecR\x04spec\x12G\n\x06status\x18\x03\
    \x20\x01(\x0b2/.k8s.io.api.core.v1.PersistentVolumeClaimStatusR\x06statu\
    s\"\xac\x02\n\x1ePersistentVolumeClaimCondition\x12\x12\n\x04type\x18\
    \x01\x20\x01(\tR\x04type\x12\x16\n\x06status\x18\x02\x20\x01(\tR\x06stat\
    us\x12P\n\rlastProbeTime\x18\x03\x20\x01(\x0b2*.k8s.io.apimachinery.pkg.\
    apis.meta.v1.TimeR\rlastProbeTime\x12Z\n\x12lastTransitionTime\x18\x04\
    \x20\x01(\x0b2*.k8s.io.apimachinery.pkg.apis.meta.v1.TimeR\x12lastTransi\
    tionTime\x12\x16\n\x06reason\x18\x05\x20\x01(\tR\x06reason\x12\x18\n\x07\
    message\x18\x06\x20\x01(\tR\x07message\"\xa8\x01\n\x19PersistentVolumeCl\
    aimList\x12J\n\x08metadata\x18\x01\x20\x01(\x0b2..k8s.io.apimachinery.pk\
    g.apis.meta.v1.ListMetaR\x08metadata\x12?\n\x05items\x18\x02\x20\x03(\
    \x0b2).k8s.io.api.core.v1.PersistentVolumeClaimR\x05items\"\x91\x03\n\
    \x19PersistentVolumeClaimSpec\x12\x20\n\x0baccessModes\x18\x01\x20\x03(\
    \tR\x0baccessModes\x12O\n\x08selector\x18\x04\x20\x01(\x0b23.k8s.io.apim\
    achinery.pkg.apis.meta.v1.LabelSelectorR\x08selector\x12F\n\tresources\
    \x18\x02\x20\x01(\x0b2(.k8s.io.api.core.v1.ResourceRequirementsR\tresour\
    ces\x12\x1e\n\nvolumeName\x18\x03\x20\x01(\tR\nvolumeName\x12*\n\x10stor\
    ageClassName\x18\x05\x20\x01(\tR\x10storageClassName\x12\x1e\n\nvolumeMo\
    de\x18\x06\x20\x01(\tR\nvolumeMode\x12M\n\ndataSource\x18\x07\x20\x01(\
    \x0b2-.k8s.io.api.core.v1.TypedLocalObjectReferenceR\ndataSource\"\xf1\
    \x02\n\x1bPersistentVolumeClaimStatus\x12\x14\n\x05phase\x18\x01\x20\x01\
    (\tR\x05phase\x12\x20\n\x0baccessModes\x18\x02\x20\x03(\tR\x0baccessMode\
    s\x12Y\n\x08capacity\x18\x03\x20\x03(\x0b2=.k8s.io.api.core.v1.Persisten\
    tVolumeClaimStatus.CapacityEntryR\x08capacity\x12R\n\nconditions\x18\x04\
    \x20\x03(\x0b22.k8s.io.api.core.v1.PersistentVolumeClaimConditionR\ncond\
    itions\x1ak\n\rCapacityEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\
    \x12D\n\x05value\x18\x02\x20\x01(\x0b2..k8s.io.apimachinery.pkg.api.reso\
    urce.QuantityR\x05value:\x028\x01\"\xb0\x01\n\x1dPersistentVolumeClaimTe\
    mplate\x12L\n\x08metadata\x18\x01\x20\x01(\x0b20.k8s.io.apimachinery.pkg\
    .apis.meta.v1.ObjectMetaR\x08metadata\x12A\n\x04spec\x18\x02\x20\x01(\
    \x0b2-.k8s.io.api.core.v1.PersistentVolumeClaimSpecR\x04spec\"]\n!Persis\
    tentVolumeClaimVolumeSource\x12\x1c\n\tclaimName\x18\x01\x20\x01(\tR\tcl\
    aimName\x12\x1a\n\x08readOnly\x18\x02\x20\x01(\x08R\x08readOnly\"\x9e\
    \x01\n\x14PersistentVolumeList\x12J\n\x08metadata\x18\x01\x20\x01(\x0b2.\
    .k8s.io.apimachinery.pkg.apis.meta.v1.ListMetaR\x08metadata\x12:\n\x05it\
    ems\x18\x02\x20\x03(\x0b2$.k8s.io.api.core.v1.PersistentVolumeR\x05items\
    \"\xa9\r\n\x16PersistentVolumeSource\x12_\n\x11gcePersistentDisk\x18\x01\
    \x20\x01(\x0b21.k8s.io.api.core.v1.GCEPersistentDiskVolumeSourceR\x11gce\
    PersistentDisk\x12h\n\x14awsElasticBlockStore\x18\x02\x20\x01(\x0b24.k8s\
    .io.api.core.v1.AWSElasticBlockStoreVolumeSourceR\x14awsElasticBlockStor\
    e\x12D\n\x08hostPath\x18\x03\x20\x01(\x0b2(.k8s.io.api.core.v1.HostPathV\
    olumeSourceR\x08hostPath\x12Q\n\tglusterfs\x18\x04\x20\x01(\x0b23.k8s.io\
    .api.core.v1.GlusterfsPersistentVolumeSourceR\tglusterfs\x125\n\x03nfs\
    \x18\x05\x20\x01(\x0b2#.k8s.io.api.core.v1.NFSVolumeSourceR\x03nfs\x12?\
    \n\x03rbd\x18\x06\x20\x01(\x0b2-.k8s.io.api.core.v1.RBDPersistentVolumeS\
    ourceR\x03rbd\x12E\n\x05iscsi\x18\x07\x20\x01(\x0b2/.k8s.io.api.core.v1.\
    ISCSIPersistentVolumeSourceR\x05iscsi\x12H\n\x06cinder\x18\x08\x20\x01(\
    \x0b20.k8s.io.api.core.v1.CinderPersistentVolumeSourceR\x06cinder\x12H\n\
    \x06cephfs\x18\t\x20\x01(\x0b20.k8s.io.api.core.v1.CephFSPersistentVolum\
    eSourceR\x06cephfs\x122\n\x02fc\x18\n\x20\x01(\x0b2\".k8s.io.api.core.v1\
    .FCVolumeSourceR\x02fc\x12A\n\x07flocker\x18\x0b\x20\x01(\x0b2'.k8s.io.a\
    pi.core.v1.FlockerVolumeSourceR\x07flocker\x12N\n\nflexVolume\x18\x0c\
    \x20\x01(\x0b2..k8s.io.api.core.v1.FlexPersistentVolumeSourceR\nflexVolu\
    me\x12Q\n\tazureFile\x18\r\x20\x01(\x0b23.k8s.io.api.core.v1.AzureFilePe\
    rsistentVolumeSourceR\tazureFile\x12X\n\rvsphereVolume\x18\x0e\x20\x01(\
    \x0b22.k8s.io.api.core.v1.VsphereVirtualDiskVolumeSourceR\rvsphereVolume\
    \x12A\n\x07quobyte\x18\x0f\x20\x01(\x0b2'.k8s.io.api.core.v1.QuobyteVolu\
    meSourceR\x07quobyte\x12G\n\tazureDisk\x18\x10\x20\x01(\x0b2).k8s.io.api\
    .core.v1.AzureDiskVolumeSourceR\tazureDisk\x12h\n\x14photonPersistentDis\
    k\x18\x11\x20\x01(\x0b24.k8s.io.api.core.v1.PhotonPersistentDiskVolumeSo\
    urceR\x14photonPersistentDisk\x12P\n\x0eportworxVolume\x18\x12\x20\x01(\
    \x0b2(.k8s.io.api.core.v1.PortworxVolumeSourceR\x0eportworxVolume\x12K\n\
    \x07scaleIO\x18\x13\x20\x01(\x0b21.k8s.io.api.core.v1.ScaleIOPersistentV\
    olumeSourceR\x07scaleIO\x12;\n\x05local\x18\x14\x20\x01(\x0b2%.k8s.io.ap\
    i.core.v1.LocalVolumeSourceR\x05local\x12Q\n\tstorageos\x18\x15\x20\x01(\
    \x0b23.k8s.io.api.core.v1.StorageOSPersistentVolumeSourceR\tstorageos\
    \x12?\n\x03csi\x18\x16\x20\x01(\x0b2-.k8s.io.api.core.v1.CSIPersistentVo\
    lumeSourceR\x03csi\"\xa0\x05\n\x14PersistentVolumeSpec\x12R\n\x08capacit\
    y\x18\x01\x20\x03(\x0b26.k8s.io.api.core.v1.PersistentVolumeSpec.Capacit\
    yEntryR\x08capacity\x12b\n\x16persistentVolumeSource\x18\x02\x20\x01(\
    \x0b2*.k8s.io.api.core.v1.PersistentVolumeSourceR\x16persistentVolumeSou\
    rce\x12\x20\n\x0baccessModes\x18\x03\x20\x03(\tR\x0baccessModes\x12?\n\
    \x08claimRef\x18\x04\x20\x01(\x0b2#.k8s.io.api.core.v1.ObjectReferenceR\
    \x08claimRef\x12D\n\x1dpersistentVolumeReclaimPolicy\x18\x05\x20\x01(\tR\
    \x1dpersistentVolumeReclaimPolicy\x12*\n\x10storageClassName\x18\x06\x20\
    \x01(\tR\x10storageClassName\x12\"\n\x0cmountOptions\x18\x07\x20\x03(\tR\
    \x0cmountOptions\x12\x1e\n\nvolumeMode\x18\x08\x20\x01(\tR\nvolumeMode\
    \x12J\n\x0cnodeAffinity\x18\t\x20\x01(\x0b2&.k8s.io.api.core.v1.VolumeNo\
    deAffinityR\x0cnodeAffinity\x1ak\n\rCapacityEntry\x12\x10\n\x03key\x18\
    \x01\x20\x01(\tR\x03key\x12D\n\x05value\x18\x02\x20\x01(\x0b2..k8s.io.ap\
    imachinery.pkg.api.resource.QuantityR\x05value:\x028\x01\"`\n\x16Persist\
    entVolumeStatus\x12\x14\n\x05phase\x18\x01\x20\x01(\tR\x05phase\x12\x18\
    \n\x07message\x18\x02\x20\x01(\tR\x07message\x12\x16\n\x06reason\x18\x03\
    \x20\x01(\tR\x06reason\"N\n\x20PhotonPersistentDiskVolumeSource\x12\x12\
    \n\x04pdID\x18\x01\x20\x01(\tR\x04pdID\x12\x16\n\x06fsType\x18\x02\x20\
    \x01(\tR\x06fsType\"\xbb\x01\n\x03Pod\x12L\n\x08metadata\x18\x01\x20\x01\
    (\x0b20.k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMetaR\x08metadata\x12\
    /\n\x04spec\x18\x02\x20\x01(\x0b2\x1b.k8s.io.api.core.v1.PodSpecR\x04spe\
    c\x125\n\x06status\x18\x03\x20\x01(\x0b2\x1d.k8s.io.api.core.v1.PodStatu\
    sR\x06status\"\xb3\x02\n\x0bPodAffinity\x12\x8b\x01\n.requiredDuringSche\
    dulingIgnoredDuringExecution\x18\x01\x20\x03(\x0b2#.k8s.io.api.core.v1.P\
    odAffinityTermR.requiredDuringSchedulingIgnoredDuringExecution\x12\x95\
    \x01\n/preferredDuringSchedulingIgnoredDuringExecution\x18\x02\x20\x03(\
    \x0b2+.k8s.io.api.core.v1.WeightedPodAffinityTermR/preferredDuringSchedu\
    lingIgnoredDuringExecution\"\xae\x01\n\x0fPodAffinityTerm\x12Y\n\rlabelS\
    elector\x18\x01\x20\x01(\x0b23.k8s.io.apimachinery.pkg.apis.meta.v1.Labe\
    lSelectorR\rlabelSelector\x12\x1e\n\nnamespaces\x18\x02\x20\x03(\tR\nnam\
    espaces\x12\x20\n\x0btopologyKey\x18\x03\x20\x01(\tR\x0btopologyKey\"\
    \xb7\x02\n\x0fPodAntiAffinity\x12\x8b\x01\n.requiredDuringSchedulingIgno\
    redDuringExecution\x18\x01\x20\x03(\x0b2#.k8s.io.api.core.v1.PodAffinity\
    TermR.requiredDuringSchedulingIgnoredDuringExecution\x12\x95\x01\n/prefe\
    rredDuringSchedulingIgnoredDuringExecution\x18\x02\x20\x03(\x0b2+.k8s.io\
    .api.core.v1.WeightedPodAffinityTermR/preferredDuringSchedulingIgnoredDu\
    ringExecution\"\x88\x01\n\x10PodAttachOptions\x12\x14\n\x05stdin\x18\x01\
    \x20\x01(\x08R\x05stdin\x12\x16\n\x06stdout\x18\x02\x20\x01(\x08R\x06std\
    out\x12\x16\n\x06stderr\x18\x03\x20\x01(\x08R\x06stderr\x12\x10\n\x03tty\
    \x18\x04\x20\x01(\x08R\x03tty\x12\x1c\n\tcontainer\x18\x05\x20\x01(\tR\t\
    container\"\x9a\x02\n\x0cPodCondition\x12\x12\n\x04type\x18\x01\x20\x01(\
    \tR\x04type\x12\x16\n\x06status\x18\x02\x20\x01(\tR\x06status\x12P\n\rla\
    stProbeTime\x18\x03\x20\x01(\x0b2*.k8s.io.apimachinery.pkg.apis.meta.v1.\
    TimeR\rlastProbeTime\x12Z\n\x12lastTransitionTime\x18\x04\x20\x01(\x0b2*\
    .k8s.io.apimachinery.pkg.apis.meta.v1.TimeR\x12lastTransitionTime\x12\
    \x16\n\x06reason\x18\x05\x20\x01(\tR\x06reason\x12\x18\n\x07message\x18\
    \x06\x20\x01(\tR\x07message\"\x8e\x01\n\x0cPodDNSConfig\x12\x20\n\x0bnam\
    eservers\x18\x01\x20\x03(\tR\x0bnameservers\x12\x1a\n\x08searches\x18\
    \x02\x20\x03(\tR\x08searches\x12@\n\x07options\x18\x03\x20\x03(\x0b2&.k8\
    s.io.api.core.v1.PodDNSConfigOptionR\x07options\">\n\x12PodDNSConfigOpti\
    on\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\x14\n\x05value\x18\
    \x02\x20\x01(\tR\x05value\"\xa0\x01\n\x0ePodExecOptions\x12\x14\n\x05std\
    in\x18\x01\x20\x01(\x08R\x05stdin\x12\x16\n\x06stdout\x18\x02\x20\x01(\
    \x08R\x06stdout\x12\x16\n\x06stderr\x18\x03\x20\x01(\x08R\x06stderr\x12\
    \x10\n\x03tty\x18\x04\x20\x01(\x08R\x03tty\x12\x1c\n\tcontainer\x18\x05\
    \x20\x01(\tR\tcontainer\x12\x18\n\x07command\x18\x06\x20\x03(\tR\x07comm\
    and\"\x17\n\x05PodIP\x12\x0e\n\x02ip\x18\x01\x20\x01(\tR\x02ip\"\x84\x01\
    \n\x07PodList\x12J\n\x08metadata\x18\x01\x20\x01(\x0b2..k8s.io.apimachin\
    ery.pkg.apis.meta.v1.ListMetaR\x08metadata\x12-\n\x05items\x18\x02\x20\
    \x03(\x0b2\x17.k8s.io.api.core.v1.PodR\x05items\"\xf1\x02\n\rPodLogOptio\
    ns\x12\x1c\n\tcontainer\x18\x01\x20\x01(\tR\tcontainer\x12\x16\n\x06foll\
    ow\x18\x02\x20\x01(\x08R\x06follow\x12\x1a\n\x08previous\x18\x03\x20\x01\
    (\x08R\x08previous\x12\"\n\x0csinceSeconds\x18\x04\x20\x01(\x03R\x0csinc\
    eSeconds\x12H\n\tsinceTime\x18\x05\x20\x01(\x0b2*.k8s.io.apimachinery.pk\
    g.apis.meta.v1.TimeR\tsinceTime\x12\x1e\n\ntimestamps\x18\x06\x20\x01(\
    \x08R\ntimestamps\x12\x1c\n\ttailLines\x18\x07\x20\x01(\x03R\ttailLines\
    \x12\x1e\n\nlimitBytes\x18\x08\x20\x01(\x03R\nlimitBytes\x12B\n\x1cinsec\
    ureSkipTLSVerifyBackend\x18\t\x20\x01(\x08R\x1cinsecureSkipTLSVerifyBack\
    end\"-\n\x15PodPortForwardOptions\x12\x14\n\x05ports\x18\x01\x20\x03(\
    \x05R\x05ports\"%\n\x0fPodProxyOptions\x12\x12\n\x04path\x18\x01\x20\x01\
    (\tR\x04path\"8\n\x10PodReadinessGate\x12$\n\rconditionType\x18\x01\x20\
    \x01(\tR\rconditionType\"\x9b\x04\n\x12PodSecurityContext\x12J\n\x0eseLi\
    nuxOptions\x18\x01\x20\x01(\x0b2\".k8s.io.api.core.v1.SELinuxOptionsR\
    \x0eseLinuxOptions\x12Y\n\x0ewindowsOptions\x18\x08\x20\x01(\x0b21.k8s.i\
    o.api.core.v1.WindowsSecurityContextOptionsR\x0ewindowsOptions\x12\x1c\n\
    \trunAsUser\x18\x02\x20\x01(\x03R\trunAsUser\x12\x1e\n\nrunAsGroup\x18\
    \x06\x20\x01(\x03R\nrunAsGroup\x12\"\n\x0crunAsNonRoot\x18\x03\x20\x01(\
    \x08R\x0crunAsNonRoot\x12.\n\x12supplementalGroups\x18\x04\x20\x03(\x03R\
    \x12supplementalGroups\x12\x18\n\x07fsGroup\x18\x05\x20\x01(\x03R\x07fsG\
    roup\x124\n\x07sysctls\x18\x07\x20\x03(\x0b2\x1a.k8s.io.api.core.v1.Sysc\
    tlR\x07sysctls\x120\n\x13fsGroupChangePolicy\x18\t\x20\x01(\tR\x13fsGrou\
    pChangePolicy\x12J\n\x0eseccompProfile\x18\n\x20\x01(\x0b2\".k8s.io.api.\
    core.v1.SeccompProfileR\x0eseccompProfile\"j\n\x0cPodSignature\x12Z\n\rp\
    odController\x18\x01\x20\x01(\x0b24.k8s.io.apimachinery.pkg.apis.meta.v1\
    .OwnerReferenceR\rpodController\"\xaa\x10\n\x07PodSpec\x124\n\x07volumes\
    \x18\x01\x20\x03(\x0b2\x1a.k8s.io.api.core.v1.VolumeR\x07volumes\x12E\n\
    \x0einitContainers\x18\x14\x20\x03(\x0b2\x1d.k8s.io.api.core.v1.Containe\
    rR\x0einitContainers\x12=\n\ncontainers\x18\x02\x20\x03(\x0b2\x1d.k8s.io\
    .api.core.v1.ContainerR\ncontainers\x12X\n\x13ephemeralContainers\x18\"\
    \x20\x03(\x0b2&.k8s.io.api.core.v1.EphemeralContainerR\x13ephemeralConta\
    iners\x12$\n\rrestartPolicy\x18\x03\x20\x01(\tR\rrestartPolicy\x12D\n\
    \x1dterminationGracePeriodSeconds\x18\x04\x20\x01(\x03R\x1dterminationGr\
    acePeriodSeconds\x124\n\x15activeDeadlineSeconds\x18\x05\x20\x01(\x03R\
    \x15activeDeadlineSeconds\x12\x1c\n\tdnsPolicy\x18\x06\x20\x01(\tR\tdnsP\
    olicy\x12Q\n\x0cnodeSelector\x18\x07\x20\x03(\x0b2-.k8s.io.api.core.v1.P\
    odSpec.NodeSelectorEntryR\x0cnodeSelector\x12.\n\x12serviceAccountName\
    \x18\x08\x20\x01(\tR\x12serviceAccountName\x12&\n\x0eserviceAccount\x18\
    \t\x20\x01(\tR\x0eserviceAccount\x12B\n\x1cautomountServiceAccountToken\
    \x18\x15\x20\x01(\x08R\x1cautomountServiceAccountToken\x12\x1a\n\x08node\
    Name\x18\n\x20\x01(\tR\x08nodeName\x12\x20\n\x0bhostNetwork\x18\x0b\x20\
    \x01(\x08R\x0bhostNetwork\x12\x18\n\x07hostPID\x18\x0c\x20\x01(\x08R\x07\
    hostPID\x12\x18\n\x07hostIPC\x18\r\x20\x01(\x08R\x07hostIPC\x124\n\x15sh\
    areProcessNamespace\x18\x1b\x20\x01(\x08R\x15shareProcessNamespace\x12P\
    \n\x0fsecurityContext\x18\x0e\x20\x01(\x0b2&.k8s.io.api.core.v1.PodSecur\
    ityContextR\x0fsecurityContext\x12T\n\x10imagePullSecrets\x18\x0f\x20\
    \x03(\x0b2(.k8s.io.api.core.v1.LocalObjectReferenceR\x10imagePullSecrets\
    \x12\x1a\n\x08hostname\x18\x10\x20\x01(\tR\x08hostname\x12\x1c\n\tsubdom\
    ain\x18\x11\x20\x01(\tR\tsubdomain\x128\n\x08affinity\x18\x12\x20\x01(\
    \x0b2\x1c.k8s.io.api.core.v1.AffinityR\x08affinity\x12$\n\rschedulerName\
    \x18\x13\x20\x01(\tR\rschedulerName\x12@\n\x0btolerations\x18\x16\x20\
    \x03(\x0b2\x1e.k8s.io.api.core.v1.TolerationR\x0btolerations\x12?\n\x0bh\
    ostAliases\x18\x17\x20\x03(\x0b2\x1d.k8s.io.api.core.v1.HostAliasR\x0bho\
    stAliases\x12,\n\x11priorityClassName\x18\x18\x20\x01(\tR\x11priorityCla\
    ssName\x12\x1a\n\x08priority\x18\x19\x20\x01(\x05R\x08priority\x12>\n\td\
    nsConfig\x18\x1a\x20\x01(\x0b2\x20.k8s.io.api.core.v1.PodDNSConfigR\tdns\
    Config\x12L\n\x0ereadinessGates\x18\x1c\x20\x03(\x0b2$.k8s.io.api.core.v\
    1.PodReadinessGateR\x0ereadinessGates\x12*\n\x10runtimeClassName\x18\x1d\
    \x20\x01(\tR\x10runtimeClassName\x12.\n\x12enableServiceLinks\x18\x1e\
    \x20\x01(\x08R\x12enableServiceLinks\x12*\n\x10preemptionPolicy\x18\x1f\
    \x20\x01(\tR\x10preemptionPolicy\x12E\n\x08overhead\x18\x20\x20\x03(\x0b\
    2).k8s.io.api.core.v1.PodSpec.OverheadEntryR\x08overhead\x12j\n\x19topol\
    ogySpreadConstraints\x18!\x20\x03(\x0b2,.k8s.io.api.core.v1.TopologySpre\
    adConstraintR\x19topologySpreadConstraints\x12,\n\x11setHostnameAsFQDN\
    \x18#\x20\x01(\x08R\x11setHostnameAsFQDN\x1a?\n\x11NodeSelectorEntry\x12\
    \x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\
    \x01(\tR\x05value:\x028\x01\x1ak\n\rOverheadEntry\x12\x10\n\x03key\x18\
    \x01\x20\x01(\tR\x03key\x12D\n\x05value\x18\x02\x20\x01(\x0b2..k8s.io.ap\
    imachinery.pkg.api.resource.QuantityR\x05value:\x028\x01\"\x9d\x05\n\tPo\
    dStatus\x12\x14\n\x05phase\x18\x01\x20\x01(\tR\x05phase\x12@\n\nconditio\
    ns\x18\x02\x20\x03(\x0b2\x20.k8s.io.api.core.v1.PodConditionR\ncondition\
    s\x12\x18\n\x07message\x18\x03\x20\x01(\tR\x07message\x12\x16\n\x06reaso\
    n\x18\x04\x20\x01(\tR\x06reason\x12,\n\x11nominatedNodeName\x18\x0b\x20\
    \x01(\tR\x11nominatedNodeName\x12\x16\n\x06hostIP\x18\x05\x20\x01(\tR\
    \x06hostIP\x12\x14\n\x05podIP\x18\x06\x20\x01(\tR\x05podIP\x121\n\x06pod\
    IPs\x18\x0c\x20\x03(\x0b2\x19.k8s.io.api.core.v1.PodIPR\x06podIPs\x12H\n\
    \tstartTime\x18\x07\x20\x01(\x0b2*.k8s.io.apimachinery.pkg.apis.meta.v1.\
    TimeR\tstartTime\x12Y\n\x15initContainerStatuses\x18\n\x20\x03(\x0b2#.k8\
    s.io.api.core.v1.ContainerStatusR\x15initContainerStatuses\x12Q\n\x11con\
    tainerStatuses\x18\x08\x20\x03(\x0b2#.k8s.io.api.core.v1.ContainerStatus\
    R\x11containerStatuses\x12\x1a\n\x08qosClass\x18\t\x20\x01(\tR\x08qosCla\
    ss\x12c\n\x1aephemeralContainerStatuses\x18\r\x20\x03(\x0b2#.k8s.io.api.\
    core.v1.ContainerStatusR\x1aephemeralContainerStatuses\"\x96\x01\n\x0fPo\
    dStatusResult\x12L\n\x08metadata\x18\x01\x20\x01(\x0b20.k8s.io.apimachin\
    ery.pkg.apis.meta.v1.ObjectMetaR\x08metadata\x125\n\x06status\x18\x02\
    \x20\x01(\x0b2\x1d.k8s.io.api.core.v1.PodStatusR\x06status\"\x9c\x01\n\
    \x0bPodTemplate\x12L\n\x08metadata\x18\x01\x20\x01(\x0b20.k8s.io.apimach\
    inery.pkg.apis.meta.v1.ObjectMetaR\x08metadata\x12?\n\x08template\x18\
    \x02\x20\x01(\x0b2#.k8s.io.api.core.v1.PodTemplateSpecR\x08template\"\
    \x94\x01\n\x0fPodTemplateList\x12J\n\x08metadata\x18\x01\x20\x01(\x0b2..\
    k8s.io.apimachinery.pkg.apis.meta.v1.ListMetaR\x08metadata\x125\n\x05ite\
    ms\x18\x02\x20\x03(\x0b2\x1f.k8s.io.api.core.v1.PodTemplateR\x05items\"\
    \x90\x01\n\x0fPodTemplateSpec\x12L\n\x08metadata\x18\x01\x20\x01(\x0b20.\
    k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMetaR\x08metadata\x12/\n\x04s\
    pec\x18\x02\x20\x01(\x0b2\x1b.k8s.io.api.core.v1.PodSpecR\x04spec\"R\n\n\
    PortStatus\x12\x12\n\x04port\x18\x01\x20\x01(\x05R\x04port\x12\x1a\n\x08\
    protocol\x18\x02\x20\x01(\tR\x08protocol\x12\x14\n\x05error\x18\x03\x20\
    \x01(\tR\x05error\"f\n\x14PortworxVolumeSource\x12\x1a\n\x08volumeID\x18\
    \x01\x20\x01(\tR\x08volumeID\x12\x16\n\x06fsType\x18\x02\x20\x01(\tR\x06\
    fsType\x12\x1a\n\x08readOnly\x18\x03\x20\x01(\x08R\x08readOnly\"!\n\rPre\
    conditions\x12\x10\n\x03uid\x18\x01\x20\x01(\tR\x03uid\"\xde\x01\n\x14Pr\
    eferAvoidPodsEntry\x12D\n\x0cpodSignature\x18\x01\x20\x01(\x0b2\x20.k8s.\
    io.api.core.v1.PodSignatureR\x0cpodSignature\x12N\n\x0cevictionTime\x18\
    \x02\x20\x01(\x0b2*.k8s.io.apimachinery.pkg.apis.meta.v1.TimeR\x0cevicti\
    onTime\x12\x16\n\x06reason\x18\x03\x20\x01(\tR\x06reason\x12\x18\n\x07me\
    ssage\x18\x04\x20\x01(\tR\x07message\"w\n\x17PreferredSchedulingTerm\x12\
    \x16\n\x06weight\x18\x01\x20\x01(\x05R\x06weight\x12D\n\npreference\x18\
    \x02\x20\x01(\x0b2$.k8s.io.api.core.v1.NodeSelectorTermR\npreference\"\
    \x96\x02\n\x05Probe\x125\n\x07handler\x18\x01\x20\x01(\x0b2\x1b.k8s.io.a\
    pi.core.v1.HandlerR\x07handler\x120\n\x13initialDelaySeconds\x18\x02\x20\
    \x01(\x05R\x13initialDelaySeconds\x12&\n\x0etimeoutSeconds\x18\x03\x20\
    \x01(\x05R\x0etimeoutSeconds\x12$\n\rperiodSeconds\x18\x04\x20\x01(\x05R\
    \rperiodSeconds\x12*\n\x10successThreshold\x18\x05\x20\x01(\x05R\x10succ\
    essThreshold\x12*\n\x10failureThreshold\x18\x06\x20\x01(\x05R\x10failure\
    Threshold\"y\n\x15ProjectedVolumeSource\x12>\n\x07sources\x18\x01\x20\
    \x03(\x0b2$.k8s.io.api.core.v1.VolumeProjectionR\x07sources\x12\x20\n\
    \x0bdefaultMode\x18\x02\x20\x01(\x05R\x0bdefaultMode\"\xa7\x01\n\x13Quob\
    yteVolumeSource\x12\x1a\n\x08registry\x18\x01\x20\x01(\tR\x08registry\
    \x12\x16\n\x06volume\x18\x02\x20\x01(\tR\x06volume\x12\x1a\n\x08readOnly\
    \x18\x03\x20\x01(\x08R\x08readOnly\x12\x12\n\x04user\x18\x04\x20\x01(\tR\
    \x04user\x12\x14\n\x05group\x18\x05\x20\x01(\tR\x05group\x12\x16\n\x06te\
    nant\x18\x06\x20\x01(\tR\x06tenant\"\x86\x02\n\x19RBDPersistentVolumeSou\
    rce\x12\x1a\n\x08monitors\x18\x01\x20\x03(\tR\x08monitors\x12\x14\n\x05i\
    mage\x18\x02\x20\x01(\tR\x05image\x12\x16\n\x06fsType\x18\x03\x20\x01(\t\
    R\x06fsType\x12\x12\n\x04pool\x18\x04\x20\x01(\tR\x04pool\x12\x12\n\x04u\
    ser\x18\x05\x20\x01(\tR\x04user\x12\x18\n\x07keyring\x18\x06\x20\x01(\tR\
    \x07keyring\x12A\n\tsecretRef\x18\x07\x20\x01(\x0b2#.k8s.io.api.core.v1.\
    SecretReferenceR\tsecretRef\x12\x1a\n\x08readOnly\x18\x08\x20\x01(\x08R\
    \x08readOnly\"\x81\x02\n\x0fRBDVolumeSource\x12\x1a\n\x08monitors\x18\
    \x01\x20\x03(\tR\x08monitors\x12\x14\n\x05image\x18\x02\x20\x01(\tR\x05i\
    mage\x12\x16\n\x06fsType\x18\x03\x20\x01(\tR\x06fsType\x12\x12\n\x04pool\
    \x18\x04\x20\x01(\tR\x04pool\x12\x12\n\x04user\x18\x05\x20\x01(\tR\x04us\
    er\x12\x18\n\x07keyring\x18\x06\x20\x01(\tR\x07keyring\x12F\n\tsecretRef\
    \x18\x07\x20\x01(\x0b2(.k8s.io.api.core.v1.LocalObjectReferenceR\tsecret\
    Ref\x12\x1a\n\x08readOnly\x18\x08\x20\x01(\x08R\x08readOnly\"\x89\x01\n\
    \x0fRangeAllocation\x12L\n\x08metadata\x18\x01\x20\x01(\x0b20.k8s.io.api\
    machinery.pkg.apis.meta.v1.ObjectMetaR\x08metadata\x12\x14\n\x05range\
    \x18\x02\x20\x01(\tR\x05range\x12\x12\n\x04data\x18\x03\x20\x01(\x0cR\
    \x04data\"\xf1\x01\n\x15ReplicationController\x12L\n\x08metadata\x18\x01\
    \x20\x01(\x0b20.k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMetaR\x08meta\
    data\x12A\n\x04spec\x18\x02\x20\x01(\x0b2-.k8s.io.api.core.v1.Replicatio\
    nControllerSpecR\x04spec\x12G\n\x06status\x18\x03\x20\x01(\x0b2/.k8s.io.\
    api.core.v1.ReplicationControllerStatusR\x06status\"\xda\x01\n\x1eReplic\
    ationControllerCondition\x12\x12\n\x04type\x18\x01\x20\x01(\tR\x04type\
    \x12\x16\n\x06status\x18\x02\x20\x01(\tR\x06status\x12Z\n\x12lastTransit\
    ionTime\x18\x03\x20\x01(\x0b2*.k8s.io.apimachinery.pkg.apis.meta.v1.Time\
    R\x12lastTransitionTime\x12\x16\n\x06reason\x18\x04\x20\x01(\tR\x06reaso\
    n\x12\x18\n\x07message\x18\x05\x20\x01(\tR\x07message\"\xa8\x01\n\x19Rep\
    licationControllerList\x12J\n\x08metadata\x18\x01\x20\x01(\x0b2..k8s.io.\
    apimachinery.pkg.apis.meta.v1.ListMetaR\x08metadata\x12?\n\x05items\x18\
    \x02\x20\x03(\x0b2).k8s.io.api.core.v1.ReplicationControllerR\x05items\"\
    \xb8\x02\n\x19ReplicationControllerSpec\x12\x1a\n\x08replicas\x18\x01\
    \x20\x01(\x05R\x08replicas\x12(\n\x0fminReadySeconds\x18\x04\x20\x01(\
    \x05R\x0fminReadySeconds\x12W\n\x08selector\x18\x02\x20\x03(\x0b2;.k8s.i\
    o.api.core.v1.ReplicationControllerSpec.SelectorEntryR\x08selector\x12?\
    \n\x08template\x18\x03\x20\x01(\x0b2#.k8s.io.api.core.v1.PodTemplateSpec\
    R\x08template\x1a;\n\rSelectorEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\
    \x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x028\x01\"\xc5\
    \x02\n\x1bReplicationControllerStatus\x12\x1a\n\x08replicas\x18\x01\x20\
    \x01(\x05R\x08replicas\x122\n\x14fullyLabeledReplicas\x18\x02\x20\x01(\
    \x05R\x14fullyLabeledReplicas\x12$\n\rreadyReplicas\x18\x04\x20\x01(\x05\
    R\rreadyReplicas\x12,\n\x11availableReplicas\x18\x05\x20\x01(\x05R\x11av\
    ailableReplicas\x12.\n\x12observedGeneration\x18\x03\x20\x01(\x03R\x12ob\
    servedGeneration\x12R\n\nconditions\x18\x06\x20\x03(\x0b22.k8s.io.api.co\
    re.v1.ReplicationControllerConditionR\nconditions\"\xa3\x01\n\x15Resourc\
    eFieldSelector\x12$\n\rcontainerName\x18\x01\x20\x01(\tR\rcontainerName\
    \x12\x1a\n\x08resource\x18\x02\x20\x01(\tR\x08resource\x12H\n\x07divisor\
    \x18\x03\x20\x01(\x0b2..k8s.io.apimachinery.pkg.api.resource.QuantityR\
    \x07divisor\"\xd9\x01\n\rResourceQuota\x12L\n\x08metadata\x18\x01\x20\
    \x01(\x0b20.k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMetaR\x08metadata\
    \x129\n\x04spec\x18\x02\x20\x01(\x0b2%.k8s.io.api.core.v1.ResourceQuotaS\
    pecR\x04spec\x12?\n\x06status\x18\x03\x20\x01(\x0b2'.k8s.io.api.core.v1.\
    ResourceQuotaStatusR\x06status\"\x98\x01\n\x11ResourceQuotaList\x12J\n\
    \x08metadata\x18\x01\x20\x01(\x0b2..k8s.io.apimachinery.pkg.apis.meta.v1\
    .ListMetaR\x08metadata\x127\n\x05items\x18\x02\x20\x03(\x0b2!.k8s.io.api\
    .core.v1.ResourceQuotaR\x05items\"\xa2\x02\n\x11ResourceQuotaSpec\x12C\n\
    \x04hard\x18\x01\x20\x03(\x0b2/.k8s.io.api.core.v1.ResourceQuotaSpec.Har\
    dEntryR\x04hard\x12\x16\n\x06scopes\x18\x02\x20\x03(\tR\x06scopes\x12G\n\
    \rscopeSelector\x18\x03\x20\x01(\x0b2!.k8s.io.api.core.v1.ScopeSelectorR\
    \rscopeSelector\x1ag\n\tHardEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\
    \x03key\x12D\n\x05value\x18\x02\x20\x01(\x0b2..k8s.io.apimachinery.pkg.a\
    pi.resource.QuantityR\x05value:\x028\x01\"\xf5\x02\n\x13ResourceQuotaSta\
    tus\x12E\n\x04hard\x18\x01\x20\x03(\x0b21.k8s.io.api.core.v1.ResourceQuo\
    taStatus.HardEntryR\x04hard\x12E\n\x04used\x18\x02\x20\x03(\x0b21.k8s.io\
    .api.core.v1.ResourceQuotaStatus.UsedEntryR\x04used\x1ag\n\tHardEntry\
    \x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12D\n\x05value\x18\x02\x20\
    \x01(\x0b2..k8s.io.apimachinery.pkg.api.resource.QuantityR\x05value:\x02\
    8\x01\x1ag\n\tUsedEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12D\
    \n\x05value\x18\x02\x20\x01(\x0b2..k8s.io.apimachinery.pkg.api.resource.\
    QuantityR\x05value:\x028\x01\"\x90\x03\n\x14ResourceRequirements\x12L\n\
    \x06limits\x18\x01\x20\x03(\x0b24.k8s.io.api.core.v1.ResourceRequirement\
    s.LimitsEntryR\x06limits\x12R\n\x08requests\x18\x02\x20\x03(\x0b26.k8s.i\
    o.api.core.v1.ResourceRequirements.RequestsEntryR\x08requests\x1ai\n\x0b\
    LimitsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12D\n\x05value\
    \x18\x02\x20\x01(\x0b2..k8s.io.apimachinery.pkg.api.resource.QuantityR\
    \x05value:\x028\x01\x1ak\n\rRequestsEntry\x12\x10\n\x03key\x18\x01\x20\
    \x01(\tR\x03key\x12D\n\x05value\x18\x02\x20\x01(\x0b2..k8s.io.apimachine\
    ry.pkg.api.resource.QuantityR\x05value:\x028\x01\"b\n\x0eSELinuxOptions\
    \x12\x12\n\x04user\x18\x01\x20\x01(\tR\x04user\x12\x12\n\x04role\x18\x02\
    \x20\x01(\tR\x04role\x12\x12\n\x04type\x18\x03\x20\x01(\tR\x04type\x12\
    \x14\n\x05level\x18\x04\x20\x01(\tR\x05level\"\xf8\x02\n\x1dScaleIOPersi\
    stentVolumeSource\x12\x18\n\x07gateway\x18\x01\x20\x01(\tR\x07gateway\
    \x12\x16\n\x06system\x18\x02\x20\x01(\tR\x06system\x12A\n\tsecretRef\x18\
    \x03\x20\x01(\x0b2#.k8s.io.api.core.v1.SecretReferenceR\tsecretRef\x12\
    \x1e\n\nsslEnabled\x18\x04\x20\x01(\x08R\nsslEnabled\x12*\n\x10protectio\
    nDomain\x18\x05\x20\x01(\tR\x10protectionDomain\x12\x20\n\x0bstoragePool\
    \x18\x06\x20\x01(\tR\x0bstoragePool\x12\x20\n\x0bstorageMode\x18\x07\x20\
    \x01(\tR\x0bstorageMode\x12\x1e\n\nvolumeName\x18\x08\x20\x01(\tR\nvolum\
    eName\x12\x16\n\x06fsType\x18\t\x20\x01(\tR\x06fsType\x12\x1a\n\x08readO\
    nly\x18\n\x20\x01(\x08R\x08readOnly\"\xf3\x02\n\x13ScaleIOVolumeSource\
    \x12\x18\n\x07gateway\x18\x01\x20\x01(\tR\x07gateway\x12\x16\n\x06system\
    \x18\x02\x20\x01(\tR\x06system\x12F\n\tsecretRef\x18\x03\x20\x01(\x0b2(.\
    k8s.io.api.core.v1.LocalObjectReferenceR\tsecretRef\x12\x1e\n\nsslEnable\
    d\x18\x04\x20\x01(\x08R\nsslEnabled\x12*\n\x10protectionDomain\x18\x05\
    \x20\x01(\tR\x10protectionDomain\x12\x20\n\x0bstoragePool\x18\x06\x20\
    \x01(\tR\x0bstoragePool\x12\x20\n\x0bstorageMode\x18\x07\x20\x01(\tR\x0b\
    storageMode\x12\x1e\n\nvolumeName\x18\x08\x20\x01(\tR\nvolumeName\x12\
    \x16\n\x06fsType\x18\t\x20\x01(\tR\x06fsType\x12\x1a\n\x08readOnly\x18\n\
    \x20\x01(\x08R\x08readOnly\"r\n\rScopeSelector\x12a\n\x10matchExpression\
    s\x18\x01\x20\x03(\x0b25.k8s.io.api.core.v1.ScopedResourceSelectorRequir\
    ementR\x10matchExpressions\"u\n!ScopedResourceSelectorRequirement\x12\
    \x1c\n\tscopeName\x18\x01\x20\x01(\tR\tscopeName\x12\x1a\n\x08operator\
    \x18\x02\x20\x01(\tR\x08operator\x12\x16\n\x06values\x18\x03\x20\x03(\tR\
    \x06values\"P\n\x0eSeccompProfile\x12\x12\n\x04type\x18\x01\x20\x01(\tR\
    \x04type\x12*\n\x10localhostProfile\x18\x02\x20\x01(\tR\x10localhostProf\
    ile\"\x86\x03\n\x06Secret\x12L\n\x08metadata\x18\x01\x20\x01(\x0b20.k8s.\
    io.apimachinery.pkg.apis.meta.v1.ObjectMetaR\x08metadata\x12\x1c\n\timmu\
    table\x18\x05\x20\x01(\x08R\timmutable\x128\n\x04data\x18\x02\x20\x03(\
    \x0b2$.k8s.io.api.core.v1.Secret.DataEntryR\x04data\x12J\n\nstringData\
    \x18\x04\x20\x03(\x0b2*.k8s.io.api.core.v1.Secret.StringDataEntryR\nstri\
    ngData\x12\x12\n\x04type\x18\x03\x20\x01(\tR\x04type\x1a7\n\tDataEntry\
    \x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\
    \x20\x01(\x0cR\x05value:\x028\x01\x1a=\n\x0fStringDataEntry\x12\x10\n\
    \x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\t\
    R\x05value:\x028\x01\"\x8b\x01\n\x0fSecretEnvSource\x12\\\n\x14localObje\
    ctReference\x18\x01\x20\x01(\x0b2(.k8s.io.api.core.v1.LocalObjectReferen\
    ceR\x14localObjectReference\x12\x1a\n\x08optional\x18\x02\x20\x01(\x08R\
    \x08optional\"\x9f\x01\n\x11SecretKeySelector\x12\\\n\x14localObjectRefe\
    rence\x18\x01\x20\x01(\x0b2(.k8s.io.api.core.v1.LocalObjectReferenceR\
    \x14localObjectReference\x12\x10\n\x03key\x18\x02\x20\x01(\tR\x03key\x12\
    \x1a\n\x08optional\x18\x03\x20\x01(\x08R\x08optional\"\x8a\x01\n\nSecret\
    List\x12J\n\x08metadata\x18\x01\x20\x01(\x0b2..k8s.io.apimachinery.pkg.a\
    pis.meta.v1.ListMetaR\x08metadata\x120\n\x05items\x18\x02\x20\x03(\x0b2\
    \x1a.k8s.io.api.core.v1.SecretR\x05items\"\xc1\x01\n\x10SecretProjection\
    \x12\\\n\x14localObjectReference\x18\x01\x20\x01(\x0b2(.k8s.io.api.core.\
    v1.LocalObjectReferenceR\x14localObjectReference\x123\n\x05items\x18\x02\
    \x20\x03(\x0b2\x1d.k8s.io.api.core.v1.KeyToPathR\x05items\x12\x1a\n\x08o\
    ptional\x18\x04\x20\x01(\x08R\x08optional\"C\n\x0fSecretReference\x12\
    \x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\x1c\n\tnamespace\x18\x02\
    \x20\x01(\tR\tnamespace\"\xa7\x01\n\x12SecretVolumeSource\x12\x1e\n\nsec\
    retName\x18\x01\x20\x01(\tR\nsecretName\x123\n\x05items\x18\x02\x20\x03(\
    \x0b2\x1d.k8s.io.api.core.v1.KeyToPathR\x05items\x12\x20\n\x0bdefaultMod\
    e\x18\x03\x20\x01(\x05R\x0bdefaultMode\x12\x1a\n\x08optional\x18\x04\x20\
    \x01(\x08R\x08optional\"\xde\x04\n\x0fSecurityContext\x12D\n\x0ccapabili\
    ties\x18\x01\x20\x01(\x0b2\x20.k8s.io.api.core.v1.CapabilitiesR\x0ccapab\
    ilities\x12\x1e\n\nprivileged\x18\x02\x20\x01(\x08R\nprivileged\x12J\n\
    \x0eseLinuxOptions\x18\x03\x20\x01(\x0b2\".k8s.io.api.core.v1.SELinuxOpt\
    ionsR\x0eseLinuxOptions\x12Y\n\x0ewindowsOptions\x18\n\x20\x01(\x0b21.k8\
    s.io.api.core.v1.WindowsSecurityContextOptionsR\x0ewindowsOptions\x12\
    \x1c\n\trunAsUser\x18\x04\x20\x01(\x03R\trunAsUser\x12\x1e\n\nrunAsGroup\
    \x18\x08\x20\x01(\x03R\nrunAsGroup\x12\"\n\x0crunAsNonRoot\x18\x05\x20\
    \x01(\x08R\x0crunAsNonRoot\x126\n\x16readOnlyRootFilesystem\x18\x06\x20\
    \x01(\x08R\x16readOnlyRootFilesystem\x12:\n\x18allowPrivilegeEscalation\
    \x18\x07\x20\x01(\x08R\x18allowPrivilegeEscalation\x12\x1c\n\tprocMount\
    \x18\t\x20\x01(\tR\tprocMount\x12J\n\x0eseccompProfile\x18\x0b\x20\x01(\
    \x0b2\".k8s.io.api.core.v1.SeccompProfileR\x0eseccompProfile\"X\n\x13Ser\
    ializedReference\x12A\n\treference\x18\x01\x20\x01(\x0b2#.k8s.io.api.cor\
    e.v1.ObjectReferenceR\treference\"\xc7\x01\n\x07Service\x12L\n\x08metada\
    ta\x18\x01\x20\x01(\x0b20.k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMet\
    aR\x08metadata\x123\n\x04spec\x18\x02\x20\x01(\x0b2\x1f.k8s.io.api.core.\
    v1.ServiceSpecR\x04spec\x129\n\x06status\x18\x03\x20\x01(\x0b2!.k8s.io.a\
    pi.core.v1.ServiceStatusR\x06status\"\xb7\x02\n\x0eServiceAccount\x12L\n\
    \x08metadata\x18\x01\x20\x01(\x0b20.k8s.io.apimachinery.pkg.apis.meta.v1\
    .ObjectMetaR\x08metadata\x12=\n\x07secrets\x18\x02\x20\x03(\x0b2#.k8s.io\
    .api.core.v1.ObjectReferenceR\x07secrets\x12T\n\x10imagePullSecrets\x18\
    \x03\x20\x03(\x0b2(.k8s.io.api.core.v1.LocalObjectReferenceR\x10imagePul\
    lSecrets\x12B\n\x1cautomountServiceAccountToken\x18\x04\x20\x01(\x08R\
    \x1cautomountServiceAccountToken\"\x9a\x01\n\x12ServiceAccountList\x12J\
    \n\x08metadata\x18\x01\x20\x01(\x0b2..k8s.io.apimachinery.pkg.apis.meta.\
    v1.ListMetaR\x08metadata\x128\n\x05items\x18\x02\x20\x03(\x0b2\".k8s.io.\
    api.core.v1.ServiceAccountR\x05items\"}\n\x1dServiceAccountTokenProjecti\
    on\x12\x1a\n\x08audience\x18\x01\x20\x01(\tR\x08audience\x12,\n\x11expir\
    ationSeconds\x18\x02\x20\x01(\x03R\x11expirationSeconds\x12\x12\n\x04pat\
    h\x18\x03\x20\x01(\tR\x04path\"\x8c\x01\n\x0bServiceList\x12J\n\x08metad\
    ata\x18\x01\x20\x01(\x0b2..k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta\
    R\x08metadata\x121\n\x05items\x18\x02\x20\x03(\x0b2\x1b.k8s.io.api.core.\
    v1.ServiceR\x05items\"\xe1\x01\n\x0bServicePort\x12\x12\n\x04name\x18\
    \x01\x20\x01(\tR\x04name\x12\x1a\n\x08protocol\x18\x02\x20\x01(\tR\x08pr\
    otocol\x12\x20\n\x0bappProtocol\x18\x06\x20\x01(\tR\x0bappProtocol\x12\
    \x12\n\x04port\x18\x03\x20\x01(\x05R\x04port\x12P\n\ntargetPort\x18\x04\
    \x20\x01(\x0b20.k8s.io.apimachinery.pkg.util.intstr.IntOrStringR\ntarget\
    Port\x12\x1a\n\x08nodePort\x18\x05\x20\x01(\x05R\x08nodePort\")\n\x13Ser\
    viceProxyOptions\x12\x12\n\x04path\x18\x01\x20\x01(\tR\x04path\"\xa9\x07\
    \n\x0bServiceSpec\x125\n\x05ports\x18\x01\x20\x03(\x0b2\x1f.k8s.io.api.c\
    ore.v1.ServicePortR\x05ports\x12I\n\x08selector\x18\x02\x20\x03(\x0b2-.k\
    8s.io.api.core.v1.ServiceSpec.SelectorEntryR\x08selector\x12\x1c\n\tclus\
    terIP\x18\x03\x20\x01(\tR\tclusterIP\x12\x1e\n\nclusterIPs\x18\x12\x20\
    \x03(\tR\nclusterIPs\x12\x12\n\x04type\x18\x04\x20\x01(\tR\x04type\x12\
    \x20\n\x0bexternalIPs\x18\x05\x20\x03(\tR\x0bexternalIPs\x12(\n\x0fsessi\
    onAffinity\x18\x07\x20\x01(\tR\x0fsessionAffinity\x12&\n\x0eloadBalancer\
    IP\x18\x08\x20\x01(\tR\x0eloadBalancerIP\x12:\n\x18loadBalancerSourceRan\
    ges\x18\t\x20\x03(\tR\x18loadBalancerSourceRanges\x12\"\n\x0cexternalNam\
    e\x18\n\x20\x01(\tR\x0cexternalName\x124\n\x15externalTrafficPolicy\x18\
    \x0b\x20\x01(\tR\x15externalTrafficPolicy\x120\n\x13healthCheckNodePort\
    \x18\x0c\x20\x01(\x05R\x13healthCheckNodePort\x12:\n\x18publishNotReadyA\
    ddresses\x18\r\x20\x01(\x08R\x18publishNotReadyAddresses\x12_\n\x15sessi\
    onAffinityConfig\x18\x0e\x20\x01(\x0b2).k8s.io.api.core.v1.SessionAffini\
    tyConfigR\x15sessionAffinityConfig\x12\"\n\x0ctopologyKeys\x18\x10\x20\
    \x03(\tR\x0ctopologyKeys\x12\x1e\n\nipFamilies\x18\x13\x20\x03(\tR\nipFa\
    milies\x12&\n\x0eipFamilyPolicy\x18\x11\x20\x01(\tR\x0eipFamilyPolicy\
    \x12D\n\x1dallocateLoadBalancerNodePorts\x18\x14\x20\x01(\x08R\x1dalloca\
    teLoadBalancerNodePorts\x1a;\n\rSelectorEntry\x12\x10\n\x03key\x18\x01\
    \x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x02\
    8\x01\"\xac\x01\n\rServiceStatus\x12J\n\x0cloadBalancer\x18\x01\x20\x01(\
    \x0b2&.k8s.io.api.core.v1.LoadBalancerStatusR\x0cloadBalancer\x12O\n\nco\
    nditions\x18\x02\x20\x03(\x0b2/.k8s.io.apimachinery.pkg.apis.meta.v1.Con\
    ditionR\nconditions\"W\n\x15SessionAffinityConfig\x12>\n\x08clientIP\x18\
    \x01\x20\x01(\x0b2\".k8s.io.api.core.v1.ClientIPConfigR\x08clientIP\"\
    \xe2\x01\n\x1fStorageOSPersistentVolumeSource\x12\x1e\n\nvolumeName\x18\
    \x01\x20\x01(\tR\nvolumeName\x12(\n\x0fvolumeNamespace\x18\x02\x20\x01(\
    \tR\x0fvolumeNamespace\x12\x16\n\x06fsType\x18\x03\x20\x01(\tR\x06fsType\
    \x12\x1a\n\x08readOnly\x18\x04\x20\x01(\x08R\x08readOnly\x12A\n\tsecretR\
    ef\x18\x05\x20\x01(\x0b2#.k8s.io.api.core.v1.ObjectReferenceR\tsecretRef\
    \"\xdd\x01\n\x15StorageOSVolumeSource\x12\x1e\n\nvolumeName\x18\x01\x20\
    \x01(\tR\nvolumeName\x12(\n\x0fvolumeNamespace\x18\x02\x20\x01(\tR\x0fvo\
    lumeNamespace\x12\x16\n\x06fsType\x18\x03\x20\x01(\tR\x06fsType\x12\x1a\
    \n\x08readOnly\x18\x04\x20\x01(\x08R\x08readOnly\x12F\n\tsecretRef\x18\
    \x05\x20\x01(\x0b2(.k8s.io.api.core.v1.LocalObjectReferenceR\tsecretRef\
    \"2\n\x06Sysctl\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\x14\n\
    \x05value\x18\x02\x20\x01(\tR\x05value\"k\n\x0fTCPSocketAction\x12D\n\
    \x04port\x18\x01\x20\x01(\x0b20.k8s.io.apimachinery.pkg.util.intstr.IntO\
    rStringR\x04port\x12\x12\n\x04host\x18\x02\x20\x01(\tR\x04host\"\x91\x01\
    \n\x05Taint\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05val\
    ue\x18\x02\x20\x01(\tR\x05value\x12\x16\n\x06effect\x18\x03\x20\x01(\tR\
    \x06effect\x12H\n\ttimeAdded\x18\x04\x20\x01(\x0b2*.k8s.io.apimachinery.\
    pkg.apis.meta.v1.TimeR\ttimeAdded\"\x96\x01\n\nToleration\x12\x10\n\x03k\
    ey\x18\x01\x20\x01(\tR\x03key\x12\x1a\n\x08operator\x18\x02\x20\x01(\tR\
    \x08operator\x12\x14\n\x05value\x18\x03\x20\x01(\tR\x05value\x12\x16\n\
    \x06effect\x18\x04\x20\x01(\tR\x06effect\x12,\n\x11tolerationSeconds\x18\
    \x05\x20\x01(\x03R\x11tolerationSeconds\"L\n\x20TopologySelectorLabelReq\
    uirement\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x16\n\x06values\
    \x18\x02\x20\x03(\tR\x06values\"\x82\x01\n\x14TopologySelectorTerm\x12j\
    \n\x15matchLabelExpressions\x18\x01\x20\x03(\x0b24.k8s.io.api.core.v1.To\
    pologySelectorLabelRequirementR\x15matchLabelExpressions\"\xdf\x01\n\x18\
    TopologySpreadConstraint\x12\x18\n\x07maxSkew\x18\x01\x20\x01(\x05R\x07m\
    axSkew\x12\x20\n\x0btopologyKey\x18\x02\x20\x01(\tR\x0btopologyKey\x12,\
    \n\x11whenUnsatisfiable\x18\x03\x20\x01(\tR\x11whenUnsatisfiable\x12Y\n\
    \rlabelSelector\x18\x04\x20\x01(\x0b23.k8s.io.apimachinery.pkg.apis.meta\
    .v1.LabelSelectorR\rlabelSelector\"_\n\x19TypedLocalObjectReference\x12\
    \x1a\n\x08apiGroup\x18\x01\x20\x01(\tR\x08apiGroup\x12\x12\n\x04kind\x18\
    \x02\x20\x01(\tR\x04kind\x12\x12\n\x04name\x18\x03\x20\x01(\tR\x04name\"\
    b\n\x06Volume\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12D\n\x0cvo\
    lumeSource\x18\x02\x20\x01(\x0b2\x20.k8s.io.api.core.v1.VolumeSourceR\
    \x0cvolumeSource\"B\n\x0cVolumeDevice\x12\x12\n\x04name\x18\x01\x20\x01(\
    \tR\x04name\x12\x1e\n\ndevicePath\x18\x02\x20\x01(\tR\ndevicePath\"\xc3\
    \x01\n\x0bVolumeMount\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\
    \x1a\n\x08readOnly\x18\x02\x20\x01(\x08R\x08readOnly\x12\x1c\n\tmountPat\
    h\x18\x03\x20\x01(\tR\tmountPath\x12\x18\n\x07subPath\x18\x04\x20\x01(\t\
    R\x07subPath\x12*\n\x10mountPropagation\x18\x05\x20\x01(\tR\x10mountProp\
    agation\x12\x20\n\x0bsubPathExpr\x18\x06\x20\x01(\tR\x0bsubPathExpr\"R\n\
    \x12VolumeNodeAffinity\x12<\n\x08required\x18\x01\x20\x01(\x0b2\x20.k8s.\
    io.api.core.v1.NodeSelectorR\x08required\"\xc9\x02\n\x10VolumeProjection\
    \x12<\n\x06secret\x18\x01\x20\x01(\x0b2$.k8s.io.api.core.v1.SecretProjec\
    tionR\x06secret\x12K\n\x0bdownwardAPI\x18\x02\x20\x01(\x0b2).k8s.io.api.\
    core.v1.DownwardAPIProjectionR\x0bdownwardAPI\x12E\n\tconfigMap\x18\x03\
    \x20\x01(\x0b2'.k8s.io.api.core.v1.ConfigMapProjectionR\tconfigMap\x12c\
    \n\x13serviceAccountToken\x18\x04\x20\x01(\x0b21.k8s.io.api.core.v1.Serv\
    iceAccountTokenProjectionR\x13serviceAccountToken\"\xde\x10\n\x0cVolumeS\
    ource\x12D\n\x08hostPath\x18\x01\x20\x01(\x0b2(.k8s.io.api.core.v1.HostP\
    athVolumeSourceR\x08hostPath\x12D\n\x08emptyDir\x18\x02\x20\x01(\x0b2(.k\
    8s.io.api.core.v1.EmptyDirVolumeSourceR\x08emptyDir\x12_\n\x11gcePersist\
    entDisk\x18\x03\x20\x01(\x0b21.k8s.io.api.core.v1.GCEPersistentDiskVolum\
    eSourceR\x11gcePersistentDisk\x12h\n\x14awsElasticBlockStore\x18\x04\x20\
    \x01(\x0b24.k8s.io.api.core.v1.AWSElasticBlockStoreVolumeSourceR\x14awsE\
    lasticBlockStore\x12A\n\x07gitRepo\x18\x05\x20\x01(\x0b2'.k8s.io.api.cor\
    e.v1.GitRepoVolumeSourceR\x07gitRepo\x12>\n\x06secret\x18\x06\x20\x01(\
    \x0b2&.k8s.io.api.core.v1.SecretVolumeSourceR\x06secret\x125\n\x03nfs\
    \x18\x07\x20\x01(\x0b2#.k8s.io.api.core.v1.NFSVolumeSourceR\x03nfs\x12;\
    \n\x05iscsi\x18\x08\x20\x01(\x0b2%.k8s.io.api.core.v1.ISCSIVolumeSourceR\
    \x05iscsi\x12G\n\tglusterfs\x18\t\x20\x01(\x0b2).k8s.io.api.core.v1.Glus\
    terfsVolumeSourceR\tglusterfs\x12k\n\x15persistentVolumeClaim\x18\n\x20\
    \x01(\x0b25.k8s.io.api.core.v1.PersistentVolumeClaimVolumeSourceR\x15per\
    sistentVolumeClaim\x125\n\x03rbd\x18\x0b\x20\x01(\x0b2#.k8s.io.api.core.\
    v1.RBDVolumeSourceR\x03rbd\x12D\n\nflexVolume\x18\x0c\x20\x01(\x0b2$.k8s\
    .io.api.core.v1.FlexVolumeSourceR\nflexVolume\x12>\n\x06cinder\x18\r\x20\
    \x01(\x0b2&.k8s.io.api.core.v1.CinderVolumeSourceR\x06cinder\x12>\n\x06c\
    ephfs\x18\x0e\x20\x01(\x0b2&.k8s.io.api.core.v1.CephFSVolumeSourceR\x06c\
    ephfs\x12A\n\x07flocker\x18\x0f\x20\x01(\x0b2'.k8s.io.api.core.v1.Flocke\
    rVolumeSourceR\x07flocker\x12M\n\x0bdownwardAPI\x18\x10\x20\x01(\x0b2+.k\
    8s.io.api.core.v1.DownwardAPIVolumeSourceR\x0bdownwardAPI\x122\n\x02fc\
    \x18\x11\x20\x01(\x0b2\".k8s.io.api.core.v1.FCVolumeSourceR\x02fc\x12G\n\
    \tazureFile\x18\x12\x20\x01(\x0b2).k8s.io.api.core.v1.AzureFileVolumeSou\
    rceR\tazureFile\x12G\n\tconfigMap\x18\x13\x20\x01(\x0b2).k8s.io.api.core\
    .v1.ConfigMapVolumeSourceR\tconfigMap\x12X\n\rvsphereVolume\x18\x14\x20\
    \x01(\x0b22.k8s.io.api.core.v1.VsphereVirtualDiskVolumeSourceR\rvsphereV\
    olume\x12A\n\x07quobyte\x18\x15\x20\x01(\x0b2'.k8s.io.api.core.v1.Quobyt\
    eVolumeSourceR\x07quobyte\x12G\n\tazureDisk\x18\x16\x20\x01(\x0b2).k8s.i\
    o.api.core.v1.AzureDiskVolumeSourceR\tazureDisk\x12h\n\x14photonPersiste\
    ntDisk\x18\x17\x20\x01(\x0b24.k8s.io.api.core.v1.PhotonPersistentDiskVol\
    umeSourceR\x14photonPersistentDisk\x12G\n\tprojected\x18\x1a\x20\x01(\
    \x0b2).k8s.io.api.core.v1.ProjectedVolumeSourceR\tprojected\x12P\n\x0epo\
    rtworxVolume\x18\x18\x20\x01(\x0b2(.k8s.io.api.core.v1.PortworxVolumeSou\
    rceR\x0eportworxVolume\x12A\n\x07scaleIO\x18\x19\x20\x01(\x0b2'.k8s.io.a\
    pi.core.v1.ScaleIOVolumeSourceR\x07scaleIO\x12G\n\tstorageos\x18\x1b\x20\
    \x01(\x0b2).k8s.io.api.core.v1.StorageOSVolumeSourceR\tstorageos\x125\n\
    \x03csi\x18\x1c\x20\x01(\x0b2#.k8s.io.api.core.v1.CSIVolumeSourceR\x03cs\
    i\x12G\n\tephemeral\x18\x1d\x20\x01(\x0b2).k8s.io.api.core.v1.EphemeralV\
    olumeSourceR\tephemeral\"\xb0\x01\n\x1eVsphereVirtualDiskVolumeSource\
    \x12\x1e\n\nvolumePath\x18\x01\x20\x01(\tR\nvolumePath\x12\x16\n\x06fsTy\
    pe\x18\x02\x20\x01(\tR\x06fsType\x12,\n\x11storagePolicyName\x18\x03\x20\
    \x01(\tR\x11storagePolicyName\x12(\n\x0fstoragePolicyID\x18\x04\x20\x01(\
    \tR\x0fstoragePolicyID\"\x80\x01\n\x17WeightedPodAffinityTerm\x12\x16\n\
    \x06weight\x18\x01\x20\x01(\x05R\x06weight\x12M\n\x0fpodAffinityTerm\x18\
    \x02\x20\x01(\x0b2#.k8s.io.api.core.v1.PodAffinityTermR\x0fpodAffinityTe\
    rm\"\xad\x01\n\x1dWindowsSecurityContextOptions\x126\n\x16gmsaCredential\
    SpecName\x18\x01\x20\x01(\tR\x16gmsaCredentialSpecName\x12.\n\x12gmsaCre\
    dentialSpec\x18\x02\x20\x01(\tR\x12gmsaCredentialSpec\x12$\n\rrunAsUserN\
    ame\x18\x03\x20\x01(\tR\rrunAsUserNameB\x04Z\x02v1J\xeb\xbf\x0f\n\x07\
    \x12\x05\x13\0\xcd+\x01\n\x82\x05\n\x01\x0c\x12\x03\x13\0\x122\xac\x04\n\
    Copyright\x20The\x20Kubernetes\x20Authors.\n\nLicensed\x20under\x20the\
    \x20Apache\x20License,\x20Version\x202.0\x20(the\x20\"License\");\nyou\
    \x20may\x20not\x20use\x20this\x20file\x20except\x20in\x20compliance\x20w\
    ith\x20the\x20License.\nYou\x20may\x20obtain\x20a\x20copy\x20of\x20the\
    \x20License\x20at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnles\
    s\x20required\x20by\x20applicable\x20law\x20or\x20agreed\x20to\x20in\x20\
    writing,\x20software\ndistributed\x20under\x20the\x20License\x20is\x20di\
    stributed\x20on\x20an\x20\"AS\x20IS\"\x20BASIS,\nWITHOUT\x20WARRANTIES\
    \x20OR\x20CONDITIONS\x20OF\x20ANY\x20KIND,\x20either\x20express\x20or\
    \x20implied.\nSee\x20the\x20License\x20for\x20the\x20specific\x20languag\
    e\x20governing\x20permissions\x20and\nlimitations\x20under\x20the\x20Lic\
    ense.\n2I\x20This\x20file\x20was\x20autogenerated\x20by\x20go-to-protobu\
    f.\x20Do\x20not\x20edit\x20it\x20manually!\n\n\x08\n\x01\x02\x12\x03\x15\
    \x08\x1a\n\t\n\x02\x03\0\x12\x03\x17\x07=\n\t\n\x02\x03\x01\x12\x03\x18\
    \x07=\n\t\n\x02\x03\x02\x12\x03\x19\x078\n\t\n\x02\x03\x03\x12\x03\x1a\
    \x07?\n\t\n\x02\x03\x04\x12\x03\x1b\x07<\n\x08\n\x01\x08\x12\x03\x1e\0\
    \x19\nA\n\x04\x08\xe7\x07\0\x12\x03\x1e\0\x19\x1a4\x20Package-wide\x20va\
    riables\x20from\x20generator\x20\"generated\".\n\n\x0c\n\x05\x08\xe7\x07\
    \0\x02\x12\x03\x1e\x07\x11\n\r\n\x06\x08\xe7\x07\0\x02\0\x12\x03\x1e\x07\
    \x11\n\x0e\n\x07\x08\xe7\x07\0\x02\0\x01\x12\x03\x1e\x07\x11\n\x0c\n\x05\
    \x08\xe7\x07\0\x07\x12\x03\x1e\x14\x18\n\xb4\x02\n\x02\x04\0\x12\x04&\0?\
    \x01\x1a\xa7\x02\x20Represents\x20a\x20Persistent\x20Disk\x20resource\
    \x20in\x20AWS.\n\n\x20An\x20AWS\x20EBS\x20disk\x20must\x20exist\x20befor\
    e\x20mounting\x20to\x20a\x20container.\x20The\x20disk\n\x20must\x20also\
    \x20be\x20in\x20the\x20same\x20AWS\x20zone\x20as\x20the\x20kubelet.\x20A\
    n\x20AWS\x20EBS\x20disk\n\x20can\x20only\x20be\x20mounted\x20as\x20read/\
    write\x20once.\x20AWS\x20EBS\x20volumes\x20support\n\x20ownership\x20man\
    agement\x20and\x20SELinux\x20relabeling.\n\n\n\n\x03\x04\0\x01\x12\x03&\
    \x08(\n\xaa\x01\n\x04\x04\0\x02\0\x12\x03)\x02\x1f\x1a\x9c\x01\x20Unique\
    \x20ID\x20of\x20the\x20persistent\x20disk\x20resource\x20in\x20AWS\x20(A\
    mazon\x20EBS\x20volume).\n\x20More\x20info:\x20https://kubernetes.io/doc\
    s/concepts/storage/volumes#awselasticblockstore\n\n\x0c\n\x05\x04\0\x02\
    \0\x04\x12\x03)\x02\n\n\x0c\n\x05\x04\0\x02\0\x05\x12\x03)\x0b\x11\n\x0c\
    \n\x05\x04\0\x02\0\x01\x12\x03)\x12\x1a\n\x0c\n\x05\x04\0\x02\0\x03\x12\
    \x03)\x1d\x1e\n\x99\x03\n\x04\x04\0\x02\x01\x12\x031\x02\x1d\x1a\x8b\x03\
    \x20Filesystem\x20type\x20of\x20the\x20volume\x20that\x20you\x20want\x20\
    to\x20mount.\n\x20Tip:\x20Ensure\x20that\x20the\x20filesystem\x20type\
    \x20is\x20supported\x20by\x20the\x20host\x20operating\x20system.\n\x20Ex\
    amples:\x20\"ext4\",\x20\"xfs\",\x20\"ntfs\".\x20Implicitly\x20inferred\
    \x20to\x20be\x20\"ext4\"\x20if\x20unspecified.\n\x20More\x20info:\x20htt\
    ps://kubernetes.io/docs/concepts/storage/volumes#awselasticblockstore\n\
    \x20TODO:\x20how\x20do\x20we\x20prevent\x20errors\x20in\x20the\x20filesy\
    stem\x20from\x20compromising\x20the\x20machine\n\x20+optional\n\n\x0c\n\
    \x05\x04\0\x02\x01\x04\x12\x031\x02\n\n\x0c\n\x05\x04\0\x02\x01\x05\x12\
    \x031\x0b\x11\n\x0c\n\x05\x04\0\x02\x01\x01\x12\x031\x12\x18\n\x0c\n\x05\
    \x04\0\x02\x01\x03\x12\x031\x1b\x1c\n\xa2\x02\n\x04\x04\0\x02\x02\x12\
    \x038\x02\x1f\x1a\x94\x02\x20The\x20partition\x20in\x20the\x20volume\x20\
    that\x20you\x20want\x20to\x20mount.\n\x20If\x20omitted,\x20the\x20defaul\
    t\x20is\x20to\x20mount\x20by\x20volume\x20name.\n\x20Examples:\x20For\
    \x20volume\x20/dev/sda1,\x20you\x20specify\x20the\x20partition\x20as\x20\
    \"1\".\n\x20Similarly,\x20the\x20volume\x20partition\x20for\x20/dev/sda\
    \x20is\x20\"0\"\x20(or\x20you\x20can\x20leave\x20the\x20property\x20empt\
    y).\n\x20+optional\n\n\x0c\n\x05\x04\0\x02\x02\x04\x12\x038\x02\n\n\x0c\
    \n\x05\x04\0\x02\x02\x05\x12\x038\x0b\x10\n\x0c\n\x05\x04\0\x02\x02\x01\
    \x12\x038\x11\x1a\n\x0c\n\x05\x04\0\x02\x02\x03\x12\x038\x1d\x1e\n\xe5\
    \x01\n\x04\x04\0\x02\x03\x12\x03>\x02\x1d\x1a\xd7\x01\x20Specify\x20\"tr\
    ue\"\x20to\x20force\x20and\x20set\x20the\x20ReadOnly\x20property\x20in\
    \x20VolumeMounts\x20to\x20\"true\".\n\x20If\x20omitted,\x20the\x20defaul\
    t\x20is\x20\"false\".\n\x20More\x20info:\x20https://kubernetes.io/docs/c\
    oncepts/storage/volumes#awselasticblockstore\n\x20+optional\n\n\x0c\n\
    \x05\x04\0\x02\x03\x04\x12\x03>\x02\n\n\x0c\n\x05\x04\0\x02\x03\x05\x12\
    \x03>\x0b\x0f\n\x0c\n\x05\x04\0\x02\x03\x01\x12\x03>\x10\x18\n\x0c\n\x05\
    \x04\0\x02\x03\x03\x12\x03>\x1b\x1c\n?\n\x02\x04\x01\x12\x04B\0N\x01\x1a\
    3\x20Affinity\x20is\x20a\x20group\x20of\x20affinity\x20scheduling\x20rul\
    es.\n\n\n\n\x03\x04\x01\x01\x12\x03B\x08\x10\nO\n\x04\x04\x01\x02\0\x12\
    \x03E\x02)\x1aB\x20Describes\x20node\x20affinity\x20scheduling\x20rules\
    \x20for\x20the\x20pod.\n\x20+optional\n\n\x0c\n\x05\x04\x01\x02\0\x04\
    \x12\x03E\x02\n\n\x0c\n\x05\x04\x01\x02\0\x06\x12\x03E\x0b\x17\n\x0c\n\
    \x05\x04\x01\x02\0\x01\x12\x03E\x18$\n\x0c\n\x05\x04\x01\x02\0\x03\x12\
    \x03E'(\n\x8f\x01\n\x04\x04\x01\x02\x01\x12\x03I\x02'\x1a\x81\x01\x20Des\
    cribes\x20pod\x20affinity\x20scheduling\x20rules\x20(e.g.\x20co-locate\
    \x20this\x20pod\x20in\x20the\x20same\x20node,\x20zone,\x20etc.\x20as\x20\
    some\x20other\x20pod(s)).\n\x20+optional\n\n\x0c\n\x05\x04\x01\x02\x01\
    \x04\x12\x03I\x02\n\n\x0c\n\x05\x04\x01\x02\x01\x06\x12\x03I\x0b\x16\n\
    \x0c\n\x05\x04\x01\x02\x01\x01\x12\x03I\x17\"\n\x0c\n\x05\x04\x01\x02\
    \x01\x03\x12\x03I%&\n\x98\x01\n\x04\x04\x01\x02\x02\x12\x03M\x02/\x1a\
    \x8a\x01\x20Describes\x20pod\x20anti-affinity\x20scheduling\x20rules\x20\
    (e.g.\x20avoid\x20putting\x20this\x20pod\x20in\x20the\x20same\x20node,\
    \x20zone,\x20etc.\x20as\x20some\x20other\x20pod(s)).\n\x20+optional\n\n\
    \x0c\n\x05\x04\x01\x02\x02\x04\x12\x03M\x02\n\n\x0c\n\x05\x04\x01\x02\
    \x02\x06\x12\x03M\x0b\x1a\n\x0c\n\x05\x04\x01\x02\x02\x01\x12\x03M\x1b*\
    \n\x0c\n\x05\x04\x01\x02\x02\x03\x12\x03M-.\nB\n\x02\x04\x02\x12\x04Q\0W\
    \x01\x1a6\x20AttachedVolume\x20describes\x20a\x20volume\x20attached\x20t\
    o\x20a\x20node\n\n\n\n\x03\x04\x02\x01\x12\x03Q\x08\x16\n*\n\x04\x04\x02\
    \x02\0\x12\x03S\x02\x1b\x1a\x1d\x20Name\x20of\x20the\x20attached\x20volu\
    me\n\n\x0c\n\x05\x04\x02\x02\0\x04\x12\x03S\x02\n\n\x0c\n\x05\x04\x02\
    \x02\0\x05\x12\x03S\x0b\x11\n\x0c\n\x05\x04\x02\x02\0\x01\x12\x03S\x12\
    \x16\n\x0c\n\x05\x04\x02\x02\0\x03\x12\x03S\x19\x1a\nY\n\x04\x04\x02\x02\
    \x01\x12\x03V\x02!\x1aL\x20DevicePath\x20represents\x20the\x20device\x20\
    path\x20where\x20the\x20volume\x20should\x20be\x20available\n\n\x0c\n\
    \x05\x04\x02\x02\x01\x04\x12\x03V\x02\n\n\x0c\n\x05\x04\x02\x02\x01\x05\
    \x12\x03V\x0b\x11\n\x0c\n\x05\x04\x02\x02\x01\x01\x12\x03V\x12\x1c\n\x0c\
    \n\x05\x04\x02\x02\x01\x03\x12\x03V\x1f\x20\n\xd7\x01\n\x02\x04\x03\x12\
    \x04\\\0a\x01\x1a\xca\x01\x20AvoidPods\x20describes\x20pods\x20that\x20s\
    hould\x20avoid\x20this\x20node.\x20This\x20is\x20the\x20value\x20for\x20\
    a\n\x20Node\x20annotation\x20with\x20key\x20scheduler.alpha.kubernetes.i\
    o/preferAvoidPods\x20and\n\x20will\x20eventually\x20become\x20a\x20field\
    \x20of\x20NodeStatus.\n\n\n\n\x03\x04\x03\x01\x12\x03\\\x08\x11\n\xb4\
    \x01\n\x04\x04\x03\x02\0\x12\x03`\x024\x1a\xa6\x01\x20Bounded-sized\x20l\
    ist\x20of\x20signatures\x20of\x20pods\x20that\x20should\x20avoid\x20this\
    \x20node,\x20sorted\n\x20in\x20timestamp\x20order\x20from\x20oldest\x20t\
    o\x20newest.\x20Size\x20of\x20the\x20slice\x20is\x20unspecified.\n\x20+o\
    ptional\n\n\x0c\n\x05\x04\x03\x02\0\x04\x12\x03`\x02\n\n\x0c\n\x05\x04\
    \x03\x02\0\x06\x12\x03`\x0b\x1f\n\x0c\n\x05\x04\x03\x02\0\x01\x12\x03`\
    \x20/\n\x0c\n\x05\x04\x03\x02\0\x03\x12\x03`23\nb\n\x02\x04\x04\x12\x04d\
    \0|\x01\x1aV\x20AzureDisk\x20represents\x20an\x20Azure\x20Data\x20Disk\
    \x20mount\x20on\x20the\x20host\x20and\x20bind\x20mount\x20to\x20the\x20p\
    od.\n\n\n\n\x03\x04\x04\x01\x12\x03d\x08\x1d\n<\n\x04\x04\x04\x02\0\x12\
    \x03f\x02\x1f\x1a/\x20The\x20Name\x20of\x20the\x20data\x20disk\x20in\x20\
    the\x20blob\x20storage\n\n\x0c\n\x05\x04\x04\x02\0\x04\x12\x03f\x02\n\n\
    \x0c\n\x05\x04\x04\x02\0\x05\x12\x03f\x0b\x11\n\x0c\n\x05\x04\x04\x02\0\
    \x01\x12\x03f\x12\x1a\n\x0c\n\x05\x04\x04\x02\0\x03\x12\x03f\x1d\x1e\n8\
    \n\x04\x04\x04\x02\x01\x12\x03i\x02\x1e\x1a+\x20The\x20URI\x20the\x20dat\
    a\x20disk\x20in\x20the\x20blob\x20storage\n\n\x0c\n\x05\x04\x04\x02\x01\
    \x04\x12\x03i\x02\n\n\x0c\n\x05\x04\x04\x02\x01\x05\x12\x03i\x0b\x11\n\
    \x0c\n\x05\x04\x04\x02\x01\x01\x12\x03i\x12\x19\n\x0c\n\x05\x04\x04\x02\
    \x01\x03\x12\x03i\x1c\x1d\nI\n\x04\x04\x04\x02\x02\x12\x03m\x02\"\x1a<\
    \x20Host\x20Caching\x20mode:\x20None,\x20Read\x20Only,\x20Read\x20Write.\
    \n\x20+optional\n\n\x0c\n\x05\x04\x04\x02\x02\x04\x12\x03m\x02\n\n\x0c\n\
    \x05\x04\x04\x02\x02\x05\x12\x03m\x0b\x11\n\x0c\n\x05\x04\x04\x02\x02\
    \x01\x12\x03m\x12\x1d\n\x0c\n\x05\x04\x04\x02\x02\x03\x12\x03m\x20!\n\
    \xc4\x01\n\x04\x04\x04\x02\x03\x12\x03s\x02\x1d\x1a\xb6\x01\x20Filesyste\
    m\x20type\x20to\x20mount.\n\x20Must\x20be\x20a\x20filesystem\x20type\x20\
    supported\x20by\x20the\x20host\x20operating\x20system.\n\x20Ex.\x20\"ext\
    4\",\x20\"xfs\",\x20\"ntfs\".\x20Implicitly\x20inferred\x20to\x20be\x20\
    \"ext4\"\x20if\x20unspecified.\n\x20+optional\n\n\x0c\n\x05\x04\x04\x02\
    \x03\x04\x12\x03s\x02\n\n\x0c\n\x05\x04\x04\x02\x03\x05\x12\x03s\x0b\x11\
    \n\x0c\n\x05\x04\x04\x02\x03\x01\x12\x03s\x12\x18\n\x0c\n\x05\x04\x04\
    \x02\x03\x03\x12\x03s\x1b\x1c\ny\n\x04\x04\x04\x02\x04\x12\x03x\x02\x1d\
    \x1al\x20Defaults\x20to\x20false\x20(read/write).\x20ReadOnly\x20here\
    \x20will\x20force\n\x20the\x20ReadOnly\x20setting\x20in\x20VolumeMounts.\
    \n\x20+optional\n\n\x0c\n\x05\x04\x04\x02\x04\x04\x12\x03x\x02\n\n\x0c\n\
    \x05\x04\x04\x02\x04\x05\x12\x03x\x0b\x0f\n\x0c\n\x05\x04\x04\x02\x04\
    \x01\x12\x03x\x10\x18\n\x0c\n\x05\x04\x04\x02\x04\x03\x12\x03x\x1b\x1c\n\
    \xd9\x01\n\x04\x04\x04\x02\x05\x12\x03{\x02\x1b\x1a\xcb\x01\x20Expected\
    \x20values\x20Shared:\x20multiple\x20blob\x20disks\x20per\x20storage\x20\
    account\x20\x20Dedicated:\x20single\x20blob\x20disk\x20per\x20storage\
    \x20account\x20\x20Managed:\x20azure\x20managed\x20data\x20disk\x20(only\
    \x20in\x20managed\x20availability\x20set).\x20defaults\x20to\x20shared\n\
    \n\x0c\n\x05\x04\x04\x02\x05\x04\x12\x03{\x02\n\n\x0c\n\x05\x04\x04\x02\
    \x05\x05\x12\x03{\x0b\x11\n\x0c\n\x05\x04\x04\x02\x05\x01\x12\x03{\x12\
    \x16\n\x0c\n\x05\x04\x04\x02\x05\x03\x12\x03{\x19\x1a\nf\n\x02\x04\x05\
    \x12\x05\x7f\0\x8f\x01\x01\x1aY\x20AzureFile\x20represents\x20an\x20Azur\
    e\x20File\x20Service\x20mount\x20on\x20the\x20host\x20and\x20bind\x20mou\
    nt\x20to\x20the\x20pod.\n\n\n\n\x03\x04\x05\x01\x12\x03\x7f\x08'\nS\n\
    \x04\x04\x05\x02\0\x12\x04\x81\x01\x02!\x1aE\x20the\x20name\x20of\x20sec\
    ret\x20that\x20contains\x20Azure\x20Storage\x20Account\x20Name\x20and\
    \x20Key\n\n\r\n\x05\x04\x05\x02\0\x04\x12\x04\x81\x01\x02\n\n\r\n\x05\
    \x04\x05\x02\0\x05\x12\x04\x81\x01\x0b\x11\n\r\n\x05\x04\x05\x02\0\x01\
    \x12\x04\x81\x01\x12\x1c\n\r\n\x05\x04\x05\x02\0\x03\x12\x04\x81\x01\x1f\
    \x20\n\x1a\n\x04\x04\x05\x02\x01\x12\x04\x84\x01\x02\x20\x1a\x0c\x20Shar\
    e\x20Name\n\n\r\n\x05\x04\x05\x02\x01\x04\x12\x04\x84\x01\x02\n\n\r\n\
    \x05\x04\x05\x02\x01\x05\x12\x04\x84\x01\x0b\x11\n\r\n\x05\x04\x05\x02\
    \x01\x01\x12\x04\x84\x01\x12\x1b\n\r\n\x05\x04\x05\x02\x01\x03\x12\x04\
    \x84\x01\x1e\x1f\nz\n\x04\x04\x05\x02\x02\x12\x04\x89\x01\x02\x1d\x1al\
    \x20Defaults\x20to\x20false\x20(read/write).\x20ReadOnly\x20here\x20will\
    \x20force\n\x20the\x20ReadOnly\x20setting\x20in\x20VolumeMounts.\n\x20+o\
    ptional\n\n\r\n\x05\x04\x05\x02\x02\x04\x12\x04\x89\x01\x02\n\n\r\n\x05\
    \x04\x05\x02\x02\x05\x12\x04\x89\x01\x0b\x0f\n\r\n\x05\x04\x05\x02\x02\
    \x01\x12\x04\x89\x01\x10\x18\n\r\n\x05\x04\x05\x02\x02\x03\x12\x04\x89\
    \x01\x1b\x1c\n\x87\x01\n\x04\x04\x05\x02\x03\x12\x04\x8e\x01\x02&\x1ay\
    \x20the\x20namespace\x20of\x20the\x20secret\x20that\x20contains\x20Azure\
    \x20Storage\x20Account\x20Name\x20and\x20Key\n\x20default\x20is\x20the\
    \x20same\x20as\x20the\x20Pod\n\x20+optional\n\n\r\n\x05\x04\x05\x02\x03\
    \x04\x12\x04\x8e\x01\x02\n\n\r\n\x05\x04\x05\x02\x03\x05\x12\x04\x8e\x01\
    \x0b\x11\n\r\n\x05\x04\x05\x02\x03\x01\x12\x04\x8e\x01\x12!\n\r\n\x05\
    \x04\x05\x02\x03\x03\x12\x04\x8e\x01$%\ng\n\x02\x04\x06\x12\x06\x92\x01\
    \0\x9d\x01\x01\x1aY\x20AzureFile\x20represents\x20an\x20Azure\x20File\
    \x20Service\x20mount\x20on\x20the\x20host\x20and\x20bind\x20mount\x20to\
    \x20the\x20pod.\n\n\x0b\n\x03\x04\x06\x01\x12\x04\x92\x01\x08\x1d\nS\n\
    \x04\x04\x06\x02\0\x12\x04\x94\x01\x02!\x1aE\x20the\x20name\x20of\x20sec\
    ret\x20that\x20contains\x20Azure\x20Storage\x20Account\x20Name\x20and\
    \x20Key\n\n\r\n\x05\x04\x06\x02\0\x04\x12\x04\x94\x01\x02\n\n\r\n\x05\
    \x04\x06\x02\0\x05\x12\x04\x94\x01\x0b\x11\n\r\n\x05\x04\x06\x02\0\x01\
    \x12\x04\x94\x01\x12\x1c\n\r\n\x05\x04\x06\x02\0\x03\x12\x04\x94\x01\x1f\
    \x20\n\x1a\n\x04\x04\x06\x02\x01\x12\x04\x97\x01\x02\x20\x1a\x0c\x20Shar\
    e\x20Name\n\n\r\n\x05\x04\x06\x02\x01\x04\x12\x04\x97\x01\x02\n\n\r\n\
    \x05\x04\x06\x02\x01\x05\x12\x04\x97\x01\x0b\x11\n\r\n\x05\x04\x06\x02\
    \x01\x01\x12\x04\x97\x01\x12\x1b\n\r\n\x05\x04\x06\x02\x01\x03\x12\x04\
    \x97\x01\x1e\x1f\nz\n\x04\x04\x06\x02\x02\x12\x04\x9c\x01\x02\x1d\x1al\
    \x20Defaults\x20to\x20false\x20(read/write).\x20ReadOnly\x20here\x20will\
    \x20force\n\x20the\x20ReadOnly\x20setting\x20in\x20VolumeMounts.\n\x20+o\
    ptional\n\n\r\n\x05\x04\x06\x02\x02\x04\x12\x04\x9c\x01\x02\n\n\r\n\x05\
    \x04\x06\x02\x02\x05\x12\x04\x9c\x01\x0b\x0f\n\r\n\x05\x04\x06\x02\x02\
    \x01\x12\x04\x9c\x01\x10\x18\n\r\n\x05\x04\x06\x02\x02\x03\x12\x04\x9c\
    \x01\x1b\x1c\n\xb3\x01\n\x02\x04\x07\x12\x06\xa1\x01\0\xa9\x01\x01\x1a\
    \xa4\x01\x20Binding\x20ties\x20one\x20object\x20to\x20another;\x20for\
    \x20example,\x20a\x20pod\x20is\x20bound\x20to\x20a\x20node\x20by\x20a\
    \x20scheduler.\n\x20Deprecated\x20in\x201.7,\x20please\x20use\x20the\x20\
    bindings\x20subresource\x20of\x20pods\x20instead.\n\n\x0b\n\x03\x04\x07\
    \x01\x12\x04\xa1\x01\x08\x0f\n\xa0\x01\n\x04\x04\x07\x02\0\x12\x04\xa5\
    \x01\x02H\x1a\x91\x01\x20Standard\x20object's\x20metadata.\n\x20More\x20\
    info:\x20https://git.k8s.io/community/contributors/devel/sig-architectur\
    e/api-conventions.md#metadata\n\x20+optional\n\n\r\n\x05\x04\x07\x02\0\
    \x04\x12\x04\xa5\x01\x02\n\n\r\n\x05\x04\x07\x02\0\x06\x12\x04\xa5\x01\
    \x0b:\n\r\n\x05\x04\x07\x02\0\x01\x12\x04\xa5\x01;C\n\r\n\x05\x04\x07\
    \x02\0\x03\x12\x04\xa5\x01FG\nO\n\x04\x04\x07\x02\x01\x12\x04\xa8\x01\
    \x02&\x1aA\x20The\x20target\x20object\x20that\x20you\x20want\x20to\x20bi\
    nd\x20to\x20the\x20standard\x20object.\n\n\r\n\x05\x04\x07\x02\x01\x04\
    \x12\x04\xa8\x01\x02\n\n\r\n\x05\x04\x07\x02\x01\x06\x12\x04\xa8\x01\x0b\
    \x1a\n\r\n\x05\x04\x07\x02\x01\x01\x12\x04\xa8\x01\x1b!\n\r\n\x05\x04\
    \x07\x02\x01\x03\x12\x04\xa8\x01$%\nb\n\x02\x04\x08\x12\x06\xac\x01\0\
    \xe5\x01\x01\x1aT\x20Represents\x20storage\x20that\x20is\x20managed\x20b\
    y\x20an\x20external\x20CSI\x20volume\x20driver\x20(Beta\x20feature)\n\n\
    \x0b\n\x03\x04\x08\x01\x12\x04\xac\x01\x08!\nS\n\x04\x04\x08\x02\0\x12\
    \x04\xaf\x01\x02\x1d\x1aE\x20Driver\x20is\x20the\x20name\x20of\x20the\
    \x20driver\x20to\x20use\x20for\x20this\x20volume.\n\x20Required.\n\n\r\n\
    \x05\x04\x08\x02\0\x04\x12\x04\xaf\x01\x02\n\n\r\n\x05\x04\x08\x02\0\x05\
    \x12\x04\xaf\x01\x0b\x11\n\r\n\x05\x04\x08\x02\0\x01\x12\x04\xaf\x01\x12\
    \x18\n\r\n\x05\x04\x08\x02\0\x03\x12\x04\xaf\x01\x1b\x1c\n\xa6\x01\n\x04\
    \x04\x08\x02\x01\x12\x04\xb4\x01\x02#\x1a\x97\x01\x20VolumeHandle\x20is\
    \x20the\x20unique\x20volume\x20name\x20returned\x20by\x20the\x20CSI\x20v\
    olume\n\x20plugin\xe2\x80\x99s\x20CreateVolume\x20to\x20refer\x20to\x20t\
    he\x20volume\x20on\x20all\x20subsequent\x20calls.\n\x20Required.\n\n\r\n\
    \x05\x04\x08\x02\x01\x04\x12\x04\xb4\x01\x02\n\n\r\n\x05\x04\x08\x02\x01\
    \x05\x12\x04\xb4\x01\x0b\x11\n\r\n\x05\x04\x08\x02\x01\x01\x12\x04\xb4\
    \x01\x12\x1e\n\r\n\x05\x04\x08\x02\x01\x03\x12\x04\xb4\x01!\"\nz\n\x04\
    \x04\x08\x02\x02\x12\x04\xb9\x01\x02\x1d\x1al\x20Optional:\x20The\x20val\
    ue\x20to\x20pass\x20to\x20ControllerPublishVolumeRequest.\n\x20Defaults\
    \x20to\x20false\x20(read/write).\n\x20+optional\n\n\r\n\x05\x04\x08\x02\
    \x02\x04\x12\x04\xb9\x01\x02\n\n\r\n\x05\x04\x08\x02\x02\x05\x12\x04\xb9\
    \x01\x0b\x0f\n\r\n\x05\x04\x08\x02\x02\x01\x12\x04\xb9\x01\x10\x18\n\r\n\
    \x05\x04\x08\x02\x02\x03\x12\x04\xb9\x01\x1b\x1c\n\x94\x01\n\x04\x04\x08\
    \x02\x03\x12\x04\xbf\x01\x02\x1d\x1a\x85\x01\x20Filesystem\x20type\x20to\
    \x20mount.\n\x20Must\x20be\x20a\x20filesystem\x20type\x20supported\x20by\
    \x20the\x20host\x20operating\x20system.\n\x20Ex.\x20\"ext4\",\x20\"xfs\"\
    ,\x20\"ntfs\".\n\x20+optional\n\n\r\n\x05\x04\x08\x02\x03\x04\x12\x04\
    \xbf\x01\x02\n\n\r\n\x05\x04\x08\x02\x03\x05\x12\x04\xbf\x01\x0b\x11\n\r\
    \n\x05\x04\x08\x02\x03\x01\x12\x04\xbf\x01\x12\x18\n\r\n\x05\x04\x08\x02\
    \x03\x03\x12\x04\xbf\x01\x1b\x1c\n?\n\x04\x04\x08\x02\x04\x12\x04\xc3\
    \x01\x02+\x1a1\x20Attributes\x20of\x20the\x20volume\x20to\x20publish.\n\
    \x20+optional\n\n\x0f\n\x05\x04\x08\x02\x04\x04\x12\x06\xc3\x01\x02\xbf\
    \x01\x1d\n\r\n\x05\x04\x08\x02\x04\x06\x12\x04\xc3\x01\x02\x15\n\r\n\x05\
    \x04\x08\x02\x04\x01\x12\x04\xc3\x01\x16&\n\r\n\x05\x04\x08\x02\x04\x03\
    \x12\x04\xc3\x01)*\n\xf9\x02\n\x04\x04\x08\x02\x05\x12\x04\xcb\x01\x02:\
    \x1a\xea\x02\x20ControllerPublishSecretRef\x20is\x20a\x20reference\x20to\
    \x20the\x20secret\x20object\x20containing\n\x20sensitive\x20information\
    \x20to\x20pass\x20to\x20the\x20CSI\x20driver\x20to\x20complete\x20the\
    \x20CSI\n\x20ControllerPublishVolume\x20and\x20ControllerUnpublishVolume\
    \x20calls.\n\x20This\x20field\x20is\x20optional,\x20and\x20may\x20be\x20\
    empty\x20if\x20no\x20secret\x20is\x20required.\x20If\x20the\n\x20secret\
    \x20object\x20contains\x20more\x20than\x20one\x20secret,\x20all\x20secre\
    ts\x20are\x20passed.\n\x20+optional\n\n\r\n\x05\x04\x08\x02\x05\x04\x12\
    \x04\xcb\x01\x02\n\n\r\n\x05\x04\x08\x02\x05\x06\x12\x04\xcb\x01\x0b\x1a\
    \n\r\n\x05\x04\x08\x02\x05\x01\x12\x04\xcb\x01\x1b5\n\r\n\x05\x04\x08\
    \x02\x05\x03\x12\x04\xcb\x0189\n\xf5\x02\n\x04\x04\x08\x02\x06\x12\x04\
    \xd3\x01\x022\x1a\xe6\x02\x20NodeStageSecretRef\x20is\x20a\x20reference\
    \x20to\x20the\x20secret\x20object\x20containing\x20sensitive\n\x20inform\
    ation\x20to\x20pass\x20to\x20the\x20CSI\x20driver\x20to\x20complete\x20t\
    he\x20CSI\x20NodeStageVolume\n\x20and\x20NodeStageVolume\x20and\x20NodeU\
    nstageVolume\x20calls.\n\x20This\x20field\x20is\x20optional,\x20and\x20m\
    ay\x20be\x20empty\x20if\x20no\x20secret\x20is\x20required.\x20If\x20the\
    \n\x20secret\x20object\x20contains\x20more\x20than\x20one\x20secret,\x20\
    all\x20secrets\x20are\x20passed.\n\x20+optional\n\n\r\n\x05\x04\x08\x02\
    \x06\x04\x12\x04\xd3\x01\x02\n\n\r\n\x05\x04\x08\x02\x06\x06\x12\x04\xd3\
    \x01\x0b\x1a\n\r\n\x05\x04\x08\x02\x06\x01\x12\x04\xd3\x01\x1b-\n\r\n\
    \x05\x04\x08\x02\x06\x03\x12\x04\xd3\x0101\n\xe7\x02\n\x04\x04\x08\x02\
    \x07\x12\x04\xdb\x01\x024\x1a\xd8\x02\x20NodePublishSecretRef\x20is\x20a\
    \x20reference\x20to\x20the\x20secret\x20object\x20containing\n\x20sensit\
    ive\x20information\x20to\x20pass\x20to\x20the\x20CSI\x20driver\x20to\x20\
    complete\x20the\x20CSI\n\x20NodePublishVolume\x20and\x20NodeUnpublishVol\
    ume\x20calls.\n\x20This\x20field\x20is\x20optional,\x20and\x20may\x20be\
    \x20empty\x20if\x20no\x20secret\x20is\x20required.\x20If\x20the\n\x20sec\
    ret\x20object\x20contains\x20more\x20than\x20one\x20secret,\x20all\x20se\
    crets\x20are\x20passed.\n\x20+optional\n\n\r\n\x05\x04\x08\x02\x07\x04\
    \x12\x04\xdb\x01\x02\n\n\r\n\x05\x04\x08\x02\x07\x06\x12\x04\xdb\x01\x0b\
    \x1a\n\r\n\x05\x04\x08\x02\x07\x01\x12\x04\xdb\x01\x1b/\n\r\n\x05\x04\
    \x08\x02\x07\x03\x12\x04\xdb\x0123\n\xa5\x03\n\x04\x04\x08\x02\x08\x12\
    \x04\xe4\x01\x029\x1a\x96\x03\x20ControllerExpandSecretRef\x20is\x20a\
    \x20reference\x20to\x20the\x20secret\x20object\x20containing\n\x20sensit\
    ive\x20information\x20to\x20pass\x20to\x20the\x20CSI\x20driver\x20to\x20\
    complete\x20the\x20CSI\n\x20ControllerExpandVolume\x20call.\n\x20This\
    \x20is\x20an\x20alpha\x20field\x20and\x20requires\x20enabling\x20ExpandC\
    SIVolumes\x20feature\x20gate.\n\x20This\x20field\x20is\x20optional,\x20a\
    nd\x20may\x20be\x20empty\x20if\x20no\x20secret\x20is\x20required.\x20If\
    \x20the\n\x20secret\x20object\x20contains\x20more\x20than\x20one\x20secr\
    et,\x20all\x20secrets\x20are\x20passed.\n\x20+optional\n\n\r\n\x05\x04\
    \x08\x02\x08\x04\x12\x04\xe4\x01\x02\n\n\r\n\x05\x04\x08\x02\x08\x06\x12\
    \x04\xe4\x01\x0b\x1a\n\r\n\x05\x04\x08\x02\x08\x01\x12\x04\xe4\x01\x1b4\
    \n\r\n\x05\x04\x08\x02\x08\x03\x12\x04\xe4\x0178\nd\n\x02\x04\t\x12\x06\
    \xe8\x01\0\x84\x02\x01\x1aV\x20Represents\x20a\x20source\x20location\x20\
    of\x20a\x20volume\x20to\x20mount,\x20managed\x20by\x20an\x20external\x20\
    CSI\x20driver\n\n\x0b\n\x03\x04\t\x01\x12\x04\xe8\x01\x08\x17\n\x9b\x01\
    \n\x04\x04\t\x02\0\x12\x04\xeb\x01\x02\x1d\x1a\x8c\x01\x20Driver\x20is\
    \x20the\x20name\x20of\x20the\x20CSI\x20driver\x20that\x20handles\x20this\
    \x20volume.\n\x20Consult\x20with\x20your\x20admin\x20for\x20the\x20corre\
    ct\x20name\x20as\x20registered\x20in\x20the\x20cluster.\n\n\r\n\x05\x04\
    \t\x02\0\x04\x12\x04\xeb\x01\x02\n\n\r\n\x05\x04\t\x02\0\x05\x12\x04\xeb\
    \x01\x0b\x11\n\r\n\x05\x04\t\x02\0\x01\x12\x04\xeb\x01\x12\x18\n\r\n\x05\
    \x04\t\x02\0\x03\x12\x04\xeb\x01\x1b\x1c\no\n\x04\x04\t\x02\x01\x12\x04\
    \xf0\x01\x02\x1d\x1aa\x20Specifies\x20a\x20read-only\x20configuration\
    \x20for\x20the\x20volume.\n\x20Defaults\x20to\x20false\x20(read/write).\
    \n\x20+optional\n\n\r\n\x05\x04\t\x02\x01\x04\x12\x04\xf0\x01\x02\n\n\r\
    \n\x05\x04\t\x02\x01\x05\x12\x04\xf0\x01\x0b\x0f\n\r\n\x05\x04\t\x02\x01\
    \x01\x12\x04\xf0\x01\x10\x18\n\r\n\x05\x04\t\x02\x01\x03\x12\x04\xf0\x01\
    \x1b\x1c\n\xd0\x01\n\x04\x04\t\x02\x02\x12\x04\xf6\x01\x02\x1d\x1a\xc1\
    \x01\x20Filesystem\x20type\x20to\x20mount.\x20Ex.\x20\"ext4\",\x20\"xfs\
    \",\x20\"ntfs\".\n\x20If\x20not\x20provided,\x20the\x20empty\x20value\
    \x20is\x20passed\x20to\x20the\x20associated\x20CSI\x20driver\n\x20which\
    \x20will\x20determine\x20the\x20default\x20filesystem\x20to\x20apply.\n\
    \x20+optional\n\n\r\n\x05\x04\t\x02\x02\x04\x12\x04\xf6\x01\x02\n\n\r\n\
    \x05\x04\t\x02\x02\x05\x12\x04\xf6\x01\x0b\x11\n\r\n\x05\x04\t\x02\x02\
    \x01\x12\x04\xf6\x01\x12\x18\n\r\n\x05\x04\t\x02\x02\x03\x12\x04\xf6\x01\
    \x1b\x1c\n\xac\x01\n\x04\x04\t\x02\x03\x12\x04\xfb\x01\x02+\x1a\x9d\x01\
    \x20VolumeAttributes\x20stores\x20driver-specific\x20properties\x20that\
    \x20are\x20passed\x20to\x20the\x20CSI\n\x20driver.\x20Consult\x20your\
    \x20driver's\x20documentation\x20for\x20supported\x20values.\n\x20+optio\
    nal\n\n\x0f\n\x05\x04\t\x02\x03\x04\x12\x06\xfb\x01\x02\xf6\x01\x1d\n\r\
    \n\x05\x04\t\x02\x03\x06\x12\x04\xfb\x01\x02\x15\n\r\n\x05\x04\t\x02\x03\
    \x01\x12\x04\xfb\x01\x16&\n\r\n\x05\x04\t\x02\x03\x03\x12\x04\xfb\x01)*\
    \n\xf2\x02\n\x04\x04\t\x02\x04\x12\x04\x83\x02\x029\x1a\xe3\x02\x20NodeP\
    ublishSecretRef\x20is\x20a\x20reference\x20to\x20the\x20secret\x20object\
    \x20containing\n\x20sensitive\x20information\x20to\x20pass\x20to\x20the\
    \x20CSI\x20driver\x20to\x20complete\x20the\x20CSI\n\x20NodePublishVolume\
    \x20and\x20NodeUnpublishVolume\x20calls.\n\x20This\x20field\x20is\x20opt\
    ional,\x20and\x20\x20may\x20be\x20empty\x20if\x20no\x20secret\x20is\x20r\
    equired.\x20If\x20the\n\x20secret\x20object\x20contains\x20more\x20than\
    \x20one\x20secret,\x20all\x20secret\x20references\x20are\x20passed.\n\
    \x20+optional\n\n\r\n\x05\x04\t\x02\x04\x04\x12\x04\x83\x02\x02\n\n\r\n\
    \x05\x04\t\x02\x04\x06\x12\x04\x83\x02\x0b\x1f\n\r\n\x05\x04\t\x02\x04\
    \x01\x12\x04\x83\x02\x204\n\r\n\x05\x04\t\x02\x04\x03\x12\x04\x83\x0278\
    \nL\n\x02\x04\n\x12\x06\x87\x02\0\x8f\x02\x01\x1a>\x20Adds\x20and\x20rem\
    oves\x20POSIX\x20capabilities\x20from\x20running\x20containers.\n\n\x0b\
    \n\x03\x04\n\x01\x12\x04\x87\x02\x08\x14\n-\n\x04\x04\n\x02\0\x12\x04\
    \x8a\x02\x02\x1a\x1a\x1f\x20Added\x20capabilities\n\x20+optional\n\n\r\n\
    \x05\x04\n\x02\0\x04\x12\x04\x8a\x02\x02\n\n\r\n\x05\x04\n\x02\0\x05\x12\
    \x04\x8a\x02\x0b\x11\n\r\n\x05\x04\n\x02\0\x01\x12\x04\x8a\x02\x12\x15\n\
    \r\n\x05\x04\n\x02\0\x03\x12\x04\x8a\x02\x18\x19\n/\n\x04\x04\n\x02\x01\
    \x12\x04\x8e\x02\x02\x1b\x1a!\x20Removed\x20capabilities\n\x20+optional\
    \n\n\r\n\x05\x04\n\x02\x01\x04\x12\x04\x8e\x02\x02\n\n\r\n\x05\x04\n\x02\
    \x01\x05\x12\x04\x8e\x02\x0b\x11\n\r\n\x05\x04\n\x02\x01\x01\x12\x04\x8e\
    \x02\x12\x16\n\r\n\x05\x04\n\x02\x01\x03\x12\x04\x8e\x02\x19\x1a\n\x9f\
    \x01\n\x02\x04\x0b\x12\x06\x93\x02\0\xb0\x02\x01\x1a\x90\x01\x20Represen\
    ts\x20a\x20Ceph\x20Filesystem\x20mount\x20that\x20lasts\x20the\x20lifeti\
    me\x20of\x20a\x20pod\n\x20Cephfs\x20volumes\x20do\x20not\x20support\x20o\
    wnership\x20management\x20or\x20SELinux\x20relabeling.\n\n\x0b\n\x03\x04\
    \x0b\x01\x12\x04\x93\x02\x08$\n\x8f\x01\n\x04\x04\x0b\x02\0\x12\x04\x96\
    \x02\x02\x1f\x1a\x80\x01\x20Required:\x20Monitors\x20is\x20a\x20collecti\
    on\x20of\x20Ceph\x20monitors\n\x20More\x20info:\x20https://examples.k8s.\
    io/volumes/cephfs/README.md#how-to-use-it\n\n\r\n\x05\x04\x0b\x02\0\x04\
    \x12\x04\x96\x02\x02\n\n\r\n\x05\x04\x0b\x02\0\x05\x12\x04\x96\x02\x0b\
    \x11\n\r\n\x05\x04\x0b\x02\0\x01\x12\x04\x96\x02\x12\x1a\n\r\n\x05\x04\
    \x0b\x02\0\x03\x12\x04\x96\x02\x1d\x1e\nk\n\x04\x04\x0b\x02\x01\x12\x04\
    \x9a\x02\x02\x1b\x1a]\x20Optional:\x20Used\x20as\x20the\x20mounted\x20ro\
    ot,\x20rather\x20than\x20the\x20full\x20Ceph\x20tree,\x20default\x20is\
    \x20/\n\x20+optional\n\n\r\n\x05\x04\x0b\x02\x01\x04\x12\x04\x9a\x02\x02\
    \n\n\r\n\x05\x04\x0b\x02\x01\x05\x12\x04\x9a\x02\x0b\x11\n\r\n\x05\x04\
    \x0b\x02\x01\x01\x12\x04\x9a\x02\x12\x16\n\r\n\x05\x04\x0b\x02\x01\x03\
    \x12\x04\x9a\x02\x19\x1a\n\x9e\x01\n\x04\x04\x0b\x02\x02\x12\x04\x9f\x02\
    \x02\x1b\x1a\x8f\x01\x20Optional:\x20User\x20is\x20the\x20rados\x20user\
    \x20name,\x20default\x20is\x20admin\n\x20More\x20info:\x20https://exampl\
    es.k8s.io/volumes/cephfs/README.md#how-to-use-it\n\x20+optional\n\n\r\n\
    \x05\x04\x0b\x02\x02\x04\x12\x04\x9f\x02\x02\n\n\r\n\x05\x04\x0b\x02\x02\
    \x05\x12\x04\x9f\x02\x0b\x11\n\r\n\x05\x04\x0b\x02\x02\x01\x12\x04\x9f\
    \x02\x12\x16\n\r\n\x05\x04\x0b\x02\x02\x03\x12\x04\x9f\x02\x19\x1a\n\xbe\
    \x01\n\x04\x04\x0b\x02\x03\x12\x04\xa4\x02\x02!\x1a\xaf\x01\x20Optional:\
    \x20SecretFile\x20is\x20the\x20path\x20to\x20key\x20ring\x20for\x20User,\
    \x20default\x20is\x20/etc/ceph/user.secret\n\x20More\x20info:\x20https:/\
    /examples.k8s.io/volumes/cephfs/README.md#how-to-use-it\n\x20+optional\n\
    \n\r\n\x05\x04\x0b\x02\x03\x04\x12\x04\xa4\x02\x02\n\n\r\n\x05\x04\x0b\
    \x02\x03\x05\x12\x04\xa4\x02\x0b\x11\n\r\n\x05\x04\x0b\x02\x03\x01\x12\
    \x04\xa4\x02\x12\x1c\n\r\n\x05\x04\x0b\x02\x03\x03\x12\x04\xa4\x02\x1f\
    \x20\n\xc0\x01\n\x04\x04\x0b\x02\x04\x12\x04\xa9\x02\x02)\x1a\xb1\x01\
    \x20Optional:\x20SecretRef\x20is\x20reference\x20to\x20the\x20authentica\
    tion\x20secret\x20for\x20User,\x20default\x20is\x20empty.\n\x20More\x20i\
    nfo:\x20https://examples.k8s.io/volumes/cephfs/README.md#how-to-use-it\n\
    \x20+optional\n\n\r\n\x05\x04\x0b\x02\x04\x04\x12\x04\xa9\x02\x02\n\n\r\
    \n\x05\x04\x0b\x02\x04\x06\x12\x04\xa9\x02\x0b\x1a\n\r\n\x05\x04\x0b\x02\
    \x04\x01\x12\x04\xa9\x02\x1b$\n\r\n\x05\x04\x0b\x02\x04\x03\x12\x04\xa9\
    \x02'(\n\xd0\x01\n\x04\x04\x0b\x02\x05\x12\x04\xaf\x02\x02\x1d\x1a\xc1\
    \x01\x20Optional:\x20Defaults\x20to\x20false\x20(read/write).\x20ReadOnl\
    y\x20here\x20will\x20force\n\x20the\x20ReadOnly\x20setting\x20in\x20Volu\
    meMounts.\n\x20More\x20info:\x20https://examples.k8s.io/volumes/cephfs/R\
    EADME.md#how-to-use-it\n\x20+optional\n\n\r\n\x05\x04\x0b\x02\x05\x04\
    \x12\x04\xaf\x02\x02\n\n\r\n\x05\x04\x0b\x02\x05\x05\x12\x04\xaf\x02\x0b\
    \x0f\n\r\n\x05\x04\x0b\x02\x05\x01\x12\x04\xaf\x02\x10\x18\n\r\n\x05\x04\
    \x0b\x02\x05\x03\x12\x04\xaf\x02\x1b\x1c\n\x9f\x01\n\x02\x04\x0c\x12\x06\
    \xb4\x02\0\xd1\x02\x01\x1a\x90\x01\x20Represents\x20a\x20Ceph\x20Filesys\
    tem\x20mount\x20that\x20lasts\x20the\x20lifetime\x20of\x20a\x20pod\n\x20\
    Cephfs\x20volumes\x20do\x20not\x20support\x20ownership\x20management\x20\
    or\x20SELinux\x20relabeling.\n\n\x0b\n\x03\x04\x0c\x01\x12\x04\xb4\x02\
    \x08\x1a\n\x8f\x01\n\x04\x04\x0c\x02\0\x12\x04\xb7\x02\x02\x1f\x1a\x80\
    \x01\x20Required:\x20Monitors\x20is\x20a\x20collection\x20of\x20Ceph\x20\
    monitors\n\x20More\x20info:\x20https://examples.k8s.io/volumes/cephfs/RE\
    ADME.md#how-to-use-it\n\n\r\n\x05\x04\x0c\x02\0\x04\x12\x04\xb7\x02\x02\
    \n\n\r\n\x05\x04\x0c\x02\0\x05\x12\x04\xb7\x02\x0b\x11\n\r\n\x05\x04\x0c\
    \x02\0\x01\x12\x04\xb7\x02\x12\x1a\n\r\n\x05\x04\x0c\x02\0\x03\x12\x04\
    \xb7\x02\x1d\x1e\nk\n\x04\x04\x0c\x02\x01\x12\x04\xbb\x02\x02\x1b\x1a]\
    \x20Optional:\x20Used\x20as\x20the\x20mounted\x20root,\x20rather\x20than\
    \x20the\x20full\x20Ceph\x20tree,\x20default\x20is\x20/\n\x20+optional\n\
    \n\r\n\x05\x04\x0c\x02\x01\x04\x12\x04\xbb\x02\x02\n\n\r\n\x05\x04\x0c\
    \x02\x01\x05\x12\x04\xbb\x02\x0b\x11\n\r\n\x05\x04\x0c\x02\x01\x01\x12\
    \x04\xbb\x02\x12\x16\n\r\n\x05\x04\x0c\x02\x01\x03\x12\x04\xbb\x02\x19\
    \x1a\n\x9e\x01\n\x04\x04\x0c\x02\x02\x12\x04\xc0\x02\x02\x1b\x1a\x8f\x01\
    \x20Optional:\x20User\x20is\x20the\x20rados\x20user\x20name,\x20default\
    \x20is\x20admin\n\x20More\x20info:\x20https://examples.k8s.io/volumes/ce\
    phfs/README.md#how-to-use-it\n\x20+optional\n\n\r\n\x05\x04\x0c\x02\x02\
    \x04\x12\x04\xc0\x02\x02\n\n\r\n\x05\x04\x0c\x02\x02\x05\x12\x04\xc0\x02\
    \x0b\x11\n\r\n\x05\x04\x0c\x02\x02\x01\x12\x04\xc0\x02\x12\x16\n\r\n\x05\
    \x04\x0c\x02\x02\x03\x12\x04\xc0\x02\x19\x1a\n\xbe\x01\n\x04\x04\x0c\x02\
    \x03\x12\x04\xc5\x02\x02!\x1a\xaf\x01\x20Optional:\x20SecretFile\x20is\
    \x20the\x20path\x20to\x20key\x20ring\x20for\x20User,\x20default\x20is\
    \x20/etc/ceph/user.secret\n\x20More\x20info:\x20https://examples.k8s.io/\
    volumes/cephfs/README.md#how-to-use-it\n\x20+optional\n\n\r\n\x05\x04\
    \x0c\x02\x03\x04\x12\x04\xc5\x02\x02\n\n\r\n\x05\x04\x0c\x02\x03\x05\x12\
    \x04\xc5\x02\x0b\x11\n\r\n\x05\x04\x0c\x02\x03\x01\x12\x04\xc5\x02\x12\
    \x1c\n\r\n\x05\x04\x0c\x02\x03\x03\x12\x04\xc5\x02\x1f\x20\n\xc0\x01\n\
    \x04\x04\x0c\x02\x04\x12\x04\xca\x02\x02.\x1a\xb1\x01\x20Optional:\x20Se\
    cretRef\x20is\x20reference\x20to\x20the\x20authentication\x20secret\x20f\
    or\x20User,\x20default\x20is\x20empty.\n\x20More\x20info:\x20https://exa\
    mples.k8s.io/volumes/cephfs/README.md#how-to-use-it\n\x20+optional\n\n\r\
    \n\x05\x04\x0c\x02\x04\x04\x12\x04\xca\x02\x02\n\n\r\n\x05\x04\x0c\x02\
    \x04\x06\x12\x04\xca\x02\x0b\x1f\n\r\n\x05\x04\x0c\x02\x04\x01\x12\x04\
    \xca\x02\x20)\n\r\n\x05\x04\x0c\x02\x04\x03\x12\x04\xca\x02,-\n\xd0\x01\
    \n\x04\x04\x0c\x02\x05\x12\x04\xd0\x02\x02\x1d\x1a\xc1\x01\x20Optional:\
    \x20Defaults\x20to\x20false\x20(read/write).\x20ReadOnly\x20here\x20will\
    \x20force\n\x20the\x20ReadOnly\x20setting\x20in\x20VolumeMounts.\n\x20Mo\
    re\x20info:\x20https://examples.k8s.io/volumes/cephfs/README.md#how-to-u\
    se-it\n\x20+optional\n\n\r\n\x05\x04\x0c\x02\x05\x04\x12\x04\xd0\x02\x02\
    \n\n\r\n\x05\x04\x0c\x02\x05\x05\x12\x04\xd0\x02\x0b\x0f\n\r\n\x05\x04\
    \x0c\x02\x05\x01\x12\x04\xd0\x02\x10\x18\n\r\n\x05\x04\x0c\x02\x05\x03\
    \x12\x04\xd0\x02\x1b\x1c\n\xff\x01\n\x02\x04\r\x12\x06\xd7\x02\0\xed\x02\
    \x01\x1a\xf0\x01\x20Represents\x20a\x20cinder\x20volume\x20resource\x20i\
    n\x20Openstack.\n\x20A\x20Cinder\x20volume\x20must\x20exist\x20before\
    \x20mounting\x20to\x20a\x20container.\n\x20The\x20volume\x20must\x20also\
    \x20be\x20in\x20the\x20same\x20region\x20as\x20the\x20kubelet.\n\x20Cind\
    er\x20volumes\x20support\x20ownership\x20management\x20and\x20SELinux\
    \x20relabeling.\n\n\x0b\n\x03\x04\r\x01\x12\x04\xd7\x02\x08$\n~\n\x04\
    \x04\r\x02\0\x12\x04\xda\x02\x02\x1f\x1ap\x20volume\x20id\x20used\x20to\
    \x20identify\x20the\x20volume\x20in\x20cinder.\n\x20More\x20info:\x20htt\
    ps://examples.k8s.io/mysql-cinder-pd/README.md\n\n\r\n\x05\x04\r\x02\0\
    \x04\x12\x04\xda\x02\x02\n\n\r\n\x05\x04\r\x02\0\x05\x12\x04\xda\x02\x0b\
    \x11\n\r\n\x05\x04\r\x02\0\x01\x12\x04\xda\x02\x12\x1a\n\r\n\x05\x04\r\
    \x02\0\x03\x12\x04\xda\x02\x1d\x1e\n\x89\x02\n\x04\x04\r\x02\x01\x12\x04\
    \xe1\x02\x02\x1d\x1a\xfa\x01\x20Filesystem\x20type\x20to\x20mount.\n\x20\
    Must\x20be\x20a\x20filesystem\x20type\x20supported\x20by\x20the\x20host\
    \x20operating\x20system.\n\x20Examples:\x20\"ext4\",\x20\"xfs\",\x20\"nt\
    fs\".\x20Implicitly\x20inferred\x20to\x20be\x20\"ext4\"\x20if\x20unspeci\
    fied.\n\x20More\x20info:\x20https://examples.k8s.io/mysql-cinder-pd/READ\
    ME.md\n\x20+optional\n\n\r\n\x05\x04\r\x02\x01\x04\x12\x04\xe1\x02\x02\n\
    \n\r\n\x05\x04\r\x02\x01\x05\x12\x04\xe1\x02\x0b\x11\n\r\n\x05\x04\r\x02\
    \x01\x01\x12\x04\xe1\x02\x12\x18\n\r\n\x05\x04\r\x02\x01\x03\x12\x04\xe1\
    \x02\x1b\x1c\n\xc3\x01\n\x04\x04\r\x02\x02\x12\x04\xe7\x02\x02\x1d\x1a\
    \xb4\x01\x20Optional:\x20Defaults\x20to\x20false\x20(read/write).\x20Rea\
    dOnly\x20here\x20will\x20force\n\x20the\x20ReadOnly\x20setting\x20in\x20\
    VolumeMounts.\n\x20More\x20info:\x20https://examples.k8s.io/mysql-cinder\
    -pd/README.md\n\x20+optional\n\n\r\n\x05\x04\r\x02\x02\x04\x12\x04\xe7\
    \x02\x02\n\n\r\n\x05\x04\r\x02\x02\x05\x12\x04\xe7\x02\x0b\x0f\n\r\n\x05\
    \x04\r\x02\x02\x01\x12\x04\xe7\x02\x10\x18\n\r\n\x05\x04\r\x02\x02\x03\
    \x12\x04\xe7\x02\x1b\x1c\ns\n\x04\x04\r\x02\x03\x12\x04\xec\x02\x02)\x1a\
    e\x20Optional:\x20points\x20to\x20a\x20secret\x20object\x20containing\
    \x20parameters\x20used\x20to\x20connect\n\x20to\x20OpenStack.\n\x20+opti\
    onal\n\n\r\n\x05\x04\r\x02\x03\x04\x12\x04\xec\x02\x02\n\n\r\n\x05\x04\r\
    \x02\x03\x06\x12\x04\xec\x02\x0b\x1a\n\r\n\x05\x04\r\x02\x03\x01\x12\x04\
    \xec\x02\x1b$\n\r\n\x05\x04\r\x02\x03\x03\x12\x04\xec\x02'(\n\xff\x01\n\
    \x02\x04\x0e\x12\x06\xf3\x02\0\x89\x03\x01\x1a\xf0\x01\x20Represents\x20\
    a\x20cinder\x20volume\x20resource\x20in\x20Openstack.\n\x20A\x20Cinder\
    \x20volume\x20must\x20exist\x20before\x20mounting\x20to\x20a\x20containe\
    r.\n\x20The\x20volume\x20must\x20also\x20be\x20in\x20the\x20same\x20regi\
    on\x20as\x20the\x20kubelet.\n\x20Cinder\x20volumes\x20support\x20ownersh\
    ip\x20management\x20and\x20SELinux\x20relabeling.\n\n\x0b\n\x03\x04\x0e\
    \x01\x12\x04\xf3\x02\x08\x1a\n~\n\x04\x04\x0e\x02\0\x12\x04\xf6\x02\x02\
    \x1f\x1ap\x20volume\x20id\x20used\x20to\x20identify\x20the\x20volume\x20\
    in\x20cinder.\n\x20More\x20info:\x20https://examples.k8s.io/mysql-cinder\
    -pd/README.md\n\n\r\n\x05\x04\x0e\x02\0\x04\x12\x04\xf6\x02\x02\n\n\r\n\
    \x05\x04\x0e\x02\0\x05\x12\x04\xf6\x02\x0b\x11\n\r\n\x05\x04\x0e\x02\0\
    \x01\x12\x04\xf6\x02\x12\x1a\n\r\n\x05\x04\x0e\x02\0\x03\x12\x04\xf6\x02\
    \x1d\x1e\n\x89\x02\n\x04\x04\x0e\x02\x01\x12\x04\xfd\x02\x02\x1d\x1a\xfa\
    \x01\x20Filesystem\x20type\x20to\x20mount.\n\x20Must\x20be\x20a\x20files\
    ystem\x20type\x20supported\x20by\x20the\x20host\x20operating\x20system.\
    \n\x20Examples:\x20\"ext4\",\x20\"xfs\",\x20\"ntfs\".\x20Implicitly\x20i\
    nferred\x20to\x20be\x20\"ext4\"\x20if\x20unspecified.\n\x20More\x20info:\
    \x20https://examples.k8s.io/mysql-cinder-pd/README.md\n\x20+optional\n\n\
    \r\n\x05\x04\x0e\x02\x01\x04\x12\x04\xfd\x02\x02\n\n\r\n\x05\x04\x0e\x02\
    \x01\x05\x12\x04\xfd\x02\x0b\x11\n\r\n\x05\x04\x0e\x02\x01\x01\x12\x04\
    \xfd\x02\x12\x18\n\r\n\x05\x04\x0e\x02\x01\x03\x12\x04\xfd\x02\x1b\x1c\n\
    \xc3\x01\n\x04\x04\x0e\x02\x02\x12\x04\x83\x03\x02\x1d\x1a\xb4\x01\x20Op\
    tional:\x20Defaults\x20to\x20false\x20(read/write).\x20ReadOnly\x20here\
    \x20will\x20force\n\x20the\x20ReadOnly\x20setting\x20in\x20VolumeMounts.\
    \n\x20More\x20info:\x20https://examples.k8s.io/mysql-cinder-pd/README.md\
    \n\x20+optional\n\n\r\n\x05\x04\x0e\x02\x02\x04\x12\x04\x83\x03\x02\n\n\
    \r\n\x05\x04\x0e\x02\x02\x05\x12\x04\x83\x03\x0b\x0f\n\r\n\x05\x04\x0e\
    \x02\x02\x01\x12\x04\x83\x03\x10\x18\n\r\n\x05\x04\x0e\x02\x02\x03\x12\
    \x04\x83\x03\x1b\x1c\ns\n\x04\x04\x0e\x02\x03\x12\x04\x88\x03\x02.\x1ae\
    \x20Optional:\x20points\x20to\x20a\x20secret\x20object\x20containing\x20\
    parameters\x20used\x20to\x20connect\n\x20to\x20OpenStack.\n\x20+optional\
    \n\n\r\n\x05\x04\x0e\x02\x03\x04\x12\x04\x88\x03\x02\n\n\r\n\x05\x04\x0e\
    \x02\x03\x06\x12\x04\x88\x03\x0b\x1f\n\r\n\x05\x04\x0e\x02\x03\x01\x12\
    \x04\x88\x03\x20)\n\r\n\x05\x04\x0e\x02\x03\x03\x12\x04\x88\x03,-\na\n\
    \x02\x04\x0f\x12\x06\x8c\x03\0\x92\x03\x01\x1aS\x20ClientIPConfig\x20rep\
    resents\x20the\x20configurations\x20of\x20Client\x20IP\x20based\x20sessi\
    on\x20affinity.\n\n\x0b\n\x03\x04\x0f\x01\x12\x04\x8c\x03\x08\x16\n\xda\
    \x01\n\x04\x04\x0f\x02\0\x12\x04\x91\x03\x02$\x1a\xcb\x01\x20timeoutSeco\
    nds\x20specifies\x20the\x20seconds\x20of\x20ClientIP\x20type\x20session\
    \x20sticky\x20time.\n\x20The\x20value\x20must\x20be\x20>0\x20&&\x20<=864\
    00(for\x201\x20day)\x20if\x20ServiceAffinity\x20==\x20\"ClientIP\".\n\
    \x20Default\x20value\x20is\x2010800(for\x203\x20hours).\n\x20+optional\n\
    \n\r\n\x05\x04\x0f\x02\0\x04\x12\x04\x91\x03\x02\n\n\r\n\x05\x04\x0f\x02\
    \0\x05\x12\x04\x91\x03\x0b\x10\n\r\n\x05\x04\x0f\x02\0\x01\x12\x04\x91\
    \x03\x11\x1f\n\r\n\x05\x04\x0f\x02\0\x03\x12\x04\x91\x03\"#\n?\n\x02\x04\
    \x10\x12\x06\x95\x03\0\xa7\x03\x01\x1a1\x20Information\x20about\x20the\
    \x20condition\x20of\x20a\x20component.\n\n\x0b\n\x03\x04\x10\x01\x12\x04\
    \x95\x03\x08\x1a\nJ\n\x04\x04\x10\x02\0\x12\x04\x98\x03\x02\x1b\x1a<\x20\
    Type\x20of\x20condition\x20for\x20a\x20component.\n\x20Valid\x20value:\
    \x20\"Healthy\"\n\n\r\n\x05\x04\x10\x02\0\x04\x12\x04\x98\x03\x02\n\n\r\
    \n\x05\x04\x10\x02\0\x05\x12\x04\x98\x03\x0b\x11\n\r\n\x05\x04\x10\x02\0\
    \x01\x12\x04\x98\x03\x12\x16\n\r\n\x05\x04\x10\x02\0\x03\x12\x04\x98\x03\
    \x19\x1a\nt\n\x04\x04\x10\x02\x01\x12\x04\x9c\x03\x02\x1d\x1af\x20Status\
    \x20of\x20the\x20condition\x20for\x20a\x20component.\n\x20Valid\x20value\
    s\x20for\x20\"Healthy\":\x20\"True\",\x20\"False\",\x20or\x20\"Unknown\"\
    .\n\n\r\n\x05\x04\x10\x02\x01\x04\x12\x04\x9c\x03\x02\n\n\r\n\x05\x04\
    \x10\x02\x01\x05\x12\x04\x9c\x03\x0b\x11\n\r\n\x05\x04\x10\x02\x01\x01\
    \x12\x04\x9c\x03\x12\x18\n\r\n\x05\x04\x10\x02\x01\x03\x12\x04\x9c\x03\
    \x1b\x1c\nw\n\x04\x04\x10\x02\x02\x12\x04\xa1\x03\x02\x1e\x1ai\x20Messag\
    e\x20about\x20the\x20condition\x20for\x20a\x20component.\n\x20For\x20exa\
    mple,\x20information\x20about\x20a\x20health\x20check.\n\x20+optional\n\
    \n\r\n\x05\x04\x10\x02\x02\x04\x12\x04\xa1\x03\x02\n\n\r\n\x05\x04\x10\
    \x02\x02\x05\x12\x04\xa1\x03\x0b\x11\n\r\n\x05\x04\x10\x02\x02\x01\x12\
    \x04\xa1\x03\x12\x19\n\r\n\x05\x04\x10\x02\x02\x03\x12\x04\xa1\x03\x1c\
    \x1d\ni\n\x04\x04\x10\x02\x03\x12\x04\xa6\x03\x02\x1c\x1a[\x20Condition\
    \x20error\x20code\x20for\x20a\x20component.\n\x20For\x20example,\x20a\
    \x20health\x20check\x20error\x20code.\n\x20+optional\n\n\r\n\x05\x04\x10\
    \x02\x03\x04\x12\x04\xa6\x03\x02\n\n\r\n\x05\x04\x10\x02\x03\x05\x12\x04\
    \xa6\x03\x0b\x11\n\r\n\x05\x04\x10\x02\x03\x01\x12\x04\xa6\x03\x12\x17\n\
    \r\n\x05\x04\x10\x02\x03\x03\x12\x04\xa6\x03\x1a\x1b\n\x8a\x01\n\x02\x04\
    \x11\x12\x06\xab\x03\0\xb6\x03\x01\x1a|\x20ComponentStatus\x20(and\x20Co\
    mponentStatusList)\x20holds\x20the\x20cluster\x20validation\x20info.\n\
    \x20Deprecated:\x20This\x20API\x20is\x20deprecated\x20in\x20v1.19+\n\n\
    \x0b\n\x03\x04\x11\x01\x12\x04\xab\x03\x08\x17\n\xa0\x01\n\x04\x04\x11\
    \x02\0\x12\x04\xaf\x03\x02H\x1a\x91\x01\x20Standard\x20object's\x20metad\
    ata.\n\x20More\x20info:\x20https://git.k8s.io/community/contributors/dev\
    el/sig-architecture/api-conventions.md#metadata\n\x20+optional\n\n\r\n\
    \x05\x04\x11\x02\0\x04\x12\x04\xaf\x03\x02\n\n\r\n\x05\x04\x11\x02\0\x06\
    \x12\x04\xaf\x03\x0b:\n\r\n\x05\x04\x11\x02\0\x01\x12\x04\xaf\x03;C\n\r\
    \n\x05\x04\x11\x02\0\x03\x12\x04\xaf\x03FG\nk\n\x04\x04\x11\x02\x01\x12\
    \x04\xb5\x03\x02-\x1a]\x20List\x20of\x20component\x20conditions\x20obser\
    ved\n\x20+optional\n\x20+patchMergeKey=type\n\x20+patchStrategy=merge\n\
    \n\r\n\x05\x04\x11\x02\x01\x04\x12\x04\xb5\x03\x02\n\n\r\n\x05\x04\x11\
    \x02\x01\x06\x12\x04\xb5\x03\x0b\x1d\n\r\n\x05\x04\x11\x02\x01\x01\x12\
    \x04\xb5\x03\x1e(\n\r\n\x05\x04\x11\x02\x01\x03\x12\x04\xb5\x03+,\n\x93\
    \x01\n\x02\x04\x12\x12\x06\xba\x03\0\xc2\x03\x01\x1a\x84\x01\x20Status\
    \x20of\x20all\x20the\x20conditions\x20for\x20the\x20component\x20as\x20a\
    \x20list\x20of\x20ComponentStatus\x20objects.\n\x20Deprecated:\x20This\
    \x20API\x20is\x20deprecated\x20in\x20v1.19+\n\n\x0b\n\x03\x04\x12\x01\
    \x12\x04\xba\x03\x08\x1b\n\x9f\x01\n\x04\x04\x12\x02\0\x12\x04\xbe\x03\
    \x02F\x1a\x90\x01\x20Standard\x20list\x20metadata.\n\x20More\x20info:\
    \x20https://git.k8s.io/community/contributors/devel/sig-architecture/api\
    -conventions.md#types-kinds\n\x20+optional\n\n\r\n\x05\x04\x12\x02\0\x04\
    \x12\x04\xbe\x03\x02\n\n\r\n\x05\x04\x12\x02\0\x06\x12\x04\xbe\x03\x0b8\
    \n\r\n\x05\x04\x12\x02\0\x01\x12\x04\xbe\x039A\n\r\n\x05\x04\x12\x02\0\
    \x03\x12\x04\xbe\x03DE\n0\n\x04\x04\x12\x02\x01\x12\x04\xc1\x03\x02%\x1a\
    \"\x20List\x20of\x20ComponentStatus\x20objects.\n\n\r\n\x05\x04\x12\x02\
    \x01\x04\x12\x04\xc1\x03\x02\n\n\r\n\x05\x04\x12\x02\x01\x06\x12\x04\xc1\
    \x03\x0b\x1a\n\r\n\x05\x04\x12\x02\x01\x01\x12\x04\xc1\x03\x1b\x20\n\r\n\
    \x05\x04\x12\x02\x01\x03\x12\x04\xc1\x03#$\nG\n\x02\x04\x13\x12\x06\xc5\
    \x03\0\xe4\x03\x01\x1a9\x20ConfigMap\x20holds\x20configuration\x20data\
    \x20for\x20pods\x20to\x20consume.\n\n\x0b\n\x03\x04\x13\x01\x12\x04\xc5\
    \x03\x08\x11\n\xa0\x01\n\x04\x04\x13\x02\0\x12\x04\xc9\x03\x02H\x1a\x91\
    \x01\x20Standard\x20object's\x20metadata.\n\x20More\x20info:\x20https://\
    git.k8s.io/community/contributors/devel/sig-architecture/api-conventions\
    .md#metadata\n\x20+optional\n\n\r\n\x05\x04\x13\x02\0\x04\x12\x04\xc9\
    \x03\x02\n\n\r\n\x05\x04\x13\x02\0\x06\x12\x04\xc9\x03\x0b:\n\r\n\x05\
    \x04\x13\x02\0\x01\x12\x04\xc9\x03;C\n\r\n\x05\x04\x13\x02\0\x03\x12\x04\
    \xc9\x03FG\n\xb3\x02\n\x04\x04\x13\x02\x01\x12\x04\xd1\x03\x02\x1e\x1a\
    \xa4\x02\x20Immutable,\x20if\x20set\x20to\x20true,\x20ensures\x20that\
    \x20data\x20stored\x20in\x20the\x20ConfigMap\x20cannot\n\x20be\x20update\
    d\x20(only\x20object\x20metadata\x20can\x20be\x20modified).\n\x20If\x20n\
    ot\x20set\x20to\x20true,\x20the\x20field\x20can\x20be\x20modified\x20at\
    \x20any\x20time.\n\x20Defaulted\x20to\x20nil.\n\x20This\x20is\x20a\x20be\
    ta\x20field\x20enabled\x20by\x20ImmutableEphemeralVolumes\x20feature\x20\
    gate.\n\x20+optional\n\n\r\n\x05\x04\x13\x02\x01\x04\x12\x04\xd1\x03\x02\
    \n\n\r\n\x05\x04\x13\x02\x01\x05\x12\x04\xd1\x03\x0b\x0f\n\r\n\x05\x04\
    \x13\x02\x01\x01\x12\x04\xd1\x03\x10\x19\n\r\n\x05\x04\x13\x02\x01\x03\
    \x12\x04\xd1\x03\x1c\x1d\n\xc8\x02\n\x04\x04\x13\x02\x02\x12\x04\xd9\x03\
    \x02\x1f\x1a\xb9\x02\x20Data\x20contains\x20the\x20configuration\x20data\
    .\n\x20Each\x20key\x20must\x20consist\x20of\x20alphanumeric\x20character\
    s,\x20'-',\x20'_'\x20or\x20'.'.\n\x20Values\x20with\x20non-UTF-8\x20byte\
    \x20sequences\x20must\x20use\x20the\x20BinaryData\x20field.\n\x20The\x20\
    keys\x20stored\x20in\x20Data\x20must\x20not\x20overlap\x20with\x20the\
    \x20keys\x20in\n\x20the\x20BinaryData\x20field,\x20this\x20is\x20enforce\
    d\x20during\x20validation\x20process.\n\x20+optional\n\n\x0f\n\x05\x04\
    \x13\x02\x02\x04\x12\x06\xd9\x03\x02\xd1\x03\x1e\n\r\n\x05\x04\x13\x02\
    \x02\x06\x12\x04\xd9\x03\x02\x15\n\r\n\x05\x04\x13\x02\x02\x01\x12\x04\
    \xd9\x03\x16\x1a\n\r\n\x05\x04\x13\x02\x02\x03\x12\x04\xd9\x03\x1d\x1e\n\
    \x87\x03\n\x04\x04\x13\x02\x03\x12\x04\xe3\x03\x02$\x1a\xf8\x02\x20Binar\
    yData\x20contains\x20the\x20binary\x20data.\n\x20Each\x20key\x20must\x20\
    consist\x20of\x20alphanumeric\x20characters,\x20'-',\x20'_'\x20or\x20'.'\
    .\n\x20BinaryData\x20can\x20contain\x20byte\x20sequences\x20that\x20are\
    \x20not\x20in\x20the\x20UTF-8\x20range.\n\x20The\x20keys\x20stored\x20in\
    \x20BinaryData\x20must\x20not\x20overlap\x20with\x20the\x20ones\x20in\n\
    \x20the\x20Data\x20field,\x20this\x20is\x20enforced\x20during\x20validat\
    ion\x20process.\n\x20Using\x20this\x20field\x20will\x20require\x201.10+\
    \x20apiserver\x20and\n\x20kubelet.\n\x20+optional\n\n\x0f\n\x05\x04\x13\
    \x02\x03\x04\x12\x06\xe3\x03\x02\xd9\x03\x1f\n\r\n\x05\x04\x13\x02\x03\
    \x06\x12\x04\xe3\x03\x02\x14\n\r\n\x05\x04\x13\x02\x03\x01\x12\x04\xe3\
    \x03\x15\x1f\n\r\n\x05\x04\x13\x02\x03\x03\x12\x04\xe3\x03\"#\n\xd6\x01\
    \n\x02\x04\x14\x12\x06\xeb\x03\0\xf2\x03\x01\x1a\xc7\x01\x20ConfigMapEnv\
    Source\x20selects\x20a\x20ConfigMap\x20to\x20populate\x20the\x20environm\
    ent\n\x20variables\x20with.\n\n\x20The\x20contents\x20of\x20the\x20targe\
    t\x20ConfigMap's\x20Data\x20field\x20will\x20represent\x20the\n\x20key-v\
    alue\x20pairs\x20as\x20environment\x20variables.\n\n\x0b\n\x03\x04\x14\
    \x01\x12\x04\xeb\x03\x08\x1a\n-\n\x04\x04\x14\x02\0\x12\x04\xed\x03\x029\
    \x1a\x1f\x20The\x20ConfigMap\x20to\x20select\x20from.\n\n\r\n\x05\x04\
    \x14\x02\0\x04\x12\x04\xed\x03\x02\n\n\r\n\x05\x04\x14\x02\0\x06\x12\x04\
    \xed\x03\x0b\x1f\n\r\n\x05\x04\x14\x02\0\x01\x12\x04\xed\x03\x204\n\r\n\
    \x05\x04\x14\x02\0\x03\x12\x04\xed\x0378\nH\n\x04\x04\x14\x02\x01\x12\
    \x04\xf1\x03\x02\x1d\x1a:\x20Specify\x20whether\x20the\x20ConfigMap\x20m\
    ust\x20be\x20defined\n\x20+optional\n\n\r\n\x05\x04\x14\x02\x01\x04\x12\
    \x04\xf1\x03\x02\n\n\r\n\x05\x04\x14\x02\x01\x05\x12\x04\xf1\x03\x0b\x0f\
    \n\r\n\x05\x04\x14\x02\x01\x01\x12\x04\xf1\x03\x10\x18\n\r\n\x05\x04\x14\
    \x02\x01\x03\x12\x04\xf1\x03\x1b\x1c\n/\n\x02\x04\x15\x12\x06\xf5\x03\0\
    \xff\x03\x01\x1a!\x20Selects\x20a\x20key\x20from\x20a\x20ConfigMap.\n\n\
    \x0b\n\x03\x04\x15\x01\x12\x04\xf5\x03\x08\x1c\n-\n\x04\x04\x15\x02\0\
    \x12\x04\xf7\x03\x029\x1a\x1f\x20The\x20ConfigMap\x20to\x20select\x20fro\
    m.\n\n\r\n\x05\x04\x15\x02\0\x04\x12\x04\xf7\x03\x02\n\n\r\n\x05\x04\x15\
    \x02\0\x06\x12\x04\xf7\x03\x0b\x1f\n\r\n\x05\x04\x15\x02\0\x01\x12\x04\
    \xf7\x03\x204\n\r\n\x05\x04\x15\x02\0\x03\x12\x04\xf7\x0378\n\"\n\x04\
    \x04\x15\x02\x01\x12\x04\xfa\x03\x02\x1a\x1a\x14\x20The\x20key\x20to\x20\
    select.\n\n\r\n\x05\x04\x15\x02\x01\x04\x12\x04\xfa\x03\x02\n\n\r\n\x05\
    \x04\x15\x02\x01\x05\x12\x04\xfa\x03\x0b\x11\n\r\n\x05\x04\x15\x02\x01\
    \x01\x12\x04\xfa\x03\x12\x15\n\r\n\x05\x04\x15\x02\x01\x03\x12\x04\xfa\
    \x03\x18\x19\nS\n\x04\x04\x15\x02\x02\x12\x04\xfe\x03\x02\x1d\x1aE\x20Sp\
    ecify\x20whether\x20the\x20ConfigMap\x20or\x20its\x20key\x20must\x20be\
    \x20defined\n\x20+optional\n\n\r\n\x05\x04\x15\x02\x02\x04\x12\x04\xfe\
    \x03\x02\n\n\r\n\x05\x04\x15\x02\x02\x05\x12\x04\xfe\x03\x0b\x0f\n\r\n\
    \x05\x04\x15\x02\x02\x01\x12\x04\xfe\x03\x10\x18\n\r\n\x05\x04\x15\x02\
    \x02\x03\x12\x04\xfe\x03\x1b\x1c\nS\n\x02\x04\x16\x12\x06\x82\x04\0\x89\
    \x04\x01\x1aE\x20ConfigMapList\x20is\x20a\x20resource\x20containing\x20a\
    \x20list\x20of\x20ConfigMap\x20objects.\n\n\x0b\n\x03\x04\x16\x01\x12\
    \x04\x82\x04\x08\x15\n\x82\x01\n\x04\x04\x16\x02\0\x12\x04\x85\x04\x02F\
    \x1at\x20More\x20info:\x20https://git.k8s.io/community/contributors/deve\
    l/sig-architecture/api-conventions.md#metadata\n\x20+optional\n\n\r\n\
    \x05\x04\x16\x02\0\x04\x12\x04\x85\x04\x02\n\n\r\n\x05\x04\x16\x02\0\x06\
    \x12\x04\x85\x04\x0b8\n\r\n\x05\x04\x16\x02\0\x01\x12\x04\x85\x049A\n\r\
    \n\x05\x04\x16\x02\0\x03\x12\x04\x85\x04DE\n0\n\x04\x04\x16\x02\x01\x12\
    \x04\x88\x04\x02\x1f\x1a\"\x20Items\x20is\x20the\x20list\x20of\x20Config\
    Maps.\n\n\r\n\x05\x04\x16\x02\x01\x04\x12\x04\x88\x04\x02\n\n\r\n\x05\
    \x04\x16\x02\x01\x06\x12\x04\x88\x04\x0b\x14\n\r\n\x05\x04\x16\x02\x01\
    \x01\x12\x04\x88\x04\x15\x1a\n\r\n\x05\x04\x16\x02\x01\x03\x12\x04\x88\
    \x04\x1d\x1e\n|\n\x02\x04\x17\x12\x06\x8c\x04\0\xa2\x04\x01\x1an\x20Conf\
    igMapNodeConfigSource\x20contains\x20the\x20information\x20to\x20referen\
    ce\x20a\x20ConfigMap\x20as\x20a\x20config\x20source\x20for\x20the\x20Nod\
    e.\n\n\x0b\n\x03\x04\x17\x01\x12\x04\x8c\x04\x08!\nv\n\x04\x04\x17\x02\0\
    \x12\x04\x8f\x04\x02\x20\x1ah\x20Namespace\x20is\x20the\x20metadata.name\
    space\x20of\x20the\x20referenced\x20ConfigMap.\n\x20This\x20field\x20is\
    \x20required\x20in\x20all\x20cases.\n\n\r\n\x05\x04\x17\x02\0\x04\x12\
    \x04\x8f\x04\x02\n\n\r\n\x05\x04\x17\x02\0\x05\x12\x04\x8f\x04\x0b\x11\n\
    \r\n\x05\x04\x17\x02\0\x01\x12\x04\x8f\x04\x12\x1b\n\r\n\x05\x04\x17\x02\
    \0\x03\x12\x04\x8f\x04\x1e\x1f\nl\n\x04\x04\x17\x02\x01\x12\x04\x93\x04\
    \x02\x1b\x1a^\x20Name\x20is\x20the\x20metadata.name\x20of\x20the\x20refe\
    renced\x20ConfigMap.\n\x20This\x20field\x20is\x20required\x20in\x20all\
    \x20cases.\n\n\r\n\x05\x04\x17\x02\x01\x04\x12\x04\x93\x04\x02\n\n\r\n\
    \x05\x04\x17\x02\x01\x05\x12\x04\x93\x04\x0b\x11\n\r\n\x05\x04\x17\x02\
    \x01\x01\x12\x04\x93\x04\x12\x16\n\r\n\x05\x04\x17\x02\x01\x03\x12\x04\
    \x93\x04\x19\x1a\n\x94\x01\n\x04\x04\x17\x02\x02\x12\x04\x98\x04\x02\x1a\
    \x1a\x85\x01\x20UID\x20is\x20the\x20metadata.UID\x20of\x20the\x20referen\
    ced\x20ConfigMap.\n\x20This\x20field\x20is\x20forbidden\x20in\x20Node.Sp\
    ec,\x20and\x20required\x20in\x20Node.Status.\n\x20+optional\n\n\r\n\x05\
    \x04\x17\x02\x02\x04\x12\x04\x98\x04\x02\n\n\r\n\x05\x04\x17\x02\x02\x05\
    \x12\x04\x98\x04\x0b\x11\n\r\n\x05\x04\x17\x02\x02\x01\x12\x04\x98\x04\
    \x12\x15\n\r\n\x05\x04\x17\x02\x02\x03\x12\x04\x98\x04\x18\x19\n\xac\x01\
    \n\x04\x04\x17\x02\x03\x12\x04\x9d\x04\x02&\x1a\x9d\x01\x20ResourceVersi\
    on\x20is\x20the\x20metadata.ResourceVersion\x20of\x20the\x20referenced\
    \x20ConfigMap.\n\x20This\x20field\x20is\x20forbidden\x20in\x20Node.Spec,\
    \x20and\x20required\x20in\x20Node.Status.\n\x20+optional\n\n\r\n\x05\x04\
    \x17\x02\x03\x04\x12\x04\x9d\x04\x02\n\n\r\n\x05\x04\x17\x02\x03\x05\x12\
    \x04\x9d\x04\x0b\x11\n\r\n\x05\x04\x17\x02\x03\x01\x12\x04\x9d\x04\x12!\
    \n\r\n\x05\x04\x17\x02\x03\x03\x12\x04\x9d\x04$%\n\xa8\x01\n\x04\x04\x17\
    \x02\x04\x12\x04\xa1\x04\x02'\x1a\x99\x01\x20KubeletConfigKey\x20declare\
    s\x20which\x20key\x20of\x20the\x20referenced\x20ConfigMap\x20corresponds\
    \x20to\x20the\x20KubeletConfiguration\x20structure\n\x20This\x20field\
    \x20is\x20required\x20in\x20all\x20cases.\n\n\r\n\x05\x04\x17\x02\x04\
    \x04\x12\x04\xa1\x04\x02\n\n\r\n\x05\x04\x17\x02\x04\x05\x12\x04\xa1\x04\
    \x0b\x11\n\r\n\x05\x04\x17\x02\x04\x01\x12\x04\xa1\x04\x12\"\n\r\n\x05\
    \x04\x17\x02\x04\x03\x12\x04\xa1\x04%&\n\xfb\x02\n\x02\x04\x18\x12\x06\
    \xab\x04\0\xbb\x04\x01\x1a\xec\x02\x20Adapts\x20a\x20ConfigMap\x20into\
    \x20a\x20projected\x20volume.\n\n\x20The\x20contents\x20of\x20the\x20tar\
    get\x20ConfigMap's\x20Data\x20field\x20will\x20be\x20presented\x20in\x20\
    a\n\x20projected\x20volume\x20as\x20files\x20using\x20the\x20keys\x20in\
    \x20the\x20Data\x20field\x20as\x20the\x20file\x20names,\n\x20unless\x20t\
    he\x20items\x20element\x20is\x20populated\x20with\x20specific\x20mapping\
    s\x20of\x20keys\x20to\x20paths.\n\x20Note\x20that\x20this\x20is\x20ident\
    ical\x20to\x20a\x20configmap\x20volume\x20source\x20without\x20the\x20de\
    fault\n\x20mode.\n\n\x0b\n\x03\x04\x18\x01\x12\x04\xab\x04\x08\x1b\n\x0c\
    \n\x04\x04\x18\x02\0\x12\x04\xac\x04\x029\n\r\n\x05\x04\x18\x02\0\x04\
    \x12\x04\xac\x04\x02\n\n\r\n\x05\x04\x18\x02\0\x06\x12\x04\xac\x04\x0b\
    \x1f\n\r\n\x05\x04\x18\x02\0\x01\x12\x04\xac\x04\x204\n\r\n\x05\x04\x18\
    \x02\0\x03\x12\x04\xac\x0478\n\x84\x04\n\x04\x04\x18\x02\x01\x12\x04\xb6\
    \x04\x02\x1f\x1a\xf5\x03\x20If\x20unspecified,\x20each\x20key-value\x20p\
    air\x20in\x20the\x20Data\x20field\x20of\x20the\x20referenced\n\x20Config\
    Map\x20will\x20be\x20projected\x20into\x20the\x20volume\x20as\x20a\x20fi\
    le\x20whose\x20name\x20is\x20the\n\x20key\x20and\x20content\x20is\x20the\
    \x20value.\x20If\x20specified,\x20the\x20listed\x20keys\x20will\x20be\n\
    \x20projected\x20into\x20the\x20specified\x20paths,\x20and\x20unlisted\
    \x20keys\x20will\x20not\x20be\n\x20present.\x20If\x20a\x20key\x20is\x20s\
    pecified\x20which\x20is\x20not\x20present\x20in\x20the\x20ConfigMap,\n\
    \x20the\x20volume\x20setup\x20will\x20error\x20unless\x20it\x20is\x20mar\
    ked\x20optional.\x20Paths\x20must\x20be\n\x20relative\x20and\x20may\x20n\
    ot\x20contain\x20the\x20'..'\x20path\x20or\x20start\x20with\x20'..'.\n\
    \x20+optional\n\n\r\n\x05\x04\x18\x02\x01\x04\x12\x04\xb6\x04\x02\n\n\r\
    \n\x05\x04\x18\x02\x01\x06\x12\x04\xb6\x04\x0b\x14\n\r\n\x05\x04\x18\x02\
    \x01\x01\x12\x04\xb6\x04\x15\x1a\n\r\n\x05\x04\x18\x02\x01\x03\x12\x04\
    \xb6\x04\x1d\x1e\nT\n\x04\x04\x18\x02\x02\x12\x04\xba\x04\x02\x1d\x1aF\
    \x20Specify\x20whether\x20the\x20ConfigMap\x20or\x20its\x20keys\x20must\
    \x20be\x20defined\n\x20+optional\n\n\r\n\x05\x04\x18\x02\x02\x04\x12\x04\
    \xba\x04\x02\n\n\r\n\x05\x04\x18\x02\x02\x05\x12\x04\xba\x04\x0b\x0f\n\r\
    \n\x05\x04\x18\x02\x02\x01\x12\x04\xba\x04\x10\x18\n\r\n\x05\x04\x18\x02\
    \x02\x03\x12\x04\xba\x04\x1b\x1c\n\xda\x02\n\x02\x04\x19\x12\x06\xc3\x04\
    \0\xdd\x04\x01\x1a\xcb\x02\x20Adapts\x20a\x20ConfigMap\x20into\x20a\x20v\
    olume.\n\n\x20The\x20contents\x20of\x20the\x20target\x20ConfigMap's\x20D\
    ata\x20field\x20will\x20be\x20presented\x20in\x20a\n\x20volume\x20as\x20\
    files\x20using\x20the\x20keys\x20in\x20the\x20Data\x20field\x20as\x20the\
    \x20file\x20names,\x20unless\n\x20the\x20items\x20element\x20is\x20popul\
    ated\x20with\x20specific\x20mappings\x20of\x20keys\x20to\x20paths.\n\x20\
    ConfigMap\x20volumes\x20support\x20ownership\x20management\x20and\x20SEL\
    inux\x20relabeling.\n\n\x0b\n\x03\x04\x19\x01\x12\x04\xc3\x04\x08\x1d\n\
    \x0c\n\x04\x04\x19\x02\0\x12\x04\xc4\x04\x029\n\r\n\x05\x04\x19\x02\0\
    \x04\x12\x04\xc4\x04\x02\n\n\r\n\x05\x04\x19\x02\0\x06\x12\x04\xc4\x04\
    \x0b\x1f\n\r\n\x05\x04\x19\x02\0\x01\x12\x04\xc4\x04\x204\n\r\n\x05\x04\
    \x19\x02\0\x03\x12\x04\xc4\x0478\n\x84\x04\n\x04\x04\x19\x02\x01\x12\x04\
    \xce\x04\x02\x1f\x1a\xf5\x03\x20If\x20unspecified,\x20each\x20key-value\
    \x20pair\x20in\x20the\x20Data\x20field\x20of\x20the\x20referenced\n\x20C\
    onfigMap\x20will\x20be\x20projected\x20into\x20the\x20volume\x20as\x20a\
    \x20file\x20whose\x20name\x20is\x20the\n\x20key\x20and\x20content\x20is\
    \x20the\x20value.\x20If\x20specified,\x20the\x20listed\x20keys\x20will\
    \x20be\n\x20projected\x20into\x20the\x20specified\x20paths,\x20and\x20un\
    listed\x20keys\x20will\x20not\x20be\n\x20present.\x20If\x20a\x20key\x20i\
    s\x20specified\x20which\x20is\x20not\x20present\x20in\x20the\x20ConfigMa\
    p,\n\x20the\x20volume\x20setup\x20will\x20error\x20unless\x20it\x20is\
    \x20marked\x20optional.\x20Paths\x20must\x20be\n\x20relative\x20and\x20m\
    ay\x20not\x20contain\x20the\x20'..'\x20path\x20or\x20start\x20with\x20'.\
    .'.\n\x20+optional\n\n\r\n\x05\x04\x19\x02\x01\x04\x12\x04\xce\x04\x02\n\
    \n\r\n\x05\x04\x19\x02\x01\x06\x12\x04\xce\x04\x0b\x14\n\r\n\x05\x04\x19\
    \x02\x01\x01\x12\x04\xce\x04\x15\x1a\n\r\n\x05\x04\x19\x02\x01\x03\x12\
    \x04\xce\x04\x1d\x1e\n\xe6\x03\n\x04\x04\x19\x02\x02\x12\x04\xd8\x04\x02\
    !\x1a\xd7\x03\x20Optional:\x20mode\x20bits\x20used\x20to\x20set\x20permi\
    ssions\x20on\x20created\x20files\x20by\x20default.\n\x20Must\x20be\x20an\
    \x20octal\x20value\x20between\x200000\x20and\x200777\x20or\x20a\x20decim\
    al\x20value\x20between\x200\x20and\x20511.\n\x20YAML\x20accepts\x20both\
    \x20octal\x20and\x20decimal\x20values,\x20JSON\x20requires\x20decimal\
    \x20values\x20for\x20mode\x20bits.\n\x20Defaults\x20to\x200644.\n\x20Dir\
    ectories\x20within\x20the\x20path\x20are\x20not\x20affected\x20by\x20thi\
    s\x20setting.\n\x20This\x20might\x20be\x20in\x20conflict\x20with\x20othe\
    r\x20options\x20that\x20affect\x20the\x20file\n\x20mode,\x20like\x20fsGr\
    oup,\x20and\x20the\x20result\x20can\x20be\x20other\x20mode\x20bits\x20se\
    t.\n\x20+optional\n\n\r\n\x05\x04\x19\x02\x02\x04\x12\x04\xd8\x04\x02\n\
    \n\r\n\x05\x04\x19\x02\x02\x05\x12\x04\xd8\x04\x0b\x10\n\r\n\x05\x04\x19\
    \x02\x02\x01\x12\x04\xd8\x04\x11\x1c\n\r\n\x05\x04\x19\x02\x02\x03\x12\
    \x04\xd8\x04\x1f\x20\nT\n\x04\x04\x19\x02\x03\x12\x04\xdc\x04\x02\x1d\
    \x1aF\x20Specify\x20whether\x20the\x20ConfigMap\x20or\x20its\x20keys\x20\
    must\x20be\x20defined\n\x20+optional\n\n\r\n\x05\x04\x19\x02\x03\x04\x12\
    \x04\xdc\x04\x02\n\n\r\n\x05\x04\x19\x02\x03\x05\x12\x04\xdc\x04\x0b\x0f\
    \n\r\n\x05\x04\x19\x02\x03\x01\x12\x04\xdc\x04\x10\x18\n\r\n\x05\x04\x19\
    \x02\x03\x03\x12\x04\xdc\x04\x1b\x1c\nQ\n\x02\x04\x1a\x12\x06\xe0\x04\0\
    \x8f\x06\x01\x1aC\x20A\x20single\x20application\x20container\x20that\x20\
    you\x20want\x20to\x20run\x20within\x20a\x20pod.\n\n\x0b\n\x03\x04\x1a\
    \x01\x12\x04\xe0\x04\x08\x11\n\x92\x01\n\x04\x04\x1a\x02\0\x12\x04\xe4\
    \x04\x02\x1b\x1a\x83\x01\x20Name\x20of\x20the\x20container\x20specified\
    \x20as\x20a\x20DNS_LABEL.\n\x20Each\x20container\x20in\x20a\x20pod\x20mu\
    st\x20have\x20a\x20unique\x20name\x20(DNS_LABEL).\n\x20Cannot\x20be\x20u\
    pdated.\n\n\r\n\x05\x04\x1a\x02\0\x04\x12\x04\xe4\x04\x02\n\n\r\n\x05\
    \x04\x1a\x02\0\x05\x12\x04\xe4\x04\x0b\x11\n\r\n\x05\x04\x1a\x02\0\x01\
    \x12\x04\xe4\x04\x12\x16\n\r\n\x05\x04\x1a\x02\0\x03\x12\x04\xe4\x04\x19\
    \x1a\n\x94\x02\n\x04\x04\x1a\x02\x01\x12\x04\xeb\x04\x02\x1c\x1a\x85\x02\
    \x20Docker\x20image\x20name.\n\x20More\x20info:\x20https://kubernetes.io\
    /docs/concepts/containers/images\n\x20This\x20field\x20is\x20optional\
    \x20to\x20allow\x20higher\x20level\x20config\x20management\x20to\x20defa\
    ult\x20or\x20override\n\x20container\x20images\x20in\x20workload\x20cont\
    rollers\x20like\x20Deployments\x20and\x20StatefulSets.\n\x20+optional\n\
    \n\r\n\x05\x04\x1a\x02\x01\x04\x12\x04\xeb\x04\x02\n\n\r\n\x05\x04\x1a\
    \x02\x01\x05\x12\x04\xeb\x04\x0b\x11\n\r\n\x05\x04\x1a\x02\x01\x01\x12\
    \x04\xeb\x04\x12\x17\n\r\n\x05\x04\x1a\x02\x01\x03\x12\x04\xeb\x04\x1a\
    \x1b\n\xf5\x04\n\x04\x04\x1a\x02\x02\x12\x04\xf6\x04\x02\x1e\x1a\xe6\x04\
    \x20Entrypoint\x20array.\x20Not\x20executed\x20within\x20a\x20shell.\n\
    \x20The\x20docker\x20image's\x20ENTRYPOINT\x20is\x20used\x20if\x20this\
    \x20is\x20not\x20provided.\n\x20Variable\x20references\x20$(VAR_NAME)\
    \x20are\x20expanded\x20using\x20the\x20container's\x20environment.\x20If\
    \x20a\x20variable\n\x20cannot\x20be\x20resolved,\x20the\x20reference\x20\
    in\x20the\x20input\x20string\x20will\x20be\x20unchanged.\x20The\x20$(VAR\
    _NAME)\x20syntax\n\x20can\x20be\x20escaped\x20with\x20a\x20double\x20$$,\
    \x20ie:\x20$$(VAR_NAME).\x20Escaped\x20references\x20will\x20never\x20be\
    \x20expanded,\n\x20regardless\x20of\x20whether\x20the\x20variable\x20exi\
    sts\x20or\x20not.\n\x20Cannot\x20be\x20updated.\n\x20More\x20info:\x20ht\
    tps://kubernetes.io/docs/tasks/inject-data-application/define-command-ar\
    gument-container/#running-a-command-in-a-shell\n\x20+optional\n\n\r\n\
    \x05\x04\x1a\x02\x02\x04\x12\x04\xf6\x04\x02\n\n\r\n\x05\x04\x1a\x02\x02\
    \x05\x12\x04\xf6\x04\x0b\x11\n\r\n\x05\x04\x1a\x02\x02\x01\x12\x04\xf6\
    \x04\x12\x19\n\r\n\x05\x04\x1a\x02\x02\x03\x12\x04\xf6\x04\x1c\x1d\n\xdc\
    \x04\n\x04\x04\x1a\x02\x03\x12\x04\x81\x05\x02\x1b\x1a\xcd\x04\x20Argume\
    nts\x20to\x20the\x20entrypoint.\n\x20The\x20docker\x20image's\x20CMD\x20\
    is\x20used\x20if\x20this\x20is\x20not\x20provided.\n\x20Variable\x20refe\
    rences\x20$(VAR_NAME)\x20are\x20expanded\x20using\x20the\x20container's\
    \x20environment.\x20If\x20a\x20variable\n\x20cannot\x20be\x20resolved,\
    \x20the\x20reference\x20in\x20the\x20input\x20string\x20will\x20be\x20un\
    changed.\x20The\x20$(VAR_NAME)\x20syntax\n\x20can\x20be\x20escaped\x20wi\
    th\x20a\x20double\x20$$,\x20ie:\x20$$(VAR_NAME).\x20Escaped\x20reference\
    s\x20will\x20never\x20be\x20expanded,\n\x20regardless\x20of\x20whether\
    \x20the\x20variable\x20exists\x20or\x20not.\n\x20Cannot\x20be\x20updated\
    .\n\x20More\x20info:\x20https://kubernetes.io/docs/tasks/inject-data-app\
    lication/define-command-argument-container/#running-a-command-in-a-shell\
    \n\x20+optional\n\n\r\n\x05\x04\x1a\x02\x03\x04\x12\x04\x81\x05\x02\n\n\
    \r\n\x05\x04\x1a\x02\x03\x05\x12\x04\x81\x05\x0b\x11\n\r\n\x05\x04\x1a\
    \x02\x03\x01\x12\x04\x81\x05\x12\x16\n\r\n\x05\x04\x1a\x02\x03\x03\x12\
    \x04\x81\x05\x19\x1a\n\xc2\x01\n\x04\x04\x1a\x02\x04\x12\x04\x88\x05\x02\
    !\x1a\xb3\x01\x20Container's\x20working\x20directory.\n\x20If\x20not\x20\
    specified,\x20the\x20container\x20runtime's\x20default\x20will\x20be\x20\
    used,\x20which\n\x20might\x20be\x20configured\x20in\x20the\x20container\
    \x20image.\n\x20Cannot\x20be\x20updated.\n\x20+optional\n\n\r\n\x05\x04\
    \x1a\x02\x04\x04\x12\x04\x88\x05\x02\n\n\r\n\x05\x04\x1a\x02\x04\x05\x12\
    \x04\x88\x05\x0b\x11\n\r\n\x05\x04\x1a\x02\x04\x01\x12\x04\x88\x05\x12\
    \x1c\n\r\n\x05\x04\x1a\x02\x04\x03\x12\x04\x88\x05\x1f\x20\n\xa0\x04\n\
    \x04\x04\x1a\x02\x05\x12\x04\x97\x05\x02#\x1a\x91\x04\x20List\x20of\x20p\
    orts\x20to\x20expose\x20from\x20the\x20container.\x20Exposing\x20a\x20po\
    rt\x20here\x20gives\n\x20the\x20system\x20additional\x20information\x20a\
    bout\x20the\x20network\x20connections\x20a\n\x20container\x20uses,\x20bu\
    t\x20is\x20primarily\x20informational.\x20Not\x20specifying\x20a\x20port\
    \x20here\n\x20DOES\x20NOT\x20prevent\x20that\x20port\x20from\x20being\
    \x20exposed.\x20Any\x20port\x20which\x20is\n\x20listening\x20on\x20the\
    \x20default\x20\"0.0.0.0\"\x20address\x20inside\x20a\x20container\x20wil\
    l\x20be\n\x20accessible\x20from\x20the\x20network.\n\x20Cannot\x20be\x20\
    updated.\n\x20+optional\n\x20+patchMergeKey=containerPort\n\x20+patchStr\
    ategy=merge\n\x20+listType=map\n\x20+listMapKey=containerPort\n\x20+list\
    MapKey=protocol\n\n\r\n\x05\x04\x1a\x02\x05\x04\x12\x04\x97\x05\x02\n\n\
    \r\n\x05\x04\x1a\x02\x05\x06\x12\x04\x97\x05\x0b\x18\n\r\n\x05\x04\x1a\
    \x02\x05\x01\x12\x04\x97\x05\x19\x1e\n\r\n\x05\x04\x1a\x02\x05\x03\x12\
    \x04\x97\x05!\"\n\xa9\x03\n\x04\x04\x1a\x02\x06\x12\x04\xa0\x05\x02&\x1a\
    \x9a\x03\x20List\x20of\x20sources\x20to\x20populate\x20environment\x20va\
    riables\x20in\x20the\x20container.\n\x20The\x20keys\x20defined\x20within\
    \x20a\x20source\x20must\x20be\x20a\x20C_IDENTIFIER.\x20All\x20invalid\
    \x20keys\n\x20will\x20be\x20reported\x20as\x20an\x20event\x20when\x20the\
    \x20container\x20is\x20starting.\x20When\x20a\x20key\x20exists\x20in\x20\
    multiple\n\x20sources,\x20the\x20value\x20associated\x20with\x20the\x20l\
    ast\x20source\x20will\x20take\x20precedence.\n\x20Values\x20defined\x20b\
    y\x20an\x20Env\x20with\x20a\x20duplicate\x20key\x20will\x20take\x20prece\
    dence.\n\x20Cannot\x20be\x20updated.\n\x20+optional\n\n\r\n\x05\x04\x1a\
    \x02\x06\x04\x12\x04\xa0\x05\x02\n\n\r\n\x05\x04\x1a\x02\x06\x06\x12\x04\
    \xa0\x05\x0b\x18\n\r\n\x05\x04\x1a\x02\x06\x01\x12\x04\xa0\x05\x19\x20\n\
    \r\n\x05\x04\x1a\x02\x06\x03\x12\x04\xa0\x05#%\n\x91\x01\n\x04\x04\x1a\
    \x02\x07\x12\x04\xa7\x05\x02\x1a\x1a\x82\x01\x20List\x20of\x20environmen\
    t\x20variables\x20to\x20set\x20in\x20the\x20container.\n\x20Cannot\x20be\
    \x20updated.\n\x20+optional\n\x20+patchMergeKey=name\n\x20+patchStrategy\
    =merge\n\n\r\n\x05\x04\x1a\x02\x07\x04\x12\x04\xa7\x05\x02\n\n\r\n\x05\
    \x04\x1a\x02\x07\x06\x12\x04\xa7\x05\x0b\x11\n\r\n\x05\x04\x1a\x02\x07\
    \x01\x12\x04\xa7\x05\x12\x15\n\r\n\x05\x04\x1a\x02\x07\x03\x12\x04\xa7\
    \x05\x18\x19\n\xbf\x01\n\x04\x04\x1a\x02\x08\x12\x04\xad\x05\x02.\x1a\
    \xb0\x01\x20Compute\x20Resources\x20required\x20by\x20this\x20container.\
    \n\x20Cannot\x20be\x20updated.\n\x20More\x20info:\x20https://kubernetes.\
    io/docs/concepts/configuration/manage-compute-resources-container/\n\x20\
    +optional\n\n\r\n\x05\x04\x1a\x02\x08\x04\x12\x04\xad\x05\x02\n\n\r\n\
    \x05\x04\x1a\x02\x08\x06\x12\x04\xad\x05\x0b\x1f\n\r\n\x05\x04\x1a\x02\
    \x08\x01\x12\x04\xad\x05\x20)\n\r\n\x05\x04\x1a\x02\x08\x03\x12\x04\xad\
    \x05,-\n\x95\x01\n\x04\x04\x1a\x02\t\x12\x04\xb4\x05\x02(\x1a\x86\x01\
    \x20Pod\x20volumes\x20to\x20mount\x20into\x20the\x20container's\x20files\
    ystem.\n\x20Cannot\x20be\x20updated.\n\x20+optional\n\x20+patchMergeKey=\
    mountPath\n\x20+patchStrategy=merge\n\n\r\n\x05\x04\x1a\x02\t\x04\x12\
    \x04\xb4\x05\x02\n\n\r\n\x05\x04\x1a\x02\t\x06\x12\x04\xb4\x05\x0b\x16\n\
    \r\n\x05\x04\x1a\x02\t\x01\x12\x04\xb4\x05\x17#\n\r\n\x05\x04\x1a\x02\t\
    \x03\x12\x04\xb4\x05&'\n\x94\x01\n\x04\x04\x1a\x02\n\x12\x04\xba\x05\x02\
    +\x1a\x85\x01\x20volumeDevices\x20is\x20the\x20list\x20of\x20block\x20de\
    vices\x20to\x20be\x20used\x20by\x20the\x20container.\n\x20+patchMergeKey\
    =devicePath\n\x20+patchStrategy=merge\n\x20+optional\n\n\r\n\x05\x04\x1a\
    \x02\n\x04\x12\x04\xba\x05\x02\n\n\r\n\x05\x04\x1a\x02\n\x06\x12\x04\xba\
    \x05\x0b\x17\n\r\n\x05\x04\x1a\x02\n\x01\x12\x04\xba\x05\x18%\n\r\n\x05\
    \x04\x1a\x02\n\x03\x12\x04\xba\x05(*\n\xe4\x01\n\x04\x04\x1a\x02\x0b\x12\
    \x04\xc1\x05\x02$\x1a\xd5\x01\x20Periodic\x20probe\x20of\x20container\
    \x20liveness.\n\x20Container\x20will\x20be\x20restarted\x20if\x20the\x20\
    probe\x20fails.\n\x20Cannot\x20be\x20updated.\n\x20More\x20info:\x20http\
    s://kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#container-p\
    robes\n\x20+optional\n\n\r\n\x05\x04\x1a\x02\x0b\x04\x12\x04\xc1\x05\x02\
    \n\n\r\n\x05\x04\x1a\x02\x0b\x06\x12\x04\xc1\x05\x0b\x10\n\r\n\x05\x04\
    \x1a\x02\x0b\x01\x12\x04\xc1\x05\x11\x1e\n\r\n\x05\x04\x1a\x02\x0b\x03\
    \x12\x04\xc1\x05!#\n\x82\x02\n\x04\x04\x1a\x02\x0c\x12\x04\xc8\x05\x02%\
    \x1a\xf3\x01\x20Periodic\x20probe\x20of\x20container\x20service\x20readi\
    ness.\n\x20Container\x20will\x20be\x20removed\x20from\x20service\x20endp\
    oints\x20if\x20the\x20probe\x20fails.\n\x20Cannot\x20be\x20updated.\n\
    \x20More\x20info:\x20https://kubernetes.io/docs/concepts/workloads/pods/\
    pod-lifecycle#container-probes\n\x20+optional\n\n\r\n\x05\x04\x1a\x02\
    \x0c\x04\x12\x04\xc8\x05\x02\n\n\r\n\x05\x04\x1a\x02\x0c\x06\x12\x04\xc8\
    \x05\x0b\x10\n\r\n\x05\x04\x1a\x02\x0c\x01\x12\x04\xc8\x05\x11\x1f\n\r\n\
    \x05\x04\x1a\x02\x0c\x03\x12\x04\xc8\x05\"$\n\xba\x04\n\x04\x04\x1a\x02\
    \r\x12\x04\xd2\x05\x02#\x1a\xab\x04\x20StartupProbe\x20indicates\x20that\
    \x20the\x20Pod\x20has\x20successfully\x20initialized.\n\x20If\x20specifi\
    ed,\x20no\x20other\x20probes\x20are\x20executed\x20until\x20this\x20comp\
    letes\x20successfully.\n\x20If\x20this\x20probe\x20fails,\x20the\x20Pod\
    \x20will\x20be\x20restarted,\x20just\x20as\x20if\x20the\x20livenessProbe\
    \x20failed.\n\x20This\x20can\x20be\x20used\x20to\x20provide\x20different\
    \x20probe\x20parameters\x20at\x20the\x20beginning\x20of\x20a\x20Pod's\
    \x20lifecycle,\n\x20when\x20it\x20might\x20take\x20a\x20long\x20time\x20\
    to\x20load\x20data\x20or\x20warm\x20a\x20cache,\x20than\x20during\x20ste\
    ady-state\x20operation.\n\x20This\x20cannot\x20be\x20updated.\n\x20More\
    \x20info:\x20https://kubernetes.io/docs/concepts/workloads/pods/pod-life\
    cycle#container-probes\n\x20+optional\n\n\r\n\x05\x04\x1a\x02\r\x04\x12\
    \x04\xd2\x05\x02\n\n\r\n\x05\x04\x1a\x02\r\x06\x12\x04\xd2\x05\x0b\x10\n\
    \r\n\x05\x04\x1a\x02\r\x01\x12\x04\xd2\x05\x11\x1d\n\r\n\x05\x04\x1a\x02\
    \r\x03\x12\x04\xd2\x05\x20\"\n\x88\x01\n\x04\x04\x1a\x02\x0e\x12\x04\xd7\
    \x05\x02$\x1az\x20Actions\x20that\x20the\x20management\x20system\x20shou\
    ld\x20take\x20in\x20response\x20to\x20container\x20lifecycle\x20events.\
    \n\x20Cannot\x20be\x20updated.\n\x20+optional\n\n\r\n\x05\x04\x1a\x02\
    \x0e\x04\x12\x04\xd7\x05\x02\n\n\r\n\x05\x04\x1a\x02\x0e\x06\x12\x04\xd7\
    \x05\x0b\x14\n\r\n\x05\x04\x1a\x02\x0e\x01\x12\x04\xd7\x05\x15\x1e\n\r\n\
    \x05\x04\x1a\x02\x0e\x03\x12\x04\xd7\x05!#\n\xbe\x03\n\x04\x04\x1a\x02\
    \x0f\x12\x04\xe1\x05\x02.\x1a\xaf\x03\x20Optional:\x20Path\x20at\x20whic\
    h\x20the\x20file\x20to\x20which\x20the\x20container's\x20termination\x20\
    message\n\x20will\x20be\x20written\x20is\x20mounted\x20into\x20the\x20co\
    ntainer's\x20filesystem.\n\x20Message\x20written\x20is\x20intended\x20to\
    \x20be\x20brief\x20final\x20status,\x20such\x20as\x20an\x20assertion\x20\
    failure\x20message.\n\x20Will\x20be\x20truncated\x20by\x20the\x20node\
    \x20if\x20greater\x20than\x204096\x20bytes.\x20The\x20total\x20message\
    \x20length\x20across\n\x20all\x20containers\x20will\x20be\x20limited\x20\
    to\x2012kb.\n\x20Defaults\x20to\x20/dev/termination-log.\n\x20Cannot\x20\
    be\x20updated.\n\x20+optional\n\n\r\n\x05\x04\x1a\x02\x0f\x04\x12\x04\
    \xe1\x05\x02\n\n\r\n\x05\x04\x1a\x02\x0f\x05\x12\x04\xe1\x05\x0b\x11\n\r\
    \n\x05\x04\x1a\x02\x0f\x01\x12\x04\xe1\x05\x12(\n\r\n\x05\x04\x1a\x02\
    \x0f\x03\x12\x04\xe1\x05+-\n\xdd\x03\n\x04\x04\x1a\x02\x10\x12\x04\xeb\
    \x05\x020\x1a\xce\x03\x20Indicate\x20how\x20the\x20termination\x20messag\
    e\x20should\x20be\x20populated.\x20File\x20will\x20use\x20the\x20content\
    s\x20of\n\x20terminationMessagePath\x20to\x20populate\x20the\x20containe\
    r\x20status\x20message\x20on\x20both\x20success\x20and\x20failure.\n\x20\
    FallbackToLogsOnError\x20will\x20use\x20the\x20last\x20chunk\x20of\x20co\
    ntainer\x20log\x20output\x20if\x20the\x20termination\n\x20message\x20fil\
    e\x20is\x20empty\x20and\x20the\x20container\x20exited\x20with\x20an\x20e\
    rror.\n\x20The\x20log\x20output\x20is\x20limited\x20to\x202048\x20bytes\
    \x20or\x2080\x20lines,\x20whichever\x20is\x20smaller.\n\x20Defaults\x20t\
    o\x20File.\n\x20Cannot\x20be\x20updated.\n\x20+optional\n\n\r\n\x05\x04\
    \x1a\x02\x10\x04\x12\x04\xeb\x05\x02\n\n\r\n\x05\x04\x1a\x02\x10\x05\x12\
    \x04\xeb\x05\x0b\x11\n\r\n\x05\x04\x1a\x02\x10\x01\x12\x04\xeb\x05\x12*\
    \n\r\n\x05\x04\x1a\x02\x10\x03\x12\x04\xeb\x05-/\n\x85\x02\n\x04\x04\x1a\
    \x02\x11\x12\x04\xf3\x05\x02'\x1a\xf6\x01\x20Image\x20pull\x20policy.\n\
    \x20One\x20of\x20Always,\x20Never,\x20IfNotPresent.\n\x20Defaults\x20to\
    \x20Always\x20if\x20:latest\x20tag\x20is\x20specified,\x20or\x20IfNotPre\
    sent\x20otherwise.\n\x20Cannot\x20be\x20updated.\n\x20More\x20info:\x20h\
    ttps://kubernetes.io/docs/concepts/containers/images#updating-images\n\
    \x20+optional\n\n\r\n\x05\x04\x1a\x02\x11\x04\x12\x04\xf3\x05\x02\n\n\r\
    \n\x05\x04\x1a\x02\x11\x05\x12\x04\xf3\x05\x0b\x11\n\r\n\x05\x04\x1a\x02\
    \x11\x01\x12\x04\xf3\x05\x12!\n\r\n\x05\x04\x1a\x02\x11\x03\x12\x04\xf3\
    \x05$&\n\xe5\x01\n\x04\x04\x1a\x02\x12\x12\x04\xf9\x05\x020\x1a\xd6\x01\
    \x20Security\x20options\x20the\x20pod\x20should\x20run\x20with.\n\x20Mor\
    e\x20info:\x20https://kubernetes.io/docs/concepts/policy/security-contex\
    t/\n\x20More\x20info:\x20https://kubernetes.io/docs/tasks/configure-pod-\
    container/security-context/\n\x20+optional\n\n\r\n\x05\x04\x1a\x02\x12\
    \x04\x12\x04\xf9\x05\x02\n\n\r\n\x05\x04\x1a\x02\x12\x06\x12\x04\xf9\x05\
    \x0b\x1a\n\r\n\x05\x04\x1a\x02\x12\x01\x12\x04\xf9\x05\x1b*\n\r\n\x05\
    \x04\x1a\x02\x12\x03\x12\x04\xf9\x05-/\n\xd4\x01\n\x04\x04\x1a\x02\x13\
    \x12\x04\xff\x05\x02\x1b\x1a\xc5\x01\x20Whether\x20this\x20container\x20\
    should\x20allocate\x20a\x20buffer\x20for\x20stdin\x20in\x20the\x20contai\
    ner\x20runtime.\x20If\x20this\n\x20is\x20not\x20set,\x20reads\x20from\
    \x20stdin\x20in\x20the\x20container\x20will\x20always\x20result\x20in\
    \x20EOF.\n\x20Default\x20is\x20false.\n\x20+optional\n\n\r\n\x05\x04\x1a\
    \x02\x13\x04\x12\x04\xff\x05\x02\n\n\r\n\x05\x04\x1a\x02\x13\x05\x12\x04\
    \xff\x05\x0b\x0f\n\r\n\x05\x04\x1a\x02\x13\x01\x12\x04\xff\x05\x10\x15\n\
    \r\n\x05\x04\x1a\x02\x13\x03\x12\x04\xff\x05\x18\x1a\n\xdc\x04\n\x04\x04\
    \x1a\x02\x14\x12\x04\x89\x06\x02\x1f\x1a\xcd\x04\x20Whether\x20the\x20co\
    ntainer\x20runtime\x20should\x20close\x20the\x20stdin\x20channel\x20afte\
    r\x20it\x20has\x20been\x20opened\x20by\n\x20a\x20single\x20attach.\x20Wh\
    en\x20stdin\x20is\x20true\x20the\x20stdin\x20stream\x20will\x20remain\
    \x20open\x20across\x20multiple\x20attach\n\x20sessions.\x20If\x20stdinOn\
    ce\x20is\x20set\x20to\x20true,\x20stdin\x20is\x20opened\x20on\x20contain\
    er\x20start,\x20is\x20empty\x20until\x20the\n\x20first\x20client\x20atta\
    ches\x20to\x20stdin,\x20and\x20then\x20remains\x20open\x20and\x20accepts\
    \x20data\x20until\x20the\x20client\x20disconnects,\n\x20at\x20which\x20t\
    ime\x20stdin\x20is\x20closed\x20and\x20remains\x20closed\x20until\x20the\
    \x20container\x20is\x20restarted.\x20If\x20this\n\x20flag\x20is\x20false\
    ,\x20a\x20container\x20processes\x20that\x20reads\x20from\x20stdin\x20wi\
    ll\x20never\x20receive\x20an\x20EOF.\n\x20Default\x20is\x20false\n\x20+o\
    ptional\n\n\r\n\x05\x04\x1a\x02\x14\x04\x12\x04\x89\x06\x02\n\n\r\n\x05\
    \x04\x1a\x02\x14\x05\x12\x04\x89\x06\x0b\x0f\n\r\n\x05\x04\x1a\x02\x14\
    \x01\x12\x04\x89\x06\x10\x19\n\r\n\x05\x04\x1a\x02\x14\x03\x12\x04\x89\
    \x06\x1c\x1e\n\x88\x01\n\x04\x04\x1a\x02\x15\x12\x04\x8e\x06\x02\x19\x1a\
    z\x20Whether\x20this\x20container\x20should\x20allocate\x20a\x20TTY\x20f\
    or\x20itself,\x20also\x20requires\x20'stdin'\x20to\x20be\x20true.\n\x20D\
    efault\x20is\x20false.\n\x20+optional\n\n\r\n\x05\x04\x1a\x02\x15\x04\
    \x12\x04\x8e\x06\x02\n\n\r\n\x05\x04\x1a\x02\x15\x05\x12\x04\x8e\x06\x0b\
    \x0f\n\r\n\x05\x04\x1a\x02\x15\x01\x12\x04\x8e\x06\x10\x13\n\r\n\x05\x04\
    \x1a\x02\x15\x03\x12\x04\x8e\x06\x16\x18\n*\n\x02\x04\x1b\x12\x06\x92\
    \x06\0\x9a\x06\x01\x1a\x1c\x20Describe\x20a\x20container\x20image\n\n\
    \x0b\n\x03\x04\x1b\x01\x12\x04\x92\x06\x08\x16\n\x8c\x01\n\x04\x04\x1b\
    \x02\0\x12\x04\x95\x06\x02\x1c\x1a~\x20Names\x20by\x20which\x20this\x20i\
    mage\x20is\x20known.\n\x20e.g.\x20[\"k8s.gcr.io/hyperkube:v1.0.7\",\x20\
    \"dockerhub.io/google_containers/hyperkube:v1.0.7\"]\n\n\r\n\x05\x04\x1b\
    \x02\0\x04\x12\x04\x95\x06\x02\n\n\r\n\x05\x04\x1b\x02\0\x05\x12\x04\x95\
    \x06\x0b\x11\n\r\n\x05\x04\x1b\x02\0\x01\x12\x04\x95\x06\x12\x17\n\r\n\
    \x05\x04\x1b\x02\0\x03\x12\x04\x95\x06\x1a\x1b\n:\n\x04\x04\x1b\x02\x01\
    \x12\x04\x99\x06\x02\x1f\x1a,\x20The\x20size\x20of\x20the\x20image\x20in\
    \x20bytes.\n\x20+optional\n\n\r\n\x05\x04\x1b\x02\x01\x04\x12\x04\x99\
    \x06\x02\n\n\r\n\x05\x04\x1b\x02\x01\x05\x12\x04\x99\x06\x0b\x10\n\r\n\
    \x05\x04\x1b\x02\x01\x01\x12\x04\x99\x06\x11\x1a\n\r\n\x05\x04\x1b\x02\
    \x01\x03\x12\x04\x99\x06\x1d\x1e\nN\n\x02\x04\x1c\x12\x06\x9d\x06\0\xb8\
    \x06\x01\x1a@\x20ContainerPort\x20represents\x20a\x20network\x20port\x20\
    in\x20a\x20single\x20container.\n\n\x0b\n\x03\x04\x1c\x01\x12\x04\x9d\
    \x06\x08\x15\n\xcd\x01\n\x04\x04\x1c\x02\0\x12\x04\xa2\x06\x02\x1b\x1a\
    \xbe\x01\x20If\x20specified,\x20this\x20must\x20be\x20an\x20IANA_SVC_NAM\
    E\x20and\x20unique\x20within\x20the\x20pod.\x20Each\n\x20named\x20port\
    \x20in\x20a\x20pod\x20must\x20have\x20a\x20unique\x20name.\x20Name\x20fo\
    r\x20the\x20port\x20that\x20can\x20be\n\x20referred\x20to\x20by\x20servi\
    ces.\n\x20+optional\n\n\r\n\x05\x04\x1c\x02\0\x04\x12\x04\xa2\x06\x02\n\
    \n\r\n\x05\x04\x1c\x02\0\x05\x12\x04\xa2\x06\x0b\x11\n\r\n\x05\x04\x1c\
    \x02\0\x01\x12\x04\xa2\x06\x12\x16\n\r\n\x05\x04\x1c\x02\0\x03\x12\x04\
    \xa2\x06\x19\x1a\n\xe1\x01\n\x04\x04\x1c\x02\x01\x12\x04\xa9\x06\x02\x1e\
    \x1a\xd2\x01\x20Number\x20of\x20port\x20to\x20expose\x20on\x20the\x20hos\
    t.\n\x20If\x20specified,\x20this\x20must\x20be\x20a\x20valid\x20port\x20\
    number,\x200\x20<\x20x\x20<\x2065536.\n\x20If\x20HostNetwork\x20is\x20sp\
    ecified,\x20this\x20must\x20match\x20ContainerPort.\n\x20Most\x20contain\
    ers\x20do\x20not\x20need\x20this.\n\x20+optional\n\n\r\n\x05\x04\x1c\x02\
    \x01\x04\x12\x04\xa9\x06\x02\n\n\r\n\x05\x04\x1c\x02\x01\x05\x12\x04\xa9\
    \x06\x0b\x10\n\r\n\x05\x04\x1c\x02\x01\x01\x12\x04\xa9\x06\x11\x19\n\r\n\
    \x05\x04\x1c\x02\x01\x03\x12\x04\xa9\x06\x1c\x1d\ns\n\x04\x04\x1c\x02\
    \x02\x12\x04\xad\x06\x02#\x1ae\x20Number\x20of\x20port\x20to\x20expose\
    \x20on\x20the\x20pod's\x20IP\x20address.\n\x20This\x20must\x20be\x20a\
    \x20valid\x20port\x20number,\x200\x20<\x20x\x20<\x2065536.\n\n\r\n\x05\
    \x04\x1c\x02\x02\x04\x12\x04\xad\x06\x02\n\n\r\n\x05\x04\x1c\x02\x02\x05\
    \x12\x04\xad\x06\x0b\x10\n\r\n\x05\x04\x1c\x02\x02\x01\x12\x04\xad\x06\
    \x11\x1e\n\r\n\x05\x04\x1c\x02\x02\x03\x12\x04\xad\x06!\"\nl\n\x04\x04\
    \x1c\x02\x03\x12\x04\xb3\x06\x02\x1f\x1a^\x20Protocol\x20for\x20port.\
    \x20Must\x20be\x20UDP,\x20TCP,\x20or\x20SCTP.\n\x20Defaults\x20to\x20\"T\
    CP\".\n\x20+optional\n\x20+default=\"TCP\"\n\n\r\n\x05\x04\x1c\x02\x03\
    \x04\x12\x04\xb3\x06\x02\n\n\r\n\x05\x04\x1c\x02\x03\x05\x12\x04\xb3\x06\
    \x0b\x11\n\r\n\x05\x04\x1c\x02\x03\x01\x12\x04\xb3\x06\x12\x1a\n\r\n\x05\
    \x04\x1c\x02\x03\x03\x12\x04\xb3\x06\x1d\x1e\nE\n\x04\x04\x1c\x02\x04\
    \x12\x04\xb7\x06\x02\x1d\x1a7\x20What\x20host\x20IP\x20to\x20bind\x20the\
    \x20external\x20port\x20to.\n\x20+optional\n\n\r\n\x05\x04\x1c\x02\x04\
    \x04\x12\x04\xb7\x06\x02\n\n\r\n\x05\x04\x1c\x02\x04\x05\x12\x04\xb7\x06\
    \x0b\x11\n\r\n\x05\x04\x1c\x02\x04\x01\x12\x04\xb7\x06\x12\x18\n\r\n\x05\
    \x04\x1c\x02\x04\x03\x12\x04\xb7\x06\x1b\x1c\n\xb8\x01\n\x02\x04\x1d\x12\
    \x06\xbd\x06\0\xc9\x06\x01\x1a\xa9\x01\x20ContainerState\x20holds\x20a\
    \x20possible\x20state\x20of\x20container.\n\x20Only\x20one\x20of\x20its\
    \x20members\x20may\x20be\x20specified.\n\x20If\x20none\x20of\x20them\x20\
    is\x20specified,\x20the\x20default\x20one\x20is\x20ContainerStateWaiting\
    .\n\n\x0b\n\x03\x04\x1d\x01\x12\x04\xbd\x06\x08\x16\n<\n\x04\x04\x1d\x02\
    \0\x12\x04\xc0\x06\x02-\x1a.\x20Details\x20about\x20a\x20waiting\x20cont\
    ainer\n\x20+optional\n\n\r\n\x05\x04\x1d\x02\0\x04\x12\x04\xc0\x06\x02\n\
    \n\r\n\x05\x04\x1d\x02\0\x06\x12\x04\xc0\x06\x0b\x20\n\r\n\x05\x04\x1d\
    \x02\0\x01\x12\x04\xc0\x06!(\n\r\n\x05\x04\x1d\x02\0\x03\x12\x04\xc0\x06\
    +,\n<\n\x04\x04\x1d\x02\x01\x12\x04\xc4\x06\x02-\x1a.\x20Details\x20abou\
    t\x20a\x20running\x20container\n\x20+optional\n\n\r\n\x05\x04\x1d\x02\
    \x01\x04\x12\x04\xc4\x06\x02\n\n\r\n\x05\x04\x1d\x02\x01\x06\x12\x04\xc4\
    \x06\x0b\x20\n\r\n\x05\x04\x1d\x02\x01\x01\x12\x04\xc4\x06!(\n\r\n\x05\
    \x04\x1d\x02\x01\x03\x12\x04\xc4\x06+,\n?\n\x04\x04\x1d\x02\x02\x12\x04\
    \xc8\x06\x023\x1a1\x20Details\x20about\x20a\x20terminated\x20container\n\
    \x20+optional\n\n\r\n\x05\x04\x1d\x02\x02\x04\x12\x04\xc8\x06\x02\n\n\r\
    \n\x05\x04\x1d\x02\x02\x06\x12\x04\xc8\x06\x0b#\n\r\n\x05\x04\x1d\x02\
    \x02\x01\x12\x04\xc8\x06$.\n\r\n\x05\x04\x1d\x02\x02\x03\x12\x04\xc8\x06\
    12\nH\n\x02\x04\x1e\x12\x06\xcc\x06\0\xd0\x06\x01\x1a:\x20ContainerState\
    Running\x20is\x20a\x20running\x20state\x20of\x20a\x20container.\n\n\x0b\
    \n\x03\x04\x1e\x01\x12\x04\xcc\x06\x08\x1d\nL\n\x04\x04\x1e\x02\0\x12\
    \x04\xcf\x06\x02C\x1a>\x20Time\x20at\x20which\x20the\x20container\x20was\
    \x20last\x20(re-)started\n\x20+optional\n\n\r\n\x05\x04\x1e\x02\0\x04\
    \x12\x04\xcf\x06\x02\n\n\r\n\x05\x04\x1e\x02\0\x06\x12\x04\xcf\x06\x0b4\
    \n\r\n\x05\x04\x1e\x02\0\x01\x12\x04\xcf\x065>\n\r\n\x05\x04\x1e\x02\0\
    \x03\x12\x04\xcf\x06AB\nN\n\x02\x04\x1f\x12\x06\xd3\x06\0\xee\x06\x01\
    \x1a@\x20ContainerStateTerminated\x20is\x20a\x20terminated\x20state\x20o\
    f\x20a\x20container.\n\n\x0b\n\x03\x04\x1f\x01\x12\x04\xd3\x06\x08\x20\n\
    F\n\x04\x04\x1f\x02\0\x12\x04\xd5\x06\x02\x1e\x1a8\x20Exit\x20status\x20\
    from\x20the\x20last\x20termination\x20of\x20the\x20container\n\n\r\n\x05\
    \x04\x1f\x02\0\x04\x12\x04\xd5\x06\x02\n\n\r\n\x05\x04\x1f\x02\0\x05\x12\
    \x04\xd5\x06\x0b\x10\n\r\n\x05\x04\x1f\x02\0\x01\x12\x04\xd5\x06\x11\x19\
    \n\r\n\x05\x04\x1f\x02\0\x03\x12\x04\xd5\x06\x1c\x1d\nL\n\x04\x04\x1f\
    \x02\x01\x12\x04\xd9\x06\x02\x1c\x1a>\x20Signal\x20from\x20the\x20last\
    \x20termination\x20of\x20the\x20container\n\x20+optional\n\n\r\n\x05\x04\
    \x1f\x02\x01\x04\x12\x04\xd9\x06\x02\n\n\r\n\x05\x04\x1f\x02\x01\x05\x12\
    \x04\xd9\x06\x0b\x10\n\r\n\x05\x04\x1f\x02\x01\x01\x12\x04\xd9\x06\x11\
    \x17\n\r\n\x05\x04\x1f\x02\x01\x03\x12\x04\xd9\x06\x1a\x1b\nT\n\x04\x04\
    \x1f\x02\x02\x12\x04\xdd\x06\x02\x1d\x1aF\x20(brief)\x20reason\x20from\
    \x20the\x20last\x20termination\x20of\x20the\x20container\n\x20+optional\
    \n\n\r\n\x05\x04\x1f\x02\x02\x04\x12\x04\xdd\x06\x02\n\n\r\n\x05\x04\x1f\
    \x02\x02\x05\x12\x04\xdd\x06\x0b\x11\n\r\n\x05\x04\x1f\x02\x02\x01\x12\
    \x04\xdd\x06\x12\x18\n\r\n\x05\x04\x1f\x02\x02\x03\x12\x04\xdd\x06\x1b\
    \x1c\nR\n\x04\x04\x1f\x02\x03\x12\x04\xe1\x06\x02\x1e\x1aD\x20Message\
    \x20regarding\x20the\x20last\x20termination\x20of\x20the\x20container\n\
    \x20+optional\n\n\r\n\x05\x04\x1f\x02\x03\x04\x12\x04\xe1\x06\x02\n\n\r\
    \n\x05\x04\x1f\x02\x03\x05\x12\x04\xe1\x06\x0b\x11\n\r\n\x05\x04\x1f\x02\
    \x03\x01\x12\x04\xe1\x06\x12\x19\n\r\n\x05\x04\x1f\x02\x03\x03\x12\x04\
    \xe1\x06\x1c\x1d\nT\n\x04\x04\x1f\x02\x04\x12\x04\xe5\x06\x02C\x1aF\x20T\
    ime\x20at\x20which\x20previous\x20execution\x20of\x20the\x20container\
    \x20started\n\x20+optional\n\n\r\n\x05\x04\x1f\x02\x04\x04\x12\x04\xe5\
    \x06\x02\n\n\r\n\x05\x04\x1f\x02\x04\x06\x12\x04\xe5\x06\x0b4\n\r\n\x05\
    \x04\x1f\x02\x04\x01\x12\x04\xe5\x065>\n\r\n\x05\x04\x1f\x02\x04\x03\x12\
    \x04\xe5\x06AB\nF\n\x04\x04\x1f\x02\x05\x12\x04\xe9\x06\x02D\x1a8\x20Tim\
    e\x20at\x20which\x20the\x20container\x20last\x20terminated\n\x20+optiona\
    l\n\n\r\n\x05\x04\x1f\x02\x05\x04\x12\x04\xe9\x06\x02\n\n\r\n\x05\x04\
    \x1f\x02\x05\x06\x12\x04\xe9\x06\x0b4\n\r\n\x05\x04\x1f\x02\x05\x01\x12\
    \x04\xe9\x065?\n\r\n\x05\x04\x1f\x02\x05\x03\x12\x04\xe9\x06BC\nQ\n\x04\
    \x04\x1f\x02\x06\x12\x04\xed\x06\x02\"\x1aC\x20Container's\x20ID\x20in\
    \x20the\x20format\x20'docker://<container_id>'\n\x20+optional\n\n\r\n\
    \x05\x04\x1f\x02\x06\x04\x12\x04\xed\x06\x02\n\n\r\n\x05\x04\x1f\x02\x06\
    \x05\x12\x04\xed\x06\x0b\x11\n\r\n\x05\x04\x1f\x02\x06\x01\x12\x04\xed\
    \x06\x12\x1d\n\r\n\x05\x04\x1f\x02\x06\x03\x12\x04\xed\x06\x20!\nH\n\x02\
    \x04\x20\x12\x06\xf1\x06\0\xf9\x06\x01\x1a:\x20ContainerStateWaiting\x20\
    is\x20a\x20waiting\x20state\x20of\x20a\x20container.\n\n\x0b\n\x03\x04\
    \x20\x01\x12\x04\xf1\x06\x08\x1d\nK\n\x04\x04\x20\x02\0\x12\x04\xf4\x06\
    \x02\x1d\x1a=\x20(brief)\x20reason\x20the\x20container\x20is\x20not\x20y\
    et\x20running.\n\x20+optional\n\n\r\n\x05\x04\x20\x02\0\x04\x12\x04\xf4\
    \x06\x02\n\n\r\n\x05\x04\x20\x02\0\x05\x12\x04\xf4\x06\x0b\x11\n\r\n\x05\
    \x04\x20\x02\0\x01\x12\x04\xf4\x06\x12\x18\n\r\n\x05\x04\x20\x02\0\x03\
    \x12\x04\xf4\x06\x1b\x1c\nR\n\x04\x04\x20\x02\x01\x12\x04\xf8\x06\x02\
    \x1e\x1aD\x20Message\x20regarding\x20why\x20the\x20container\x20is\x20no\
    t\x20yet\x20running.\n\x20+optional\n\n\r\n\x05\x04\x20\x02\x01\x04\x12\
    \x04\xf8\x06\x02\n\n\r\n\x05\x04\x20\x02\x01\x05\x12\x04\xf8\x06\x0b\x11\
    \n\r\n\x05\x04\x20\x02\x01\x01\x12\x04\xf8\x06\x12\x19\n\r\n\x05\x04\x20\
    \x02\x01\x03\x12\x04\xf8\x06\x1c\x1d\nZ\n\x02\x04!\x12\x06\xfc\x06\0\xa4\
    \x07\x01\x1aL\x20ContainerStatus\x20contains\x20details\x20for\x20the\
    \x20current\x20status\x20of\x20this\x20container.\n\n\x0b\n\x03\x04!\x01\
    \x12\x04\xfc\x06\x08\x17\nn\n\x04\x04!\x02\0\x12\x04\xff\x06\x02\x1b\x1a\
    `\x20This\x20must\x20be\x20a\x20DNS_LABEL.\x20Each\x20container\x20in\
    \x20a\x20pod\x20must\x20have\x20a\x20unique\x20name.\n\x20Cannot\x20be\
    \x20updated.\n\n\r\n\x05\x04!\x02\0\x04\x12\x04\xff\x06\x02\n\n\r\n\x05\
    \x04!\x02\0\x05\x12\x04\xff\x06\x0b\x11\n\r\n\x05\x04!\x02\0\x01\x12\x04\
    \xff\x06\x12\x16\n\r\n\x05\x04!\x02\0\x03\x12\x04\xff\x06\x19\x1a\nK\n\
    \x04\x04!\x02\x01\x12\x04\x83\x07\x02$\x1a=\x20Details\x20about\x20the\
    \x20container's\x20current\x20condition.\n\x20+optional\n\n\r\n\x05\x04!\
    \x02\x01\x04\x12\x04\x83\x07\x02\n\n\r\n\x05\x04!\x02\x01\x06\x12\x04\
    \x83\x07\x0b\x19\n\r\n\x05\x04!\x02\x01\x01\x12\x04\x83\x07\x1a\x1f\n\r\
    \n\x05\x04!\x02\x01\x03\x12\x04\x83\x07\"#\nT\n\x04\x04!\x02\x02\x12\x04\
    \x87\x07\x02(\x1aF\x20Details\x20about\x20the\x20container's\x20last\x20\
    termination\x20condition.\n\x20+optional\n\n\r\n\x05\x04!\x02\x02\x04\
    \x12\x04\x87\x07\x02\n\n\r\n\x05\x04!\x02\x02\x06\x12\x04\x87\x07\x0b\
    \x19\n\r\n\x05\x04!\x02\x02\x01\x12\x04\x87\x07\x1a#\n\r\n\x05\x04!\x02\
    \x02\x03\x12\x04\x87\x07&'\nO\n\x04\x04!\x02\x03\x12\x04\x8a\x07\x02\x1a\
    \x1aA\x20Specifies\x20whether\x20the\x20container\x20has\x20passed\x20it\
    s\x20readiness\x20probe.\n\n\r\n\x05\x04!\x02\x03\x04\x12\x04\x8a\x07\
    \x02\n\n\r\n\x05\x04!\x02\x03\x05\x12\x04\x8a\x07\x0b\x0f\n\r\n\x05\x04!\
    \x02\x03\x01\x12\x04\x8a\x07\x10\x15\n\r\n\x05\x04!\x02\x03\x03\x12\x04\
    \x8a\x07\x18\x19\n\xac\x02\n\x04\x04!\x02\x04\x12\x04\x90\x07\x02\"\x1a\
    \x9d\x02\x20The\x20number\x20of\x20times\x20the\x20container\x20has\x20b\
    een\x20restarted,\x20currently\x20based\x20on\n\x20the\x20number\x20of\
    \x20dead\x20containers\x20that\x20have\x20not\x20yet\x20been\x20removed.\
    \n\x20Note\x20that\x20this\x20is\x20calculated\x20from\x20dead\x20contai\
    ners.\x20But\x20those\x20containers\x20are\x20subject\x20to\n\x20garbage\
    \x20collection.\x20This\x20value\x20will\x20get\x20capped\x20at\x205\x20\
    by\x20GC.\n\n\r\n\x05\x04!\x02\x04\x04\x12\x04\x90\x07\x02\n\n\r\n\x05\
    \x04!\x02\x04\x05\x12\x04\x90\x07\x0b\x10\n\r\n\x05\x04!\x02\x04\x01\x12\
    \x04\x90\x07\x11\x1d\n\r\n\x05\x04!\x02\x04\x03\x12\x04\x90\x07\x20!\n\
    \xb3\x01\n\x04\x04!\x02\x05\x12\x04\x95\x07\x02\x1c\x1a\xa4\x01\x20The\
    \x20image\x20the\x20container\x20is\x20running.\n\x20More\x20info:\x20ht\
    tps://kubernetes.io/docs/concepts/containers/images\n\x20TODO(dchen1107)\
    :\x20Which\x20image\x20the\x20container\x20is\x20running\x20with?\n\n\r\
    \n\x05\x04!\x02\x05\x04\x12\x04\x95\x07\x02\n\n\r\n\x05\x04!\x02\x05\x05\
    \x12\x04\x95\x07\x0b\x11\n\r\n\x05\x04!\x02\x05\x01\x12\x04\x95\x07\x12\
    \x17\n\r\n\x05\x04!\x02\x05\x03\x12\x04\x95\x07\x1a\x1b\n1\n\x04\x04!\
    \x02\x06\x12\x04\x98\x07\x02\x1e\x1a#\x20ImageID\x20of\x20the\x20contain\
    er's\x20image.\n\n\r\n\x05\x04!\x02\x06\x04\x12\x04\x98\x07\x02\n\n\r\n\
    \x05\x04!\x02\x06\x05\x12\x04\x98\x07\x0b\x11\n\r\n\x05\x04!\x02\x06\x01\
    \x12\x04\x98\x07\x12\x19\n\r\n\x05\x04!\x02\x06\x03\x12\x04\x98\x07\x1c\
    \x1d\nR\n\x04\x04!\x02\x07\x12\x04\x9c\x07\x02\"\x1aD\x20Container's\x20\
    ID\x20in\x20the\x20format\x20'docker://<container_id>'.\n\x20+optional\n\
    \n\r\n\x05\x04!\x02\x07\x04\x12\x04\x9c\x07\x02\n\n\r\n\x05\x04!\x02\x07\
    \x05\x12\x04\x9c\x07\x0b\x11\n\r\n\x05\x04!\x02\x07\x01\x12\x04\x9c\x07\
    \x12\x1d\n\r\n\x05\x04!\x02\x07\x03\x12\x04\x9c\x07\x20!\n\xb4\x02\n\x04\
    \x04!\x02\x08\x12\x04\xa3\x07\x02\x1c\x1a\xa5\x02\x20Specifies\x20whethe\
    r\x20the\x20container\x20has\x20passed\x20its\x20startup\x20probe.\n\x20\
    Initialized\x20as\x20false,\x20becomes\x20true\x20after\x20startupProbe\
    \x20is\x20considered\x20successful.\n\x20Resets\x20to\x20false\x20when\
    \x20the\x20container\x20is\x20restarted,\x20or\x20if\x20kubelet\x20loses\
    \x20state\x20temporarily.\n\x20Is\x20always\x20true\x20when\x20no\x20sta\
    rtupProbe\x20is\x20defined.\n\x20+optional\n\n\r\n\x05\x04!\x02\x08\x04\
    \x12\x04\xa3\x07\x02\n\n\r\n\x05\x04!\x02\x08\x05\x12\x04\xa3\x07\x0b\
    \x0f\n\r\n\x05\x04!\x02\x08\x01\x12\x04\xa3\x07\x10\x17\n\r\n\x05\x04!\
    \x02\x08\x03\x12\x04\xa3\x07\x1a\x1b\nS\n\x02\x04\"\x12\x06\xa7\x07\0\
    \xaa\x07\x01\x1aE\x20DaemonEndpoint\x20contains\x20information\x20about\
    \x20a\x20single\x20Daemon\x20endpoint.\n\n\x0b\n\x03\x04\"\x01\x12\x04\
    \xa7\x07\x08\x16\n2\n\x04\x04\"\x02\0\x12\x04\xa9\x07\x02\x1a\x1a$\x20Po\
    rt\x20number\x20of\x20the\x20given\x20endpoint.\n\n\r\n\x05\x04\"\x02\0\
    \x04\x12\x04\xa9\x07\x02\n\n\r\n\x05\x04\"\x02\0\x05\x12\x04\xa9\x07\x0b\
    \x10\n\r\n\x05\x04\"\x02\0\x01\x12\x04\xa9\x07\x11\x15\n\r\n\x05\x04\"\
    \x02\0\x03\x12\x04\xa9\x07\x18\x19\n\xac\x01\n\x02\x04#\x12\x06\xaf\x07\
    \0\xb3\x07\x01\x1a\x9d\x01\x20Represents\x20downward\x20API\x20info\x20f\
    or\x20projecting\x20into\x20a\x20projected\x20volume.\n\x20Note\x20that\
    \x20this\x20is\x20identical\x20to\x20a\x20downwardAPI\x20volume\x20sourc\
    e\x20without\x20the\x20default\n\x20mode.\n\n\x0b\n\x03\x04#\x01\x12\x04\
    \xaf\x07\x08\x1d\nD\n\x04\x04#\x02\0\x12\x04\xb2\x07\x02+\x1a6\x20Items\
    \x20is\x20a\x20list\x20of\x20DownwardAPIVolume\x20file\n\x20+optional\n\
    \n\r\n\x05\x04#\x02\0\x04\x12\x04\xb2\x07\x02\n\n\r\n\x05\x04#\x02\0\x06\
    \x12\x04\xb2\x07\x0b\x20\n\r\n\x05\x04#\x02\0\x01\x12\x04\xb2\x07!&\n\r\
    \n\x05\x04#\x02\0\x03\x12\x04\xb2\x07)*\nh\n\x02\x04$\x12\x06\xb6\x07\0\
    \xcb\x07\x01\x1aZ\x20DownwardAPIVolumeFile\x20represents\x20information\
    \x20to\x20create\x20the\x20file\x20containing\x20the\x20pod\x20field\n\n\
    \x0b\n\x03\x04$\x01\x12\x04\xb6\x07\x08\x1d\n\xd8\x01\n\x04\x04$\x02\0\
    \x12\x04\xb8\x07\x02\x1b\x1a\xc9\x01\x20Required:\x20Path\x20is\x20\x20t\
    he\x20relative\x20path\x20name\x20of\x20the\x20file\x20to\x20be\x20creat\
    ed.\x20Must\x20not\x20be\x20absolute\x20or\x20contain\x20the\x20'..'\x20\
    path.\x20Must\x20be\x20utf-8\x20encoded.\x20The\x20first\x20item\x20of\
    \x20the\x20relative\x20path\x20must\x20not\x20start\x20with\x20'..'\n\n\
    \r\n\x05\x04$\x02\0\x04\x12\x04\xb8\x07\x02\n\n\r\n\x05\x04$\x02\0\x05\
    \x12\x04\xb8\x07\x0b\x11\n\r\n\x05\x04$\x02\0\x01\x12\x04\xb8\x07\x12\
    \x16\n\r\n\x05\x04$\x02\0\x03\x12\x04\xb8\x07\x19\x1a\n|\n\x04\x04$\x02\
    \x01\x12\x04\xbc\x07\x02,\x1an\x20Required:\x20Selects\x20a\x20field\x20\
    of\x20the\x20pod:\x20only\x20annotations,\x20labels,\x20name\x20and\x20n\
    amespace\x20are\x20supported.\n\x20+optional\n\n\r\n\x05\x04$\x02\x01\
    \x04\x12\x04\xbc\x07\x02\n\n\r\n\x05\x04$\x02\x01\x06\x12\x04\xbc\x07\
    \x0b\x1e\n\r\n\x05\x04$\x02\x01\x01\x12\x04\xbc\x07\x1f'\n\r\n\x05\x04$\
    \x02\x01\x03\x12\x04\xbc\x07*+\n\xbb\x01\n\x04\x04$\x02\x02\x12\x04\xc1\
    \x07\x026\x1a\xac\x01\x20Selects\x20a\x20resource\x20of\x20the\x20contai\
    ner:\x20only\x20resources\x20limits\x20and\x20requests\n\x20(limits.cpu,\
    \x20limits.memory,\x20requests.cpu\x20and\x20requests.memory)\x20are\x20\
    currently\x20supported.\n\x20+optional\n\n\r\n\x05\x04$\x02\x02\x04\x12\
    \x04\xc1\x07\x02\n\n\r\n\x05\x04$\x02\x02\x06\x12\x04\xc1\x07\x0b\x20\n\
    \r\n\x05\x04$\x02\x02\x01\x12\x04\xc1\x07!1\n\r\n\x05\x04$\x02\x02\x03\
    \x12\x04\xc1\x0745\n\xbd\x03\n\x04\x04$\x02\x03\x12\x04\xca\x07\x02\x1a\
    \x1a\xae\x03\x20Optional:\x20mode\x20bits\x20used\x20to\x20set\x20permis\
    sions\x20on\x20this\x20file,\x20must\x20be\x20an\x20octal\x20value\n\x20\
    between\x200000\x20and\x200777\x20or\x20a\x20decimal\x20value\x20between\
    \x200\x20and\x20511.\n\x20YAML\x20accepts\x20both\x20octal\x20and\x20dec\
    imal\x20values,\x20JSON\x20requires\x20decimal\x20values\x20for\x20mode\
    \x20bits.\n\x20If\x20not\x20specified,\x20the\x20volume\x20defaultMode\
    \x20will\x20be\x20used.\n\x20This\x20might\x20be\x20in\x20conflict\x20wi\
    th\x20other\x20options\x20that\x20affect\x20the\x20file\n\x20mode,\x20li\
    ke\x20fsGroup,\x20and\x20the\x20result\x20can\x20be\x20other\x20mode\x20\
    bits\x20set.\n\x20+optional\n\n\r\n\x05\x04$\x02\x03\x04\x12\x04\xca\x07\
    \x02\n\n\r\n\x05\x04$\x02\x03\x05\x12\x04\xca\x07\x0b\x10\n\r\n\x05\x04$\
    \x02\x03\x01\x12\x04\xca\x07\x11\x15\n\r\n\x05\x04$\x02\x03\x03\x12\x04\
    \xca\x07\x18\x19\n\xa5\x01\n\x02\x04%\x12\x06\xcf\x07\0\xde\x07\x01\x1a\
    \x96\x01\x20DownwardAPIVolumeSource\x20represents\x20a\x20volume\x20cont\
    aining\x20downward\x20API\x20info.\n\x20Downward\x20API\x20volumes\x20su\
    pport\x20ownership\x20management\x20and\x20SELinux\x20relabeling.\n\n\
    \x0b\n\x03\x04%\x01\x12\x04\xcf\x07\x08\x1f\nF\n\x04\x04%\x02\0\x12\x04\
    \xd2\x07\x02+\x1a8\x20Items\x20is\x20a\x20list\x20of\x20downward\x20API\
    \x20volume\x20file\n\x20+optional\n\n\r\n\x05\x04%\x02\0\x04\x12\x04\xd2\
    \x07\x02\n\n\r\n\x05\x04%\x02\0\x06\x12\x04\xd2\x07\x0b\x20\n\r\n\x05\
    \x04%\x02\0\x01\x12\x04\xd2\x07!&\n\r\n\x05\x04%\x02\0\x03\x12\x04\xd2\
    \x07)*\n\xa9\x04\n\x04\x04%\x02\x01\x12\x04\xdd\x07\x02!\x1a\x9a\x04\x20\
    Optional:\x20mode\x20bits\x20to\x20use\x20on\x20created\x20files\x20by\
    \x20default.\x20Must\x20be\x20a\n\x20Optional:\x20mode\x20bits\x20used\
    \x20to\x20set\x20permissions\x20on\x20created\x20files\x20by\x20default.\
    \n\x20Must\x20be\x20an\x20octal\x20value\x20between\x200000\x20and\x2007\
    77\x20or\x20a\x20decimal\x20value\x20between\x200\x20and\x20511.\n\x20YA\
    ML\x20accepts\x20both\x20octal\x20and\x20decimal\x20values,\x20JSON\x20r\
    equires\x20decimal\x20values\x20for\x20mode\x20bits.\n\x20Defaults\x20to\
    \x200644.\n\x20Directories\x20within\x20the\x20path\x20are\x20not\x20aff\
    ected\x20by\x20this\x20setting.\n\x20This\x20might\x20be\x20in\x20confli\
    ct\x20with\x20other\x20options\x20that\x20affect\x20the\x20file\n\x20mod\
    e,\x20like\x20fsGroup,\x20and\x20the\x20result\x20can\x20be\x20other\x20\
    mode\x20bits\x20set.\n\x20+optional\n\n\r\n\x05\x04%\x02\x01\x04\x12\x04\
    \xdd\x07\x02\n\n\r\n\x05\x04%\x02\x01\x05\x12\x04\xdd\x07\x0b\x10\n\r\n\
    \x05\x04%\x02\x01\x01\x12\x04\xdd\x07\x11\x1c\n\r\n\x05\x04%\x02\x01\x03\
    \x12\x04\xdd\x07\x1f\x20\n\x86\x01\n\x02\x04&\x12\x06\xe2\x07\0\xf2\x07\
    \x01\x1ax\x20Represents\x20an\x20empty\x20directory\x20for\x20a\x20pod.\
    \n\x20Empty\x20directory\x20volumes\x20support\x20ownership\x20managemen\
    t\x20and\x20SELinux\x20relabeling.\n\n\x0b\n\x03\x04&\x01\x12\x04\xe2\
    \x07\x08\x1c\n\x8b\x02\n\x04\x04&\x02\0\x12\x04\xe8\x07\x02\x1d\x1a\xfc\
    \x01\x20What\x20type\x20of\x20storage\x20medium\x20should\x20back\x20thi\
    s\x20directory.\n\x20The\x20default\x20is\x20\"\"\x20which\x20means\x20t\
    o\x20use\x20the\x20node's\x20default\x20medium.\n\x20Must\x20be\x20an\
    \x20empty\x20string\x20(default)\x20or\x20Memory.\n\x20More\x20info:\x20\
    https://kubernetes.io/docs/concepts/storage/volumes#emptydir\n\x20+optio\
    nal\n\n\r\n\x05\x04&\x02\0\x04\x12\x04\xe8\x07\x02\n\n\r\n\x05\x04&\x02\
    \0\x05\x12\x04\xe8\x07\x0b\x11\n\r\n\x05\x04&\x02\0\x01\x12\x04\xe8\x07\
    \x12\x18\n\r\n\x05\x04&\x02\0\x03\x12\x04\xe8\x07\x1b\x1c\n\xb8\x03\n\
    \x04\x04&\x02\x01\x12\x04\xf1\x07\x02G\x1a\xa9\x03\x20Total\x20amount\
    \x20of\x20local\x20storage\x20required\x20for\x20this\x20EmptyDir\x20vol\
    ume.\n\x20The\x20size\x20limit\x20is\x20also\x20applicable\x20for\x20mem\
    ory\x20medium.\n\x20The\x20maximum\x20usage\x20on\x20memory\x20medium\
    \x20EmptyDir\x20would\x20be\x20the\x20minimum\x20value\x20between\n\x20t\
    he\x20SizeLimit\x20specified\x20here\x20and\x20the\x20sum\x20of\x20memor\
    y\x20limits\x20of\x20all\x20containers\x20in\x20a\x20pod.\n\x20The\x20de\
    fault\x20is\x20nil\x20which\x20means\x20that\x20the\x20limit\x20is\x20un\
    defined.\n\x20More\x20info:\x20http://kubernetes.io/docs/user-guide/volu\
    mes#emptydir\n\x20+optional\n\n\r\n\x05\x04&\x02\x01\x04\x12\x04\xf1\x07\
    \x02\n\n\r\n\x05\x04&\x02\x01\x06\x12\x04\xf1\x07\x0b8\n\r\n\x05\x04&\
    \x02\x01\x01\x12\x04\xf1\x079B\n\r\n\x05\x04&\x02\x01\x03\x12\x04\xf1\
    \x07EF\nL\n\x02\x04'\x12\x06\xf5\x07\0\x89\x08\x01\x1a>\x20EndpointAddre\
    ss\x20is\x20a\x20tuple\x20that\x20describes\x20single\x20IP\x20address.\
    \n\n\x0b\n\x03\x04'\x01\x12\x04\xf5\x07\x08\x17\n\xd4\x02\n\x04\x04'\x02\
    \0\x12\x04\xfc\x07\x02\x19\x1a\xc5\x02\x20The\x20IP\x20of\x20this\x20end\
    point.\n\x20May\x20not\x20be\x20loopback\x20(127.0.0.0/8),\x20link-local\
    \x20(169.254.0.0/16),\n\x20or\x20link-local\x20multicast\x20((224.0.0.0/\
    24).\n\x20IPv6\x20is\x20also\x20accepted\x20but\x20not\x20fully\x20suppo\
    rted\x20on\x20all\x20platforms.\x20Also,\x20certain\n\x20kubernetes\x20c\
    omponents,\x20like\x20kube-proxy,\x20are\x20not\x20IPv6\x20ready.\n\x20T\
    ODO:\x20This\x20should\x20allow\x20hostname\x20or\x20IP,\x20See\x20#4447\
    .\n\n\r\n\x05\x04'\x02\0\x04\x12\x04\xfc\x07\x02\n\n\r\n\x05\x04'\x02\0\
    \x05\x12\x04\xfc\x07\x0b\x11\n\r\n\x05\x04'\x02\0\x01\x12\x04\xfc\x07\
    \x12\x14\n\r\n\x05\x04'\x02\0\x03\x12\x04\xfc\x07\x17\x18\n8\n\x04\x04'\
    \x02\x01\x12\x04\x80\x08\x02\x1f\x1a*\x20The\x20Hostname\x20of\x20this\
    \x20endpoint\n\x20+optional\n\n\r\n\x05\x04'\x02\x01\x04\x12\x04\x80\x08\
    \x02\n\n\r\n\x05\x04'\x02\x01\x05\x12\x04\x80\x08\x0b\x11\n\r\n\x05\x04'\
    \x02\x01\x01\x12\x04\x80\x08\x12\x1a\n\r\n\x05\x04'\x02\x01\x03\x12\x04\
    \x80\x08\x1d\x1e\ny\n\x04\x04'\x02\x02\x12\x04\x84\x08\x02\x1f\x1ak\x20O\
    ptional:\x20Node\x20hosting\x20this\x20endpoint.\x20This\x20can\x20be\
    \x20used\x20to\x20determine\x20endpoints\x20local\x20to\x20a\x20node.\n\
    \x20+optional\n\n\r\n\x05\x04'\x02\x02\x04\x12\x04\x84\x08\x02\n\n\r\n\
    \x05\x04'\x02\x02\x05\x12\x04\x84\x08\x0b\x11\n\r\n\x05\x04'\x02\x02\x01\
    \x12\x04\x84\x08\x12\x1a\n\r\n\x05\x04'\x02\x02\x03\x12\x04\x84\x08\x1d\
    \x1e\nF\n\x04\x04'\x02\x03\x12\x04\x88\x08\x02)\x1a8\x20Reference\x20to\
    \x20object\x20providing\x20the\x20endpoint.\n\x20+optional\n\n\r\n\x05\
    \x04'\x02\x03\x04\x12\x04\x88\x08\x02\n\n\r\n\x05\x04'\x02\x03\x06\x12\
    \x04\x88\x08\x0b\x1a\n\r\n\x05\x04'\x02\x03\x01\x12\x04\x88\x08\x1b$\n\r\
    \n\x05\x04'\x02\x03\x03\x12\x04\x88\x08'(\nE\n\x02\x04(\x12\x06\x8c\x08\
    \0\xa7\x08\x01\x1a7\x20EndpointPort\x20is\x20a\x20tuple\x20that\x20descr\
    ibes\x20a\x20single\x20port.\n\n\x0b\n\x03\x04(\x01\x12\x04\x8c\x08\x08\
    \x14\n\xb4\x01\n\x04\x04(\x02\0\x12\x04\x92\x08\x02\x1b\x1a\xa5\x01\x20T\
    he\x20name\x20of\x20this\x20port.\x20\x20This\x20must\x20match\x20the\
    \x20'name'\x20field\x20in\x20the\n\x20corresponding\x20ServicePort.\n\
    \x20Must\x20be\x20a\x20DNS_LABEL.\n\x20Optional\x20only\x20if\x20one\x20\
    port\x20is\x20defined.\n\x20+optional\n\n\r\n\x05\x04(\x02\0\x04\x12\x04\
    \x92\x08\x02\n\n\r\n\x05\x04(\x02\0\x05\x12\x04\x92\x08\x0b\x11\n\r\n\
    \x05\x04(\x02\0\x01\x12\x04\x92\x08\x12\x16\n\r\n\x05\x04(\x02\0\x03\x12\
    \x04\x92\x08\x19\x1a\n0\n\x04\x04(\x02\x01\x12\x04\x95\x08\x02\x1a\x1a\"\
    \x20The\x20port\x20number\x20of\x20the\x20endpoint.\n\n\r\n\x05\x04(\x02\
    \x01\x04\x12\x04\x95\x08\x02\n\n\r\n\x05\x04(\x02\x01\x05\x12\x04\x95\
    \x08\x0b\x10\n\r\n\x05\x04(\x02\x01\x01\x12\x04\x95\x08\x11\x15\n\r\n\
    \x05\x04(\x02\x01\x03\x12\x04\x95\x08\x18\x19\nf\n\x04\x04(\x02\x02\x12\
    \x04\x9b\x08\x02\x1f\x1aX\x20The\x20IP\x20protocol\x20for\x20this\x20por\
    t.\n\x20Must\x20be\x20UDP,\x20TCP,\x20or\x20SCTP.\n\x20Default\x20is\x20\
    TCP.\n\x20+optional\n\n\r\n\x05\x04(\x02\x02\x04\x12\x04\x9b\x08\x02\n\n\
    \r\n\x05\x04(\x02\x02\x05\x12\x04\x9b\x08\x0b\x11\n\r\n\x05\x04(\x02\x02\
    \x01\x12\x04\x9b\x08\x12\x1a\n\r\n\x05\x04(\x02\x02\x03\x12\x04\x9b\x08\
    \x1d\x1e\n\xc2\x03\n\x04\x04(\x02\x03\x12\x04\xa6\x08\x02\"\x1a\xb3\x03\
    \x20The\x20application\x20protocol\x20for\x20this\x20port.\n\x20This\x20\
    field\x20follows\x20standard\x20Kubernetes\x20label\x20syntax.\n\x20Un-p\
    refixed\x20names\x20are\x20reserved\x20for\x20IANA\x20standard\x20servic\
    e\x20names\x20(as\x20per\n\x20RFC-6335\x20and\x20http://www.iana.org/ass\
    ignments/service-names).\n\x20Non-standard\x20protocols\x20should\x20use\
    \x20prefixed\x20names\x20such\x20as\n\x20mycompany.com/my-custom-protoco\
    l.\n\x20This\x20is\x20a\x20beta\x20field\x20that\x20is\x20guarded\x20by\
    \x20the\x20ServiceAppProtocol\x20feature\n\x20gate\x20and\x20enabled\x20\
    by\x20default.\n\x20+optional\n\n\r\n\x05\x04(\x02\x03\x04\x12\x04\xa6\
    \x08\x02\n\n\r\n\x05\x04(\x02\x03\x05\x12\x04\xa6\x08\x0b\x11\n\r\n\x05\
    \x04(\x02\x03\x01\x12\x04\xa6\x08\x12\x1d\n\r\n\x05\x04(\x02\x03\x03\x12\
    \x04\xa6\x08\x20!\n\xcd\x03\n\x02\x04)\x12\x06\xb3\x08\0\xc2\x08\x01\x1a\
    \xbe\x03\x20EndpointSubset\x20is\x20a\x20group\x20of\x20addresses\x20wit\
    h\x20a\x20common\x20set\x20of\x20ports.\x20The\n\x20expanded\x20set\x20o\
    f\x20endpoints\x20is\x20the\x20Cartesian\x20product\x20of\x20Addresses\
    \x20x\x20Ports.\n\x20For\x20example,\x20given:\n\x20\x20\x20{\n\x20\x20\
    \x20\x20\x20Addresses:\x20[{\"ip\":\x20\"10.10.1.1\"},\x20{\"ip\":\x20\"\
    10.10.2.2\"}],\n\x20\x20\x20\x20\x20Ports:\x20\x20\x20\x20\x20[{\"name\"\
    :\x20\"a\",\x20\"port\":\x208675},\x20{\"name\":\x20\"b\",\x20\"port\":\
    \x20309}]\n\x20\x20\x20}\n\x20The\x20resulting\x20set\x20of\x20endpoints\
    \x20can\x20be\x20viewed\x20as:\n\x20\x20\x20\x20\x20a:\x20[\x2010.10.1.1\
    :8675,\x2010.10.2.2:8675\x20],\n\x20\x20\x20\x20\x20b:\x20[\x2010.10.1.1\
    :309,\x2010.10.2.2:309\x20]\n\n\x0b\n\x03\x04)\x01\x12\x04\xb3\x08\x08\
    \x16\n\xb6\x01\n\x04\x04)\x02\0\x12\x04\xb7\x08\x02)\x1a\xa7\x01\x20IP\
    \x20addresses\x20which\x20offer\x20the\x20related\x20ports\x20that\x20ar\
    e\x20marked\x20as\x20ready.\x20These\x20endpoints\n\x20should\x20be\x20c\
    onsidered\x20safe\x20for\x20load\x20balancers\x20and\x20clients\x20to\
    \x20utilize.\n\x20+optional\n\n\r\n\x05\x04)\x02\0\x04\x12\x04\xb7\x08\
    \x02\n\n\r\n\x05\x04)\x02\0\x06\x12\x04\xb7\x08\x0b\x1a\n\r\n\x05\x04)\
    \x02\0\x01\x12\x04\xb7\x08\x1b$\n\r\n\x05\x04)\x02\0\x03\x12\x04\xb7\x08\
    '(\n\xed\x01\n\x04\x04)\x02\x01\x12\x04\xbd\x08\x021\x1a\xde\x01\x20IP\
    \x20addresses\x20which\x20offer\x20the\x20related\x20ports\x20but\x20are\
    \x20not\x20currently\x20marked\x20as\x20ready\n\x20because\x20they\x20ha\
    ve\x20not\x20yet\x20finished\x20starting,\x20have\x20recently\x20failed\
    \x20a\x20readiness\x20check,\n\x20or\x20have\x20recently\x20failed\x20a\
    \x20liveness\x20check.\n\x20+optional\n\n\r\n\x05\x04)\x02\x01\x04\x12\
    \x04\xbd\x08\x02\n\n\r\n\x05\x04)\x02\x01\x06\x12\x04\xbd\x08\x0b\x1a\n\
    \r\n\x05\x04)\x02\x01\x01\x12\x04\xbd\x08\x1b,\n\r\n\x05\x04)\x02\x01\
    \x03\x12\x04\xbd\x08/0\nN\n\x04\x04)\x02\x02\x12\x04\xc1\x08\x02\"\x1a@\
    \x20Port\x20numbers\x20available\x20on\x20the\x20related\x20IP\x20addres\
    ses.\n\x20+optional\n\n\r\n\x05\x04)\x02\x02\x04\x12\x04\xc1\x08\x02\n\n\
    \r\n\x05\x04)\x02\x02\x06\x12\x04\xc1\x08\x0b\x17\n\r\n\x05\x04)\x02\x02\
    \x01\x12\x04\xc1\x08\x18\x1d\n\r\n\x05\x04)\x02\x02\x03\x12\x04\xc1\x08\
    \x20!\n\x99\x03\n\x02\x04*\x12\x06\xd0\x08\0\xdf\x08\x01\x1a\x8a\x03\x20\
    Endpoints\x20is\x20a\x20collection\x20of\x20endpoints\x20that\x20impleme\
    nt\x20the\x20actual\x20service.\x20Example:\n\x20\x20\x20Name:\x20\"mysv\
    c\",\n\x20\x20\x20Subsets:\x20[\n\x20\x20\x20\x20\x20{\n\x20\x20\x20\x20\
    \x20\x20\x20Addresses:\x20[{\"ip\":\x20\"10.10.1.1\"},\x20{\"ip\":\x20\"\
    10.10.2.2\"}],\n\x20\x20\x20\x20\x20\x20\x20Ports:\x20[{\"name\":\x20\"a\
    \",\x20\"port\":\x208675},\x20{\"name\":\x20\"b\",\x20\"port\":\x20309}]\
    \n\x20\x20\x20\x20\x20},\n\x20\x20\x20\x20\x20{\n\x20\x20\x20\x20\x20\
    \x20\x20Addresses:\x20[{\"ip\":\x20\"10.10.3.3\"}],\n\x20\x20\x20\x20\
    \x20\x20\x20Ports:\x20[{\"name\":\x20\"a\",\x20\"port\":\x2093},\x20{\"n\
    ame\":\x20\"b\",\x20\"port\":\x2076}]\n\x20\x20\x20\x20\x20},\n\x20\x20]\
    \n\n\x0b\n\x03\x04*\x01\x12\x04\xd0\x08\x08\x11\n\xa0\x01\n\x04\x04*\x02\
    \0\x12\x04\xd4\x08\x02H\x1a\x91\x01\x20Standard\x20object's\x20metadata.\
    \n\x20More\x20info:\x20https://git.k8s.io/community/contributors/devel/s\
    ig-architecture/api-conventions.md#metadata\n\x20+optional\n\n\r\n\x05\
    \x04*\x02\0\x04\x12\x04\xd4\x08\x02\n\n\r\n\x05\x04*\x02\0\x06\x12\x04\
    \xd4\x08\x0b:\n\r\n\x05\x04*\x02\0\x01\x12\x04\xd4\x08;C\n\r\n\x05\x04*\
    \x02\0\x03\x12\x04\xd4\x08FG\n\x81\x04\n\x04\x04*\x02\x01\x12\x04\xde\
    \x08\x02&\x1a\xf2\x03\x20The\x20set\x20of\x20all\x20endpoints\x20is\x20t\
    he\x20union\x20of\x20all\x20subsets.\x20Addresses\x20are\x20placed\x20in\
    to\n\x20subsets\x20according\x20to\x20the\x20IPs\x20they\x20share.\x20A\
    \x20single\x20address\x20with\x20multiple\x20ports,\n\x20some\x20of\x20w\
    hich\x20are\x20ready\x20and\x20some\x20of\x20which\x20are\x20not\x20(bec\
    ause\x20they\x20come\x20from\n\x20different\x20containers)\x20will\x20re\
    sult\x20in\x20the\x20address\x20being\x20displayed\x20in\x20different\n\
    \x20subsets\x20for\x20the\x20different\x20ports.\x20No\x20address\x20wil\
    l\x20appear\x20in\x20both\x20Addresses\x20and\n\x20NotReadyAddresses\x20\
    in\x20the\x20same\x20subset.\n\x20Sets\x20of\x20addresses\x20and\x20port\
    s\x20that\x20comprise\x20a\x20service.\n\x20+optional\n\n\r\n\x05\x04*\
    \x02\x01\x04\x12\x04\xde\x08\x02\n\n\r\n\x05\x04*\x02\x01\x06\x12\x04\
    \xde\x08\x0b\x19\n\r\n\x05\x04*\x02\x01\x01\x12\x04\xde\x08\x1a!\n\r\n\
    \x05\x04*\x02\x01\x03\x12\x04\xde\x08$%\n5\n\x02\x04+\x12\x06\xe2\x08\0\
    \xea\x08\x01\x1a'\x20EndpointsList\x20is\x20a\x20list\x20of\x20endpoints\
    .\n\n\x0b\n\x03\x04+\x01\x12\x04\xe2\x08\x08\x15\n\x9f\x01\n\x04\x04+\
    \x02\0\x12\x04\xe6\x08\x02F\x1a\x90\x01\x20Standard\x20list\x20metadata.\
    \n\x20More\x20info:\x20https://git.k8s.io/community/contributors/devel/s\
    ig-architecture/api-conventions.md#types-kinds\n\x20+optional\n\n\r\n\
    \x05\x04+\x02\0\x04\x12\x04\xe6\x08\x02\n\n\r\n\x05\x04+\x02\0\x06\x12\
    \x04\xe6\x08\x0b8\n\r\n\x05\x04+\x02\0\x01\x12\x04\xe6\x089A\n\r\n\x05\
    \x04+\x02\0\x03\x12\x04\xe6\x08DE\n\"\n\x04\x04+\x02\x01\x12\x04\xe9\x08\
    \x02\x1f\x1a\x14\x20List\x20of\x20endpoints.\n\n\r\n\x05\x04+\x02\x01\
    \x04\x12\x04\xe9\x08\x02\n\n\r\n\x05\x04+\x02\x01\x06\x12\x04\xe9\x08\
    \x0b\x14\n\r\n\x05\x04+\x02\x01\x01\x12\x04\xe9\x08\x15\x1a\n\r\n\x05\
    \x04+\x02\x01\x03\x12\x04\xe9\x08\x1d\x1e\nJ\n\x02\x04,\x12\x06\xed\x08\
    \0\xf9\x08\x01\x1a<\x20EnvFromSource\x20represents\x20the\x20source\x20o\
    f\x20a\x20set\x20of\x20ConfigMaps\n\n\x0b\n\x03\x04,\x01\x12\x04\xed\x08\
    \x08\x15\nr\n\x04\x04,\x02\0\x12\x04\xf0\x08\x02\x1d\x1ad\x20An\x20optio\
    nal\x20identifier\x20to\x20prepend\x20to\x20each\x20key\x20in\x20the\x20\
    ConfigMap.\x20Must\x20be\x20a\x20C_IDENTIFIER.\n\x20+optional\n\n\r\n\
    \x05\x04,\x02\0\x04\x12\x04\xf0\x08\x02\n\n\r\n\x05\x04,\x02\0\x05\x12\
    \x04\xf0\x08\x0b\x11\n\r\n\x05\x04,\x02\0\x01\x12\x04\xf0\x08\x12\x18\n\
    \r\n\x05\x04,\x02\0\x03\x12\x04\xf0\x08\x1b\x1c\n7\n\x04\x04,\x02\x01\
    \x12\x04\xf4\x08\x02/\x1a)\x20The\x20ConfigMap\x20to\x20select\x20from\n\
    \x20+optional\n\n\r\n\x05\x04,\x02\x01\x04\x12\x04\xf4\x08\x02\n\n\r\n\
    \x05\x04,\x02\x01\x06\x12\x04\xf4\x08\x0b\x1d\n\r\n\x05\x04,\x02\x01\x01\
    \x12\x04\xf4\x08\x1e*\n\r\n\x05\x04,\x02\x01\x03\x12\x04\xf4\x08-.\n4\n\
    \x04\x04,\x02\x02\x12\x04\xf8\x08\x02)\x1a&\x20The\x20Secret\x20to\x20se\
    lect\x20from\n\x20+optional\n\n\r\n\x05\x04,\x02\x02\x04\x12\x04\xf8\x08\
    \x02\n\n\r\n\x05\x04,\x02\x02\x06\x12\x04\xf8\x08\x0b\x1a\n\r\n\x05\x04,\
    \x02\x02\x01\x12\x04\xf8\x08\x1b$\n\r\n\x05\x04,\x02\x02\x03\x12\x04\xf8\
    \x08'(\nQ\n\x02\x04-\x12\x06\xfc\x08\0\x8e\t\x01\x1aC\x20EnvVar\x20repre\
    sents\x20an\x20environment\x20variable\x20present\x20in\x20a\x20Containe\
    r.\n\n\x0b\n\x03\x04-\x01\x12\x04\xfc\x08\x08\x0e\nI\n\x04\x04-\x02\0\
    \x12\x04\xfe\x08\x02\x1b\x1a;\x20Name\x20of\x20the\x20environment\x20var\
    iable.\x20Must\x20be\x20a\x20C_IDENTIFIER.\n\n\r\n\x05\x04-\x02\0\x04\
    \x12\x04\xfe\x08\x02\n\n\r\n\x05\x04-\x02\0\x05\x12\x04\xfe\x08\x0b\x11\
    \n\r\n\x05\x04-\x02\0\x01\x12\x04\xfe\x08\x12\x16\n\r\n\x05\x04-\x02\0\
    \x03\x12\x04\xfe\x08\x19\x1a\n\xc6\x03\n\x04\x04-\x02\x01\x12\x04\x89\t\
    \x02\x1c\x1a\xb7\x03\x20Variable\x20references\x20$(VAR_NAME)\x20are\x20\
    expanded\n\x20using\x20the\x20previous\x20defined\x20environment\x20vari\
    ables\x20in\x20the\x20container\x20and\n\x20any\x20service\x20environmen\
    t\x20variables.\x20If\x20a\x20variable\x20cannot\x20be\x20resolved,\n\
    \x20the\x20reference\x20in\x20the\x20input\x20string\x20will\x20be\x20un\
    changed.\x20The\x20$(VAR_NAME)\n\x20syntax\x20can\x20be\x20escaped\x20wi\
    th\x20a\x20double\x20$$,\x20ie:\x20$$(VAR_NAME).\x20Escaped\n\x20referen\
    ces\x20will\x20never\x20be\x20expanded,\x20regardless\x20of\x20whether\
    \x20the\x20variable\n\x20exists\x20or\x20not.\n\x20Defaults\x20to\x20\"\
    \".\n\x20+optional\n\n\r\n\x05\x04-\x02\x01\x04\x12\x04\x89\t\x02\n\n\r\
    \n\x05\x04-\x02\x01\x05\x12\x04\x89\t\x0b\x11\n\r\n\x05\x04-\x02\x01\x01\
    \x12\x04\x89\t\x12\x17\n\r\n\x05\x04-\x02\x01\x03\x12\x04\x89\t\x1a\x1b\
    \nm\n\x04\x04-\x02\x02\x12\x04\x8d\t\x02&\x1a_\x20Source\x20for\x20the\
    \x20environment\x20variable's\x20value.\x20Cannot\x20be\x20used\x20if\
    \x20value\x20is\x20not\x20empty.\n\x20+optional\n\n\r\n\x05\x04-\x02\x02\
    \x04\x12\x04\x8d\t\x02\n\n\r\n\x05\x04-\x02\x02\x06\x12\x04\x8d\t\x0b\
    \x17\n\r\n\x05\x04-\x02\x02\x01\x12\x04\x8d\t\x18!\n\r\n\x05\x04-\x02\
    \x02\x03\x12\x04\x8d\t$%\nL\n\x02\x04.\x12\x06\x91\t\0\xa3\t\x01\x1a>\
    \x20EnvVarSource\x20represents\x20a\x20source\x20for\x20the\x20value\x20\
    of\x20an\x20EnvVar.\n\n\x0b\n\x03\x04.\x01\x12\x04\x91\t\x08\x14\n\xf5\
    \x01\n\x04\x04.\x02\0\x12\x04\x95\t\x02,\x1a\xe6\x01\x20Selects\x20a\x20\
    field\x20of\x20the\x20pod:\x20supports\x20metadata.name,\x20metadata.nam\
    espace,\x20`metadata.labels['<KEY>']`,\x20`metadata.annotations['<KEY>']\
    `,\n\x20spec.nodeName,\x20spec.serviceAccountName,\x20status.hostIP,\x20\
    status.podIP,\x20status.podIPs.\n\x20+optional\n\n\r\n\x05\x04.\x02\0\
    \x04\x12\x04\x95\t\x02\n\n\r\n\x05\x04.\x02\0\x06\x12\x04\x95\t\x0b\x1e\
    \n\r\n\x05\x04.\x02\0\x01\x12\x04\x95\t\x1f'\n\r\n\x05\x04.\x02\0\x03\
    \x12\x04\x95\t*+\n\xf1\x01\n\x04\x04.\x02\x01\x12\x04\x9a\t\x026\x1a\xe2\
    \x01\x20Selects\x20a\x20resource\x20of\x20the\x20container:\x20only\x20r\
    esources\x20limits\x20and\x20requests\n\x20(limits.cpu,\x20limits.memory\
    ,\x20limits.ephemeral-storage,\x20requests.cpu,\x20requests.memory\x20an\
    d\x20requests.ephemeral-storage)\x20are\x20currently\x20supported.\n\x20\
    +optional\n\n\r\n\x05\x04.\x02\x01\x04\x12\x04\x9a\t\x02\n\n\r\n\x05\x04\
    .\x02\x01\x06\x12\x04\x9a\t\x0b\x20\n\r\n\x05\x04.\x02\x01\x01\x12\x04\
    \x9a\t!1\n\r\n\x05\x04.\x02\x01\x03\x12\x04\x9a\t45\n8\n\x04\x04.\x02\
    \x02\x12\x04\x9e\t\x024\x1a*\x20Selects\x20a\x20key\x20of\x20a\x20Config\
    Map.\n\x20+optional\n\n\r\n\x05\x04.\x02\x02\x04\x12\x04\x9e\t\x02\n\n\r\
    \n\x05\x04.\x02\x02\x06\x12\x04\x9e\t\x0b\x1f\n\r\n\x05\x04.\x02\x02\x01\
    \x12\x04\x9e\t\x20/\n\r\n\x05\x04.\x02\x02\x03\x12\x04\x9e\t23\nK\n\x04\
    \x04.\x02\x03\x12\x04\xa2\t\x02.\x1a=\x20Selects\x20a\x20key\x20of\x20a\
    \x20secret\x20in\x20the\x20pod's\x20namespace\n\x20+optional\n\n\r\n\x05\
    \x04.\x02\x03\x04\x12\x04\xa2\t\x02\n\n\r\n\x05\x04.\x02\x03\x06\x12\x04\
    \xa2\t\x0b\x1c\n\r\n\x05\x04.\x02\x03\x01\x12\x04\xa2\t\x1d)\n\r\n\x05\
    \x04.\x02\x03\x03\x12\x04\xa2\t,-\n\x9c\x05\n\x02\x04/\x12\x06\xae\t\0\
    \xbb\t\x01\x1a\x8d\x05\x20An\x20EphemeralContainer\x20is\x20a\x20contain\
    er\x20that\x20may\x20be\x20added\x20temporarily\x20to\x20an\x20existing\
    \x20pod\x20for\n\x20user-initiated\x20activities\x20such\x20as\x20debugg\
    ing.\x20Ephemeral\x20containers\x20have\x20no\x20resource\x20or\n\x20sch\
    eduling\x20guarantees,\x20and\x20they\x20will\x20not\x20be\x20restarted\
    \x20when\x20they\x20exit\x20or\x20when\x20a\x20pod\x20is\n\x20removed\
    \x20or\x20restarted.\x20If\x20an\x20ephemeral\x20container\x20causes\x20\
    a\x20pod\x20to\x20exceed\x20its\x20resource\n\x20allocation,\x20the\x20p\
    od\x20may\x20be\x20evicted.\n\x20Ephemeral\x20containers\x20may\x20not\
    \x20be\x20added\x20by\x20directly\x20updating\x20the\x20pod\x20spec.\x20\
    They\x20must\x20be\x20added\n\x20via\x20the\x20pod's\x20ephemeralcontain\
    ers\x20subresource,\x20and\x20they\x20will\x20appear\x20in\x20the\x20pod\
    \x20spec\n\x20once\x20added.\n\x20This\x20is\x20an\x20alpha\x20feature\
    \x20enabled\x20by\x20the\x20EphemeralContainers\x20feature\x20flag.\n\n\
    \x0b\n\x03\x04/\x01\x12\x04\xae\t\x08\x1a\n\x90\x02\n\x04\x04/\x02\0\x12\
    \x04\xb3\t\x02A\x1a\x81\x02\x20Ephemeral\x20containers\x20have\x20all\
    \x20of\x20the\x20fields\x20of\x20Container,\x20plus\x20additional\x20fie\
    lds\n\x20specific\x20to\x20ephemeral\x20containers.\x20Fields\x20in\x20c\
    ommon\x20with\x20Container\x20are\x20in\x20the\n\x20following\x20inlined\
    \x20struct\x20so\x20than\x20an\x20EphemeralContainer\x20may\x20easily\
    \x20be\x20converted\n\x20to\x20a\x20Container.\n\n\r\n\x05\x04/\x02\0\
    \x04\x12\x04\xb3\t\x02\n\n\r\n\x05\x04/\x02\0\x06\x12\x04\xb3\t\x0b#\n\r\
    \n\x05\x04/\x02\0\x01\x12\x04\xb3\t$<\n\r\n\x05\x04/\x02\0\x03\x12\x04\
    \xb3\t?@\n\xe6\x02\n\x04\x04/\x02\x01\x12\x04\xba\t\x02*\x1a\xd7\x02\x20\
    If\x20set,\x20the\x20name\x20of\x20the\x20container\x20from\x20PodSpec\
    \x20that\x20this\x20ephemeral\x20container\x20targets.\n\x20The\x20ephem\
    eral\x20container\x20will\x20be\x20run\x20in\x20the\x20namespaces\x20(IP\
    C,\x20PID,\x20etc)\x20of\x20this\x20container.\n\x20If\x20not\x20set\x20\
    then\x20the\x20ephemeral\x20container\x20is\x20run\x20in\x20whatever\x20\
    namespaces\x20are\x20shared\n\x20for\x20the\x20pod.\x20Note\x20that\x20t\
    he\x20container\x20runtime\x20must\x20support\x20this\x20feature.\n\x20+\
    optional\n\n\r\n\x05\x04/\x02\x01\x04\x12\x04\xba\t\x02\n\n\r\n\x05\x04/\
    \x02\x01\x05\x12\x04\xba\t\x0b\x11\n\r\n\x05\x04/\x02\x01\x01\x12\x04\
    \xba\t\x12%\n\r\n\x05\x04/\x02\x01\x03\x12\x04\xba\t()\n\xd3\x02\n\x02\
    \x040\x12\x06\xc1\t\0\xd0\n\x01\x1a\xc4\x02\x20EphemeralContainerCommon\
    \x20is\x20a\x20copy\x20of\x20all\x20fields\x20in\x20Container\x20to\x20b\
    e\x20inlined\x20in\n\x20EphemeralContainer.\x20This\x20separate\x20type\
    \x20allows\x20easy\x20conversion\x20from\x20EphemeralContainer\n\x20to\
    \x20Container\x20and\x20allows\x20separate\x20documentation\x20for\x20th\
    e\x20fields\x20of\x20EphemeralContainer.\n\x20When\x20a\x20new\x20field\
    \x20is\x20added\x20to\x20Container\x20it\x20must\x20be\x20added\x20here\
    \x20as\x20well.\n\n\x0b\n\x03\x040\x01\x12\x04\xc1\t\x08\x20\n\xa4\x01\n\
    \x04\x040\x02\0\x12\x04\xc4\t\x02\x1b\x1a\x95\x01\x20Name\x20of\x20the\
    \x20ephemeral\x20container\x20specified\x20as\x20a\x20DNS_LABEL.\n\x20Th\
    is\x20name\x20must\x20be\x20unique\x20among\x20all\x20containers,\x20ini\
    t\x20containers\x20and\x20ephemeral\x20containers.\n\n\r\n\x05\x040\x02\
    \0\x04\x12\x04\xc4\t\x02\n\n\r\n\x05\x040\x02\0\x05\x12\x04\xc4\t\x0b\
    \x11\n\r\n\x05\x040\x02\0\x01\x12\x04\xc4\t\x12\x16\n\r\n\x05\x040\x02\0\
    \x03\x12\x04\xc4\t\x19\x1a\nd\n\x04\x040\x02\x01\x12\x04\xc8\t\x02\x1c\
    \x1aV\x20Docker\x20image\x20name.\n\x20More\x20info:\x20https://kubernet\
    es.io/docs/concepts/containers/images\n\n\r\n\x05\x040\x02\x01\x04\x12\
    \x04\xc8\t\x02\n\n\r\n\x05\x040\x02\x01\x05\x12\x04\xc8\t\x0b\x11\n\r\n\
    \x05\x040\x02\x01\x01\x12\x04\xc8\t\x12\x17\n\r\n\x05\x040\x02\x01\x03\
    \x12\x04\xc8\t\x1a\x1b\n\xf5\x04\n\x04\x040\x02\x02\x12\x04\xd3\t\x02\
    \x1e\x1a\xe6\x04\x20Entrypoint\x20array.\x20Not\x20executed\x20within\
    \x20a\x20shell.\n\x20The\x20docker\x20image's\x20ENTRYPOINT\x20is\x20use\
    d\x20if\x20this\x20is\x20not\x20provided.\n\x20Variable\x20references\
    \x20$(VAR_NAME)\x20are\x20expanded\x20using\x20the\x20container's\x20env\
    ironment.\x20If\x20a\x20variable\n\x20cannot\x20be\x20resolved,\x20the\
    \x20reference\x20in\x20the\x20input\x20string\x20will\x20be\x20unchanged\
    .\x20The\x20$(VAR_NAME)\x20syntax\n\x20can\x20be\x20escaped\x20with\x20a\
    \x20double\x20$$,\x20ie:\x20$$(VAR_NAME).\x20Escaped\x20references\x20wi\
    ll\x20never\x20be\x20expanded,\n\x20regardless\x20of\x20whether\x20the\
    \x20variable\x20exists\x20or\x20not.\n\x20Cannot\x20be\x20updated.\n\x20\
    More\x20info:\x20https://kubernetes.io/docs/tasks/inject-data-applicatio\
    n/define-command-argument-container/#running-a-command-in-a-shell\n\x20+\
    optional\n\n\r\n\x05\x040\x02\x02\x04\x12\x04\xd3\t\x02\n\n\r\n\x05\x040\
    \x02\x02\x05\x12\x04\xd3\t\x0b\x11\n\r\n\x05\x040\x02\x02\x01\x12\x04\
    \xd3\t\x12\x19\n\r\n\x05\x040\x02\x02\x03\x12\x04\xd3\t\x1c\x1d\n\xdc\
    \x04\n\x04\x040\x02\x03\x12\x04\xde\t\x02\x1b\x1a\xcd\x04\x20Arguments\
    \x20to\x20the\x20entrypoint.\n\x20The\x20docker\x20image's\x20CMD\x20is\
    \x20used\x20if\x20this\x20is\x20not\x20provided.\n\x20Variable\x20refere\
    nces\x20$(VAR_NAME)\x20are\x20expanded\x20using\x20the\x20container's\
    \x20environment.\x20If\x20a\x20variable\n\x20cannot\x20be\x20resolved,\
    \x20the\x20reference\x20in\x20the\x20input\x20string\x20will\x20be\x20un\
    changed.\x20The\x20$(VAR_NAME)\x20syntax\n\x20can\x20be\x20escaped\x20wi\
    th\x20a\x20double\x20$$,\x20ie:\x20$$(VAR_NAME).\x20Escaped\x20reference\
    s\x20will\x20never\x20be\x20expanded,\n\x20regardless\x20of\x20whether\
    \x20the\x20variable\x20exists\x20or\x20not.\n\x20Cannot\x20be\x20updated\
    .\n\x20More\x20info:\x20https://kubernetes.io/docs/tasks/inject-data-app\
    lication/define-command-argument-container/#running-a-command-in-a-shell\
    \n\x20+optional\n\n\r\n\x05\x040\x02\x03\x04\x12\x04\xde\t\x02\n\n\r\n\
    \x05\x040\x02\x03\x05\x12\x04\xde\t\x0b\x11\n\r\n\x05\x040\x02\x03\x01\
    \x12\x04\xde\t\x12\x16\n\r\n\x05\x040\x02\x03\x03\x12\x04\xde\t\x19\x1a\
    \n\xc2\x01\n\x04\x040\x02\x04\x12\x04\xe5\t\x02!\x1a\xb3\x01\x20Containe\
    r's\x20working\x20directory.\n\x20If\x20not\x20specified,\x20the\x20cont\
    ainer\x20runtime's\x20default\x20will\x20be\x20used,\x20which\n\x20might\
    \x20be\x20configured\x20in\x20the\x20container\x20image.\n\x20Cannot\x20\
    be\x20updated.\n\x20+optional\n\n\r\n\x05\x040\x02\x04\x04\x12\x04\xe5\t\
    \x02\n\n\r\n\x05\x040\x02\x04\x05\x12\x04\xe5\t\x0b\x11\n\r\n\x05\x040\
    \x02\x04\x01\x12\x04\xe5\t\x12\x1c\n\r\n\x05\x040\x02\x04\x03\x12\x04\
    \xe5\t\x1f\x20\n?\n\x04\x040\x02\x05\x12\x04\xe8\t\x02#\x1a1\x20Ports\
    \x20are\x20not\x20allowed\x20for\x20ephemeral\x20containers.\n\n\r\n\x05\
    \x040\x02\x05\x04\x12\x04\xe8\t\x02\n\n\r\n\x05\x040\x02\x05\x06\x12\x04\
    \xe8\t\x0b\x18\n\r\n\x05\x040\x02\x05\x01\x12\x04\xe8\t\x19\x1e\n\r\n\
    \x05\x040\x02\x05\x03\x12\x04\xe8\t!\"\n\xa9\x03\n\x04\x040\x02\x06\x12\
    \x04\xf1\t\x02&\x1a\x9a\x03\x20List\x20of\x20sources\x20to\x20populate\
    \x20environment\x20variables\x20in\x20the\x20container.\n\x20The\x20keys\
    \x20defined\x20within\x20a\x20source\x20must\x20be\x20a\x20C_IDENTIFIER.\
    \x20All\x20invalid\x20keys\n\x20will\x20be\x20reported\x20as\x20an\x20ev\
    ent\x20when\x20the\x20container\x20is\x20starting.\x20When\x20a\x20key\
    \x20exists\x20in\x20multiple\n\x20sources,\x20the\x20value\x20associated\
    \x20with\x20the\x20last\x20source\x20will\x20take\x20precedence.\n\x20Va\
    lues\x20defined\x20by\x20an\x20Env\x20with\x20a\x20duplicate\x20key\x20w\
    ill\x20take\x20precedence.\n\x20Cannot\x20be\x20updated.\n\x20+optional\
    \n\n\r\n\x05\x040\x02\x06\x04\x12\x04\xf1\t\x02\n\n\r\n\x05\x040\x02\x06\
    \x06\x12\x04\xf1\t\x0b\x18\n\r\n\x05\x040\x02\x06\x01\x12\x04\xf1\t\x19\
    \x20\n\r\n\x05\x040\x02\x06\x03\x12\x04\xf1\t#%\n\x91\x01\n\x04\x040\x02\
    \x07\x12\x04\xf8\t\x02\x1a\x1a\x82\x01\x20List\x20of\x20environment\x20v\
    ariables\x20to\x20set\x20in\x20the\x20container.\n\x20Cannot\x20be\x20up\
    dated.\n\x20+optional\n\x20+patchMergeKey=name\n\x20+patchStrategy=merge\
    \n\n\r\n\x05\x040\x02\x07\x04\x12\x04\xf8\t\x02\n\n\r\n\x05\x040\x02\x07\
    \x06\x12\x04\xf8\t\x0b\x11\n\r\n\x05\x040\x02\x07\x01\x12\x04\xf8\t\x12\
    \x15\n\r\n\x05\x040\x02\x07\x03\x12\x04\xf8\t\x18\x19\n\x97\x01\n\x04\
    \x040\x02\x08\x12\x04\xfd\t\x02.\x1a\x88\x01\x20Resources\x20are\x20not\
    \x20allowed\x20for\x20ephemeral\x20containers.\x20Ephemeral\x20container\
    s\x20use\x20spare\x20resources\n\x20already\x20allocated\x20to\x20the\
    \x20pod.\n\x20+optional\n\n\r\n\x05\x040\x02\x08\x04\x12\x04\xfd\t\x02\n\
    \n\r\n\x05\x040\x02\x08\x06\x12\x04\xfd\t\x0b\x1f\n\r\n\x05\x040\x02\x08\
    \x01\x12\x04\xfd\t\x20)\n\r\n\x05\x040\x02\x08\x03\x12\x04\xfd\t,-\n\x95\
    \x01\n\x04\x040\x02\t\x12\x04\x84\n\x02(\x1a\x86\x01\x20Pod\x20volumes\
    \x20to\x20mount\x20into\x20the\x20container's\x20filesystem.\n\x20Cannot\
    \x20be\x20updated.\n\x20+optional\n\x20+patchMergeKey=mountPath\n\x20+pa\
    tchStrategy=merge\n\n\r\n\x05\x040\x02\t\x04\x12\x04\x84\n\x02\n\n\r\n\
    \x05\x040\x02\t\x06\x12\x04\x84\n\x0b\x16\n\r\n\x05\x040\x02\t\x01\x12\
    \x04\x84\n\x17#\n\r\n\x05\x040\x02\t\x03\x12\x04\x84\n&'\n\x94\x01\n\x04\
    \x040\x02\n\x12\x04\x8a\n\x02+\x1a\x85\x01\x20volumeDevices\x20is\x20the\
    \x20list\x20of\x20block\x20devices\x20to\x20be\x20used\x20by\x20the\x20c\
    ontainer.\n\x20+patchMergeKey=devicePath\n\x20+patchStrategy=merge\n\x20\
    +optional\n\n\r\n\x05\x040\x02\n\x04\x12\x04\x8a\n\x02\n\n\r\n\x05\x040\
    \x02\n\x06\x12\x04\x8a\n\x0b\x17\n\r\n\x05\x040\x02\n\x01\x12\x04\x8a\n\
    \x18%\n\r\n\x05\x040\x02\n\x03\x12\x04\x8a\n(*\nK\n\x04\x040\x02\x0b\x12\
    \x04\x8e\n\x02$\x1a=\x20Probes\x20are\x20not\x20allowed\x20for\x20epheme\
    ral\x20containers.\n\x20+optional\n\n\r\n\x05\x040\x02\x0b\x04\x12\x04\
    \x8e\n\x02\n\n\r\n\x05\x040\x02\x0b\x06\x12\x04\x8e\n\x0b\x10\n\r\n\x05\
    \x040\x02\x0b\x01\x12\x04\x8e\n\x11\x1e\n\r\n\x05\x040\x02\x0b\x03\x12\
    \x04\x8e\n!#\nK\n\x04\x040\x02\x0c\x12\x04\x92\n\x02%\x1a=\x20Probes\x20\
    are\x20not\x20allowed\x20for\x20ephemeral\x20containers.\n\x20+optional\
    \n\n\r\n\x05\x040\x02\x0c\x04\x12\x04\x92\n\x02\n\n\r\n\x05\x040\x02\x0c\
    \x06\x12\x04\x92\n\x0b\x10\n\r\n\x05\x040\x02\x0c\x01\x12\x04\x92\n\x11\
    \x1f\n\r\n\x05\x040\x02\x0c\x03\x12\x04\x92\n\"$\nK\n\x04\x040\x02\r\x12\
    \x04\x96\n\x02#\x1a=\x20Probes\x20are\x20not\x20allowed\x20for\x20epheme\
    ral\x20containers.\n\x20+optional\n\n\r\n\x05\x040\x02\r\x04\x12\x04\x96\
    \n\x02\n\n\r\n\x05\x040\x02\r\x06\x12\x04\x96\n\x0b\x10\n\r\n\x05\x040\
    \x02\r\x01\x12\x04\x96\n\x11\x1d\n\r\n\x05\x040\x02\r\x03\x12\x04\x96\n\
    \x20\"\nM\n\x04\x040\x02\x0e\x12\x04\x9a\n\x02$\x1a?\x20Lifecycle\x20is\
    \x20not\x20allowed\x20for\x20ephemeral\x20containers.\n\x20+optional\n\n\
    \r\n\x05\x040\x02\x0e\x04\x12\x04\x9a\n\x02\n\n\r\n\x05\x040\x02\x0e\x06\
    \x12\x04\x9a\n\x0b\x14\n\r\n\x05\x040\x02\x0e\x01\x12\x04\x9a\n\x15\x1e\
    \n\r\n\x05\x040\x02\x0e\x03\x12\x04\x9a\n!#\n\xbe\x03\n\x04\x040\x02\x0f\
    \x12\x04\xa4\n\x02.\x1a\xaf\x03\x20Optional:\x20Path\x20at\x20which\x20t\
    he\x20file\x20to\x20which\x20the\x20container's\x20termination\x20messag\
    e\n\x20will\x20be\x20written\x20is\x20mounted\x20into\x20the\x20containe\
    r's\x20filesystem.\n\x20Message\x20written\x20is\x20intended\x20to\x20be\
    \x20brief\x20final\x20status,\x20such\x20as\x20an\x20assertion\x20failur\
    e\x20message.\n\x20Will\x20be\x20truncated\x20by\x20the\x20node\x20if\
    \x20greater\x20than\x204096\x20bytes.\x20The\x20total\x20message\x20leng\
    th\x20across\n\x20all\x20containers\x20will\x20be\x20limited\x20to\x2012\
    kb.\n\x20Defaults\x20to\x20/dev/termination-log.\n\x20Cannot\x20be\x20up\
    dated.\n\x20+optional\n\n\r\n\x05\x040\x02\x0f\x04\x12\x04\xa4\n\x02\n\n\
    \r\n\x05\x040\x02\x0f\x05\x12\x04\xa4\n\x0b\x11\n\r\n\x05\x040\x02\x0f\
    \x01\x12\x04\xa4\n\x12(\n\r\n\x05\x040\x02\x0f\x03\x12\x04\xa4\n+-\n\xdd\
    \x03\n\x04\x040\x02\x10\x12\x04\xae\n\x020\x1a\xce\x03\x20Indicate\x20ho\
    w\x20the\x20termination\x20message\x20should\x20be\x20populated.\x20File\
    \x20will\x20use\x20the\x20contents\x20of\n\x20terminationMessagePath\x20\
    to\x20populate\x20the\x20container\x20status\x20message\x20on\x20both\
    \x20success\x20and\x20failure.\n\x20FallbackToLogsOnError\x20will\x20use\
    \x20the\x20last\x20chunk\x20of\x20container\x20log\x20output\x20if\x20th\
    e\x20termination\n\x20message\x20file\x20is\x20empty\x20and\x20the\x20co\
    ntainer\x20exited\x20with\x20an\x20error.\n\x20The\x20log\x20output\x20i\
    s\x20limited\x20to\x202048\x20bytes\x20or\x2080\x20lines,\x20whichever\
    \x20is\x20smaller.\n\x20Defaults\x20to\x20File.\n\x20Cannot\x20be\x20upd\
    ated.\n\x20+optional\n\n\r\n\x05\x040\x02\x10\x04\x12\x04\xae\n\x02\n\n\
    \r\n\x05\x040\x02\x10\x05\x12\x04\xae\n\x0b\x11\n\r\n\x05\x040\x02\x10\
    \x01\x12\x04\xae\n\x12*\n\r\n\x05\x040\x02\x10\x03\x12\x04\xae\n-/\n\x85\
    \x02\n\x04\x040\x02\x11\x12\x04\xb6\n\x02'\x1a\xf6\x01\x20Image\x20pull\
    \x20policy.\n\x20One\x20of\x20Always,\x20Never,\x20IfNotPresent.\n\x20De\
    faults\x20to\x20Always\x20if\x20:latest\x20tag\x20is\x20specified,\x20or\
    \x20IfNotPresent\x20otherwise.\n\x20Cannot\x20be\x20updated.\n\x20More\
    \x20info:\x20https://kubernetes.io/docs/concepts/containers/images#updat\
    ing-images\n\x20+optional\n\n\r\n\x05\x040\x02\x11\x04\x12\x04\xb6\n\x02\
    \n\n\r\n\x05\x040\x02\x11\x05\x12\x04\xb6\n\x0b\x11\n\r\n\x05\x040\x02\
    \x11\x01\x12\x04\xb6\n\x12!\n\r\n\x05\x040\x02\x11\x03\x12\x04\xb6\n$&\n\
    S\n\x04\x040\x02\x12\x12\x04\xba\n\x020\x1aE\x20SecurityContext\x20is\
    \x20not\x20allowed\x20for\x20ephemeral\x20containers.\n\x20+optional\n\n\
    \r\n\x05\x040\x02\x12\x04\x12\x04\xba\n\x02\n\n\r\n\x05\x040\x02\x12\x06\
    \x12\x04\xba\n\x0b\x1a\n\r\n\x05\x040\x02\x12\x01\x12\x04\xba\n\x1b*\n\r\
    \n\x05\x040\x02\x12\x03\x12\x04\xba\n-/\n\xd4\x01\n\x04\x040\x02\x13\x12\
    \x04\xc0\n\x02\x1b\x1a\xc5\x01\x20Whether\x20this\x20container\x20should\
    \x20allocate\x20a\x20buffer\x20for\x20stdin\x20in\x20the\x20container\
    \x20runtime.\x20If\x20this\n\x20is\x20not\x20set,\x20reads\x20from\x20st\
    din\x20in\x20the\x20container\x20will\x20always\x20result\x20in\x20EOF.\
    \n\x20Default\x20is\x20false.\n\x20+optional\n\n\r\n\x05\x040\x02\x13\
    \x04\x12\x04\xc0\n\x02\n\n\r\n\x05\x040\x02\x13\x05\x12\x04\xc0\n\x0b\
    \x0f\n\r\n\x05\x040\x02\x13\x01\x12\x04\xc0\n\x10\x15\n\r\n\x05\x040\x02\
    \x13\x03\x12\x04\xc0\n\x18\x1a\n\xdc\x04\n\x04\x040\x02\x14\x12\x04\xca\
    \n\x02\x1f\x1a\xcd\x04\x20Whether\x20the\x20container\x20runtime\x20shou\
    ld\x20close\x20the\x20stdin\x20channel\x20after\x20it\x20has\x20been\x20\
    opened\x20by\n\x20a\x20single\x20attach.\x20When\x20stdin\x20is\x20true\
    \x20the\x20stdin\x20stream\x20will\x20remain\x20open\x20across\x20multip\
    le\x20attach\n\x20sessions.\x20If\x20stdinOnce\x20is\x20set\x20to\x20tru\
    e,\x20stdin\x20is\x20opened\x20on\x20container\x20start,\x20is\x20empty\
    \x20until\x20the\n\x20first\x20client\x20attaches\x20to\x20stdin,\x20and\
    \x20then\x20remains\x20open\x20and\x20accepts\x20data\x20until\x20the\
    \x20client\x20disconnects,\n\x20at\x20which\x20time\x20stdin\x20is\x20cl\
    osed\x20and\x20remains\x20closed\x20until\x20the\x20container\x20is\x20r\
    estarted.\x20If\x20this\n\x20flag\x20is\x20false,\x20a\x20container\x20p\
    rocesses\x20that\x20reads\x20from\x20stdin\x20will\x20never\x20receive\
    \x20an\x20EOF.\n\x20Default\x20is\x20false\n\x20+optional\n\n\r\n\x05\
    \x040\x02\x14\x04\x12\x04\xca\n\x02\n\n\r\n\x05\x040\x02\x14\x05\x12\x04\
    \xca\n\x0b\x0f\n\r\n\x05\x040\x02\x14\x01\x12\x04\xca\n\x10\x19\n\r\n\
    \x05\x040\x02\x14\x03\x12\x04\xca\n\x1c\x1e\n\x88\x01\n\x04\x040\x02\x15\
    \x12\x04\xcf\n\x02\x19\x1az\x20Whether\x20this\x20container\x20should\
    \x20allocate\x20a\x20TTY\x20for\x20itself,\x20also\x20requires\x20'stdin\
    '\x20to\x20be\x20true.\n\x20Default\x20is\x20false.\n\x20+optional\n\n\r\
    \n\x05\x040\x02\x15\x04\x12\x04\xcf\n\x02\n\n\r\n\x05\x040\x02\x15\x05\
    \x12\x04\xcf\n\x0b\x0f\n\r\n\x05\x040\x02\x15\x01\x12\x04\xcf\n\x10\x13\
    \n\r\n\x05\x040\x02\x15\x03\x12\x04\xcf\n\x16\x18\na\n\x02\x041\x12\x06\
    \xd3\n\0\xdd\n\x01\x1aS\x20A\x20list\x20of\x20ephemeral\x20containers\
    \x20used\x20with\x20the\x20Pod\x20ephemeralcontainers\x20subresource.\n\
    \n\x0b\n\x03\x041\x01\x12\x04\xd3\n\x08\x1b\n\x19\n\x04\x041\x02\0\x12\
    \x04\xd5\n\x02H\x1a\x0b\x20+optional\n\n\r\n\x05\x041\x02\0\x04\x12\x04\
    \xd5\n\x02\n\n\r\n\x05\x041\x02\0\x06\x12\x04\xd5\n\x0b:\n\r\n\x05\x041\
    \x02\0\x01\x12\x04\xd5\n;C\n\r\n\x05\x041\x02\0\x03\x12\x04\xd5\nFG\n\
    \xef\x01\n\x04\x041\x02\x01\x12\x04\xdc\n\x026\x1a\xe0\x01\x20A\x20list\
    \x20of\x20ephemeral\x20containers\x20associated\x20with\x20this\x20pod.\
    \x20New\x20ephemeral\x20containers\n\x20may\x20be\x20appended\x20to\x20t\
    his\x20list,\x20but\x20existing\x20ephemeral\x20containers\x20may\x20not\
    \x20be\x20removed\n\x20or\x20modified.\n\x20+patchMergeKey=name\n\x20+pa\
    tchStrategy=merge\n\n\r\n\x05\x041\x02\x01\x04\x12\x04\xdc\n\x02\n\n\r\n\
    \x05\x041\x02\x01\x06\x12\x04\xdc\n\x0b\x1d\n\r\n\x05\x041\x02\x01\x01\
    \x12\x04\xdc\n\x1e1\n\r\n\x05\x041\x02\x01\x03\x12\x04\xdc\n45\nZ\n\x02\
    \x042\x12\x06\xe0\n\0\xfc\n\x01\x1aL\x20Represents\x20an\x20ephemeral\
    \x20volume\x20that\x20is\x20handled\x20by\x20a\x20normal\x20storage\x20d\
    river.\n\n\x0b\n\x03\x042\x01\x12\x04\xe0\n\x08\x1d\n\xa4\x08\n\x04\x042\
    \x02\0\x12\x04\xf6\n\x02A\x1a\x95\x08\x20Will\x20be\x20used\x20to\x20cre\
    ate\x20a\x20stand-alone\x20PVC\x20to\x20provision\x20the\x20volume.\n\
    \x20The\x20pod\x20in\x20which\x20this\x20EphemeralVolumeSource\x20is\x20\
    embedded\x20will\x20be\x20the\n\x20owner\x20of\x20the\x20PVC,\x20i.e.\
    \x20the\x20PVC\x20will\x20be\x20deleted\x20together\x20with\x20the\n\x20\
    pod.\x20\x20The\x20name\x20of\x20the\x20PVC\x20will\x20be\x20`<pod\x20na\
    me>-<volume\x20name>`\x20where\n\x20`<volume\x20name>`\x20is\x20the\x20n\
    ame\x20from\x20the\x20`PodSpec.Volumes`\x20array\n\x20entry.\x20Pod\x20v\
    alidation\x20will\x20reject\x20the\x20pod\x20if\x20the\x20concatenated\
    \x20name\n\x20is\x20not\x20valid\x20for\x20a\x20PVC\x20(for\x20example,\
    \x20too\x20long).\n\n\x20An\x20existing\x20PVC\x20with\x20that\x20name\
    \x20that\x20is\x20not\x20owned\x20by\x20the\x20pod\n\x20will\x20*not*\
    \x20be\x20used\x20for\x20the\x20pod\x20to\x20avoid\x20using\x20an\x20unr\
    elated\n\x20volume\x20by\x20mistake.\x20Starting\x20the\x20pod\x20is\x20\
    then\x20blocked\x20until\n\x20the\x20unrelated\x20PVC\x20is\x20removed.\
    \x20If\x20such\x20a\x20pre-created\x20PVC\x20is\n\x20meant\x20to\x20be\
    \x20used\x20by\x20the\x20pod,\x20the\x20PVC\x20has\x20to\x20updated\x20w\
    ith\x20an\n\x20owner\x20reference\x20to\x20the\x20pod\x20once\x20the\x20\
    pod\x20exists.\x20Normally\n\x20this\x20should\x20not\x20be\x20necessary\
    ,\x20but\x20it\x20may\x20be\x20useful\x20when\n\x20manually\x20reconstru\
    cting\x20a\x20broken\x20cluster.\n\n\x20This\x20field\x20is\x20read-only\
    \x20and\x20no\x20changes\x20will\x20be\x20made\x20by\x20Kubernetes\n\x20\
    to\x20the\x20PVC\x20after\x20it\x20has\x20been\x20created.\n\n\x20Requir\
    ed,\x20must\x20not\x20be\x20nil.\n\n\r\n\x05\x042\x02\0\x04\x12\x04\xf6\
    \n\x02\n\n\r\n\x05\x042\x02\0\x06\x12\x04\xf6\n\x0b(\n\r\n\x05\x042\x02\
    \0\x01\x12\x04\xf6\n)<\n\r\n\x05\x042\x02\0\x03\x12\x04\xf6\n?@\no\n\x04\
    \x042\x02\x01\x12\x04\xfb\n\x02\x1d\x1aa\x20Specifies\x20a\x20read-only\
    \x20configuration\x20for\x20the\x20volume.\n\x20Defaults\x20to\x20false\
    \x20(read/write).\n\x20+optional\n\n\r\n\x05\x042\x02\x01\x04\x12\x04\
    \xfb\n\x02\n\n\r\n\x05\x042\x02\x01\x05\x12\x04\xfb\n\x0b\x0f\n\r\n\x05\
    \x042\x02\x01\x01\x12\x04\xfb\n\x10\x18\n\r\n\x05\x042\x02\x01\x03\x12\
    \x04\xfb\n\x1b\x1c\n\x9f\x03\n\x02\x043\x12\x06\x84\x0b\0\xc2\x0b\x01\
    \x1a\x90\x03\x20Event\x20is\x20a\x20report\x20of\x20an\x20event\x20somew\
    here\x20in\x20the\x20cluster.\x20\x20Events\n\x20have\x20a\x20limited\
    \x20retention\x20time\x20and\x20triggers\x20and\x20messages\x20may\x20ev\
    olve\n\x20with\x20time.\x20\x20Event\x20consumers\x20should\x20not\x20re\
    ly\x20on\x20the\x20timing\x20of\x20an\x20event\n\x20with\x20a\x20given\
    \x20Reason\x20reflecting\x20a\x20consistent\x20underlying\x20trigger,\
    \x20or\x20the\n\x20continued\x20existence\x20of\x20events\x20with\x20tha\
    t\x20Reason.\x20\x20Events\x20should\x20be\n\x20treated\x20as\x20informa\
    tive,\x20best-effort,\x20supplemental\x20data.\n\n\x0b\n\x03\x043\x01\
    \x12\x04\x84\x0b\x08\r\n\x95\x01\n\x04\x043\x02\0\x12\x04\x87\x0b\x02H\
    \x1a\x86\x01\x20Standard\x20object's\x20metadata.\n\x20More\x20info:\x20\
    https://git.k8s.io/community/contributors/devel/sig-architecture/api-con\
    ventions.md#metadata\n\n\r\n\x05\x043\x02\0\x04\x12\x04\x87\x0b\x02\n\n\
    \r\n\x05\x043\x02\0\x06\x12\x04\x87\x0b\x0b:\n\r\n\x05\x043\x02\0\x01\
    \x12\x04\x87\x0b;C\n\r\n\x05\x043\x02\0\x03\x12\x04\x87\x0bFG\n4\n\x04\
    \x043\x02\x01\x12\x04\x8a\x0b\x02.\x1a&\x20The\x20object\x20that\x20this\
    \x20event\x20is\x20about.\n\n\r\n\x05\x043\x02\x01\x04\x12\x04\x8a\x0b\
    \x02\n\n\r\n\x05\x043\x02\x01\x06\x12\x04\x8a\x0b\x0b\x1a\n\r\n\x05\x043\
    \x02\x01\x01\x12\x04\x8a\x0b\x1b)\n\r\n\x05\x043\x02\x01\x03\x12\x04\x8a\
    \x0b,-\n\xcc\x01\n\x04\x043\x02\x02\x12\x04\x90\x0b\x02\x1d\x1a\xbd\x01\
    \x20This\x20should\x20be\x20a\x20short,\x20machine\x20understandable\x20\
    string\x20that\x20gives\x20the\x20reason\n\x20for\x20the\x20transition\
    \x20into\x20the\x20object's\x20current\x20status.\n\x20TODO:\x20provide\
    \x20exact\x20specification\x20for\x20format.\n\x20+optional\n\n\r\n\x05\
    \x043\x02\x02\x04\x12\x04\x90\x0b\x02\n\n\r\n\x05\x043\x02\x02\x05\x12\
    \x04\x90\x0b\x0b\x11\n\r\n\x05\x043\x02\x02\x01\x12\x04\x90\x0b\x12\x18\
    \n\r\n\x05\x043\x02\x02\x03\x12\x04\x90\x0b\x1b\x1c\ny\n\x04\x043\x02\
    \x03\x12\x04\x95\x0b\x02\x1e\x1ak\x20A\x20human-readable\x20description\
    \x20of\x20the\x20status\x20of\x20this\x20operation.\n\x20TODO:\x20decide\
    \x20on\x20maximum\x20length.\n\x20+optional\n\n\r\n\x05\x043\x02\x03\x04\
    \x12\x04\x95\x0b\x02\n\n\r\n\x05\x043\x02\x03\x05\x12\x04\x95\x0b\x0b\
    \x11\n\r\n\x05\x043\x02\x03\x01\x12\x04\x95\x0b\x12\x19\n\r\n\x05\x043\
    \x02\x03\x03\x12\x04\x95\x0b\x1c\x1d\no\n\x04\x043\x02\x04\x12\x04\x99\
    \x0b\x02\"\x1aa\x20The\x20component\x20reporting\x20this\x20event.\x20Sh\
    ould\x20be\x20a\x20short\x20machine\x20understandable\x20string.\n\x20+o\
    ptional\n\n\r\n\x05\x043\x02\x04\x04\x12\x04\x99\x0b\x02\n\n\r\n\x05\x04\
    3\x02\x04\x06\x12\x04\x99\x0b\x0b\x16\n\r\n\x05\x043\x02\x04\x01\x12\x04\
    \x99\x0b\x17\x1d\n\r\n\x05\x043\x02\x04\x03\x12\x04\x99\x0b\x20!\ns\n\
    \x04\x043\x02\x05\x12\x04\x9d\x0b\x02H\x1ae\x20The\x20time\x20at\x20whic\
    h\x20the\x20event\x20was\x20first\x20recorded.\x20(Time\x20of\x20server\
    \x20receipt\x20is\x20in\x20TypeMeta.)\n\x20+optional\n\n\r\n\x05\x043\
    \x02\x05\x04\x12\x04\x9d\x0b\x02\n\n\r\n\x05\x043\x02\x05\x06\x12\x04\
    \x9d\x0b\x0b4\n\r\n\x05\x043\x02\x05\x01\x12\x04\x9d\x0b5C\n\r\n\x05\x04\
    3\x02\x05\x03\x12\x04\x9d\x0bFG\nc\n\x04\x043\x02\x06\x12\x04\xa1\x0b\
    \x02G\x1aU\x20The\x20time\x20at\x20which\x20the\x20most\x20recent\x20occ\
    urrence\x20of\x20this\x20event\x20was\x20recorded.\n\x20+optional\n\n\r\
    \n\x05\x043\x02\x06\x04\x12\x04\xa1\x0b\x02\n\n\r\n\x05\x043\x02\x06\x06\
    \x12\x04\xa1\x0b\x0b4\n\r\n\x05\x043\x02\x06\x01\x12\x04\xa1\x0b5B\n\r\n\
    \x05\x043\x02\x06\x03\x12\x04\xa1\x0bEF\nG\n\x04\x043\x02\x07\x12\x04\
    \xa5\x0b\x02\x1b\x1a9\x20The\x20number\x20of\x20times\x20this\x20event\
    \x20has\x20occurred.\n\x20+optional\n\n\r\n\x05\x043\x02\x07\x04\x12\x04\
    \xa5\x0b\x02\n\n\r\n\x05\x043\x02\x07\x05\x12\x04\xa5\x0b\x0b\x10\n\r\n\
    \x05\x043\x02\x07\x01\x12\x04\xa5\x0b\x11\x16\n\r\n\x05\x043\x02\x07\x03\
    \x12\x04\xa5\x0b\x19\x1a\ng\n\x04\x043\x02\x08\x12\x04\xa9\x0b\x02\x1b\
    \x1aY\x20Type\x20of\x20this\x20event\x20(Normal,\x20Warning),\x20new\x20\
    types\x20could\x20be\x20added\x20in\x20the\x20future\n\x20+optional\n\n\
    \r\n\x05\x043\x02\x08\x04\x12\x04\xa9\x0b\x02\n\n\r\n\x05\x043\x02\x08\
    \x05\x12\x04\xa9\x0b\x0b\x11\n\r\n\x05\x043\x02\x08\x01\x12\x04\xa9\x0b\
    \x12\x16\n\r\n\x05\x043\x02\x08\x03\x12\x04\xa9\x0b\x19\x1a\nC\n\x04\x04\
    3\x02\t\x12\x04\xad\x0b\x02I\x1a5\x20Time\x20when\x20this\x20Event\x20wa\
    s\x20first\x20observed.\n\x20+optional\n\n\r\n\x05\x043\x02\t\x04\x12\
    \x04\xad\x0b\x02\n\n\r\n\x05\x043\x02\t\x06\x12\x04\xad\x0b\x0b9\n\r\n\
    \x05\x043\x02\t\x01\x12\x04\xad\x0b:C\n\r\n\x05\x043\x02\t\x03\x12\x04\
    \xad\x0bFH\nn\n\x04\x043\x02\n\x12\x04\xb1\x0b\x02#\x1a`\x20Data\x20abou\
    t\x20the\x20Event\x20series\x20this\x20event\x20represents\x20or\x20nil\
    \x20if\x20it's\x20a\x20singleton\x20Event.\n\x20+optional\n\n\r\n\x05\
    \x043\x02\n\x04\x12\x04\xb1\x0b\x02\n\n\r\n\x05\x043\x02\n\x06\x12\x04\
    \xb1\x0b\x0b\x16\n\r\n\x05\x043\x02\n\x01\x12\x04\xb1\x0b\x17\x1d\n\r\n\
    \x05\x043\x02\n\x03\x12\x04\xb1\x0b\x20\"\nZ\n\x04\x043\x02\x0b\x12\x04\
    \xb5\x0b\x02\x1e\x1aL\x20What\x20action\x20was\x20taken/failed\x20regard\
    ing\x20to\x20the\x20Regarding\x20object.\n\x20+optional\n\n\r\n\x05\x043\
    \x02\x0b\x04\x12\x04\xb5\x0b\x02\n\n\r\n\x05\x043\x02\x0b\x05\x12\x04\
    \xb5\x0b\x0b\x11\n\r\n\x05\x043\x02\x0b\x01\x12\x04\xb5\x0b\x12\x18\n\r\
    \n\x05\x043\x02\x0b\x03\x12\x04\xb5\x0b\x1b\x1d\nN\n\x04\x043\x02\x0c\
    \x12\x04\xb9\x0b\x02(\x1a@\x20Optional\x20secondary\x20object\x20for\x20\
    more\x20complex\x20actions.\n\x20+optional\n\n\r\n\x05\x043\x02\x0c\x04\
    \x12\x04\xb9\x0b\x02\n\n\r\n\x05\x043\x02\x0c\x06\x12\x04\xb9\x0b\x0b\
    \x1a\n\r\n\x05\x043\x02\x0c\x01\x12\x04\xb9\x0b\x1b\"\n\r\n\x05\x043\x02\
    \x0c\x03\x12\x04\xb9\x0b%'\nh\n\x04\x043\x02\r\x12\x04\xbd\x0b\x02*\x1aZ\
    \x20Name\x20of\x20the\x20controller\x20that\x20emitted\x20this\x20Event,\
    \x20e.g.\x20`kubernetes.io/kubelet`.\n\x20+optional\n\n\r\n\x05\x043\x02\
    \r\x04\x12\x04\xbd\x0b\x02\n\n\r\n\x05\x043\x02\r\x05\x12\x04\xbd\x0b\
    \x0b\x11\n\r\n\x05\x043\x02\r\x01\x12\x04\xbd\x0b\x12$\n\r\n\x05\x043\
    \x02\r\x03\x12\x04\xbd\x0b')\nN\n\x04\x043\x02\x0e\x12\x04\xc1\x0b\x02)\
    \x1a@\x20ID\x20of\x20the\x20controller\x20instance,\x20e.g.\x20`kubelet-\
    xyzf`.\n\x20+optional\n\n\r\n\x05\x043\x02\x0e\x04\x12\x04\xc1\x0b\x02\n\
    \n\r\n\x05\x043\x02\x0e\x05\x12\x04\xc1\x0b\x0b\x11\n\r\n\x05\x043\x02\
    \x0e\x01\x12\x04\xc1\x0b\x12#\n\r\n\x05\x043\x02\x0e\x03\x12\x04\xc1\x0b\
    &(\n.\n\x02\x044\x12\x06\xc5\x0b\0\xcd\x0b\x01\x1a\x20\x20EventList\x20i\
    s\x20a\x20list\x20of\x20events.\n\n\x0b\n\x03\x044\x01\x12\x04\xc5\x0b\
    \x08\x11\n\x9f\x01\n\x04\x044\x02\0\x12\x04\xc9\x0b\x02F\x1a\x90\x01\x20\
    Standard\x20list\x20metadata.\n\x20More\x20info:\x20https://git.k8s.io/c\
    ommunity/contributors/devel/sig-architecture/api-conventions.md#types-ki\
    nds\n\x20+optional\n\n\r\n\x05\x044\x02\0\x04\x12\x04\xc9\x0b\x02\n\n\r\
    \n\x05\x044\x02\0\x06\x12\x04\xc9\x0b\x0b8\n\r\n\x05\x044\x02\0\x01\x12\
    \x04\xc9\x0b9A\n\r\n\x05\x044\x02\0\x03\x12\x04\xc9\x0bDE\n\x1e\n\x04\
    \x044\x02\x01\x12\x04\xcc\x0b\x02\x1b\x1a\x10\x20List\x20of\x20events\n\
    \n\r\n\x05\x044\x02\x01\x04\x12\x04\xcc\x0b\x02\n\n\r\n\x05\x044\x02\x01\
    \x06\x12\x04\xcc\x0b\x0b\x10\n\r\n\x05\x044\x02\x01\x01\x12\x04\xcc\x0b\
    \x11\x16\n\r\n\x05\x044\x02\x01\x03\x12\x04\xcc\x0b\x19\x1a\n\x82\x01\n\
    \x02\x045\x12\x06\xd1\x0b\0\xd7\x0b\x01\x1at\x20EventSeries\x20contain\
    \x20information\x20on\x20series\x20of\x20events,\x20i.e.\x20thing\x20tha\
    t\x20was/is\x20happening\n\x20continuously\x20for\x20some\x20time.\n\n\
    \x0b\n\x03\x045\x01\x12\x04\xd1\x0b\x08\x13\nR\n\x04\x045\x02\0\x12\x04\
    \xd3\x0b\x02\x1b\x1aD\x20Number\x20of\x20occurrences\x20in\x20this\x20se\
    ries\x20up\x20to\x20the\x20last\x20heartbeat\x20time\n\n\r\n\x05\x045\
    \x02\0\x04\x12\x04\xd3\x0b\x02\n\n\r\n\x05\x045\x02\0\x05\x12\x04\xd3\
    \x0b\x0b\x10\n\r\n\x05\x045\x02\0\x01\x12\x04\xd3\x0b\x11\x16\n\r\n\x05\
    \x045\x02\0\x03\x12\x04\xd3\x0b\x19\x1a\n4\n\x04\x045\x02\x01\x12\x04\
    \xd6\x0b\x02O\x1a&\x20Time\x20of\x20the\x20last\x20occurrence\x20observe\
    d\n\n\r\n\x05\x045\x02\x01\x04\x12\x04\xd6\x0b\x02\n\n\r\n\x05\x045\x02\
    \x01\x06\x12\x04\xd6\x0b\x0b9\n\r\n\x05\x045\x02\x01\x01\x12\x04\xd6\x0b\
    :J\n\r\n\x05\x045\x02\x01\x03\x12\x04\xd6\x0bMN\n>\n\x02\x046\x12\x06\
    \xda\x0b\0\xe2\x0b\x01\x1a0\x20EventSource\x20contains\x20information\
    \x20for\x20an\x20event.\n\n\x0b\n\x03\x046\x01\x12\x04\xda\x0b\x08\x13\n\
    G\n\x04\x046\x02\0\x12\x04\xdd\x0b\x02\x20\x1a9\x20Component\x20from\x20\
    which\x20the\x20event\x20is\x20generated.\n\x20+optional\n\n\r\n\x05\x04\
    6\x02\0\x04\x12\x04\xdd\x0b\x02\n\n\r\n\x05\x046\x02\0\x05\x12\x04\xdd\
    \x0b\x0b\x11\n\r\n\x05\x046\x02\0\x01\x12\x04\xdd\x0b\x12\x1b\n\r\n\x05\
    \x046\x02\0\x03\x12\x04\xdd\x0b\x1e\x1f\nE\n\x04\x046\x02\x01\x12\x04\
    \xe1\x0b\x02\x1b\x1a7\x20Node\x20name\x20on\x20which\x20the\x20event\x20\
    is\x20generated.\n\x20+optional\n\n\r\n\x05\x046\x02\x01\x04\x12\x04\xe1\
    \x0b\x02\n\n\r\n\x05\x046\x02\x01\x05\x12\x04\xe1\x0b\x0b\x11\n\r\n\x05\
    \x046\x02\x01\x01\x12\x04\xe1\x0b\x12\x16\n\r\n\x05\x046\x02\x01\x03\x12\
    \x04\xe1\x0b\x19\x1a\nA\n\x02\x047\x12\x06\xe5\x0b\0\xed\x0b\x01\x1a3\
    \x20ExecAction\x20describes\x20a\x20\"run\x20in\x20container\"\x20action\
    .\n\n\x0b\n\x03\x047\x01\x12\x04\xe5\x0b\x08\x12\n\xab\x03\n\x04\x047\
    \x02\0\x12\x04\xec\x0b\x02\x1e\x1a\x9c\x03\x20Command\x20is\x20the\x20co\
    mmand\x20line\x20to\x20execute\x20inside\x20the\x20container,\x20the\x20\
    working\x20directory\x20for\x20the\n\x20command\x20\x20is\x20root\x20('/\
    ')\x20in\x20the\x20container's\x20filesystem.\x20The\x20command\x20is\
    \x20simply\x20exec'd,\x20it\x20is\n\x20not\x20run\x20inside\x20a\x20shel\
    l,\x20so\x20traditional\x20shell\x20instructions\x20('|',\x20etc)\x20won\
    't\x20work.\x20To\x20use\n\x20a\x20shell,\x20you\x20need\x20to\x20explic\
    itly\x20call\x20out\x20to\x20that\x20shell.\n\x20Exit\x20status\x20of\
    \x200\x20is\x20treated\x20as\x20live/healthy\x20and\x20non-zero\x20is\
    \x20unhealthy.\n\x20+optional\n\n\r\n\x05\x047\x02\0\x04\x12\x04\xec\x0b\
    \x02\n\n\r\n\x05\x047\x02\0\x05\x12\x04\xec\x0b\x0b\x11\n\r\n\x05\x047\
    \x02\0\x01\x12\x04\xec\x0b\x12\x19\n\r\n\x05\x047\x02\0\x03\x12\x04\xec\
    \x0b\x1c\x1d\n\xbe\x01\n\x02\x048\x12\x06\xf2\x0b\0\x8b\x0c\x01\x1a\xaf\
    \x01\x20Represents\x20a\x20Fibre\x20Channel\x20volume.\n\x20Fibre\x20Cha\
    nnel\x20volumes\x20can\x20only\x20be\x20mounted\x20as\x20read/write\x20o\
    nce.\n\x20Fibre\x20Channel\x20volumes\x20support\x20ownership\x20managem\
    ent\x20and\x20SELinux\x20relabeling.\n\n\x0b\n\x03\x048\x01\x12\x04\xf2\
    \x0b\x08\x16\nE\n\x04\x048\x02\0\x12\x04\xf5\x0b\x02!\x1a7\x20Optional:\
    \x20FC\x20target\x20worldwide\x20names\x20(WWNs)\n\x20+optional\n\n\r\n\
    \x05\x048\x02\0\x04\x12\x04\xf5\x0b\x02\n\n\r\n\x05\x048\x02\0\x05\x12\
    \x04\xf5\x0b\x0b\x11\n\r\n\x05\x048\x02\0\x01\x12\x04\xf5\x0b\x12\x1c\n\
    \r\n\x05\x048\x02\0\x03\x12\x04\xf5\x0b\x1f\x20\n9\n\x04\x048\x02\x01\
    \x12\x04\xf9\x0b\x02\x19\x1a+\x20Optional:\x20FC\x20target\x20lun\x20num\
    ber\n\x20+optional\n\n\r\n\x05\x048\x02\x01\x04\x12\x04\xf9\x0b\x02\n\n\
    \r\n\x05\x048\x02\x01\x05\x12\x04\xf9\x0b\x0b\x10\n\r\n\x05\x048\x02\x01\
    \x01\x12\x04\xf9\x0b\x11\x14\n\r\n\x05\x048\x02\x01\x03\x12\x04\xf9\x0b\
    \x17\x18\n\x95\x02\n\x04\x048\x02\x02\x12\x04\x80\x0c\x02\x1d\x1a\x86\
    \x02\x20Filesystem\x20type\x20to\x20mount.\n\x20Must\x20be\x20a\x20files\
    ystem\x20type\x20supported\x20by\x20the\x20host\x20operating\x20system.\
    \n\x20Ex.\x20\"ext4\",\x20\"xfs\",\x20\"ntfs\".\x20Implicitly\x20inferre\
    d\x20to\x20be\x20\"ext4\"\x20if\x20unspecified.\n\x20TODO:\x20how\x20do\
    \x20we\x20prevent\x20errors\x20in\x20the\x20filesystem\x20from\x20compro\
    mising\x20the\x20machine\n\x20+optional\n\n\r\n\x05\x048\x02\x02\x04\x12\
    \x04\x80\x0c\x02\n\n\r\n\x05\x048\x02\x02\x05\x12\x04\x80\x0c\x0b\x11\n\
    \r\n\x05\x048\x02\x02\x01\x12\x04\x80\x0c\x12\x18\n\r\n\x05\x048\x02\x02\
    \x03\x12\x04\x80\x0c\x1b\x1c\n\x84\x01\n\x04\x048\x02\x03\x12\x04\x85\
    \x0c\x02\x1d\x1av\x20Optional:\x20Defaults\x20to\x20false\x20(read/write\
    ).\x20ReadOnly\x20here\x20will\x20force\n\x20the\x20ReadOnly\x20setting\
    \x20in\x20VolumeMounts.\n\x20+optional\n\n\r\n\x05\x048\x02\x03\x04\x12\
    \x04\x85\x0c\x02\n\n\r\n\x05\x048\x02\x03\x05\x12\x04\x85\x0c\x0b\x0f\n\
    \r\n\x05\x048\x02\x03\x01\x12\x04\x85\x0c\x10\x18\n\r\n\x05\x048\x02\x03\
    \x03\x12\x04\x85\x0c\x1b\x1c\n\xab\x01\n\x04\x048\x02\x04\x12\x04\x8a\
    \x0c\x02\x1c\x1a\x9c\x01\x20Optional:\x20FC\x20volume\x20world\x20wide\
    \x20identifiers\x20(wwids)\n\x20Either\x20wwids\x20or\x20combination\x20\
    of\x20targetWWNs\x20and\x20lun\x20must\x20be\x20set,\x20but\x20not\x20bo\
    th\x20simultaneously.\n\x20+optional\n\n\r\n\x05\x048\x02\x04\x04\x12\
    \x04\x8a\x0c\x02\n\n\r\n\x05\x048\x02\x04\x05\x12\x04\x8a\x0c\x0b\x11\n\
    \r\n\x05\x048\x02\x04\x01\x12\x04\x8a\x0c\x12\x17\n\r\n\x05\x048\x02\x04\
    \x03\x12\x04\x8a\x0c\x1a\x1b\n\x95\x01\n\x02\x049\x12\x06\x8f\x0c\0\xa9\
    \x0c\x01\x1a\x86\x01\x20FlexPersistentVolumeSource\x20represents\x20a\
    \x20generic\x20persistent\x20volume\x20resource\x20that\x20is\n\x20provi\
    sioned/attached\x20using\x20an\x20exec\x20based\x20plugin.\n\n\x0b\n\x03\
    \x049\x01\x12\x04\x8f\x0c\x08\"\nH\n\x04\x049\x02\0\x12\x04\x91\x0c\x02\
    \x1d\x1a:\x20Driver\x20is\x20the\x20name\x20of\x20the\x20driver\x20to\
    \x20use\x20for\x20this\x20volume.\n\n\r\n\x05\x049\x02\0\x04\x12\x04\x91\
    \x0c\x02\n\n\r\n\x05\x049\x02\0\x05\x12\x04\x91\x0c\x0b\x11\n\r\n\x05\
    \x049\x02\0\x01\x12\x04\x91\x0c\x12\x18\n\r\n\x05\x049\x02\0\x03\x12\x04\
    \x91\x0c\x1b\x1c\n\xc9\x01\n\x04\x049\x02\x01\x12\x04\x97\x0c\x02\x1d\
    \x1a\xba\x01\x20Filesystem\x20type\x20to\x20mount.\n\x20Must\x20be\x20a\
    \x20filesystem\x20type\x20supported\x20by\x20the\x20host\x20operating\
    \x20system.\n\x20Ex.\x20\"ext4\",\x20\"xfs\",\x20\"ntfs\".\x20The\x20def\
    ault\x20filesystem\x20depends\x20on\x20FlexVolume\x20script.\n\x20+optio\
    nal\n\n\r\n\x05\x049\x02\x01\x04\x12\x04\x97\x0c\x02\n\n\r\n\x05\x049\
    \x02\x01\x05\x12\x04\x97\x0c\x0b\x11\n\r\n\x05\x049\x02\x01\x01\x12\x04\
    \x97\x0c\x12\x18\n\r\n\x05\x049\x02\x01\x03\x12\x04\x97\x0c\x1b\x1c\n\
    \xab\x02\n\x04\x049\x02\x02\x12\x04\x9f\x0c\x02)\x1a\x9c\x02\x20Optional\
    :\x20SecretRef\x20is\x20reference\x20to\x20the\x20secret\x20object\x20co\
    ntaining\n\x20sensitive\x20information\x20to\x20pass\x20to\x20the\x20plu\
    gin\x20scripts.\x20This\x20may\x20be\n\x20empty\x20if\x20no\x20secret\
    \x20object\x20is\x20specified.\x20If\x20the\x20secret\x20object\n\x20con\
    tains\x20more\x20than\x20one\x20secret,\x20all\x20secrets\x20are\x20pass\
    ed\x20to\x20the\x20plugin\n\x20scripts.\n\x20+optional\n\n\r\n\x05\x049\
    \x02\x02\x04\x12\x04\x9f\x0c\x02\n\n\r\n\x05\x049\x02\x02\x06\x12\x04\
    \x9f\x0c\x0b\x1a\n\r\n\x05\x049\x02\x02\x01\x12\x04\x9f\x0c\x1b$\n\r\n\
    \x05\x049\x02\x02\x03\x12\x04\x9f\x0c'(\n\x84\x01\n\x04\x049\x02\x03\x12\
    \x04\xa4\x0c\x02\x1d\x1av\x20Optional:\x20Defaults\x20to\x20false\x20(re\
    ad/write).\x20ReadOnly\x20here\x20will\x20force\n\x20the\x20ReadOnly\x20\
    setting\x20in\x20VolumeMounts.\n\x20+optional\n\n\r\n\x05\x049\x02\x03\
    \x04\x12\x04\xa4\x0c\x02\n\n\r\n\x05\x049\x02\x03\x05\x12\x04\xa4\x0c\
    \x0b\x0f\n\r\n\x05\x049\x02\x03\x01\x12\x04\xa4\x0c\x10\x18\n\r\n\x05\
    \x049\x02\x03\x03\x12\x04\xa4\x0c\x1b\x1c\nB\n\x04\x049\x02\x04\x12\x04\
    \xa8\x0c\x02\"\x1a4\x20Optional:\x20Extra\x20command\x20options\x20if\
    \x20any.\n\x20+optional\n\n\x0f\n\x05\x049\x02\x04\x04\x12\x06\xa8\x0c\
    \x02\xa4\x0c\x1d\n\r\n\x05\x049\x02\x04\x06\x12\x04\xa8\x0c\x02\x15\n\r\
    \n\x05\x049\x02\x04\x01\x12\x04\xa8\x0c\x16\x1d\n\r\n\x05\x049\x02\x04\
    \x03\x12\x04\xa8\x0c\x20!\ny\n\x02\x04:\x12\x06\xad\x0c\0\xc7\x0c\x01\
    \x1ak\x20FlexVolume\x20represents\x20a\x20generic\x20volume\x20resource\
    \x20that\x20is\n\x20provisioned/attached\x20using\x20an\x20exec\x20based\
    \x20plugin.\n\n\x0b\n\x03\x04:\x01\x12\x04\xad\x0c\x08\x18\nH\n\x04\x04:\
    \x02\0\x12\x04\xaf\x0c\x02\x1d\x1a:\x20Driver\x20is\x20the\x20name\x20of\
    \x20the\x20driver\x20to\x20use\x20for\x20this\x20volume.\n\n\r\n\x05\x04\
    :\x02\0\x04\x12\x04\xaf\x0c\x02\n\n\r\n\x05\x04:\x02\0\x05\x12\x04\xaf\
    \x0c\x0b\x11\n\r\n\x05\x04:\x02\0\x01\x12\x04\xaf\x0c\x12\x18\n\r\n\x05\
    \x04:\x02\0\x03\x12\x04\xaf\x0c\x1b\x1c\n\xc9\x01\n\x04\x04:\x02\x01\x12\
    \x04\xb5\x0c\x02\x1d\x1a\xba\x01\x20Filesystem\x20type\x20to\x20mount.\n\
    \x20Must\x20be\x20a\x20filesystem\x20type\x20supported\x20by\x20the\x20h\
    ost\x20operating\x20system.\n\x20Ex.\x20\"ext4\",\x20\"xfs\",\x20\"ntfs\
    \".\x20The\x20default\x20filesystem\x20depends\x20on\x20FlexVolume\x20sc\
    ript.\n\x20+optional\n\n\r\n\x05\x04:\x02\x01\x04\x12\x04\xb5\x0c\x02\n\
    \n\r\n\x05\x04:\x02\x01\x05\x12\x04\xb5\x0c\x0b\x11\n\r\n\x05\x04:\x02\
    \x01\x01\x12\x04\xb5\x0c\x12\x18\n\r\n\x05\x04:\x02\x01\x03\x12\x04\xb5\
    \x0c\x1b\x1c\n\xab\x02\n\x04\x04:\x02\x02\x12\x04\xbd\x0c\x02.\x1a\x9c\
    \x02\x20Optional:\x20SecretRef\x20is\x20reference\x20to\x20the\x20secret\
    \x20object\x20containing\n\x20sensitive\x20information\x20to\x20pass\x20\
    to\x20the\x20plugin\x20scripts.\x20This\x20may\x20be\n\x20empty\x20if\
    \x20no\x20secret\x20object\x20is\x20specified.\x20If\x20the\x20secret\
    \x20object\n\x20contains\x20more\x20than\x20one\x20secret,\x20all\x20sec\
    rets\x20are\x20passed\x20to\x20the\x20plugin\n\x20scripts.\n\x20+optiona\
    l\n\n\r\n\x05\x04:\x02\x02\x04\x12\x04\xbd\x0c\x02\n\n\r\n\x05\x04:\x02\
    \x02\x06\x12\x04\xbd\x0c\x0b\x1f\n\r\n\x05\x04:\x02\x02\x01\x12\x04\xbd\
    \x0c\x20)\n\r\n\x05\x04:\x02\x02\x03\x12\x04\xbd\x0c,-\n\x84\x01\n\x04\
    \x04:\x02\x03\x12\x04\xc2\x0c\x02\x1d\x1av\x20Optional:\x20Defaults\x20t\
    o\x20false\x20(read/write).\x20ReadOnly\x20here\x20will\x20force\n\x20th\
    e\x20ReadOnly\x20setting\x20in\x20VolumeMounts.\n\x20+optional\n\n\r\n\
    \x05\x04:\x02\x03\x04\x12\x04\xc2\x0c\x02\n\n\r\n\x05\x04:\x02\x03\x05\
    \x12\x04\xc2\x0c\x0b\x0f\n\r\n\x05\x04:\x02\x03\x01\x12\x04\xc2\x0c\x10\
    \x18\n\r\n\x05\x04:\x02\x03\x03\x12\x04\xc2\x0c\x1b\x1c\nB\n\x04\x04:\
    \x02\x04\x12\x04\xc6\x0c\x02\"\x1a4\x20Optional:\x20Extra\x20command\x20\
    options\x20if\x20any.\n\x20+optional\n\n\x0f\n\x05\x04:\x02\x04\x04\x12\
    \x06\xc6\x0c\x02\xc2\x0c\x1d\n\r\n\x05\x04:\x02\x04\x06\x12\x04\xc6\x0c\
    \x02\x15\n\r\n\x05\x04:\x02\x04\x01\x12\x04\xc6\x0c\x16\x1d\n\r\n\x05\
    \x04:\x02\x04\x03\x12\x04\xc6\x0c\x20!\n\xd6\x01\n\x02\x04;\x12\x06\xcc\
    \x0c\0\xd5\x0c\x01\x1a\xc7\x01\x20Represents\x20a\x20Flocker\x20volume\
    \x20mounted\x20by\x20the\x20Flocker\x20agent.\n\x20One\x20and\x20only\
    \x20one\x20of\x20datasetName\x20and\x20datasetUUID\x20should\x20be\x20se\
    t.\n\x20Flocker\x20volumes\x20do\x20not\x20support\x20ownership\x20manag\
    ement\x20or\x20SELinux\x20relabeling.\n\n\x0b\n\x03\x04;\x01\x12\x04\xcc\
    \x0c\x08\x1b\n\x88\x01\n\x04\x04;\x02\0\x12\x04\xd0\x0c\x02\"\x1az\x20Na\
    me\x20of\x20the\x20dataset\x20stored\x20as\x20metadata\x20->\x20name\x20\
    on\x20the\x20dataset\x20for\x20Flocker\n\x20should\x20be\x20considered\
    \x20as\x20deprecated\n\x20+optional\n\n\r\n\x05\x04;\x02\0\x04\x12\x04\
    \xd0\x0c\x02\n\n\r\n\x05\x04;\x02\0\x05\x12\x04\xd0\x0c\x0b\x11\n\r\n\
    \x05\x04;\x02\0\x01\x12\x04\xd0\x0c\x12\x1d\n\r\n\x05\x04;\x02\0\x03\x12\
    \x04\xd0\x0c\x20!\n^\n\x04\x04;\x02\x01\x12\x04\xd4\x0c\x02\"\x1aP\x20UU\
    ID\x20of\x20the\x20dataset.\x20This\x20is\x20unique\x20identifier\x20of\
    \x20a\x20Flocker\x20dataset\n\x20+optional\n\n\r\n\x05\x04;\x02\x01\x04\
    \x12\x04\xd4\x0c\x02\n\n\r\n\x05\x04;\x02\x01\x05\x12\x04\xd4\x0c\x0b\
    \x11\n\r\n\x05\x04;\x02\x01\x01\x12\x04\xd4\x0c\x12\x1d\n\r\n\x05\x04;\
    \x02\x01\x03\x12\x04\xd4\x0c\x20!\n\xd6\x02\n\x02\x04<\x12\x06\xdd\x0c\0\
    \xf7\x0c\x01\x1a\xc7\x02\x20Represents\x20a\x20Persistent\x20Disk\x20res\
    ource\x20in\x20Google\x20Compute\x20Engine.\n\n\x20A\x20GCE\x20PD\x20mus\
    t\x20exist\x20before\x20mounting\x20to\x20a\x20container.\x20The\x20disk\
    \x20must\n\x20also\x20be\x20in\x20the\x20same\x20GCE\x20project\x20and\
    \x20zone\x20as\x20the\x20kubelet.\x20A\x20GCE\x20PD\n\x20can\x20only\x20\
    be\x20mounted\x20as\x20read/write\x20once\x20or\x20read-only\x20many\x20\
    times.\x20GCE\n\x20PDs\x20support\x20ownership\x20management\x20and\x20S\
    ELinux\x20relabeling.\n\n\x0b\n\x03\x04<\x01\x12\x04\xdd\x0c\x08%\n\xab\
    \x01\n\x04\x04<\x02\0\x12\x04\xe0\x0c\x02\x1d\x1a\x9c\x01\x20Unique\x20n\
    ame\x20of\x20the\x20PD\x20resource\x20in\x20GCE.\x20Used\x20to\x20identi\
    fy\x20the\x20disk\x20in\x20GCE.\n\x20More\x20info:\x20https://kubernetes\
    .io/docs/concepts/storage/volumes#gcepersistentdisk\n\n\r\n\x05\x04<\x02\
    \0\x04\x12\x04\xe0\x0c\x02\n\n\r\n\x05\x04<\x02\0\x05\x12\x04\xe0\x0c\
    \x0b\x11\n\r\n\x05\x04<\x02\0\x01\x12\x04\xe0\x0c\x12\x18\n\r\n\x05\x04<\
    \x02\0\x03\x12\x04\xe0\x0c\x1b\x1c\n\x97\x03\n\x04\x04<\x02\x01\x12\x04\
    \xe8\x0c\x02\x1d\x1a\x88\x03\x20Filesystem\x20type\x20of\x20the\x20volum\
    e\x20that\x20you\x20want\x20to\x20mount.\n\x20Tip:\x20Ensure\x20that\x20\
    the\x20filesystem\x20type\x20is\x20supported\x20by\x20the\x20host\x20ope\
    rating\x20system.\n\x20Examples:\x20\"ext4\",\x20\"xfs\",\x20\"ntfs\".\
    \x20Implicitly\x20inferred\x20to\x20be\x20\"ext4\"\x20if\x20unspecified.\
    \n\x20More\x20info:\x20https://kubernetes.io/docs/concepts/storage/volum\
    es#gcepersistentdisk\n\x20TODO:\x20how\x20do\x20we\x20prevent\x20errors\
    \x20in\x20the\x20filesystem\x20from\x20compromising\x20the\x20machine\n\
    \x20+optional\n\n\r\n\x05\x04<\x02\x01\x04\x12\x04\xe8\x0c\x02\n\n\r\n\
    \x05\x04<\x02\x01\x05\x12\x04\xe8\x0c\x0b\x11\n\r\n\x05\x04<\x02\x01\x01\
    \x12\x04\xe8\x0c\x12\x18\n\r\n\x05\x04<\x02\x01\x03\x12\x04\xe8\x0c\x1b\
    \x1c\n\xf5\x02\n\x04\x04<\x02\x02\x12\x04\xf0\x0c\x02\x1f\x1a\xe6\x02\
    \x20The\x20partition\x20in\x20the\x20volume\x20that\x20you\x20want\x20to\
    \x20mount.\n\x20If\x20omitted,\x20the\x20default\x20is\x20to\x20mount\
    \x20by\x20volume\x20name.\n\x20Examples:\x20For\x20volume\x20/dev/sda1,\
    \x20you\x20specify\x20the\x20partition\x20as\x20\"1\".\n\x20Similarly,\
    \x20the\x20volume\x20partition\x20for\x20/dev/sda\x20is\x20\"0\"\x20(or\
    \x20you\x20can\x20leave\x20the\x20property\x20empty).\n\x20More\x20info:\
    \x20https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdis\
    k\n\x20+optional\n\n\r\n\x05\x04<\x02\x02\x04\x12\x04\xf0\x0c\x02\n\n\r\
    \n\x05\x04<\x02\x02\x05\x12\x04\xf0\x0c\x0b\x10\n\r\n\x05\x04<\x02\x02\
    \x01\x12\x04\xf0\x0c\x11\x1a\n\r\n\x05\x04<\x02\x02\x03\x12\x04\xf0\x0c\
    \x1d\x1e\n\xc0\x01\n\x04\x04<\x02\x03\x12\x04\xf6\x0c\x02\x1d\x1a\xb1\
    \x01\x20ReadOnly\x20here\x20will\x20force\x20the\x20ReadOnly\x20setting\
    \x20in\x20VolumeMounts.\n\x20Defaults\x20to\x20false.\n\x20More\x20info:\
    \x20https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdis\
    k\n\x20+optional\n\n\r\n\x05\x04<\x02\x03\x04\x12\x04\xf6\x0c\x02\n\n\r\
    \n\x05\x04<\x02\x03\x05\x12\x04\xf6\x0c\x0b\x0f\n\r\n\x05\x04<\x02\x03\
    \x01\x12\x04\xf6\x0c\x10\x18\n\r\n\x05\x04<\x02\x03\x03\x12\x04\xf6\x0c\
    \x1b\x1c\n\x8d\x03\n\x02\x04=\x12\x06\x80\r\0\x8e\r\x01\x1a\xfe\x02\x20R\
    epresents\x20a\x20volume\x20that\x20is\x20populated\x20with\x20the\x20co\
    ntents\x20of\x20a\x20git\x20repository.\n\x20Git\x20repo\x20volumes\x20d\
    o\x20not\x20support\x20ownership\x20management.\n\x20Git\x20repo\x20volu\
    mes\x20support\x20SELinux\x20relabeling.\n\n\x20DEPRECATED:\x20GitRepo\
    \x20is\x20deprecated.\x20To\x20provision\x20a\x20container\x20with\x20a\
    \x20git\x20repo,\x20mount\x20an\n\x20EmptyDir\x20into\x20an\x20InitConta\
    iner\x20that\x20clones\x20the\x20repo\x20using\x20git,\x20then\x20mount\
    \x20the\x20EmptyDir\n\x20into\x20the\x20Pod's\x20container.\n\n\x0b\n\
    \x03\x04=\x01\x12\x04\x80\r\x08\x1b\n\x1e\n\x04\x04=\x02\0\x12\x04\x82\r\
    \x02!\x1a\x10\x20Repository\x20URL\n\n\r\n\x05\x04=\x02\0\x04\x12\x04\
    \x82\r\x02\n\n\r\n\x05\x04=\x02\0\x05\x12\x04\x82\r\x0b\x11\n\r\n\x05\
    \x04=\x02\0\x01\x12\x04\x82\r\x12\x1c\n\r\n\x05\x04=\x02\0\x03\x12\x04\
    \x82\r\x1f\x20\nB\n\x04\x04=\x02\x01\x12\x04\x86\r\x02\x1f\x1a4\x20Commi\
    t\x20hash\x20for\x20the\x20specified\x20revision.\n\x20+optional\n\n\r\n\
    \x05\x04=\x02\x01\x04\x12\x04\x86\r\x02\n\n\r\n\x05\x04=\x02\x01\x05\x12\
    \x04\x86\r\x0b\x11\n\r\n\x05\x04=\x02\x01\x01\x12\x04\x86\r\x12\x1a\n\r\
    \n\x05\x04=\x02\x01\x03\x12\x04\x86\r\x1d\x1e\n\x8e\x02\n\x04\x04=\x02\
    \x02\x12\x04\x8d\r\x02\x20\x1a\xff\x01\x20Target\x20directory\x20name.\n\
    \x20Must\x20not\x20contain\x20or\x20start\x20with\x20'..'.\x20\x20If\x20\
    '.'\x20is\x20supplied,\x20the\x20volume\x20directory\x20will\x20be\x20th\
    e\n\x20git\x20repository.\x20\x20Otherwise,\x20if\x20specified,\x20the\
    \x20volume\x20will\x20contain\x20the\x20git\x20repository\x20in\n\x20the\
    \x20subdirectory\x20with\x20the\x20given\x20name.\n\x20+optional\n\n\r\n\
    \x05\x04=\x02\x02\x04\x12\x04\x8d\r\x02\n\n\r\n\x05\x04=\x02\x02\x05\x12\
    \x04\x8d\r\x0b\x11\n\r\n\x05\x04=\x02\x02\x01\x12\x04\x8d\r\x12\x1b\n\r\
    \n\x05\x04=\x02\x02\x03\x12\x04\x8d\r\x1e\x1f\n\x9d\x01\n\x02\x04>\x12\
    \x06\x92\r\0\xa6\r\x01\x1a\x8e\x01\x20Represents\x20a\x20Glusterfs\x20mo\
    unt\x20that\x20lasts\x20the\x20lifetime\x20of\x20a\x20pod.\n\x20Glusterf\
    s\x20volumes\x20do\x20not\x20support\x20ownership\x20management\x20or\
    \x20SELinux\x20relabeling.\n\n\x0b\n\x03\x04>\x01\x12\x04\x92\r\x08'\n\
    \xa1\x01\n\x04\x04>\x02\0\x12\x04\x95\r\x02\x20\x1a\x92\x01\x20Endpoints\
    Name\x20is\x20the\x20endpoint\x20name\x20that\x20details\x20Glusterfs\
    \x20topology.\n\x20More\x20info:\x20https://examples.k8s.io/volumes/glus\
    terfs/README.md#create-a-pod\n\n\r\n\x05\x04>\x02\0\x04\x12\x04\x95\r\
    \x02\n\n\r\n\x05\x04>\x02\0\x05\x12\x04\x95\r\x0b\x11\n\r\n\x05\x04>\x02\
    \0\x01\x12\x04\x95\r\x12\x1b\n\r\n\x05\x04>\x02\0\x03\x12\x04\x95\r\x1e\
    \x1f\n\x7f\n\x04\x04>\x02\x01\x12\x04\x99\r\x02\x1b\x1aq\x20Path\x20is\
    \x20the\x20Glusterfs\x20volume\x20path.\n\x20More\x20info:\x20https://ex\
    amples.k8s.io/volumes/glusterfs/README.md#create-a-pod\n\n\r\n\x05\x04>\
    \x02\x01\x04\x12\x04\x99\r\x02\n\n\r\n\x05\x04>\x02\x01\x05\x12\x04\x99\
    \r\x0b\x11\n\r\n\x05\x04>\x02\x01\x01\x12\x04\x99\r\x12\x16\n\r\n\x05\
    \x04>\x02\x01\x03\x12\x04\x99\r\x19\x1a\n\xd4\x01\n\x04\x04>\x02\x02\x12\
    \x04\x9f\r\x02\x1d\x1a\xc5\x01\x20ReadOnly\x20here\x20will\x20force\x20t\
    he\x20Glusterfs\x20volume\x20to\x20be\x20mounted\x20with\x20read-only\
    \x20permissions.\n\x20Defaults\x20to\x20false.\n\x20More\x20info:\x20htt\
    ps://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod\n\x20+opti\
    onal\n\n\r\n\x05\x04>\x02\x02\x04\x12\x04\x9f\r\x02\n\n\r\n\x05\x04>\x02\
    \x02\x05\x12\x04\x9f\r\x0b\x0f\n\r\n\x05\x04>\x02\x02\x01\x12\x04\x9f\r\
    \x10\x18\n\r\n\x05\x04>\x02\x02\x03\x12\x04\x9f\r\x1b\x1c\n\x8e\x02\n\
    \x04\x04>\x02\x03\x12\x04\xa5\r\x02)\x1a\xff\x01\x20EndpointsNamespace\
    \x20is\x20the\x20namespace\x20that\x20contains\x20Glusterfs\x20endpoint.\
    \n\x20If\x20this\x20field\x20is\x20empty,\x20the\x20EndpointNamespace\
    \x20defaults\x20to\x20the\x20same\x20namespace\x20as\x20the\x20bound\x20\
    PVC.\n\x20More\x20info:\x20https://examples.k8s.io/volumes/glusterfs/REA\
    DME.md#create-a-pod\n\x20+optional\n\n\r\n\x05\x04>\x02\x03\x04\x12\x04\
    \xa5\r\x02\n\n\r\n\x05\x04>\x02\x03\x05\x12\x04\xa5\r\x0b\x11\n\r\n\x05\
    \x04>\x02\x03\x01\x12\x04\xa5\r\x12$\n\r\n\x05\x04>\x02\x03\x03\x12\x04\
    \xa5\r'(\n\x9d\x01\n\x02\x04?\x12\x06\xaa\r\0\xb8\r\x01\x1a\x8e\x01\x20R\
    epresents\x20a\x20Glusterfs\x20mount\x20that\x20lasts\x20the\x20lifetime\
    \x20of\x20a\x20pod.\n\x20Glusterfs\x20volumes\x20do\x20not\x20support\
    \x20ownership\x20management\x20or\x20SELinux\x20relabeling.\n\n\x0b\n\
    \x03\x04?\x01\x12\x04\xaa\r\x08\x1d\n\xa1\x01\n\x04\x04?\x02\0\x12\x04\
    \xad\r\x02\x20\x1a\x92\x01\x20EndpointsName\x20is\x20the\x20endpoint\x20\
    name\x20that\x20details\x20Glusterfs\x20topology.\n\x20More\x20info:\x20\
    https://examples.k8s.io/volumes/glusterfs/README.md#create-a-pod\n\n\r\n\
    \x05\x04?\x02\0\x04\x12\x04\xad\r\x02\n\n\r\n\x05\x04?\x02\0\x05\x12\x04\
    \xad\r\x0b\x11\n\r\n\x05\x04?\x02\0\x01\x12\x04\xad\r\x12\x1b\n\r\n\x05\
    \x04?\x02\0\x03\x12\x04\xad\r\x1e\x1f\n\x7f\n\x04\x04?\x02\x01\x12\x04\
    \xb1\r\x02\x1b\x1aq\x20Path\x20is\x20the\x20Glusterfs\x20volume\x20path.\
    \n\x20More\x20info:\x20https://examples.k8s.io/volumes/glusterfs/README.\
    md#create-a-pod\n\n\r\n\x05\x04?\x02\x01\x04\x12\x04\xb1\r\x02\n\n\r\n\
    \x05\x04?\x02\x01\x05\x12\x04\xb1\r\x0b\x11\n\r\n\x05\x04?\x02\x01\x01\
    \x12\x04\xb1\r\x12\x16\n\r\n\x05\x04?\x02\x01\x03\x12\x04\xb1\r\x19\x1a\
    \n\xd4\x01\n\x04\x04?\x02\x02\x12\x04\xb7\r\x02\x1d\x1a\xc5\x01\x20ReadO\
    nly\x20here\x20will\x20force\x20the\x20Glusterfs\x20volume\x20to\x20be\
    \x20mounted\x20with\x20read-only\x20permissions.\n\x20Defaults\x20to\x20\
    false.\n\x20More\x20info:\x20https://examples.k8s.io/volumes/glusterfs/R\
    EADME.md#create-a-pod\n\x20+optional\n\n\r\n\x05\x04?\x02\x02\x04\x12\
    \x04\xb7\r\x02\n\n\r\n\x05\x04?\x02\x02\x05\x12\x04\xb7\r\x0b\x0f\n\r\n\
    \x05\x04?\x02\x02\x01\x12\x04\xb7\r\x10\x18\n\r\n\x05\x04?\x02\x02\x03\
    \x12\x04\xb7\r\x1b\x1c\nM\n\x02\x04@\x12\x06\xbb\r\0\xd2\r\x01\x1a?\x20H\
    TTPGetAction\x20describes\x20an\x20action\x20based\x20on\x20HTTP\x20Get\
    \x20requests.\n\n\x0b\n\x03\x04@\x01\x12\x04\xbb\r\x08\x15\n=\n\x04\x04@\
    \x02\0\x12\x04\xbe\r\x02\x1b\x1a/\x20Path\x20to\x20access\x20on\x20the\
    \x20HTTP\x20server.\n\x20+optional\n\n\r\n\x05\x04@\x02\0\x04\x12\x04\
    \xbe\r\x02\n\n\r\n\x05\x04@\x02\0\x05\x12\x04\xbe\r\x0b\x11\n\r\n\x05\
    \x04@\x02\0\x01\x12\x04\xbe\r\x12\x16\n\r\n\x05\x04@\x02\0\x03\x12\x04\
    \xbe\r\x19\x1a\n\x90\x01\n\x04\x04@\x02\x01\x12\x04\xc3\r\x02D\x1a\x81\
    \x01\x20Name\x20or\x20number\x20of\x20the\x20port\x20to\x20access\x20on\
    \x20the\x20container.\n\x20Number\x20must\x20be\x20in\x20the\x20range\
    \x201\x20to\x2065535.\n\x20Name\x20must\x20be\x20an\x20IANA_SVC_NAME.\n\
    \n\r\n\x05\x04@\x02\x01\x04\x12\x04\xc3\r\x02\n\n\r\n\x05\x04@\x02\x01\
    \x06\x12\x04\xc3\r\x0b:\n\r\n\x05\x04@\x02\x01\x01\x12\x04\xc3\r;?\n\r\n\
    \x05\x04@\x02\x01\x03\x12\x04\xc3\rBC\n\x84\x01\n\x04\x04@\x02\x02\x12\
    \x04\xc8\r\x02\x1b\x1av\x20Host\x20name\x20to\x20connect\x20to,\x20defau\
    lts\x20to\x20the\x20pod\x20IP.\x20You\x20probably\x20want\x20to\x20set\n\
    \x20\"Host\"\x20in\x20httpHeaders\x20instead.\n\x20+optional\n\n\r\n\x05\
    \x04@\x02\x02\x04\x12\x04\xc8\r\x02\n\n\r\n\x05\x04@\x02\x02\x05\x12\x04\
    \xc8\r\x0b\x11\n\r\n\x05\x04@\x02\x02\x01\x12\x04\xc8\r\x12\x16\n\r\n\
    \x05\x04@\x02\x02\x03\x12\x04\xc8\r\x19\x1a\nW\n\x04\x04@\x02\x03\x12\
    \x04\xcd\r\x02\x1d\x1aI\x20Scheme\x20to\x20use\x20for\x20connecting\x20t\
    o\x20the\x20host.\n\x20Defaults\x20to\x20HTTP.\n\x20+optional\n\n\r\n\
    \x05\x04@\x02\x03\x04\x12\x04\xcd\r\x02\n\n\r\n\x05\x04@\x02\x03\x05\x12\
    \x04\xcd\r\x0b\x11\n\r\n\x05\x04@\x02\x03\x01\x12\x04\xcd\r\x12\x18\n\r\
    \n\x05\x04@\x02\x03\x03\x12\x04\xcd\r\x1b\x1c\n^\n\x04\x04@\x02\x04\x12\
    \x04\xd1\r\x02&\x1aP\x20Custom\x20headers\x20to\x20set\x20in\x20the\x20r\
    equest.\x20HTTP\x20allows\x20repeated\x20headers.\n\x20+optional\n\n\r\n\
    \x05\x04@\x02\x04\x04\x12\x04\xd1\r\x02\n\n\r\n\x05\x04@\x02\x04\x06\x12\
    \x04\xd1\r\x0b\x15\n\r\n\x05\x04@\x02\x04\x01\x12\x04\xd1\r\x16!\n\r\n\
    \x05\x04@\x02\x04\x03\x12\x04\xd1\r$%\nN\n\x02\x04A\x12\x06\xd5\r\0\xdb\
    \r\x01\x1a@\x20HTTPHeader\x20describes\x20a\x20custom\x20header\x20to\
    \x20be\x20used\x20in\x20HTTP\x20probes\n\n\x0b\n\x03\x04A\x01\x12\x04\
    \xd5\r\x08\x12\n%\n\x04\x04A\x02\0\x12\x04\xd7\r\x02\x1b\x1a\x17\x20The\
    \x20header\x20field\x20name\n\n\r\n\x05\x04A\x02\0\x04\x12\x04\xd7\r\x02\
    \n\n\r\n\x05\x04A\x02\0\x05\x12\x04\xd7\r\x0b\x11\n\r\n\x05\x04A\x02\0\
    \x01\x12\x04\xd7\r\x12\x16\n\r\n\x05\x04A\x02\0\x03\x12\x04\xd7\r\x19\
    \x1a\n&\n\x04\x04A\x02\x01\x12\x04\xda\r\x02\x1c\x1a\x18\x20The\x20heade\
    r\x20field\x20value\n\n\r\n\x05\x04A\x02\x01\x04\x12\x04\xda\r\x02\n\n\r\
    \n\x05\x04A\x02\x01\x05\x12\x04\xda\r\x0b\x11\n\r\n\x05\x04A\x02\x01\x01\
    \x12\x04\xda\r\x12\x17\n\r\n\x05\x04A\x02\x01\x03\x12\x04\xda\r\x1a\x1b\
    \n\x92\x01\n\x02\x04B\x12\x06\xdf\r\0\xee\r\x01\x1a\x83\x01\x20Handler\
    \x20defines\x20a\x20specific\x20action\x20that\x20should\x20be\x20taken\
    \n\x20TODO:\x20pass\x20structured\x20data\x20to\x20these\x20actions,\x20\
    and\x20document\x20that\x20data\x20here.\n\n\x0b\n\x03\x04B\x01\x12\x04\
    \xdf\r\x08\x0f\nu\n\x04\x04B\x02\0\x12\x04\xe3\r\x02\x1f\x1ag\x20One\x20\
    and\x20only\x20one\x20of\x20the\x20following\x20should\x20be\x20specifie\
    d.\n\x20Exec\x20specifies\x20the\x20action\x20to\x20take.\n\x20+optional\
    \n\n\r\n\x05\x04B\x02\0\x04\x12\x04\xe3\r\x02\n\n\r\n\x05\x04B\x02\0\x06\
    \x12\x04\xe3\r\x0b\x15\n\r\n\x05\x04B\x02\0\x01\x12\x04\xe3\r\x16\x1a\n\
    \r\n\x05\x04B\x02\0\x03\x12\x04\xe3\r\x1d\x1e\nI\n\x04\x04B\x02\x01\x12\
    \x04\xe7\r\x02%\x1a;\x20HTTPGet\x20specifies\x20the\x20http\x20request\
    \x20to\x20perform.\n\x20+optional\n\n\r\n\x05\x04B\x02\x01\x04\x12\x04\
    \xe7\r\x02\n\n\r\n\x05\x04B\x02\x01\x06\x12\x04\xe7\r\x0b\x18\n\r\n\x05\
    \x04B\x02\x01\x01\x12\x04\xe7\r\x19\x20\n\r\n\x05\x04B\x02\x01\x03\x12\
    \x04\xe7\r#$\n\x9c\x01\n\x04\x04B\x02\x02\x12\x04\xed\r\x02)\x1a\x8d\x01\
    \x20TCPSocket\x20specifies\x20an\x20action\x20involving\x20a\x20TCP\x20p\
    ort.\n\x20TCP\x20hooks\x20not\x20yet\x20supported\n\x20TODO:\x20implemen\
    t\x20a\x20realistic\x20TCP\x20lifecycle\x20hook\n\x20+optional\n\n\r\n\
    \x05\x04B\x02\x02\x04\x12\x04\xed\r\x02\n\n\r\n\x05\x04B\x02\x02\x06\x12\
    \x04\xed\r\x0b\x1a\n\r\n\x05\x04B\x02\x02\x01\x12\x04\xed\r\x1b$\n\r\n\
    \x05\x04B\x02\x02\x03\x12\x04\xed\r'(\n\x80\x01\n\x02\x04C\x12\x06\xf2\r\
    \0\xf8\r\x01\x1ar\x20HostAlias\x20holds\x20the\x20mapping\x20between\x20\
    IP\x20and\x20hostnames\x20that\x20will\x20be\x20injected\x20as\x20an\x20\
    entry\x20in\x20the\n\x20pod's\x20hosts\x20file.\n\n\x0b\n\x03\x04C\x01\
    \x12\x04\xf2\r\x08\x11\n2\n\x04\x04C\x02\0\x12\x04\xf4\r\x02\x19\x1a$\
    \x20IP\x20address\x20of\x20the\x20host\x20file\x20entry.\n\n\r\n\x05\x04\
    C\x02\0\x04\x12\x04\xf4\r\x02\n\n\r\n\x05\x04C\x02\0\x05\x12\x04\xf4\r\
    \x0b\x11\n\r\n\x05\x04C\x02\0\x01\x12\x04\xf4\r\x12\x14\n\r\n\x05\x04C\
    \x02\0\x03\x12\x04\xf4\r\x17\x18\n3\n\x04\x04C\x02\x01\x12\x04\xf7\r\x02\
    \x20\x1a%\x20Hostnames\x20for\x20the\x20above\x20IP\x20address.\n\n\r\n\
    \x05\x04C\x02\x01\x04\x12\x04\xf7\r\x02\n\n\r\n\x05\x04C\x02\x01\x05\x12\
    \x04\xf7\r\x0b\x11\n\r\n\x05\x04C\x02\x01\x01\x12\x04\xf7\r\x12\x1b\n\r\
    \n\x05\x04C\x02\x01\x03\x12\x04\xf7\r\x1e\x1f\n\x87\x01\n\x02\x04D\x12\
    \x06\xfc\r\0\x87\x0e\x01\x1ay\x20Represents\x20a\x20host\x20path\x20mapp\
    ed\x20into\x20a\x20pod.\n\x20Host\x20path\x20volumes\x20do\x20not\x20sup\
    port\x20ownership\x20management\x20or\x20SELinux\x20relabeling.\n\n\x0b\
    \n\x03\x04D\x01\x12\x04\xfc\r\x08\x1c\n\xc1\x01\n\x04\x04D\x02\0\x12\x04\
    \x80\x0e\x02\x1b\x1a\xb2\x01\x20Path\x20of\x20the\x20directory\x20on\x20\
    the\x20host.\n\x20If\x20the\x20path\x20is\x20a\x20symlink,\x20it\x20will\
    \x20follow\x20the\x20link\x20to\x20the\x20real\x20path.\n\x20More\x20inf\
    o:\x20https://kubernetes.io/docs/concepts/storage/volumes#hostpath\n\n\r\
    \n\x05\x04D\x02\0\x04\x12\x04\x80\x0e\x02\n\n\r\n\x05\x04D\x02\0\x05\x12\
    \x04\x80\x0e\x0b\x11\n\r\n\x05\x04D\x02\0\x01\x12\x04\x80\x0e\x12\x16\n\
    \r\n\x05\x04D\x02\0\x03\x12\x04\x80\x0e\x19\x1a\n\x8c\x01\n\x04\x04D\x02\
    \x01\x12\x04\x86\x0e\x02\x1b\x1a~\x20Type\x20for\x20HostPath\x20Volume\n\
    \x20Defaults\x20to\x20\"\"\n\x20More\x20info:\x20https://kubernetes.io/d\
    ocs/concepts/storage/volumes#hostpath\n\x20+optional\n\n\r\n\x05\x04D\
    \x02\x01\x04\x12\x04\x86\x0e\x02\n\n\r\n\x05\x04D\x02\x01\x05\x12\x04\
    \x86\x0e\x0b\x11\n\r\n\x05\x04D\x02\x01\x01\x12\x04\x86\x0e\x12\x16\n\r\
    \n\x05\x04D\x02\x01\x03\x12\x04\x86\x0e\x19\x1a\n\xc1\x01\n\x02\x04E\x12\
    \x06\x8c\x0e\0\xbf\x0e\x01\x1a\xb2\x01\x20ISCSIPersistentVolumeSource\
    \x20represents\x20an\x20ISCSI\x20disk.\n\x20ISCSI\x20volumes\x20can\x20o\
    nly\x20be\x20mounted\x20as\x20read/write\x20once.\n\x20ISCSI\x20volumes\
    \x20support\x20ownership\x20management\x20and\x20SELinux\x20relabeling.\
    \n\n\x0b\n\x03\x04E\x01\x12\x04\x8c\x0e\x08#\n\x97\x01\n\x04\x04E\x02\0\
    \x12\x04\x8f\x0e\x02#\x1a\x88\x01\x20iSCSI\x20Target\x20Portal.\x20The\
    \x20Portal\x20is\x20either\x20an\x20IP\x20or\x20ip_addr:port\x20if\x20th\
    e\x20port\n\x20is\x20other\x20than\x20default\x20(typically\x20TCP\x20po\
    rts\x20860\x20and\x203260).\n\n\r\n\x05\x04E\x02\0\x04\x12\x04\x8f\x0e\
    \x02\n\n\r\n\x05\x04E\x02\0\x05\x12\x04\x8f\x0e\x0b\x11\n\r\n\x05\x04E\
    \x02\0\x01\x12\x04\x8f\x0e\x12\x1e\n\r\n\x05\x04E\x02\0\x03\x12\x04\x8f\
    \x0e!\"\n,\n\x04\x04E\x02\x01\x12\x04\x92\x0e\x02\x1a\x1a\x1e\x20Target\
    \x20iSCSI\x20Qualified\x20Name.\n\n\r\n\x05\x04E\x02\x01\x04\x12\x04\x92\
    \x0e\x02\n\n\r\n\x05\x04E\x02\x01\x05\x12\x04\x92\x0e\x0b\x11\n\r\n\x05\
    \x04E\x02\x01\x01\x12\x04\x92\x0e\x12\x15\n\r\n\x05\x04E\x02\x01\x03\x12\
    \x04\x92\x0e\x18\x19\n(\n\x04\x04E\x02\x02\x12\x04\x95\x0e\x02\x19\x1a\
    \x1a\x20iSCSI\x20Target\x20Lun\x20number.\n\n\r\n\x05\x04E\x02\x02\x04\
    \x12\x04\x95\x0e\x02\n\n\r\n\x05\x04E\x02\x02\x05\x12\x04\x95\x0e\x0b\
    \x10\n\r\n\x05\x04E\x02\x02\x01\x12\x04\x95\x0e\x11\x14\n\r\n\x05\x04E\
    \x02\x02\x03\x12\x04\x95\x0e\x17\x18\nk\n\x04\x04E\x02\x03\x12\x04\x9a\
    \x0e\x02%\x1a]\x20iSCSI\x20Interface\x20Name\x20that\x20uses\x20an\x20iS\
    CSI\x20transport.\n\x20Defaults\x20to\x20'default'\x20(tcp).\n\x20+optio\
    nal\n\n\r\n\x05\x04E\x02\x03\x04\x12\x04\x9a\x0e\x02\n\n\r\n\x05\x04E\
    \x02\x03\x05\x12\x04\x9a\x0e\x0b\x11\n\r\n\x05\x04E\x02\x03\x01\x12\x04\
    \x9a\x0e\x12\x20\n\r\n\x05\x04E\x02\x03\x03\x12\x04\x9a\x0e#$\n\x8b\x03\
    \n\x04\x04E\x02\x04\x12\x04\xa2\x0e\x02\x1d\x1a\xfc\x02\x20Filesystem\
    \x20type\x20of\x20the\x20volume\x20that\x20you\x20want\x20to\x20mount.\n\
    \x20Tip:\x20Ensure\x20that\x20the\x20filesystem\x20type\x20is\x20support\
    ed\x20by\x20the\x20host\x20operating\x20system.\n\x20Examples:\x20\"ext4\
    \",\x20\"xfs\",\x20\"ntfs\".\x20Implicitly\x20inferred\x20to\x20be\x20\"\
    ext4\"\x20if\x20unspecified.\n\x20More\x20info:\x20https://kubernetes.io\
    /docs/concepts/storage/volumes#iscsi\n\x20TODO:\x20how\x20do\x20we\x20pr\
    event\x20errors\x20in\x20the\x20filesystem\x20from\x20compromising\x20th\
    e\x20machine\n\x20+optional\n\n\r\n\x05\x04E\x02\x04\x04\x12\x04\xa2\x0e\
    \x02\n\n\r\n\x05\x04E\x02\x04\x05\x12\x04\xa2\x0e\x0b\x11\n\r\n\x05\x04E\
    \x02\x04\x01\x12\x04\xa2\x0e\x12\x18\n\r\n\x05\x04E\x02\x04\x03\x12\x04\
    \xa2\x0e\x1b\x1c\nm\n\x04\x04E\x02\x05\x12\x04\xa7\x0e\x02\x1d\x1a_\x20R\
    eadOnly\x20here\x20will\x20force\x20the\x20ReadOnly\x20setting\x20in\x20\
    VolumeMounts.\n\x20Defaults\x20to\x20false.\n\x20+optional\n\n\r\n\x05\
    \x04E\x02\x05\x04\x12\x04\xa7\x0e\x02\n\n\r\n\x05\x04E\x02\x05\x05\x12\
    \x04\xa7\x0e\x0b\x0f\n\r\n\x05\x04E\x02\x05\x01\x12\x04\xa7\x0e\x10\x18\
    \n\r\n\x05\x04E\x02\x05\x03\x12\x04\xa7\x0e\x1b\x1c\n\xa7\x01\n\x04\x04E\
    \x02\x06\x12\x04\xac\x0e\x02\x1e\x1a\x98\x01\x20iSCSI\x20Target\x20Porta\
    l\x20List.\x20The\x20Portal\x20is\x20either\x20an\x20IP\x20or\x20ip_addr\
    :port\x20if\x20the\x20port\n\x20is\x20other\x20than\x20default\x20(typic\
    ally\x20TCP\x20ports\x20860\x20and\x203260).\n\x20+optional\n\n\r\n\x05\
    \x04E\x02\x06\x04\x12\x04\xac\x0e\x02\n\n\r\n\x05\x04E\x02\x06\x05\x12\
    \x04\xac\x0e\x0b\x11\n\r\n\x05\x04E\x02\x06\x01\x12\x04\xac\x0e\x12\x19\
    \n\r\n\x05\x04E\x02\x06\x03\x12\x04\xac\x0e\x1c\x1d\nN\n\x04\x04E\x02\
    \x07\x12\x04\xb0\x0e\x02&\x1a@\x20whether\x20support\x20iSCSI\x20Discove\
    ry\x20CHAP\x20authentication\n\x20+optional\n\n\r\n\x05\x04E\x02\x07\x04\
    \x12\x04\xb0\x0e\x02\n\n\r\n\x05\x04E\x02\x07\x05\x12\x04\xb0\x0e\x0b\
    \x0f\n\r\n\x05\x04E\x02\x07\x01\x12\x04\xb0\x0e\x10!\n\r\n\x05\x04E\x02\
    \x07\x03\x12\x04\xb0\x0e$%\nL\n\x04\x04E\x02\x08\x12\x04\xb4\x0e\x02%\
    \x1a>\x20whether\x20support\x20iSCSI\x20Session\x20CHAP\x20authenticatio\
    n\n\x20+optional\n\n\r\n\x05\x04E\x02\x08\x04\x12\x04\xb4\x0e\x02\n\n\r\
    \n\x05\x04E\x02\x08\x05\x12\x04\xb4\x0e\x0b\x0f\n\r\n\x05\x04E\x02\x08\
    \x01\x12\x04\xb4\x0e\x10\x1f\n\r\n\x05\x04E\x02\x08\x03\x12\x04\xb4\x0e\
    \"$\nT\n\x04\x04E\x02\t\x12\x04\xb8\x0e\x02*\x1aF\x20CHAP\x20Secret\x20f\
    or\x20iSCSI\x20target\x20and\x20initiator\x20authentication\n\x20+option\
    al\n\n\r\n\x05\x04E\x02\t\x04\x12\x04\xb8\x0e\x02\n\n\r\n\x05\x04E\x02\t\
    \x06\x12\x04\xb8\x0e\x0b\x1a\n\r\n\x05\x04E\x02\t\x01\x12\x04\xb8\x0e\
    \x1b$\n\r\n\x05\x04E\x02\t\x03\x12\x04\xb8\x0e')\n\xd2\x01\n\x04\x04E\
    \x02\n\x12\x04\xbe\x0e\x02%\x1a\xc3\x01\x20Custom\x20iSCSI\x20Initiator\
    \x20Name.\n\x20If\x20initiatorName\x20is\x20specified\x20with\x20iscsiIn\
    terface\x20simultaneously,\x20new\x20iSCSI\x20interface\n\x20<target\x20\
    portal>:<volume\x20name>\x20will\x20be\x20created\x20for\x20the\x20conne\
    ction.\n\x20+optional\n\n\r\n\x05\x04E\x02\n\x04\x12\x04\xbe\x0e\x02\n\n\
    \r\n\x05\x04E\x02\n\x05\x12\x04\xbe\x0e\x0b\x11\n\r\n\x05\x04E\x02\n\x01\
    \x12\x04\xbe\x0e\x12\x1f\n\r\n\x05\x04E\x02\n\x03\x12\x04\xbe\x0e\"$\n\
    \xa5\x01\n\x02\x04F\x12\x06\xc4\x0e\0\xf7\x0e\x01\x1a\x96\x01\x20Represe\
    nts\x20an\x20ISCSI\x20disk.\n\x20ISCSI\x20volumes\x20can\x20only\x20be\
    \x20mounted\x20as\x20read/write\x20once.\n\x20ISCSI\x20volumes\x20suppor\
    t\x20ownership\x20management\x20and\x20SELinux\x20relabeling.\n\n\x0b\n\
    \x03\x04F\x01\x12\x04\xc4\x0e\x08\x19\n\x97\x01\n\x04\x04F\x02\0\x12\x04\
    \xc7\x0e\x02#\x1a\x88\x01\x20iSCSI\x20Target\x20Portal.\x20The\x20Portal\
    \x20is\x20either\x20an\x20IP\x20or\x20ip_addr:port\x20if\x20the\x20port\
    \n\x20is\x20other\x20than\x20default\x20(typically\x20TCP\x20ports\x2086\
    0\x20and\x203260).\n\n\r\n\x05\x04F\x02\0\x04\x12\x04\xc7\x0e\x02\n\n\r\
    \n\x05\x04F\x02\0\x05\x12\x04\xc7\x0e\x0b\x11\n\r\n\x05\x04F\x02\0\x01\
    \x12\x04\xc7\x0e\x12\x1e\n\r\n\x05\x04F\x02\0\x03\x12\x04\xc7\x0e!\"\n,\
    \n\x04\x04F\x02\x01\x12\x04\xca\x0e\x02\x1a\x1a\x1e\x20Target\x20iSCSI\
    \x20Qualified\x20Name.\n\n\r\n\x05\x04F\x02\x01\x04\x12\x04\xca\x0e\x02\
    \n\n\r\n\x05\x04F\x02\x01\x05\x12\x04\xca\x0e\x0b\x11\n\r\n\x05\x04F\x02\
    \x01\x01\x12\x04\xca\x0e\x12\x15\n\r\n\x05\x04F\x02\x01\x03\x12\x04\xca\
    \x0e\x18\x19\n(\n\x04\x04F\x02\x02\x12\x04\xcd\x0e\x02\x19\x1a\x1a\x20iS\
    CSI\x20Target\x20Lun\x20number.\n\n\r\n\x05\x04F\x02\x02\x04\x12\x04\xcd\
    \x0e\x02\n\n\r\n\x05\x04F\x02\x02\x05\x12\x04\xcd\x0e\x0b\x10\n\r\n\x05\
    \x04F\x02\x02\x01\x12\x04\xcd\x0e\x11\x14\n\r\n\x05\x04F\x02\x02\x03\x12\
    \x04\xcd\x0e\x17\x18\nk\n\x04\x04F\x02\x03\x12\x04\xd2\x0e\x02%\x1a]\x20\
    iSCSI\x20Interface\x20Name\x20that\x20uses\x20an\x20iSCSI\x20transport.\
    \n\x20Defaults\x20to\x20'default'\x20(tcp).\n\x20+optional\n\n\r\n\x05\
    \x04F\x02\x03\x04\x12\x04\xd2\x0e\x02\n\n\r\n\x05\x04F\x02\x03\x05\x12\
    \x04\xd2\x0e\x0b\x11\n\r\n\x05\x04F\x02\x03\x01\x12\x04\xd2\x0e\x12\x20\
    \n\r\n\x05\x04F\x02\x03\x03\x12\x04\xd2\x0e#$\n\x8b\x03\n\x04\x04F\x02\
    \x04\x12\x04\xda\x0e\x02\x1d\x1a\xfc\x02\x20Filesystem\x20type\x20of\x20\
    the\x20volume\x20that\x20you\x20want\x20to\x20mount.\n\x20Tip:\x20Ensure\
    \x20that\x20the\x20filesystem\x20type\x20is\x20supported\x20by\x20the\
    \x20host\x20operating\x20system.\n\x20Examples:\x20\"ext4\",\x20\"xfs\",\
    \x20\"ntfs\".\x20Implicitly\x20inferred\x20to\x20be\x20\"ext4\"\x20if\
    \x20unspecified.\n\x20More\x20info:\x20https://kubernetes.io/docs/concep\
    ts/storage/volumes#iscsi\n\x20TODO:\x20how\x20do\x20we\x20prevent\x20err\
    ors\x20in\x20the\x20filesystem\x20from\x20compromising\x20the\x20machine\
    \n\x20+optional\n\n\r\n\x05\x04F\x02\x04\x04\x12\x04\xda\x0e\x02\n\n\r\n\
    \x05\x04F\x02\x04\x05\x12\x04\xda\x0e\x0b\x11\n\r\n\x05\x04F\x02\x04\x01\
    \x12\x04\xda\x0e\x12\x18\n\r\n\x05\x04F\x02\x04\x03\x12\x04\xda\x0e\x1b\
    \x1c\nm\n\x04\x04F\x02\x05\x12\x04\xdf\x0e\x02\x1d\x1a_\x20ReadOnly\x20h\
    ere\x20will\x20force\x20the\x20ReadOnly\x20setting\x20in\x20VolumeMounts\
    .\n\x20Defaults\x20to\x20false.\n\x20+optional\n\n\r\n\x05\x04F\x02\x05\
    \x04\x12\x04\xdf\x0e\x02\n\n\r\n\x05\x04F\x02\x05\x05\x12\x04\xdf\x0e\
    \x0b\x0f\n\r\n\x05\x04F\x02\x05\x01\x12\x04\xdf\x0e\x10\x18\n\r\n\x05\
    \x04F\x02\x05\x03\x12\x04\xdf\x0e\x1b\x1c\n\xa7\x01\n\x04\x04F\x02\x06\
    \x12\x04\xe4\x0e\x02\x1e\x1a\x98\x01\x20iSCSI\x20Target\x20Portal\x20Lis\
    t.\x20The\x20portal\x20is\x20either\x20an\x20IP\x20or\x20ip_addr:port\
    \x20if\x20the\x20port\n\x20is\x20other\x20than\x20default\x20(typically\
    \x20TCP\x20ports\x20860\x20and\x203260).\n\x20+optional\n\n\r\n\x05\x04F\
    \x02\x06\x04\x12\x04\xe4\x0e\x02\n\n\r\n\x05\x04F\x02\x06\x05\x12\x04\
    \xe4\x0e\x0b\x11\n\r\n\x05\x04F\x02\x06\x01\x12\x04\xe4\x0e\x12\x19\n\r\
    \n\x05\x04F\x02\x06\x03\x12\x04\xe4\x0e\x1c\x1d\nN\n\x04\x04F\x02\x07\
    \x12\x04\xe8\x0e\x02&\x1a@\x20whether\x20support\x20iSCSI\x20Discovery\
    \x20CHAP\x20authentication\n\x20+optional\n\n\r\n\x05\x04F\x02\x07\x04\
    \x12\x04\xe8\x0e\x02\n\n\r\n\x05\x04F\x02\x07\x05\x12\x04\xe8\x0e\x0b\
    \x0f\n\r\n\x05\x04F\x02\x07\x01\x12\x04\xe8\x0e\x10!\n\r\n\x05\x04F\x02\
    \x07\x03\x12\x04\xe8\x0e$%\nL\n\x04\x04F\x02\x08\x12\x04\xec\x0e\x02%\
    \x1a>\x20whether\x20support\x20iSCSI\x20Session\x20CHAP\x20authenticatio\
    n\n\x20+optional\n\n\r\n\x05\x04F\x02\x08\x04\x12\x04\xec\x0e\x02\n\n\r\
    \n\x05\x04F\x02\x08\x05\x12\x04\xec\x0e\x0b\x0f\n\r\n\x05\x04F\x02\x08\
    \x01\x12\x04\xec\x0e\x10\x1f\n\r\n\x05\x04F\x02\x08\x03\x12\x04\xec\x0e\
    \"$\nT\n\x04\x04F\x02\t\x12\x04\xf0\x0e\x02/\x1aF\x20CHAP\x20Secret\x20f\
    or\x20iSCSI\x20target\x20and\x20initiator\x20authentication\n\x20+option\
    al\n\n\r\n\x05\x04F\x02\t\x04\x12\x04\xf0\x0e\x02\n\n\r\n\x05\x04F\x02\t\
    \x06\x12\x04\xf0\x0e\x0b\x1f\n\r\n\x05\x04F\x02\t\x01\x12\x04\xf0\x0e\
    \x20)\n\r\n\x05\x04F\x02\t\x03\x12\x04\xf0\x0e,.\n\xd2\x01\n\x04\x04F\
    \x02\n\x12\x04\xf6\x0e\x02%\x1a\xc3\x01\x20Custom\x20iSCSI\x20Initiator\
    \x20Name.\n\x20If\x20initiatorName\x20is\x20specified\x20with\x20iscsiIn\
    terface\x20simultaneously,\x20new\x20iSCSI\x20interface\n\x20<target\x20\
    portal>:<volume\x20name>\x20will\x20be\x20created\x20for\x20the\x20conne\
    ction.\n\x20+optional\n\n\r\n\x05\x04F\x02\n\x04\x12\x04\xf6\x0e\x02\n\n\
    \r\n\x05\x04F\x02\n\x05\x12\x04\xf6\x0e\x0b\x11\n\r\n\x05\x04F\x02\n\x01\
    \x12\x04\xf6\x0e\x12\x1f\n\r\n\x05\x04F\x02\n\x03\x12\x04\xf6\x0e\"$\n<\
    \n\x02\x04G\x12\x06\xfa\x0e\0\x8c\x0f\x01\x1a.\x20Maps\x20a\x20string\
    \x20key\x20to\x20a\x20path\x20within\x20a\x20volume.\n\n\x0b\n\x03\x04G\
    \x01\x12\x04\xfa\x0e\x08\x11\n#\n\x04\x04G\x02\0\x12\x04\xfc\x0e\x02\x1a\
    \x1a\x15\x20The\x20key\x20to\x20project.\n\n\r\n\x05\x04G\x02\0\x04\x12\
    \x04\xfc\x0e\x02\n\n\r\n\x05\x04G\x02\0\x05\x12\x04\xfc\x0e\x0b\x11\n\r\
    \n\x05\x04G\x02\0\x01\x12\x04\xfc\x0e\x12\x15\n\r\n\x05\x04G\x02\0\x03\
    \x12\x04\xfc\x0e\x18\x19\n\xac\x01\n\x04\x04G\x02\x01\x12\x04\x82\x0f\
    \x02\x1b\x1a\x9d\x01\x20The\x20relative\x20path\x20of\x20the\x20file\x20\
    to\x20map\x20the\x20key\x20to.\n\x20May\x20not\x20be\x20an\x20absolute\
    \x20path.\n\x20May\x20not\x20contain\x20the\x20path\x20element\x20'..'.\
    \n\x20May\x20not\x20start\x20with\x20the\x20string\x20'..'.\n\n\r\n\x05\
    \x04G\x02\x01\x04\x12\x04\x82\x0f\x02\n\n\r\n\x05\x04G\x02\x01\x05\x12\
    \x04\x82\x0f\x0b\x11\n\r\n\x05\x04G\x02\x01\x01\x12\x04\x82\x0f\x12\x16\
    \n\r\n\x05\x04G\x02\x01\x03\x12\x04\x82\x0f\x19\x1a\n\xbd\x03\n\x04\x04G\
    \x02\x02\x12\x04\x8b\x0f\x02\x1a\x1a\xae\x03\x20Optional:\x20mode\x20bit\
    s\x20used\x20to\x20set\x20permissions\x20on\x20this\x20file.\n\x20Must\
    \x20be\x20an\x20octal\x20value\x20between\x200000\x20and\x200777\x20or\
    \x20a\x20decimal\x20value\x20between\x200\x20and\x20511.\n\x20YAML\x20ac\
    cepts\x20both\x20octal\x20and\x20decimal\x20values,\x20JSON\x20requires\
    \x20decimal\x20values\x20for\x20mode\x20bits.\n\x20If\x20not\x20specifie\
    d,\x20the\x20volume\x20defaultMode\x20will\x20be\x20used.\n\x20This\x20m\
    ight\x20be\x20in\x20conflict\x20with\x20other\x20options\x20that\x20affe\
    ct\x20the\x20file\n\x20mode,\x20like\x20fsGroup,\x20and\x20the\x20result\
    \x20can\x20be\x20other\x20mode\x20bits\x20set.\n\x20+optional\n\n\r\n\
    \x05\x04G\x02\x02\x04\x12\x04\x8b\x0f\x02\n\n\r\n\x05\x04G\x02\x02\x05\
    \x12\x04\x8b\x0f\x0b\x10\n\r\n\x05\x04G\x02\x02\x01\x12\x04\x8b\x0f\x11\
    \x15\n\r\n\x05\x04G\x02\x02\x03\x12\x04\x8b\x0f\x18\x19\n\xbd\x02\n\x02\
    \x04H\x12\x06\x91\x0f\0\xa5\x0f\x01\x1a\xae\x02\x20Lifecycle\x20describe\
    s\x20actions\x20that\x20the\x20management\x20system\x20should\x20take\
    \x20in\x20response\x20to\x20container\x20lifecycle\n\x20events.\x20For\
    \x20the\x20PostStart\x20and\x20PreStop\x20lifecycle\x20handlers,\x20mana\
    gement\x20of\x20the\x20container\x20blocks\n\x20until\x20the\x20action\
    \x20is\x20complete,\x20unless\x20the\x20container\x20process\x20fails,\
    \x20in\x20which\x20case\x20the\x20handler\x20is\x20aborted.\n\n\x0b\n\
    \x03\x04H\x01\x12\x04\x91\x0f\x08\x11\n\xe5\x02\n\x04\x04H\x02\0\x12\x04\
    \x97\x0f\x02!\x1a\xd6\x02\x20PostStart\x20is\x20called\x20immediately\
    \x20after\x20a\x20container\x20is\x20created.\x20If\x20the\x20handler\
    \x20fails,\n\x20the\x20container\x20is\x20terminated\x20and\x20restarted\
    \x20according\x20to\x20its\x20restart\x20policy.\n\x20Other\x20managemen\
    t\x20of\x20the\x20container\x20blocks\x20until\x20the\x20hook\x20complet\
    es.\n\x20More\x20info:\x20https://kubernetes.io/docs/concepts/containers\
    /container-lifecycle-hooks/#container-hooks\n\x20+optional\n\n\r\n\x05\
    \x04H\x02\0\x04\x12\x04\x97\x0f\x02\n\n\r\n\x05\x04H\x02\0\x06\x12\x04\
    \x97\x0f\x0b\x12\n\r\n\x05\x04H\x02\0\x01\x12\x04\x97\x0f\x13\x1c\n\r\n\
    \x05\x04H\x02\0\x03\x12\x04\x97\x0f\x1f\x20\n\xfe\x05\n\x04\x04H\x02\x01\
    \x12\x04\xa4\x0f\x02\x1f\x1a\xef\x05\x20PreStop\x20is\x20called\x20immed\
    iately\x20before\x20a\x20container\x20is\x20terminated\x20due\x20to\x20a\
    n\n\x20API\x20request\x20or\x20management\x20event\x20such\x20as\x20live\
    ness/startup\x20probe\x20failure,\n\x20preemption,\x20resource\x20conten\
    tion,\x20etc.\x20The\x20handler\x20is\x20not\x20called\x20if\x20the\n\
    \x20container\x20crashes\x20or\x20exits.\x20The\x20reason\x20for\x20term\
    ination\x20is\x20passed\x20to\x20the\n\x20handler.\x20The\x20Pod's\x20te\
    rmination\x20grace\x20period\x20countdown\x20begins\x20before\x20the\n\
    \x20PreStop\x20hooked\x20is\x20executed.\x20Regardless\x20of\x20the\x20o\
    utcome\x20of\x20the\x20handler,\x20the\n\x20container\x20will\x20eventua\
    lly\x20terminate\x20within\x20the\x20Pod's\x20termination\x20grace\n\x20\
    period.\x20Other\x20management\x20of\x20the\x20container\x20blocks\x20un\
    til\x20the\x20hook\x20completes\n\x20or\x20until\x20the\x20termination\
    \x20grace\x20period\x20is\x20reached.\n\x20More\x20info:\x20https://kube\
    rnetes.io/docs/concepts/containers/container-lifecycle-hooks/#container-\
    hooks\n\x20+optional\n\n\r\n\x05\x04H\x02\x01\x04\x12\x04\xa4\x0f\x02\n\
    \n\r\n\x05\x04H\x02\x01\x06\x12\x04\xa4\x0f\x0b\x12\n\r\n\x05\x04H\x02\
    \x01\x01\x12\x04\xa4\x0f\x13\x1a\n\r\n\x05\x04H\x02\x01\x03\x12\x04\xa4\
    \x0f\x1d\x1e\n_\n\x02\x04I\x12\x06\xa8\x0f\0\xb2\x0f\x01\x1aQ\x20LimitRa\
    nge\x20sets\x20resource\x20usage\x20limits\x20for\x20each\x20kind\x20of\
    \x20resource\x20in\x20a\x20Namespace.\n\n\x0b\n\x03\x04I\x01\x12\x04\xa8\
    \x0f\x08\x12\n\xa0\x01\n\x04\x04I\x02\0\x12\x04\xac\x0f\x02H\x1a\x91\x01\
    \x20Standard\x20object's\x20metadata.\n\x20More\x20info:\x20https://git.\
    k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#\
    metadata\n\x20+optional\n\n\r\n\x05\x04I\x02\0\x04\x12\x04\xac\x0f\x02\n\
    \n\r\n\x05\x04I\x02\0\x06\x12\x04\xac\x0f\x0b:\n\r\n\x05\x04I\x02\0\x01\
    \x12\x04\xac\x0f;C\n\r\n\x05\x04I\x02\0\x03\x12\x04\xac\x0fFG\n\xad\x01\
    \n\x04\x04I\x02\x01\x12\x04\xb1\x0f\x02#\x1a\x9e\x01\x20Spec\x20defines\
    \x20the\x20limits\x20enforced.\n\x20More\x20info:\x20https://git.k8s.io/\
    community/contributors/devel/sig-architecture/api-conventions.md#spec-an\
    d-status\n\x20+optional\n\n\r\n\x05\x04I\x02\x01\x04\x12\x04\xb1\x0f\x02\
    \n\n\r\n\x05\x04I\x02\x01\x06\x12\x04\xb1\x0f\x0b\x19\n\r\n\x05\x04I\x02\
    \x01\x01\x12\x04\xb1\x0f\x1a\x1e\n\r\n\x05\x04I\x02\x01\x03\x12\x04\xb1\
    \x0f!\"\nc\n\x02\x04J\x12\x06\xb5\x0f\0\xcc\x0f\x01\x1aU\x20LimitRangeIt\
    em\x20defines\x20a\x20min/max\x20usage\x20limit\x20for\x20any\x20resourc\
    e\x20that\x20matches\x20on\x20kind.\n\n\x0b\n\x03\x04J\x01\x12\x04\xb5\
    \x0f\x08\x16\n<\n\x04\x04J\x02\0\x12\x04\xb7\x0f\x02\x1b\x1a.\x20Type\
    \x20of\x20resource\x20that\x20this\x20limit\x20applies\x20to.\n\n\r\n\
    \x05\x04J\x02\0\x04\x12\x04\xb7\x0f\x02\n\n\r\n\x05\x04J\x02\0\x05\x12\
    \x04\xb7\x0f\x0b\x11\n\r\n\x05\x04J\x02\0\x01\x12\x04\xb7\x0f\x12\x16\n\
    \r\n\x05\x04J\x02\0\x03\x12\x04\xb7\x0f\x19\x1a\nO\n\x04\x04J\x02\x01\
    \x12\x04\xbb\x0f\x02E\x1aA\x20Max\x20usage\x20constraints\x20on\x20this\
    \x20kind\x20by\x20resource\x20name.\n\x20+optional\n\n\x0f\n\x05\x04J\
    \x02\x01\x04\x12\x06\xbb\x0f\x02\xb7\x0f\x1b\n\r\n\x05\x04J\x02\x01\x06\
    \x12\x04\xbb\x0f\x02<\n\r\n\x05\x04J\x02\x01\x01\x12\x04\xbb\x0f=@\n\r\n\
    \x05\x04J\x02\x01\x03\x12\x04\xbb\x0fCD\nO\n\x04\x04J\x02\x02\x12\x04\
    \xbf\x0f\x02E\x1aA\x20Min\x20usage\x20constraints\x20on\x20this\x20kind\
    \x20by\x20resource\x20name.\n\x20+optional\n\n\x0f\n\x05\x04J\x02\x02\
    \x04\x12\x06\xbf\x0f\x02\xbb\x0fE\n\r\n\x05\x04J\x02\x02\x06\x12\x04\xbf\
    \x0f\x02<\n\r\n\x05\x04J\x02\x02\x01\x12\x04\xbf\x0f=@\n\r\n\x05\x04J\
    \x02\x02\x03\x12\x04\xbf\x0fCD\nr\n\x04\x04J\x02\x03\x12\x04\xc3\x0f\x02\
    I\x1ad\x20Default\x20resource\x20requirement\x20limit\x20value\x20by\x20\
    resource\x20name\x20if\x20resource\x20limit\x20is\x20omitted.\n\x20+opti\
    onal\n\n\x0f\n\x05\x04J\x02\x03\x04\x12\x06\xc3\x0f\x02\xbf\x0fE\n\r\n\
    \x05\x04J\x02\x03\x06\x12\x04\xc3\x0f\x02<\n\r\n\x05\x04J\x02\x03\x01\
    \x12\x04\xc3\x0f=D\n\r\n\x05\x04J\x02\x03\x03\x12\x04\xc3\x0fGH\n\x8c\
    \x01\n\x04\x04J\x02\x04\x12\x04\xc7\x0f\x02P\x1a~\x20DefaultRequest\x20i\
    s\x20the\x20default\x20resource\x20requirement\x20request\x20value\x20by\
    \x20resource\x20name\x20if\x20resource\x20request\x20is\x20omitted.\n\
    \x20+optional\n\n\x0f\n\x05\x04J\x02\x04\x04\x12\x06\xc7\x0f\x02\xc3\x0f\
    I\n\r\n\x05\x04J\x02\x04\x06\x12\x04\xc7\x0f\x02<\n\r\n\x05\x04J\x02\x04\
    \x01\x12\x04\xc7\x0f=K\n\r\n\x05\x04J\x02\x04\x03\x12\x04\xc7\x0fNO\n\
    \x8a\x02\n\x04\x04J\x02\x05\x12\x04\xcb\x0f\x02V\x1a\xfb\x01\x20MaxLimit\
    RequestRatio\x20if\x20specified,\x20the\x20named\x20resource\x20must\x20\
    have\x20a\x20request\x20and\x20limit\x20that\x20are\x20both\x20non-zero\
    \x20where\x20limit\x20divided\x20by\x20request\x20is\x20less\x20than\x20\
    or\x20equal\x20to\x20the\x20enumerated\x20value;\x20this\x20represents\
    \x20the\x20max\x20burst\x20for\x20the\x20named\x20resource.\n\x20+option\
    al\n\n\x0f\n\x05\x04J\x02\x05\x04\x12\x06\xcb\x0f\x02\xc7\x0fP\n\r\n\x05\
    \x04J\x02\x05\x06\x12\x04\xcb\x0f\x02<\n\r\n\x05\x04J\x02\x05\x01\x12\
    \x04\xcb\x0f=Q\n\r\n\x05\x04J\x02\x05\x03\x12\x04\xcb\x0fTU\n=\n\x02\x04\
    K\x12\x06\xcf\x0f\0\xd8\x0f\x01\x1a/\x20LimitRangeList\x20is\x20a\x20lis\
    t\x20of\x20LimitRange\x20items.\n\n\x0b\n\x03\x04K\x01\x12\x04\xcf\x0f\
    \x08\x16\n\x9f\x01\n\x04\x04K\x02\0\x12\x04\xd3\x0f\x02F\x1a\x90\x01\x20\
    Standard\x20list\x20metadata.\n\x20More\x20info:\x20https://git.k8s.io/c\
    ommunity/contributors/devel/sig-architecture/api-conventions.md#types-ki\
    nds\n\x20+optional\n\n\r\n\x05\x04K\x02\0\x04\x12\x04\xd3\x0f\x02\n\n\r\
    \n\x05\x04K\x02\0\x06\x12\x04\xd3\x0f\x0b8\n\r\n\x05\x04K\x02\0\x01\x12\
    \x04\xd3\x0f9A\n\r\n\x05\x04K\x02\0\x03\x12\x04\xd3\x0fDE\n\x99\x01\n\
    \x04\x04K\x02\x01\x12\x04\xd7\x0f\x02\x20\x1a\x8a\x01\x20Items\x20is\x20\
    a\x20list\x20of\x20LimitRange\x20objects.\n\x20More\x20info:\x20https://\
    kubernetes.io/docs/concepts/configuration/manage-compute-resources-conta\
    iner/\n\n\r\n\x05\x04K\x02\x01\x04\x12\x04\xd7\x0f\x02\n\n\r\n\x05\x04K\
    \x02\x01\x06\x12\x04\xd7\x0f\x0b\x15\n\r\n\x05\x04K\x02\x01\x01\x12\x04\
    \xd7\x0f\x16\x1b\n\r\n\x05\x04K\x02\x01\x03\x12\x04\xd7\x0f\x1e\x1f\n^\n\
    \x02\x04L\x12\x06\xdb\x0f\0\xde\x0f\x01\x1aP\x20LimitRangeSpec\x20define\
    s\x20a\x20min/max\x20usage\x20limit\x20for\x20resources\x20that\x20match\
    \x20on\x20kind.\n\n\x0b\n\x03\x04L\x01\x12\x04\xdb\x0f\x08\x16\nO\n\x04\
    \x04L\x02\0\x12\x04\xdd\x0f\x02%\x1aA\x20Limits\x20is\x20the\x20list\x20\
    of\x20LimitRangeItem\x20objects\x20that\x20are\x20enforced.\n\n\r\n\x05\
    \x04L\x02\0\x04\x12\x04\xdd\x0f\x02\n\n\r\n\x05\x04L\x02\0\x06\x12\x04\
    \xdd\x0f\x0b\x19\n\r\n\x05\x04L\x02\0\x01\x12\x04\xdd\x0f\x1a\x20\n\r\n\
    \x05\x04L\x02\0\x03\x12\x04\xdd\x0f#$\nS\n\x02\x04M\x12\x06\xe1\x0f\0\
    \xe9\x0f\x01\x1aE\x20List\x20holds\x20a\x20list\x20of\x20objects,\x20whi\
    ch\x20may\x20not\x20be\x20known\x20by\x20the\x20server.\n\n\x0b\n\x03\
    \x04M\x01\x12\x04\xe1\x0f\x08\x0c\n\x9f\x01\n\x04\x04M\x02\0\x12\x04\xe5\
    \x0f\x02F\x1a\x90\x01\x20Standard\x20list\x20metadata.\n\x20More\x20info\
    :\x20https://git.k8s.io/community/contributors/devel/sig-architecture/ap\
    i-conventions.md#types-kinds\n\x20+optional\n\n\r\n\x05\x04M\x02\0\x04\
    \x12\x04\xe5\x0f\x02\n\n\r\n\x05\x04M\x02\0\x06\x12\x04\xe5\x0f\x0b8\n\r\
    \n\x05\x04M\x02\0\x01\x12\x04\xe5\x0f9A\n\r\n\x05\x04M\x02\0\x03\x12\x04\
    \xe5\x0fDE\n\x1f\n\x04\x04M\x02\x01\x12\x04\xe8\x0f\x02B\x1a\x11\x20List\
    \x20of\x20objects\n\n\r\n\x05\x04M\x02\x01\x04\x12\x04\xe8\x0f\x02\n\n\r\
    \n\x05\x04M\x02\x01\x06\x12\x04\xe8\x0f\x0b7\n\r\n\x05\x04M\x02\x01\x01\
    \x12\x04\xe8\x0f8=\n\r\n\x05\x04M\x02\x01\x03\x12\x04\xe8\x0f@A\n\xa2\
    \x01\n\x02\x04N\x12\x06\xed\x0f\0\xfd\x0f\x01\x1a\x93\x01\x20LoadBalance\
    rIngress\x20represents\x20the\x20status\x20of\x20a\x20load-balancer\x20i\
    ngress\x20point:\n\x20traffic\x20intended\x20for\x20the\x20service\x20sh\
    ould\x20be\x20sent\x20to\x20an\x20ingress\x20point.\n\n\x0b\n\x03\x04N\
    \x01\x12\x04\xed\x0f\x08\x1b\n\x84\x01\n\x04\x04N\x02\0\x12\x04\xf1\x0f\
    \x02\x19\x1av\x20IP\x20is\x20set\x20for\x20load-balancer\x20ingress\x20p\
    oints\x20that\x20are\x20IP\x20based\n\x20(typically\x20GCE\x20or\x20Open\
    Stack\x20load-balancers)\n\x20+optional\n\n\r\n\x05\x04N\x02\0\x04\x12\
    \x04\xf1\x0f\x02\n\n\r\n\x05\x04N\x02\0\x05\x12\x04\xf1\x0f\x0b\x11\n\r\
    \n\x05\x04N\x02\0\x01\x12\x04\xf1\x0f\x12\x14\n\r\n\x05\x04N\x02\0\x03\
    \x12\x04\xf1\x0f\x17\x18\n~\n\x04\x04N\x02\x01\x12\x04\xf6\x0f\x02\x1f\
    \x1ap\x20Hostname\x20is\x20set\x20for\x20load-balancer\x20ingress\x20poi\
    nts\x20that\x20are\x20DNS\x20based\n\x20(typically\x20AWS\x20load-balanc\
    ers)\n\x20+optional\n\n\r\n\x05\x04N\x02\x01\x04\x12\x04\xf6\x0f\x02\n\n\
    \r\n\x05\x04N\x02\x01\x05\x12\x04\xf6\x0f\x0b\x11\n\r\n\x05\x04N\x02\x01\
    \x01\x12\x04\xf6\x0f\x12\x1a\n\r\n\x05\x04N\x02\x01\x03\x12\x04\xf6\x0f\
    \x1d\x1e\n\xa0\x01\n\x04\x04N\x02\x02\x12\x04\xfc\x0f\x02\x20\x1a\x91\
    \x01\x20Ports\x20is\x20a\x20list\x20of\x20records\x20of\x20service\x20po\
    rts\n\x20If\x20used,\x20every\x20port\x20defined\x20in\x20the\x20service\
    \x20should\x20have\x20an\x20entry\x20in\x20it\n\x20+listType=atomic\n\
    \x20+optional\n\n\r\n\x05\x04N\x02\x02\x04\x12\x04\xfc\x0f\x02\n\n\r\n\
    \x05\x04N\x02\x02\x06\x12\x04\xfc\x0f\x0b\x15\n\r\n\x05\x04N\x02\x02\x01\
    \x12\x04\xfc\x0f\x16\x1b\n\r\n\x05\x04N\x02\x02\x03\x12\x04\xfc\x0f\x1e\
    \x1f\nL\n\x02\x04O\x12\x06\x80\x10\0\x85\x10\x01\x1a>\x20LoadBalancerSta\
    tus\x20represents\x20the\x20status\x20of\x20a\x20load-balancer.\n\n\x0b\
    \n\x03\x04O\x01\x12\x04\x80\x10\x08\x1a\n\xa8\x01\n\x04\x04O\x02\0\x12\
    \x04\x84\x10\x02+\x1a\x99\x01\x20Ingress\x20is\x20a\x20list\x20containin\
    g\x20ingress\x20points\x20for\x20the\x20load-balancer.\n\x20Traffic\x20i\
    ntended\x20for\x20the\x20service\x20should\x20be\x20sent\x20to\x20these\
    \x20ingress\x20points.\n\x20+optional\n\n\r\n\x05\x04O\x02\0\x04\x12\x04\
    \x84\x10\x02\n\n\r\n\x05\x04O\x02\0\x06\x12\x04\x84\x10\x0b\x1e\n\r\n\
    \x05\x04O\x02\0\x01\x12\x04\x84\x10\x1f&\n\r\n\x05\x04O\x02\0\x03\x12\
    \x04\x84\x10)*\n\x84\x01\n\x02\x04P\x12\x06\x89\x10\0\x8f\x10\x01\x1av\
    \x20LocalObjectReference\x20contains\x20enough\x20information\x20to\x20l\
    et\x20you\x20locate\x20the\n\x20referenced\x20object\x20inside\x20the\
    \x20same\x20namespace.\n\n\x0b\n\x03\x04P\x01\x12\x04\x89\x10\x08\x1c\n\
    \xc3\x01\n\x04\x04P\x02\0\x12\x04\x8e\x10\x02\x1b\x1a\xb4\x01\x20Name\
    \x20of\x20the\x20referent.\n\x20More\x20info:\x20https://kubernetes.io/d\
    ocs/concepts/overview/working-with-objects/names/#names\n\x20TODO:\x20Ad\
    d\x20other\x20useful\x20fields.\x20apiVersion,\x20kind,\x20uid?\n\x20+op\
    tional\n\n\r\n\x05\x04P\x02\0\x04\x12\x04\x8e\x10\x02\n\n\r\n\x05\x04P\
    \x02\0\x05\x12\x04\x8e\x10\x0b\x11\n\r\n\x05\x04P\x02\0\x01\x12\x04\x8e\
    \x10\x12\x16\n\r\n\x05\x04P\x02\0\x03\x12\x04\x8e\x10\x19\x1a\n\\\n\x02\
    \x04Q\x12\x06\x92\x10\0\x9d\x10\x01\x1aN\x20Local\x20represents\x20direc\
    tly-attached\x20storage\x20with\x20node\x20affinity\x20(Beta\x20feature)\
    \n\n\x0b\n\x03\x04Q\x01\x12\x04\x92\x10\x08\x19\n~\n\x04\x04Q\x02\0\x12\
    \x04\x95\x10\x02\x1b\x1ap\x20The\x20full\x20path\x20to\x20the\x20volume\
    \x20on\x20the\x20node.\n\x20It\x20can\x20be\x20either\x20a\x20directory\
    \x20or\x20block\x20device\x20(disk,\x20partition,\x20...).\n\n\r\n\x05\
    \x04Q\x02\0\x04\x12\x04\x95\x10\x02\n\n\r\n\x05\x04Q\x02\0\x05\x12\x04\
    \x95\x10\x0b\x11\n\r\n\x05\x04Q\x02\0\x01\x12\x04\x95\x10\x12\x16\n\r\n\
    \x05\x04Q\x02\0\x03\x12\x04\x95\x10\x19\x1a\n\x86\x02\n\x04\x04Q\x02\x01\
    \x12\x04\x9c\x10\x02\x1d\x1a\xf7\x01\x20Filesystem\x20type\x20to\x20moun\
    t.\n\x20It\x20applies\x20only\x20when\x20the\x20Path\x20is\x20a\x20block\
    \x20device.\n\x20Must\x20be\x20a\x20filesystem\x20type\x20supported\x20b\
    y\x20the\x20host\x20operating\x20system.\n\x20Ex.\x20\"ext4\",\x20\"xfs\
    \",\x20\"ntfs\".\x20The\x20default\x20value\x20is\x20to\x20auto-select\
    \x20a\x20fileystem\x20if\x20unspecified.\n\x20+optional\n\n\r\n\x05\x04Q\
    \x02\x01\x04\x12\x04\x9c\x10\x02\n\n\r\n\x05\x04Q\x02\x01\x05\x12\x04\
    \x9c\x10\x0b\x11\n\r\n\x05\x04Q\x02\x01\x01\x12\x04\x9c\x10\x12\x18\n\r\
    \n\x05\x04Q\x02\x01\x03\x12\x04\x9c\x10\x1b\x1c\n\x92\x01\n\x02\x04R\x12\
    \x06\xa1\x10\0\xb0\x10\x01\x1a\x83\x01\x20Represents\x20an\x20NFS\x20mou\
    nt\x20that\x20lasts\x20the\x20lifetime\x20of\x20a\x20pod.\n\x20NFS\x20vo\
    lumes\x20do\x20not\x20support\x20ownership\x20management\x20or\x20SELinu\
    x\x20relabeling.\n\n\x0b\n\x03\x04R\x01\x12\x04\xa1\x10\x08\x17\n\x8b\
    \x01\n\x04\x04R\x02\0\x12\x04\xa4\x10\x02\x1d\x1a}\x20Server\x20is\x20th\
    e\x20hostname\x20or\x20IP\x20address\x20of\x20the\x20NFS\x20server.\n\
    \x20More\x20info:\x20https://kubernetes.io/docs/concepts/storage/volumes\
    #nfs\n\n\r\n\x05\x04R\x02\0\x04\x12\x04\xa4\x10\x02\n\n\r\n\x05\x04R\x02\
    \0\x05\x12\x04\xa4\x10\x0b\x11\n\r\n\x05\x04R\x02\0\x01\x12\x04\xa4\x10\
    \x12\x18\n\r\n\x05\x04R\x02\0\x03\x12\x04\xa4\x10\x1b\x1c\n|\n\x04\x04R\
    \x02\x01\x12\x04\xa8\x10\x02\x1b\x1an\x20Path\x20that\x20is\x20exported\
    \x20by\x20the\x20NFS\x20server.\n\x20More\x20info:\x20https://kubernetes\
    .io/docs/concepts/storage/volumes#nfs\n\n\r\n\x05\x04R\x02\x01\x04\x12\
    \x04\xa8\x10\x02\n\n\r\n\x05\x04R\x02\x01\x05\x12\x04\xa8\x10\x0b\x11\n\
    \r\n\x05\x04R\x02\x01\x01\x12\x04\xa8\x10\x12\x16\n\r\n\x05\x04R\x02\x01\
    \x03\x12\x04\xa8\x10\x19\x1a\n\xc6\x01\n\x04\x04R\x02\x02\x12\x04\xaf\
    \x10\x02\x1d\x1a\xb7\x01\x20ReadOnly\x20here\x20will\x20force\n\x20the\
    \x20NFS\x20export\x20to\x20be\x20mounted\x20with\x20read-only\x20permiss\
    ions.\n\x20Defaults\x20to\x20false.\n\x20More\x20info:\x20https://kubern\
    etes.io/docs/concepts/storage/volumes#nfs\n\x20+optional\n\n\r\n\x05\x04\
    R\x02\x02\x04\x12\x04\xaf\x10\x02\n\n\r\n\x05\x04R\x02\x02\x05\x12\x04\
    \xaf\x10\x0b\x0f\n\r\n\x05\x04R\x02\x02\x01\x12\x04\xaf\x10\x10\x18\n\r\
    \n\x05\x04R\x02\x02\x03\x12\x04\xaf\x10\x1b\x1c\n^\n\x02\x04S\x12\x06\
    \xb4\x10\0\xc3\x10\x01\x1aP\x20Namespace\x20provides\x20a\x20scope\x20fo\
    r\x20Names.\n\x20Use\x20of\x20multiple\x20namespaces\x20is\x20optional.\
    \n\n\x0b\n\x03\x04S\x01\x12\x04\xb4\x10\x08\x11\n\xa0\x01\n\x04\x04S\x02\
    \0\x12\x04\xb8\x10\x02H\x1a\x91\x01\x20Standard\x20object's\x20metadata.\
    \n\x20More\x20info:\x20https://git.k8s.io/community/contributors/devel/s\
    ig-architecture/api-conventions.md#metadata\n\x20+optional\n\n\r\n\x05\
    \x04S\x02\0\x04\x12\x04\xb8\x10\x02\n\n\r\n\x05\x04S\x02\0\x06\x12\x04\
    \xb8\x10\x0b:\n\r\n\x05\x04S\x02\0\x01\x12\x04\xb8\x10;C\n\r\n\x05\x04S\
    \x02\0\x03\x12\x04\xb8\x10FG\n\xb7\x01\n\x04\x04S\x02\x01\x12\x04\xbd\
    \x10\x02\"\x1a\xa8\x01\x20Spec\x20defines\x20the\x20behavior\x20of\x20th\
    e\x20Namespace.\n\x20More\x20info:\x20https://git.k8s.io/community/contr\
    ibutors/devel/sig-architecture/api-conventions.md#spec-and-status\n\x20+\
    optional\n\n\r\n\x05\x04S\x02\x01\x04\x12\x04\xbd\x10\x02\n\n\r\n\x05\
    \x04S\x02\x01\x06\x12\x04\xbd\x10\x0b\x18\n\r\n\x05\x04S\x02\x01\x01\x12\
    \x04\xbd\x10\x19\x1d\n\r\n\x05\x04S\x02\x01\x03\x12\x04\xbd\x10\x20!\n\
    \xbf\x01\n\x04\x04S\x02\x02\x12\x04\xc2\x10\x02&\x1a\xb0\x01\x20Status\
    \x20describes\x20the\x20current\x20status\x20of\x20a\x20Namespace.\n\x20\
    More\x20info:\x20https://git.k8s.io/community/contributors/devel/sig-arc\
    hitecture/api-conventions.md#spec-and-status\n\x20+optional\n\n\r\n\x05\
    \x04S\x02\x02\x04\x12\x04\xc2\x10\x02\n\n\r\n\x05\x04S\x02\x02\x06\x12\
    \x04\xc2\x10\x0b\x1a\n\r\n\x05\x04S\x02\x02\x01\x12\x04\xc2\x10\x1b!\n\r\
    \n\x05\x04S\x02\x02\x03\x12\x04\xc2\x10$%\nM\n\x02\x04T\x12\x06\xc6\x10\
    \0\xd5\x10\x01\x1a?\x20NamespaceCondition\x20contains\x20details\x20abou\
    t\x20state\x20of\x20namespace.\n\n\x0b\n\x03\x04T\x01\x12\x04\xc6\x10\
    \x08\x1a\n7\n\x04\x04T\x02\0\x12\x04\xc8\x10\x02\x1b\x1a)\x20Type\x20of\
    \x20namespace\x20controller\x20condition.\n\n\r\n\x05\x04T\x02\0\x04\x12\
    \x04\xc8\x10\x02\n\n\r\n\x05\x04T\x02\0\x05\x12\x04\xc8\x10\x0b\x11\n\r\
    \n\x05\x04T\x02\0\x01\x12\x04\xc8\x10\x12\x16\n\r\n\x05\x04T\x02\0\x03\
    \x12\x04\xc8\x10\x19\x1a\nE\n\x04\x04T\x02\x01\x12\x04\xcb\x10\x02\x1d\
    \x1a7\x20Status\x20of\x20the\x20condition,\x20one\x20of\x20True,\x20Fals\
    e,\x20Unknown.\n\n\r\n\x05\x04T\x02\x01\x04\x12\x04\xcb\x10\x02\n\n\r\n\
    \x05\x04T\x02\x01\x05\x12\x04\xcb\x10\x0b\x11\n\r\n\x05\x04T\x02\x01\x01\
    \x12\x04\xcb\x10\x12\x18\n\r\n\x05\x04T\x02\x01\x03\x12\x04\xcb\x10\x1b\
    \x1c\n\x19\n\x04\x04T\x02\x02\x12\x04\xce\x10\x02L\x1a\x0b\x20+optional\
    \n\n\r\n\x05\x04T\x02\x02\x04\x12\x04\xce\x10\x02\n\n\r\n\x05\x04T\x02\
    \x02\x06\x12\x04\xce\x10\x0b4\n\r\n\x05\x04T\x02\x02\x01\x12\x04\xce\x10\
    5G\n\r\n\x05\x04T\x02\x02\x03\x12\x04\xce\x10JK\n\x19\n\x04\x04T\x02\x03\
    \x12\x04\xd1\x10\x02\x1d\x1a\x0b\x20+optional\n\n\r\n\x05\x04T\x02\x03\
    \x04\x12\x04\xd1\x10\x02\n\n\r\n\x05\x04T\x02\x03\x05\x12\x04\xd1\x10\
    \x0b\x11\n\r\n\x05\x04T\x02\x03\x01\x12\x04\xd1\x10\x12\x18\n\r\n\x05\
    \x04T\x02\x03\x03\x12\x04\xd1\x10\x1b\x1c\n\x19\n\x04\x04T\x02\x04\x12\
    \x04\xd4\x10\x02\x1e\x1a\x0b\x20+optional\n\n\r\n\x05\x04T\x02\x04\x04\
    \x12\x04\xd4\x10\x02\n\n\r\n\x05\x04T\x02\x04\x05\x12\x04\xd4\x10\x0b\
    \x11\n\r\n\x05\x04T\x02\x04\x01\x12\x04\xd4\x10\x12\x19\n\r\n\x05\x04T\
    \x02\x04\x03\x12\x04\xd4\x10\x1c\x1d\n6\n\x02\x04U\x12\x06\xd8\x10\0\xe1\
    \x10\x01\x1a(\x20NamespaceList\x20is\x20a\x20list\x20of\x20Namespaces.\n\
    \n\x0b\n\x03\x04U\x01\x12\x04\xd8\x10\x08\x15\n\x9f\x01\n\x04\x04U\x02\0\
    \x12\x04\xdc\x10\x02F\x1a\x90\x01\x20Standard\x20list\x20metadata.\n\x20\
    More\x20info:\x20https://git.k8s.io/community/contributors/devel/sig-arc\
    hitecture/api-conventions.md#types-kinds\n\x20+optional\n\n\r\n\x05\x04U\
    \x02\0\x04\x12\x04\xdc\x10\x02\n\n\r\n\x05\x04U\x02\0\x06\x12\x04\xdc\
    \x10\x0b8\n\r\n\x05\x04U\x02\0\x01\x12\x04\xdc\x109A\n\r\n\x05\x04U\x02\
    \0\x03\x12\x04\xdc\x10DE\n\x9e\x01\n\x04\x04U\x02\x01\x12\x04\xe0\x10\
    \x02\x1f\x1a\x8f\x01\x20Items\x20is\x20the\x20list\x20of\x20Namespace\
    \x20objects\x20in\x20the\x20list.\n\x20More\x20info:\x20https://kubernet\
    es.io/docs/concepts/overview/working-with-objects/namespaces/\n\n\r\n\
    \x05\x04U\x02\x01\x04\x12\x04\xe0\x10\x02\n\n\r\n\x05\x04U\x02\x01\x06\
    \x12\x04\xe0\x10\x0b\x14\n\r\n\x05\x04U\x02\x01\x01\x12\x04\xe0\x10\x15\
    \x1a\n\r\n\x05\x04U\x02\x01\x03\x12\x04\xe0\x10\x1d\x1e\nF\n\x02\x04V\
    \x12\x06\xe4\x10\0\xe9\x10\x01\x1a8\x20NamespaceSpec\x20describes\x20the\
    \x20attributes\x20on\x20a\x20Namespace.\n\n\x0b\n\x03\x04V\x01\x12\x04\
    \xe4\x10\x08\x15\n\xcc\x01\n\x04\x04V\x02\0\x12\x04\xe8\x10\x02!\x1a\xbd\
    \x01\x20Finalizers\x20is\x20an\x20opaque\x20list\x20of\x20values\x20that\
    \x20must\x20be\x20empty\x20to\x20permanently\x20remove\x20object\x20from\
    \x20storage.\n\x20More\x20info:\x20https://kubernetes.io/docs/tasks/admi\
    nister-cluster/namespaces/\n\x20+optional\n\n\r\n\x05\x04V\x02\0\x04\x12\
    \x04\xe8\x10\x02\n\n\r\n\x05\x04V\x02\0\x05\x12\x04\xe8\x10\x0b\x11\n\r\
    \n\x05\x04V\x02\0\x01\x12\x04\xe8\x10\x12\x1c\n\r\n\x05\x04V\x02\0\x03\
    \x12\x04\xe8\x10\x1f\x20\nW\n\x02\x04W\x12\x06\xec\x10\0\xf7\x10\x01\x1a\
    I\x20NamespaceStatus\x20is\x20information\x20about\x20the\x20current\x20\
    status\x20of\x20a\x20Namespace.\n\n\x0b\n\x03\x04W\x01\x12\x04\xec\x10\
    \x08\x17\n\x9e\x01\n\x04\x04W\x02\0\x12\x04\xf0\x10\x02\x1c\x1a\x8f\x01\
    \x20Phase\x20is\x20the\x20current\x20lifecycle\x20phase\x20of\x20the\x20\
    namespace.\n\x20More\x20info:\x20https://kubernetes.io/docs/tasks/admini\
    ster-cluster/namespaces/\n\x20+optional\n\n\r\n\x05\x04W\x02\0\x04\x12\
    \x04\xf0\x10\x02\n\n\r\n\x05\x04W\x02\0\x05\x12\x04\xf0\x10\x0b\x11\n\r\
    \n\x05\x04W\x02\0\x01\x12\x04\xf0\x10\x12\x17\n\r\n\x05\x04W\x02\0\x03\
    \x12\x04\xf0\x10\x1a\x1b\n\x93\x01\n\x04\x04W\x02\x01\x12\x04\xf6\x10\
    \x02-\x1a\x84\x01\x20Represents\x20the\x20latest\x20available\x20observa\
    tions\x20of\x20a\x20namespace's\x20current\x20state.\n\x20+optional\n\
    \x20+patchMergeKey=type\n\x20+patchStrategy=merge\n\n\r\n\x05\x04W\x02\
    \x01\x04\x12\x04\xf6\x10\x02\n\n\r\n\x05\x04W\x02\x01\x06\x12\x04\xf6\
    \x10\x0b\x1d\n\r\n\x05\x04W\x02\x01\x01\x12\x04\xf6\x10\x1e(\n\r\n\x05\
    \x04W\x02\x01\x03\x12\x04\xf6\x10+,\nz\n\x02\x04X\x12\x06\xfb\x10\0\x8c\
    \x11\x01\x1al\x20Node\x20is\x20a\x20worker\x20node\x20in\x20Kubernetes.\
    \n\x20Each\x20node\x20will\x20have\x20a\x20unique\x20identifier\x20in\
    \x20the\x20cache\x20(i.e.\x20in\x20etcd).\n\n\x0b\n\x03\x04X\x01\x12\x04\
    \xfb\x10\x08\x0c\n\xa0\x01\n\x04\x04X\x02\0\x12\x04\xff\x10\x02H\x1a\x91\
    \x01\x20Standard\x20object's\x20metadata.\n\x20More\x20info:\x20https://\
    git.k8s.io/community/contributors/devel/sig-architecture/api-conventions\
    .md#metadata\n\x20+optional\n\n\r\n\x05\x04X\x02\0\x04\x12\x04\xff\x10\
    \x02\n\n\r\n\x05\x04X\x02\0\x06\x12\x04\xff\x10\x0b:\n\r\n\x05\x04X\x02\
    \0\x01\x12\x04\xff\x10;C\n\r\n\x05\x04X\x02\0\x03\x12\x04\xff\x10FG\n\
    \xa5\x01\n\x04\x04X\x02\x01\x12\x04\x84\x11\x02\x1d\x1a\x96\x01\x20Spec\
    \x20defines\x20the\x20behavior\x20of\x20a\x20node.\n\x20https://git.k8s.\
    io/community/contributors/devel/sig-architecture/api-conventions.md#spec\
    -and-status\n\x20+optional\n\n\r\n\x05\x04X\x02\x01\x04\x12\x04\x84\x11\
    \x02\n\n\r\n\x05\x04X\x02\x01\x06\x12\x04\x84\x11\x0b\x13\n\r\n\x05\x04X\
    \x02\x01\x01\x12\x04\x84\x11\x14\x18\n\r\n\x05\x04X\x02\x01\x03\x12\x04\
    \x84\x11\x1b\x1c\n\xdc\x01\n\x04\x04X\x02\x02\x12\x04\x8b\x11\x02!\x1a\
    \xcd\x01\x20Most\x20recently\x20observed\x20status\x20of\x20the\x20node.\
    \n\x20Populated\x20by\x20the\x20system.\n\x20Read-only.\n\x20More\x20inf\
    o:\x20https://git.k8s.io/community/contributors/devel/sig-architecture/a\
    pi-conventions.md#spec-and-status\n\x20+optional\n\n\r\n\x05\x04X\x02\
    \x02\x04\x12\x04\x8b\x11\x02\n\n\r\n\x05\x04X\x02\x02\x06\x12\x04\x8b\
    \x11\x0b\x15\n\r\n\x05\x04X\x02\x02\x01\x12\x04\x8b\x11\x16\x1c\n\r\n\
    \x05\x04X\x02\x02\x03\x12\x04\x8b\x11\x1f\x20\nH\n\x02\x04Y\x12\x06\x8f\
    \x11\0\x95\x11\x01\x1a:\x20NodeAddress\x20contains\x20information\x20for\
    \x20the\x20node's\x20address.\n\n\x0b\n\x03\x04Y\x01\x12\x04\x8f\x11\x08\
    \x13\nM\n\x04\x04Y\x02\0\x12\x04\x91\x11\x02\x1b\x1a?\x20Node\x20address\
    \x20type,\x20one\x20of\x20Hostname,\x20ExternalIP\x20or\x20InternalIP.\n\
    \n\r\n\x05\x04Y\x02\0\x04\x12\x04\x91\x11\x02\n\n\r\n\x05\x04Y\x02\0\x05\
    \x12\x04\x91\x11\x0b\x11\n\r\n\x05\x04Y\x02\0\x01\x12\x04\x91\x11\x12\
    \x16\n\r\n\x05\x04Y\x02\0\x03\x12\x04\x91\x11\x19\x1a\n!\n\x04\x04Y\x02\
    \x01\x12\x04\x94\x11\x02\x1e\x1a\x13\x20The\x20node\x20address.\n\n\r\n\
    \x05\x04Y\x02\x01\x04\x12\x04\x94\x11\x02\n\n\r\n\x05\x04Y\x02\x01\x05\
    \x12\x04\x94\x11\x0b\x11\n\r\n\x05\x04Y\x02\x01\x01\x12\x04\x94\x11\x12\
    \x19\n\r\n\x05\x04Y\x02\x01\x03\x12\x04\x94\x11\x1c\x1d\nK\n\x02\x04Z\
    \x12\x06\x98\x11\0\xac\x11\x01\x1a=\x20Node\x20affinity\x20is\x20a\x20gr\
    oup\x20of\x20node\x20affinity\x20scheduling\x20rules.\n\n\x0b\n\x03\x04Z\
    \x01\x12\x04\x98\x11\x08\x14\n\xeb\x02\n\x04\x04Z\x02\0\x12\x04\x9f\x11\
    \x02K\x1a\xdc\x02\x20If\x20the\x20affinity\x20requirements\x20specified\
    \x20by\x20this\x20field\x20are\x20not\x20met\x20at\n\x20scheduling\x20ti\
    me,\x20the\x20pod\x20will\x20not\x20be\x20scheduled\x20onto\x20the\x20no\
    de.\n\x20If\x20the\x20affinity\x20requirements\x20specified\x20by\x20thi\
    s\x20field\x20cease\x20to\x20be\x20met\n\x20at\x20some\x20point\x20durin\
    g\x20pod\x20execution\x20(e.g.\x20due\x20to\x20an\x20update),\x20the\x20\
    system\n\x20may\x20or\x20may\x20not\x20try\x20to\x20eventually\x20evict\
    \x20the\x20pod\x20from\x20its\x20node.\n\x20+optional\n\n\r\n\x05\x04Z\
    \x02\0\x04\x12\x04\x9f\x11\x02\n\n\r\n\x05\x04Z\x02\0\x06\x12\x04\x9f\
    \x11\x0b\x17\n\r\n\x05\x04Z\x02\0\x01\x12\x04\x9f\x11\x18F\n\r\n\x05\x04\
    Z\x02\0\x03\x12\x04\x9f\x11IJ\n\x82\x05\n\x04\x04Z\x02\x01\x12\x04\xab\
    \x11\x02W\x1a\xf3\x04\x20The\x20scheduler\x20will\x20prefer\x20to\x20sch\
    edule\x20pods\x20to\x20nodes\x20that\x20satisfy\n\x20the\x20affinity\x20\
    expressions\x20specified\x20by\x20this\x20field,\x20but\x20it\x20may\x20\
    choose\n\x20a\x20node\x20that\x20violates\x20one\x20or\x20more\x20of\x20\
    the\x20expressions.\x20The\x20node\x20that\x20is\n\x20most\x20preferred\
    \x20is\x20the\x20one\x20with\x20the\x20greatest\x20sum\x20of\x20weights,\
    \x20i.e.\n\x20for\x20each\x20node\x20that\x20meets\x20all\x20of\x20the\
    \x20scheduling\x20requirements\x20(resource\n\x20request,\x20requiredDur\
    ingScheduling\x20affinity\x20expressions,\x20etc.),\n\x20compute\x20a\
    \x20sum\x20by\x20iterating\x20through\x20the\x20elements\x20of\x20this\
    \x20field\x20and\x20adding\n\x20\"weight\"\x20to\x20the\x20sum\x20if\x20\
    the\x20node\x20matches\x20the\x20corresponding\x20matchExpressions;\x20t\
    he\n\x20node(s)\x20with\x20the\x20highest\x20sum\x20are\x20the\x20most\
    \x20preferred.\n\x20+optional\n\n\r\n\x05\x04Z\x02\x01\x04\x12\x04\xab\
    \x11\x02\n\n\r\n\x05\x04Z\x02\x01\x06\x12\x04\xab\x11\x0b\"\n\r\n\x05\
    \x04Z\x02\x01\x01\x12\x04\xab\x11#R\n\r\n\x05\x04Z\x02\x01\x03\x12\x04\
    \xab\x11UV\nH\n\x02\x04[\x12\x06\xaf\x11\0\xc5\x11\x01\x1a:\x20NodeCondi\
    tion\x20contains\x20condition\x20information\x20for\x20a\x20node.\n\n\
    \x0b\n\x03\x04[\x01\x12\x04\xaf\x11\x08\x15\n'\n\x04\x04[\x02\0\x12\x04\
    \xb1\x11\x02\x1b\x1a\x19\x20Type\x20of\x20node\x20condition.\n\n\r\n\x05\
    \x04[\x02\0\x04\x12\x04\xb1\x11\x02\n\n\r\n\x05\x04[\x02\0\x05\x12\x04\
    \xb1\x11\x0b\x11\n\r\n\x05\x04[\x02\0\x01\x12\x04\xb1\x11\x12\x16\n\r\n\
    \x05\x04[\x02\0\x03\x12\x04\xb1\x11\x19\x1a\nE\n\x04\x04[\x02\x01\x12\
    \x04\xb4\x11\x02\x1d\x1a7\x20Status\x20of\x20the\x20condition,\x20one\
    \x20of\x20True,\x20False,\x20Unknown.\n\n\r\n\x05\x04[\x02\x01\x04\x12\
    \x04\xb4\x11\x02\n\n\r\n\x05\x04[\x02\x01\x05\x12\x04\xb4\x11\x0b\x11\n\
    \r\n\x05\x04[\x02\x01\x01\x12\x04\xb4\x11\x12\x18\n\r\n\x05\x04[\x02\x01\
    \x03\x12\x04\xb4\x11\x1b\x1c\nK\n\x04\x04[\x02\x02\x12\x04\xb8\x11\x02K\
    \x1a=\x20Last\x20time\x20we\x20got\x20an\x20update\x20on\x20a\x20given\
    \x20condition.\n\x20+optional\n\n\r\n\x05\x04[\x02\x02\x04\x12\x04\xb8\
    \x11\x02\n\n\r\n\x05\x04[\x02\x02\x06\x12\x04\xb8\x11\x0b4\n\r\n\x05\x04\
    [\x02\x02\x01\x12\x04\xb8\x115F\n\r\n\x05\x04[\x02\x02\x03\x12\x04\xb8\
    \x11IJ\nV\n\x04\x04[\x02\x03\x12\x04\xbc\x11\x02L\x1aH\x20Last\x20time\
    \x20the\x20condition\x20transit\x20from\x20one\x20status\x20to\x20anothe\
    r.\n\x20+optional\n\n\r\n\x05\x04[\x02\x03\x04\x12\x04\xbc\x11\x02\n\n\r\
    \n\x05\x04[\x02\x03\x06\x12\x04\xbc\x11\x0b4\n\r\n\x05\x04[\x02\x03\x01\
    \x12\x04\xbc\x115G\n\r\n\x05\x04[\x02\x03\x03\x12\x04\xbc\x11JK\nN\n\x04\
    \x04[\x02\x04\x12\x04\xc0\x11\x02\x1d\x1a@\x20(brief)\x20reason\x20for\
    \x20the\x20condition's\x20last\x20transition.\n\x20+optional\n\n\r\n\x05\
    \x04[\x02\x04\x04\x12\x04\xc0\x11\x02\n\n\r\n\x05\x04[\x02\x04\x05\x12\
    \x04\xc0\x11\x0b\x11\n\r\n\x05\x04[\x02\x04\x01\x12\x04\xc0\x11\x12\x18\
    \n\r\n\x05\x04[\x02\x04\x03\x12\x04\xc0\x11\x1b\x1c\n[\n\x04\x04[\x02\
    \x05\x12\x04\xc4\x11\x02\x1e\x1aM\x20Human\x20readable\x20message\x20ind\
    icating\x20details\x20about\x20last\x20transition.\n\x20+optional\n\n\r\
    \n\x05\x04[\x02\x05\x04\x12\x04\xc4\x11\x02\n\n\r\n\x05\x04[\x02\x05\x05\
    \x12\x04\xc4\x11\x0b\x11\n\r\n\x05\x04[\x02\x05\x01\x12\x04\xc4\x11\x12\
    \x19\n\r\n\x05\x04[\x02\x05\x03\x12\x04\xc4\x11\x1c\x1d\n\x85\x01\n\x02\
    \x04\\\x12\x06\xc8\x11\0\xcb\x11\x01\x1aw\x20NodeConfigSource\x20specifi\
    es\x20a\x20source\x20of\x20node\x20configuration.\x20Exactly\x20one\x20s\
    ubfield\x20(excluding\x20metadata)\x20must\x20be\x20non-nil.\n\n\x0b\n\
    \x03\x04\\\x01\x12\x04\xc8\x11\x08\x18\n>\n\x04\x04\\\x02\0\x12\x04\xca\
    \x11\x023\x1a0\x20ConfigMap\x20is\x20a\x20reference\x20to\x20a\x20Node's\
    \x20ConfigMap\n\n\r\n\x05\x04\\\x02\0\x04\x12\x04\xca\x11\x02\n\n\r\n\
    \x05\x04\\\x02\0\x06\x12\x04\xca\x11\x0b$\n\r\n\x05\x04\\\x02\0\x01\x12\
    \x04\xca\x11%.\n\r\n\x05\x04\\\x02\0\x03\x12\x04\xca\x1112\ng\n\x02\x04]\
    \x12\x06\xce\x11\0\xfd\x11\x01\x1aY\x20NodeConfigStatus\x20describes\x20\
    the\x20status\x20of\x20the\x20config\x20assigned\x20by\x20Node.Spec.Conf\
    igSource.\n\n\x0b\n\x03\x04]\x01\x12\x04\xce\x11\x08\x18\n\xd9\x04\n\x04\
    \x04]\x02\0\x12\x04\xd8\x11\x02)\x1a\xca\x04\x20Assigned\x20reports\x20t\
    he\x20checkpointed\x20config\x20the\x20node\x20will\x20try\x20to\x20use.\
    \n\x20When\x20Node.Spec.ConfigSource\x20is\x20updated,\x20the\x20node\
    \x20checkpoints\x20the\x20associated\n\x20config\x20payload\x20to\x20loc\
    al\x20disk,\x20along\x20with\x20a\x20record\x20indicating\x20intended\n\
    \x20config.\x20The\x20node\x20refers\x20to\x20this\x20record\x20to\x20ch\
    oose\x20its\x20config\x20checkpoint,\x20and\n\x20reports\x20this\x20reco\
    rd\x20in\x20Assigned.\x20Assigned\x20only\x20updates\x20in\x20the\x20sta\
    tus\x20after\n\x20the\x20record\x20has\x20been\x20checkpointed\x20to\x20\
    disk.\x20When\x20the\x20Kubelet\x20is\x20restarted,\n\x20it\x20tries\x20\
    to\x20make\x20the\x20Assigned\x20config\x20the\x20Active\x20config\x20by\
    \x20loading\x20and\n\x20validating\x20the\x20checkpointed\x20payload\x20\
    identified\x20by\x20Assigned.\n\x20+optional\n\n\r\n\x05\x04]\x02\0\x04\
    \x12\x04\xd8\x11\x02\n\n\r\n\x05\x04]\x02\0\x06\x12\x04\xd8\x11\x0b\x1b\
    \n\r\n\x05\x04]\x02\0\x01\x12\x04\xd8\x11\x1c$\n\r\n\x05\x04]\x02\0\x03\
    \x12\x04\xd8\x11'(\n\x9f\x02\n\x04\x04]\x02\x01\x12\x04\xdf\x11\x02'\x1a\
    \x90\x02\x20Active\x20reports\x20the\x20checkpointed\x20config\x20the\
    \x20node\x20is\x20actively\x20using.\n\x20Active\x20will\x20represent\
    \x20either\x20the\x20current\x20version\x20of\x20the\x20Assigned\x20conf\
    ig,\n\x20or\x20the\x20current\x20LastKnownGood\x20config,\x20depending\
    \x20on\x20whether\x20attempting\x20to\x20use\x20the\n\x20Assigned\x20con\
    fig\x20results\x20in\x20an\x20error.\n\x20+optional\n\n\r\n\x05\x04]\x02\
    \x01\x04\x12\x04\xdf\x11\x02\n\n\r\n\x05\x04]\x02\x01\x06\x12\x04\xdf\
    \x11\x0b\x1b\n\r\n\x05\x04]\x02\x01\x01\x12\x04\xdf\x11\x1c\"\n\r\n\x05\
    \x04]\x02\x01\x03\x12\x04\xdf\x11%&\n\xd4\x06\n\x04\x04]\x02\x02\x12\x04\
    \xed\x11\x02.\x1a\xc5\x06\x20LastKnownGood\x20reports\x20the\x20checkpoi\
    nted\x20config\x20the\x20node\x20will\x20fall\x20back\x20to\n\x20when\
    \x20it\x20encounters\x20an\x20error\x20attempting\x20to\x20use\x20the\
    \x20Assigned\x20config.\n\x20The\x20Assigned\x20config\x20becomes\x20the\
    \x20LastKnownGood\x20config\x20when\x20the\x20node\x20determines\n\x20th\
    at\x20the\x20Assigned\x20config\x20is\x20stable\x20and\x20correct.\n\x20\
    This\x20is\x20currently\x20implemented\x20as\x20a\x2010-minute\x20soak\
    \x20period\x20starting\x20when\x20the\x20local\n\x20record\x20of\x20Assi\
    gned\x20config\x20is\x20updated.\x20If\x20the\x20Assigned\x20config\x20i\
    s\x20Active\x20at\x20the\x20end\n\x20of\x20this\x20period,\x20it\x20beco\
    mes\x20the\x20LastKnownGood.\x20Note\x20that\x20if\x20Spec.ConfigSource\
    \x20is\n\x20reset\x20to\x20nil\x20(use\x20local\x20defaults),\x20the\x20\
    LastKnownGood\x20is\x20also\x20immediately\x20reset\x20to\x20nil,\n\x20b\
    ecause\x20the\x20local\x20default\x20config\x20is\x20always\x20assumed\
    \x20good.\n\x20You\x20should\x20not\x20make\x20assumptions\x20about\x20t\
    he\x20node's\x20method\x20of\x20determining\x20config\x20stability\n\x20\
    and\x20correctness,\x20as\x20this\x20may\x20change\x20or\x20become\x20co\
    nfigurable\x20in\x20the\x20future.\n\x20+optional\n\n\r\n\x05\x04]\x02\
    \x02\x04\x12\x04\xed\x11\x02\n\n\r\n\x05\x04]\x02\x02\x06\x12\x04\xed\
    \x11\x0b\x1b\n\r\n\x05\x04]\x02\x02\x01\x12\x04\xed\x11\x1c)\n\r\n\x05\
    \x04]\x02\x02\x03\x12\x04\xed\x11,-\n\xaf\x08\n\x04\x04]\x02\x03\x12\x04\
    \xfc\x11\x02\x1c\x1a\xa0\x08\x20Error\x20describes\x20any\x20problems\
    \x20reconciling\x20the\x20Spec.ConfigSource\x20to\x20the\x20Active\x20co\
    nfig.\n\x20Errors\x20may\x20occur,\x20for\x20example,\x20attempting\x20t\
    o\x20checkpoint\x20Spec.ConfigSource\x20to\x20the\x20local\x20Assigned\n\
    \x20record,\x20attempting\x20to\x20checkpoint\x20the\x20payload\x20assoc\
    iated\x20with\x20Spec.ConfigSource,\x20attempting\n\x20to\x20load\x20or\
    \x20validate\x20the\x20Assigned\x20config,\x20etc.\n\x20Errors\x20may\
    \x20occur\x20at\x20different\x20points\x20while\x20syncing\x20config.\
    \x20Earlier\x20errors\x20(e.g.\x20download\x20or\n\x20checkpointing\x20e\
    rrors)\x20will\x20not\x20result\x20in\x20a\x20rollback\x20to\x20LastKnow\
    nGood,\x20and\x20may\x20resolve\x20across\n\x20Kubelet\x20retries.\x20La\
    ter\x20errors\x20(e.g.\x20loading\x20or\x20validating\x20a\x20checkpoint\
    ed\x20config)\x20will\x20result\x20in\n\x20a\x20rollback\x20to\x20LastKn\
    ownGood.\x20In\x20the\x20latter\x20case,\x20it\x20is\x20usually\x20possi\
    ble\x20to\x20resolve\x20the\x20error\n\x20by\x20fixing\x20the\x20config\
    \x20assigned\x20in\x20Spec.ConfigSource.\n\x20You\x20can\x20find\x20addi\
    tional\x20information\x20for\x20debugging\x20by\x20searching\x20the\x20e\
    rror\x20message\x20in\x20the\x20Kubelet\x20log.\n\x20Error\x20is\x20a\
    \x20human-readable\x20description\x20of\x20the\x20error\x20state;\x20mac\
    hines\x20can\x20check\x20whether\x20or\x20not\x20Error\n\x20is\x20empty,\
    \x20but\x20should\x20not\x20rely\x20on\x20the\x20stability\x20of\x20the\
    \x20Error\x20text\x20across\x20Kubelet\x20versions.\n\x20+optional\n\n\r\
    \n\x05\x04]\x02\x03\x04\x12\x04\xfc\x11\x02\n\n\r\n\x05\x04]\x02\x03\x05\
    \x12\x04\xfc\x11\x0b\x11\n\r\n\x05\x04]\x02\x03\x01\x12\x04\xfc\x11\x12\
    \x17\n\r\n\x05\x04]\x02\x03\x03\x12\x04\xfc\x11\x1a\x1b\nV\n\x02\x04^\
    \x12\x06\x80\x12\0\x84\x12\x01\x1aH\x20NodeDaemonEndpoints\x20lists\x20p\
    orts\x20opened\x20by\x20daemons\x20running\x20on\x20the\x20Node.\n\n\x0b\
    \n\x03\x04^\x01\x12\x04\x80\x12\x08\x1b\nB\n\x04\x04^\x02\0\x12\x04\x83\
    \x12\x02.\x1a4\x20Endpoint\x20on\x20which\x20Kubelet\x20is\x20listening.\
    \n\x20+optional\n\n\r\n\x05\x04^\x02\0\x04\x12\x04\x83\x12\x02\n\n\r\n\
    \x05\x04^\x02\0\x06\x12\x04\x83\x12\x0b\x19\n\r\n\x05\x04^\x02\0\x01\x12\
    \x04\x83\x12\x1a)\n\r\n\x05\x04^\x02\0\x03\x12\x04\x83\x12,-\n_\n\x02\
    \x04_\x12\x06\x87\x12\0\x8f\x12\x01\x1aQ\x20NodeList\x20is\x20the\x20who\
    le\x20list\x20of\x20all\x20Nodes\x20which\x20have\x20been\x20registered\
    \x20with\x20master.\n\n\x0b\n\x03\x04_\x01\x12\x04\x87\x12\x08\x10\n\x9f\
    \x01\n\x04\x04_\x02\0\x12\x04\x8b\x12\x02F\x1a\x90\x01\x20Standard\x20li\
    st\x20metadata.\n\x20More\x20info:\x20https://git.k8s.io/community/contr\
    ibutors/devel/sig-architecture/api-conventions.md#types-kinds\n\x20+opti\
    onal\n\n\r\n\x05\x04_\x02\0\x04\x12\x04\x8b\x12\x02\n\n\r\n\x05\x04_\x02\
    \0\x06\x12\x04\x8b\x12\x0b8\n\r\n\x05\x04_\x02\0\x01\x12\x04\x8b\x129A\n\
    \r\n\x05\x04_\x02\0\x03\x12\x04\x8b\x12DE\n\x1d\n\x04\x04_\x02\x01\x12\
    \x04\x8e\x12\x02\x1a\x1a\x0f\x20List\x20of\x20nodes\n\n\r\n\x05\x04_\x02\
    \x01\x04\x12\x04\x8e\x12\x02\n\n\r\n\x05\x04_\x02\x01\x06\x12\x04\x8e\
    \x12\x0b\x0f\n\r\n\x05\x04_\x02\x01\x01\x12\x04\x8e\x12\x10\x15\n\r\n\
    \x05\x04_\x02\x01\x03\x12\x04\x8e\x12\x18\x19\nM\n\x02\x04`\x12\x06\x92\
    \x12\0\x96\x12\x01\x1a?\x20NodeProxyOptions\x20is\x20the\x20query\x20opt\
    ions\x20to\x20a\x20Node's\x20proxy\x20call.\n\n\x0b\n\x03\x04`\x01\x12\
    \x04\x92\x12\x08\x18\n]\n\x04\x04`\x02\0\x12\x04\x95\x12\x02\x1b\x1aO\
    \x20Path\x20is\x20the\x20URL\x20path\x20to\x20use\x20for\x20the\x20curre\
    nt\x20proxy\x20request\x20to\x20node.\n\x20+optional\n\n\r\n\x05\x04`\
    \x02\0\x04\x12\x04\x95\x12\x02\n\n\r\n\x05\x04`\x02\0\x05\x12\x04\x95\
    \x12\x0b\x11\n\r\n\x05\x04`\x02\0\x01\x12\x04\x95\x12\x12\x16\n\r\n\x05\
    \x04`\x02\0\x03\x12\x04\x95\x12\x19\x1a\n\xb4\x01\n\x02\x04a\x12\x06\x9a\
    \x12\0\x9d\x12\x01\x1a\xa5\x01\x20NodeResources\x20is\x20an\x20object\
    \x20for\x20conveying\x20resource\x20information\x20about\x20a\x20node.\n\
    \x20see\x20https://kubernetes.io/docs/concepts/architecture/nodes/#capac\
    ity\x20for\x20more\x20details.\n\n\x0b\n\x03\x04a\x01\x12\x04\x9a\x12\
    \x08\x15\nE\n\x04\x04a\x02\0\x12\x04\x9c\x12\x02J\x1a7\x20Capacity\x20re\
    presents\x20the\x20available\x20resources\x20of\x20a\x20node\n\n\x0f\n\
    \x05\x04a\x02\0\x04\x12\x06\x9c\x12\x02\x9a\x12\x17\n\r\n\x05\x04a\x02\0\
    \x06\x12\x04\x9c\x12\x02<\n\r\n\x05\x04a\x02\0\x01\x12\x04\x9c\x12=E\n\r\
    \n\x05\x04a\x02\0\x03\x12\x04\x9c\x12HI\n\xcf\x01\n\x02\x04b\x12\x06\xa2\
    \x12\0\xa5\x12\x01\x1a\xc0\x01\x20A\x20node\x20selector\x20represents\
    \x20the\x20union\x20of\x20the\x20results\x20of\x20one\x20or\x20more\x20l\
    abel\x20queries\n\x20over\x20a\x20set\x20of\x20nodes;\x20that\x20is,\x20\
    it\x20represents\x20the\x20OR\x20of\x20the\x20selectors\x20represented\n\
    \x20by\x20the\x20node\x20selector\x20terms.\n\n\x0b\n\x03\x04b\x01\x12\
    \x04\xa2\x12\x08\x14\nL\n\x04\x04b\x02\0\x12\x04\xa4\x12\x022\x1a>\x20Re\
    quired.\x20A\x20list\x20of\x20node\x20selector\x20terms.\x20The\x20terms\
    \x20are\x20ORed.\n\n\r\n\x05\x04b\x02\0\x04\x12\x04\xa4\x12\x02\n\n\r\n\
    \x05\x04b\x02\0\x06\x12\x04\xa4\x12\x0b\x1b\n\r\n\x05\x04b\x02\0\x01\x12\
    \x04\xa4\x12\x1c-\n\r\n\x05\x04b\x02\0\x03\x12\x04\xa4\x1201\n\x88\x01\n\
    \x02\x04c\x12\x06\xa9\x12\0\xb8\x12\x01\x1az\x20A\x20node\x20selector\
    \x20requirement\x20is\x20a\x20selector\x20that\x20contains\x20values,\
    \x20a\x20key,\x20and\x20an\x20operator\n\x20that\x20relates\x20the\x20ke\
    y\x20and\x20values.\n\n\x0b\n\x03\x04c\x01\x12\x04\xa9\x12\x08\x1f\n;\n\
    \x04\x04c\x02\0\x12\x04\xab\x12\x02\x1a\x1a-\x20The\x20label\x20key\x20t\
    hat\x20the\x20selector\x20applies\x20to.\n\n\r\n\x05\x04c\x02\0\x04\x12\
    \x04\xab\x12\x02\n\n\r\n\x05\x04c\x02\0\x05\x12\x04\xab\x12\x0b\x11\n\r\
    \n\x05\x04c\x02\0\x01\x12\x04\xab\x12\x12\x15\n\r\n\x05\x04c\x02\0\x03\
    \x12\x04\xab\x12\x18\x19\n\x85\x01\n\x04\x04c\x02\x01\x12\x04\xaf\x12\
    \x02\x1f\x1aw\x20Represents\x20a\x20key's\x20relationship\x20to\x20a\x20\
    set\x20of\x20values.\n\x20Valid\x20operators\x20are\x20In,\x20NotIn,\x20\
    Exists,\x20DoesNotExist.\x20Gt,\x20and\x20Lt.\n\n\r\n\x05\x04c\x02\x01\
    \x04\x12\x04\xaf\x12\x02\n\n\r\n\x05\x04c\x02\x01\x05\x12\x04\xaf\x12\
    \x0b\x11\n\r\n\x05\x04c\x02\x01\x01\x12\x04\xaf\x12\x12\x1a\n\r\n\x05\
    \x04c\x02\x01\x03\x12\x04\xaf\x12\x1d\x1e\n\xf3\x02\n\x04\x04c\x02\x02\
    \x12\x04\xb7\x12\x02\x1d\x1a\xe4\x02\x20An\x20array\x20of\x20string\x20v\
    alues.\x20If\x20the\x20operator\x20is\x20In\x20or\x20NotIn,\n\x20the\x20\
    values\x20array\x20must\x20be\x20non-empty.\x20If\x20the\x20operator\x20\
    is\x20Exists\x20or\x20DoesNotExist,\n\x20the\x20values\x20array\x20must\
    \x20be\x20empty.\x20If\x20the\x20operator\x20is\x20Gt\x20or\x20Lt,\x20th\
    e\x20values\n\x20array\x20must\x20have\x20a\x20single\x20element,\x20whi\
    ch\x20will\x20be\x20interpreted\x20as\x20an\x20integer.\n\x20This\x20arr\
    ay\x20is\x20replaced\x20during\x20a\x20strategic\x20merge\x20patch.\n\
    \x20+optional\n\n\r\n\x05\x04c\x02\x02\x04\x12\x04\xb7\x12\x02\n\n\r\n\
    \x05\x04c\x02\x02\x05\x12\x04\xb7\x12\x0b\x11\n\r\n\x05\x04c\x02\x02\x01\
    \x12\x04\xb7\x12\x12\x18\n\r\n\x05\x04c\x02\x02\x03\x12\x04\xb7\x12\x1b\
    \x1c\n\xb8\x01\n\x02\x04d\x12\x06\xbd\x12\0\xc5\x12\x01\x1a\xa9\x01\x20A\
    \x20null\x20or\x20empty\x20node\x20selector\x20term\x20matches\x20no\x20\
    objects.\x20The\x20requirements\x20of\n\x20them\x20are\x20ANDed.\n\x20Th\
    e\x20TopologySelectorTerm\x20type\x20implements\x20a\x20subset\x20of\x20\
    the\x20NodeSelectorTerm.\n\n\x0b\n\x03\x04d\x01\x12\x04\xbd\x12\x08\x18\
    \nQ\n\x04\x04d\x02\0\x12\x04\xc0\x12\x028\x1aC\x20A\x20list\x20of\x20nod\
    e\x20selector\x20requirements\x20by\x20node's\x20labels.\n\x20+optional\
    \n\n\r\n\x05\x04d\x02\0\x04\x12\x04\xc0\x12\x02\n\n\r\n\x05\x04d\x02\0\
    \x06\x12\x04\xc0\x12\x0b\"\n\r\n\x05\x04d\x02\0\x01\x12\x04\xc0\x12#3\n\
    \r\n\x05\x04d\x02\0\x03\x12\x04\xc0\x1267\nQ\n\x04\x04d\x02\x01\x12\x04\
    \xc4\x12\x023\x1aC\x20A\x20list\x20of\x20node\x20selector\x20requirement\
    s\x20by\x20node's\x20fields.\n\x20+optional\n\n\r\n\x05\x04d\x02\x01\x04\
    \x12\x04\xc4\x12\x02\n\n\r\n\x05\x04d\x02\x01\x06\x12\x04\xc4\x12\x0b\"\
    \n\r\n\x05\x04d\x02\x01\x01\x12\x04\xc4\x12#.\n\r\n\x05\x04d\x02\x01\x03\
    \x12\x04\xc4\x1212\nN\n\x02\x04e\x12\x06\xc8\x12\0\xea\x12\x01\x1a@\x20N\
    odeSpec\x20describes\x20the\x20attributes\x20that\x20a\x20node\x20is\x20\
    created\x20with.\n\n\x0b\n\x03\x04e\x01\x12\x04\xc8\x12\x08\x10\nT\n\x04\
    \x04e\x02\0\x12\x04\xcb\x12\x02\x1e\x1aF\x20PodCIDR\x20represents\x20the\
    \x20pod\x20IP\x20range\x20assigned\x20to\x20the\x20node.\n\x20+optional\
    \n\n\r\n\x05\x04e\x02\0\x04\x12\x04\xcb\x12\x02\n\n\r\n\x05\x04e\x02\0\
    \x05\x12\x04\xcb\x12\x0b\x11\n\r\n\x05\x04e\x02\0\x01\x12\x04\xcb\x12\
    \x12\x19\n\r\n\x05\x04e\x02\0\x03\x12\x04\xcb\x12\x1c\x1d\n\x8c\x02\n\
    \x04\x04e\x02\x01\x12\x04\xd2\x12\x02\x1f\x1a\xfd\x01\x20podCIDRs\x20rep\
    resents\x20the\x20IP\x20ranges\x20assigned\x20to\x20the\x20node\x20for\
    \x20usage\x20by\x20Pods\x20on\x20that\x20node.\x20If\x20this\n\x20field\
    \x20is\x20specified,\x20the\x200th\x20entry\x20must\x20match\x20the\x20p\
    odCIDR\x20field.\x20It\x20may\x20contain\x20at\x20most\x201\x20value\x20\
    for\n\x20each\x20of\x20IPv4\x20and\x20IPv6.\n\x20+optional\n\x20+patchSt\
    rategy=merge\n\n\r\n\x05\x04e\x02\x01\x04\x12\x04\xd2\x12\x02\n\n\r\n\
    \x05\x04e\x02\x01\x05\x12\x04\xd2\x12\x0b\x11\n\r\n\x05\x04e\x02\x01\x01\
    \x12\x04\xd2\x12\x12\x1a\n\r\n\x05\x04e\x02\x01\x03\x12\x04\xd2\x12\x1d\
    \x1e\n\x81\x01\n\x04\x04e\x02\x02\x12\x04\xd6\x12\x02!\x1as\x20ID\x20of\
    \x20the\x20node\x20assigned\x20by\x20the\x20cloud\x20provider\x20in\x20t\
    he\x20format:\x20<ProviderName>://<ProviderSpecificNodeID>\n\x20+optiona\
    l\n\n\r\n\x05\x04e\x02\x02\x04\x12\x04\xd6\x12\x02\n\n\r\n\x05\x04e\x02\
    \x02\x05\x12\x04\xd6\x12\x0b\x11\n\r\n\x05\x04e\x02\x02\x01\x12\x04\xd6\
    \x12\x12\x1c\n\r\n\x05\x04e\x02\x02\x03\x12\x04\xd6\x12\x1f\x20\n\xcb\
    \x01\n\x04\x04e\x02\x03\x12\x04\xdb\x12\x02\"\x1a\xbc\x01\x20Unschedulab\
    le\x20controls\x20node\x20schedulability\x20of\x20new\x20pods.\x20By\x20\
    default,\x20node\x20is\x20schedulable.\n\x20More\x20info:\x20https://kub\
    ernetes.io/docs/concepts/nodes/node/#manual-node-administration\n\x20+op\
    tional\n\n\r\n\x05\x04e\x02\x03\x04\x12\x04\xdb\x12\x02\n\n\r\n\x05\x04e\
    \x02\x03\x05\x12\x04\xdb\x12\x0b\x0f\n\r\n\x05\x04e\x02\x03\x01\x12\x04\
    \xdb\x12\x10\x1d\n\r\n\x05\x04e\x02\x03\x03\x12\x04\xdb\x12\x20!\n;\n\
    \x04\x04e\x02\x04\x12\x04\xdf\x12\x02\x1c\x1a-\x20If\x20specified,\x20th\
    e\x20node's\x20taints.\n\x20+optional\n\n\r\n\x05\x04e\x02\x04\x04\x12\
    \x04\xdf\x12\x02\n\n\r\n\x05\x04e\x02\x04\x06\x12\x04\xdf\x12\x0b\x10\n\
    \r\n\x05\x04e\x02\x04\x01\x12\x04\xdf\x12\x11\x17\n\r\n\x05\x04e\x02\x04\
    \x03\x12\x04\xdf\x12\x1a\x1b\n\xac\x01\n\x04\x04e\x02\x05\x12\x04\xe4\
    \x12\x02-\x1a\x9d\x01\x20If\x20specified,\x20the\x20source\x20to\x20get\
    \x20node\x20configuration\x20from\n\x20The\x20DynamicKubeletConfig\x20fe\
    ature\x20gate\x20must\x20be\x20enabled\x20for\x20the\x20Kubelet\x20to\
    \x20use\x20this\x20field\n\x20+optional\n\n\r\n\x05\x04e\x02\x05\x04\x12\
    \x04\xe4\x12\x02\n\n\r\n\x05\x04e\x02\x05\x06\x12\x04\xe4\x12\x0b\x1b\n\
    \r\n\x05\x04e\x02\x05\x01\x12\x04\xe4\x12\x1c(\n\r\n\x05\x04e\x02\x05\
    \x03\x12\x04\xe4\x12+,\n\x87\x01\n\x04\x04e\x02\x06\x12\x04\xe9\x12\x02!\
    \x1ay\x20Deprecated.\x20Not\x20all\x20kubelets\x20will\x20set\x20this\
    \x20field.\x20Remove\x20field\x20after\x201.13.\n\x20see:\x20https://iss\
    ues.k8s.io/61966\n\x20+optional\n\n\r\n\x05\x04e\x02\x06\x04\x12\x04\xe9\
    \x12\x02\n\n\r\n\x05\x04e\x02\x06\x05\x12\x04\xe9\x12\x0b\x11\n\r\n\x05\
    \x04e\x02\x06\x01\x12\x04\xe9\x12\x12\x1c\n\r\n\x05\x04e\x02\x06\x03\x12\
    \x04\xe9\x12\x1f\x20\nM\n\x02\x04f\x12\x06\xed\x12\0\xa8\x13\x01\x1a?\
    \x20NodeStatus\x20is\x20information\x20about\x20the\x20current\x20status\
    \x20of\x20a\x20node.\n\n\x0b\n\x03\x04f\x01\x12\x04\xed\x12\x08\x12\n\
    \xa2\x01\n\x04\x04f\x02\0\x12\x04\xf1\x12\x02J\x1a\x93\x01\x20Capacity\
    \x20represents\x20the\x20total\x20resources\x20of\x20a\x20node.\n\x20Mor\
    e\x20info:\x20https://kubernetes.io/docs/concepts/storage/persistent-vol\
    umes#capacity\n\x20+optional\n\n\x0f\n\x05\x04f\x02\0\x04\x12\x06\xf1\
    \x12\x02\xed\x12\x14\n\r\n\x05\x04f\x02\0\x06\x12\x04\xf1\x12\x02<\n\r\n\
    \x05\x04f\x02\0\x01\x12\x04\xf1\x12=E\n\r\n\x05\x04f\x02\0\x03\x12\x04\
    \xf1\x12HI\n\x83\x01\n\x04\x04f\x02\x01\x12\x04\xf6\x12\x02M\x1au\x20All\
    ocatable\x20represents\x20the\x20resources\x20of\x20a\x20node\x20that\
    \x20are\x20available\x20for\x20scheduling.\n\x20Defaults\x20to\x20Capaci\
    ty.\n\x20+optional\n\n\x0f\n\x05\x04f\x02\x01\x04\x12\x06\xf6\x12\x02\
    \xf1\x12J\n\r\n\x05\x04f\x02\x01\x06\x12\x04\xf6\x12\x02<\n\r\n\x05\x04f\
    \x02\x01\x01\x12\x04\xf6\x12=H\n\r\n\x05\x04f\x02\x01\x03\x12\x04\xf6\
    \x12KL\n\xd3\x01\n\x04\x04f\x02\x02\x12\x04\xfc\x12\x02\x1c\x1a\xc4\x01\
    \x20NodePhase\x20is\x20the\x20recently\x20observed\x20lifecycle\x20phase\
    \x20of\x20the\x20node.\n\x20More\x20info:\x20https://kubernetes.io/docs/\
    concepts/nodes/node/#phase\n\x20The\x20field\x20is\x20never\x20populated\
    ,\x20and\x20now\x20is\x20deprecated.\n\x20+optional\n\n\r\n\x05\x04f\x02\
    \x02\x04\x12\x04\xfc\x12\x02\n\n\r\n\x05\x04f\x02\x02\x05\x12\x04\xfc\
    \x12\x0b\x11\n\r\n\x05\x04f\x02\x02\x01\x12\x04\xfc\x12\x12\x17\n\r\n\
    \x05\x04f\x02\x02\x03\x12\x04\xfc\x12\x1a\x1b\n\xc8\x01\n\x04\x04f\x02\
    \x03\x12\x04\x83\x13\x02(\x1a\xb9\x01\x20Conditions\x20is\x20an\x20array\
    \x20of\x20current\x20observed\x20node\x20conditions.\n\x20More\x20info:\
    \x20https://kubernetes.io/docs/concepts/nodes/node/#condition\n\x20+opti\
    onal\n\x20+patchMergeKey=type\n\x20+patchStrategy=merge\n\n\r\n\x05\x04f\
    \x02\x03\x04\x12\x04\x83\x13\x02\n\n\r\n\x05\x04f\x02\x03\x06\x12\x04\
    \x83\x13\x0b\x18\n\r\n\x05\x04f\x02\x03\x01\x12\x04\x83\x13\x19#\n\r\n\
    \x05\x04f\x02\x03\x03\x12\x04\x83\x13&'\n\xd0\x03\n\x04\x04f\x02\x04\x12\
    \x04\x8e\x13\x02%\x1a\xc1\x03\x20List\x20of\x20addresses\x20reachable\
    \x20to\x20the\x20node.\n\x20Queried\x20from\x20cloud\x20provider,\x20if\
    \x20available.\n\x20More\x20info:\x20https://kubernetes.io/docs/concepts\
    /nodes/node/#addresses\n\x20Note:\x20This\x20field\x20is\x20declared\x20\
    as\x20mergeable,\x20but\x20the\x20merge\x20key\x20is\x20not\x20sufficien\
    tly\n\x20unique,\x20which\x20can\x20cause\x20data\x20corruption\x20when\
    \x20it\x20is\x20merged.\x20Callers\x20should\x20instead\n\x20use\x20a\
    \x20full-replacement\x20patch.\x20See\x20http://pr.k8s.io/79391\x20for\
    \x20an\x20example.\n\x20+optional\n\x20+patchMergeKey=type\n\x20+patchSt\
    rategy=merge\n\n\r\n\x05\x04f\x02\x04\x04\x12\x04\x8e\x13\x02\n\n\r\n\
    \x05\x04f\x02\x04\x06\x12\x04\x8e\x13\x0b\x16\n\r\n\x05\x04f\x02\x04\x01\
    \x12\x04\x8e\x13\x17\x20\n\r\n\x05\x04f\x02\x04\x03\x12\x04\x8e\x13#$\nD\
    \n\x04\x04f\x02\x05\x12\x04\x92\x13\x023\x1a6\x20Endpoints\x20of\x20daem\
    ons\x20running\x20on\x20the\x20Node.\n\x20+optional\n\n\r\n\x05\x04f\x02\
    \x05\x04\x12\x04\x92\x13\x02\n\n\r\n\x05\x04f\x02\x05\x06\x12\x04\x92\
    \x13\x0b\x1e\n\r\n\x05\x04f\x02\x05\x01\x12\x04\x92\x13\x1f.\n\r\n\x05\
    \x04f\x02\x05\x03\x12\x04\x92\x1312\n\x8b\x01\n\x04\x04f\x02\x06\x12\x04\
    \x97\x13\x02'\x1a}\x20Set\x20of\x20ids/uuids\x20to\x20uniquely\x20identi\
    fy\x20the\x20node.\n\x20More\x20info:\x20https://kubernetes.io/docs/conc\
    epts/nodes/node/#info\n\x20+optional\n\n\r\n\x05\x04f\x02\x06\x04\x12\
    \x04\x97\x13\x02\n\n\r\n\x05\x04f\x02\x06\x06\x12\x04\x97\x13\x0b\x19\n\
    \r\n\x05\x04f\x02\x06\x01\x12\x04\x97\x13\x1a\"\n\r\n\x05\x04f\x02\x06\
    \x03\x12\x04\x97\x13%&\n@\n\x04\x04f\x02\x07\x12\x04\x9b\x13\x02%\x1a2\
    \x20List\x20of\x20container\x20images\x20on\x20this\x20node\n\x20+option\
    al\n\n\r\n\x05\x04f\x02\x07\x04\x12\x04\x9b\x13\x02\n\n\r\n\x05\x04f\x02\
    \x07\x06\x12\x04\x9b\x13\x0b\x19\n\r\n\x05\x04f\x02\x07\x01\x12\x04\x9b\
    \x13\x1a\x20\n\r\n\x05\x04f\x02\x07\x03\x12\x04\x9b\x13#$\nS\n\x04\x04f\
    \x02\x08\x12\x04\x9f\x13\x02#\x1aE\x20List\x20of\x20attachable\x20volume\
    s\x20in\x20use\x20(mounted)\x20by\x20the\x20node.\n\x20+optional\n\n\r\n\
    \x05\x04f\x02\x08\x04\x12\x04\x9f\x13\x02\n\n\r\n\x05\x04f\x02\x08\x05\
    \x12\x04\x9f\x13\x0b\x11\n\r\n\x05\x04f\x02\x08\x01\x12\x04\x9f\x13\x12\
    \x1e\n\r\n\x05\x04f\x02\x08\x03\x12\x04\x9f\x13!\"\nI\n\x04\x04f\x02\t\
    \x12\x04\xa3\x13\x02/\x1a;\x20List\x20of\x20volumes\x20that\x20are\x20at\
    tached\x20to\x20the\x20node.\n\x20+optional\n\n\r\n\x05\x04f\x02\t\x04\
    \x12\x04\xa3\x13\x02\n\n\r\n\x05\x04f\x02\t\x06\x12\x04\xa3\x13\x0b\x19\
    \n\r\n\x05\x04f\x02\t\x01\x12\x04\xa3\x13\x1a)\n\r\n\x05\x04f\x02\t\x03\
    \x12\x04\xa3\x13,.\nl\n\x04\x04f\x02\n\x12\x04\xa7\x13\x02(\x1a^\x20Stat\
    us\x20of\x20the\x20config\x20assigned\x20to\x20the\x20node\x20via\x20the\
    \x20dynamic\x20Kubelet\x20config\x20feature.\n\x20+optional\n\n\r\n\x05\
    \x04f\x02\n\x04\x12\x04\xa7\x13\x02\n\n\r\n\x05\x04f\x02\n\x06\x12\x04\
    \xa7\x13\x0b\x1b\n\r\n\x05\x04f\x02\n\x01\x12\x04\xa7\x13\x1c\"\n\r\n\
    \x05\x04f\x02\n\x03\x12\x04\xa7\x13%'\nS\n\x02\x04g\x12\x06\xab\x13\0\
    \xcd\x13\x01\x1aE\x20NodeSystemInfo\x20is\x20a\x20set\x20of\x20ids/uuids\
    \x20to\x20uniquely\x20identify\x20the\x20node.\n\n\x0b\n\x03\x04g\x01\
    \x12\x04\xab\x13\x08\x16\n\xd6\x01\n\x04\x04g\x02\0\x12\x04\xaf\x13\x02\
    \x20\x1a\xc7\x01\x20MachineID\x20reported\x20by\x20the\x20node.\x20For\
    \x20unique\x20machine\x20identification\n\x20in\x20the\x20cluster\x20thi\
    s\x20field\x20is\x20preferred.\x20Learn\x20more\x20from\x20man(5)\n\x20m\
    achine-id:\x20http://man7.org/linux/man-pages/man5/machine-id.5.html\n\n\
    \r\n\x05\x04g\x02\0\x04\x12\x04\xaf\x13\x02\n\n\r\n\x05\x04g\x02\0\x05\
    \x12\x04\xaf\x13\x0b\x11\n\r\n\x05\x04g\x02\0\x01\x12\x04\xaf\x13\x12\
    \x1b\n\r\n\x05\x04g\x02\0\x03\x12\x04\xaf\x13\x1e\x1f\n\xf4\x01\n\x04\
    \x04g\x02\x01\x12\x04\xb4\x13\x02!\x1a\xe5\x01\x20SystemUUID\x20reported\
    \x20by\x20the\x20node.\x20For\x20unique\x20machine\x20identification\n\
    \x20MachineID\x20is\x20preferred.\x20This\x20field\x20is\x20specific\x20\
    to\x20Red\x20Hat\x20hosts\n\x20https://access.redhat.com/documentation/e\
    n-us/red_hat_subscription_management/1/html/rhsm/uuid\n\n\r\n\x05\x04g\
    \x02\x01\x04\x12\x04\xb4\x13\x02\n\n\r\n\x05\x04g\x02\x01\x05\x12\x04\
    \xb4\x13\x0b\x11\n\r\n\x05\x04g\x02\x01\x01\x12\x04\xb4\x13\x12\x1c\n\r\
    \n\x05\x04g\x02\x01\x03\x12\x04\xb4\x13\x1f\x20\n-\n\x04\x04g\x02\x02\
    \x12\x04\xb7\x13\x02\x1d\x1a\x1f\x20Boot\x20ID\x20reported\x20by\x20the\
    \x20node.\n\n\r\n\x05\x04g\x02\x02\x04\x12\x04\xb7\x13\x02\n\n\r\n\x05\
    \x04g\x02\x02\x05\x12\x04\xb7\x13\x0b\x11\n\r\n\x05\x04g\x02\x02\x01\x12\
    \x04\xb7\x13\x12\x18\n\r\n\x05\x04g\x02\x02\x03\x12\x04\xb7\x13\x1b\x1c\
    \n`\n\x04\x04g\x02\x03\x12\x04\xba\x13\x02$\x1aR\x20Kernel\x20Version\
    \x20reported\x20by\x20the\x20node\x20from\x20'uname\x20-r'\x20(e.g.\x203\
    .16.0-0.bpo.4-amd64).\n\n\r\n\x05\x04g\x02\x03\x04\x12\x04\xba\x13\x02\n\
    \n\r\n\x05\x04g\x02\x03\x05\x12\x04\xba\x13\x0b\x11\n\r\n\x05\x04g\x02\
    \x03\x01\x12\x04\xba\x13\x12\x1f\n\r\n\x05\x04g\x02\x03\x03\x12\x04\xba\
    \x13\"#\nf\n\x04\x04g\x02\x04\x12\x04\xbd\x13\x02\x1e\x1aX\x20OS\x20Imag\
    e\x20reported\x20by\x20the\x20node\x20from\x20/etc/os-release\x20(e.g.\
    \x20Debian\x20GNU/Linux\x207\x20(wheezy)).\n\n\r\n\x05\x04g\x02\x04\x04\
    \x12\x04\xbd\x13\x02\n\n\r\n\x05\x04g\x02\x04\x05\x12\x04\xbd\x13\x0b\
    \x11\n\r\n\x05\x04g\x02\x04\x01\x12\x04\xbd\x13\x12\x19\n\r\n\x05\x04g\
    \x02\x04\x03\x12\x04\xbd\x13\x1c\x1d\no\n\x04\x04g\x02\x05\x12\x04\xc0\
    \x13\x02.\x1aa\x20ContainerRuntime\x20Version\x20reported\x20by\x20the\
    \x20node\x20through\x20runtime\x20remote\x20API\x20(e.g.\x20docker://1.5\
    .0).\n\n\r\n\x05\x04g\x02\x05\x04\x12\x04\xc0\x13\x02\n\n\r\n\x05\x04g\
    \x02\x05\x05\x12\x04\xc0\x13\x0b\x11\n\r\n\x05\x04g\x02\x05\x01\x12\x04\
    \xc0\x13\x12)\n\r\n\x05\x04g\x02\x05\x03\x12\x04\xc0\x13,-\n5\n\x04\x04g\
    \x02\x06\x12\x04\xc3\x13\x02%\x1a'\x20Kubelet\x20Version\x20reported\x20\
    by\x20the\x20node.\n\n\r\n\x05\x04g\x02\x06\x04\x12\x04\xc3\x13\x02\n\n\
    \r\n\x05\x04g\x02\x06\x05\x12\x04\xc3\x13\x0b\x11\n\r\n\x05\x04g\x02\x06\
    \x01\x12\x04\xc3\x13\x12\x20\n\r\n\x05\x04g\x02\x06\x03\x12\x04\xc3\x13#\
    $\n7\n\x04\x04g\x02\x07\x12\x04\xc6\x13\x02'\x1a)\x20KubeProxy\x20Versio\
    n\x20reported\x20by\x20the\x20node.\n\n\r\n\x05\x04g\x02\x07\x04\x12\x04\
    \xc6\x13\x02\n\n\r\n\x05\x04g\x02\x07\x05\x12\x04\xc6\x13\x0b\x11\n\r\n\
    \x05\x04g\x02\x07\x01\x12\x04\xc6\x13\x12\"\n\r\n\x05\x04g\x02\x07\x03\
    \x12\x04\xc6\x13%&\n9\n\x04\x04g\x02\x08\x12\x04\xc9\x13\x02&\x1a+\x20Th\
    e\x20Operating\x20System\x20reported\x20by\x20the\x20node\n\n\r\n\x05\
    \x04g\x02\x08\x04\x12\x04\xc9\x13\x02\n\n\r\n\x05\x04g\x02\x08\x05\x12\
    \x04\xc9\x13\x0b\x11\n\r\n\x05\x04g\x02\x08\x01\x12\x04\xc9\x13\x12!\n\r\
    \n\x05\x04g\x02\x08\x03\x12\x04\xc9\x13$%\n5\n\x04\x04g\x02\t\x12\x04\
    \xcc\x13\x02$\x1a'\x20The\x20Architecture\x20reported\x20by\x20the\x20no\
    de\n\n\r\n\x05\x04g\x02\t\x04\x12\x04\xcc\x13\x02\n\n\r\n\x05\x04g\x02\t\
    \x05\x12\x04\xcc\x13\x0b\x11\n\r\n\x05\x04g\x02\t\x01\x12\x04\xcc\x13\
    \x12\x1e\n\r\n\x05\x04g\x02\t\x03\x12\x04\xcc\x13!#\nO\n\x02\x04h\x12\
    \x06\xd0\x13\0\xd7\x13\x01\x1aA\x20ObjectFieldSelector\x20selects\x20an\
    \x20APIVersioned\x20field\x20of\x20an\x20object.\n\n\x0b\n\x03\x04h\x01\
    \x12\x04\xd0\x13\x08\x1b\nh\n\x04\x04h\x02\0\x12\x04\xd3\x13\x02!\x1aZ\
    \x20Version\x20of\x20the\x20schema\x20the\x20FieldPath\x20is\x20written\
    \x20in\x20terms\x20of,\x20defaults\x20to\x20\"v1\".\n\x20+optional\n\n\r\
    \n\x05\x04h\x02\0\x04\x12\x04\xd3\x13\x02\n\n\r\n\x05\x04h\x02\0\x05\x12\
    \x04\xd3\x13\x0b\x11\n\r\n\x05\x04h\x02\0\x01\x12\x04\xd3\x13\x12\x1c\n\
    \r\n\x05\x04h\x02\0\x03\x12\x04\xd3\x13\x1f\x20\nI\n\x04\x04h\x02\x01\
    \x12\x04\xd6\x13\x02\x20\x1a;\x20Path\x20of\x20the\x20field\x20to\x20sel\
    ect\x20in\x20the\x20specified\x20API\x20version.\n\n\r\n\x05\x04h\x02\
    \x01\x04\x12\x04\xd6\x13\x02\n\n\r\n\x05\x04h\x02\x01\x05\x12\x04\xd6\
    \x13\x0b\x11\n\r\n\x05\x04h\x02\x01\x01\x12\x04\xd6\x13\x12\x1b\n\r\n\
    \x05\x04h\x02\x01\x03\x12\x04\xd6\x13\x1e\x1f\n\x9d\r\n\x02\x04i\x12\x06\
    \xe9\x13\0\x91\x14\x01\x1a\x8e\r\x20ObjectReference\x20contains\x20enoug\
    h\x20information\x20to\x20let\x20you\x20inspect\x20or\x20modify\x20the\
    \x20referred\x20object.\n\x20---\n\x20New\x20uses\x20of\x20this\x20type\
    \x20are\x20discouraged\x20because\x20of\x20difficulty\x20describing\x20i\
    ts\x20usage\x20when\x20embedded\x20in\x20APIs.\n\x20\x201.\x20Ignored\
    \x20fields.\x20\x20It\x20includes\x20many\x20fields\x20which\x20are\x20n\
    ot\x20generally\x20honored.\x20\x20For\x20instance,\x20ResourceVersion\
    \x20and\x20FieldPath\x20are\x20both\x20very\x20rarely\x20valid\x20in\x20\
    actual\x20usage.\n\x20\x202.\x20Invalid\x20usage\x20help.\x20\x20It\x20i\
    s\x20impossible\x20to\x20add\x20specific\x20help\x20for\x20individual\
    \x20usage.\x20\x20In\x20most\x20embedded\x20usages,\x20there\x20are\x20p\
    articular\n\x20\x20\x20\x20\x20restrictions\x20like,\x20\"must\x20refer\
    \x20only\x20to\x20types\x20A\x20and\x20B\"\x20or\x20\"UID\x20not\x20hono\
    red\"\x20or\x20\"name\x20must\x20be\x20restricted\".\n\x20\x20\x20\x20\
    \x20Those\x20cannot\x20be\x20well\x20described\x20when\x20embedded.\n\
    \x20\x203.\x20Inconsistent\x20validation.\x20\x20Because\x20the\x20usage\
    s\x20are\x20different,\x20the\x20validation\x20rules\x20are\x20different\
    \x20by\x20usage,\x20which\x20makes\x20it\x20hard\x20for\x20users\x20to\
    \x20predict\x20what\x20will\x20happen.\n\x20\x204.\x20The\x20fields\x20a\
    re\x20both\x20imprecise\x20and\x20overly\x20precise.\x20\x20Kind\x20is\
    \x20not\x20a\x20precise\x20mapping\x20to\x20a\x20URL.\x20This\x20can\x20\
    produce\x20ambiguity\n\x20\x20\x20\x20\x20during\x20interpretation\x20an\
    d\x20require\x20a\x20REST\x20mapping.\x20\x20In\x20most\x20cases,\x20the\
    \x20dependency\x20is\x20on\x20the\x20group,resource\x20tuple\n\x20\x20\
    \x20\x20\x20and\x20the\x20version\x20of\x20the\x20actual\x20struct\x20is\
    \x20irrelevant.\n\x20\x205.\x20We\x20cannot\x20easily\x20change\x20it.\
    \x20\x20Because\x20this\x20type\x20is\x20embedded\x20in\x20many\x20locat\
    ions,\x20updates\x20to\x20this\x20type\n\x20\x20\x20\x20\x20will\x20affe\
    ct\x20numerous\x20schemas.\x20\x20Don't\x20make\x20new\x20APIs\x20embed\
    \x20an\x20underspecified\x20API\x20type\x20they\x20do\x20not\x20control.\
    \n\x20Instead\x20of\x20using\x20this\x20type,\x20create\x20a\x20locally\
    \x20provided\x20and\x20used\x20type\x20that\x20is\x20well-focused\x20on\
    \x20your\x20reference.\n\x20For\x20example,\x20ServiceReferences\x20for\
    \x20admission\x20registration:\x20https://github.com/kubernetes/api/blob\
    /release-1.17/admissionregistration/v1/types.go#L533\x20.\n\x20+k8s:deep\
    copy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object\n\n\x0b\n\x03\
    \x04i\x01\x12\x04\xe9\x13\x08\x17\n\x9d\x01\n\x04\x04i\x02\0\x12\x04\xed\
    \x13\x02\x1b\x1a\x8e\x01\x20Kind\x20of\x20the\x20referent.\n\x20More\x20\
    info:\x20https://git.k8s.io/community/contributors/devel/sig-architectur\
    e/api-conventions.md#types-kinds\n\x20+optional\n\n\r\n\x05\x04i\x02\0\
    \x04\x12\x04\xed\x13\x02\n\n\r\n\x05\x04i\x02\0\x05\x12\x04\xed\x13\x0b\
    \x11\n\r\n\x05\x04i\x02\0\x01\x12\x04\xed\x13\x12\x16\n\r\n\x05\x04i\x02\
    \0\x03\x12\x04\xed\x13\x19\x1a\n\x90\x01\n\x04\x04i\x02\x01\x12\x04\xf2\
    \x13\x02\x20\x1a\x81\x01\x20Namespace\x20of\x20the\x20referent.\n\x20Mor\
    e\x20info:\x20https://kubernetes.io/docs/concepts/overview/working-with-\
    objects/namespaces/\n\x20+optional\n\n\r\n\x05\x04i\x02\x01\x04\x12\x04\
    \xf2\x13\x02\n\n\r\n\x05\x04i\x02\x01\x05\x12\x04\xf2\x13\x0b\x11\n\r\n\
    \x05\x04i\x02\x01\x01\x12\x04\xf2\x13\x12\x1b\n\r\n\x05\x04i\x02\x01\x03\
    \x12\x04\xf2\x13\x1e\x1f\n\x8b\x01\n\x04\x04i\x02\x02\x12\x04\xf7\x13\
    \x02\x1b\x1a}\x20Name\x20of\x20the\x20referent.\n\x20More\x20info:\x20ht\
    tps://kubernetes.io/docs/concepts/overview/working-with-objects/names/#n\
    ames\n\x20+optional\n\n\r\n\x05\x04i\x02\x02\x04\x12\x04\xf7\x13\x02\n\n\
    \r\n\x05\x04i\x02\x02\x05\x12\x04\xf7\x13\x0b\x11\n\r\n\x05\x04i\x02\x02\
    \x01\x12\x04\xf7\x13\x12\x16\n\r\n\x05\x04i\x02\x02\x03\x12\x04\xf7\x13\
    \x19\x1a\n\x89\x01\n\x04\x04i\x02\x03\x12\x04\xfc\x13\x02\x1a\x1a{\x20UI\
    D\x20of\x20the\x20referent.\n\x20More\x20info:\x20https://kubernetes.io/\
    docs/concepts/overview/working-with-objects/names/#uids\n\x20+optional\n\
    \n\r\n\x05\x04i\x02\x03\x04\x12\x04\xfc\x13\x02\n\n\r\n\x05\x04i\x02\x03\
    \x05\x12\x04\xfc\x13\x0b\x11\n\r\n\x05\x04i\x02\x03\x01\x12\x04\xfc\x13\
    \x12\x15\n\r\n\x05\x04i\x02\x03\x03\x12\x04\xfc\x13\x18\x19\n7\n\x04\x04\
    i\x02\x04\x12\x04\x80\x14\x02!\x1a)\x20API\x20version\x20of\x20the\x20re\
    ferent.\n\x20+optional\n\n\r\n\x05\x04i\x02\x04\x04\x12\x04\x80\x14\x02\
    \n\n\r\n\x05\x04i\x02\x04\x05\x12\x04\x80\x14\x0b\x11\n\r\n\x05\x04i\x02\
    \x04\x01\x12\x04\x80\x14\x12\x1c\n\r\n\x05\x04i\x02\x04\x03\x12\x04\x80\
    \x14\x1f\x20\n\xe1\x01\n\x04\x04i\x02\x05\x12\x04\x85\x14\x02&\x1a\xd2\
    \x01\x20Specific\x20resourceVersion\x20to\x20which\x20this\x20reference\
    \x20is\x20made,\x20if\x20any.\n\x20More\x20info:\x20https://git.k8s.io/c\
    ommunity/contributors/devel/sig-architecture/api-conventions.md#concurre\
    ncy-control-and-consistency\n\x20+optional\n\n\r\n\x05\x04i\x02\x05\x04\
    \x12\x04\x85\x14\x02\n\n\r\n\x05\x04i\x02\x05\x05\x12\x04\x85\x14\x0b\
    \x11\n\r\n\x05\x04i\x02\x05\x01\x12\x04\x85\x14\x12!\n\r\n\x05\x04i\x02\
    \x05\x03\x12\x04\x85\x14$%\n\xad\x05\n\x04\x04i\x02\x06\x12\x04\x90\x14\
    \x02\x20\x1a\x9e\x05\x20If\x20referring\x20to\x20a\x20piece\x20of\x20an\
    \x20object\x20instead\x20of\x20an\x20entire\x20object,\x20this\x20string\
    \n\x20should\x20contain\x20a\x20valid\x20JSON/Go\x20field\x20access\x20s\
    tatement,\x20such\x20as\x20desiredState.manifest.containers[2].\n\x20For\
    \x20example,\x20if\x20the\x20object\x20reference\x20is\x20to\x20a\x20con\
    tainer\x20within\x20a\x20pod,\x20this\x20would\x20take\x20on\x20a\x20val\
    ue\x20like:\n\x20\"spec.containers{name}\"\x20(where\x20\"name\"\x20refe\
    rs\x20to\x20the\x20name\x20of\x20the\x20container\x20that\x20triggered\n\
    \x20the\x20event)\x20or\x20if\x20no\x20container\x20name\x20is\x20specif\
    ied\x20\"spec.containers[2]\"\x20(container\x20with\n\x20index\x202\x20i\
    n\x20this\x20pod).\x20This\x20syntax\x20is\x20chosen\x20only\x20to\x20ha\
    ve\x20some\x20well-defined\x20way\x20of\n\x20referencing\x20a\x20part\
    \x20of\x20an\x20object.\n\x20TODO:\x20this\x20design\x20is\x20not\x20fin\
    al\x20and\x20this\x20field\x20is\x20subject\x20to\x20change\x20in\x20the\
    \x20future.\n\x20+optional\n\n\r\n\x05\x04i\x02\x06\x04\x12\x04\x90\x14\
    \x02\n\n\r\n\x05\x04i\x02\x06\x05\x12\x04\x90\x14\x0b\x11\n\r\n\x05\x04i\
    \x02\x06\x01\x12\x04\x90\x14\x12\x1b\n\r\n\x05\x04i\x02\x06\x03\x12\x04\
    \x90\x14\x1e\x1f\n\xc4\x01\n\x02\x04j\x12\x06\x96\x14\0\xa8\x14\x01\x1a\
    \xb5\x01\x20PersistentVolume\x20(PV)\x20is\x20a\x20storage\x20resource\
    \x20provisioned\x20by\x20an\x20administrator.\n\x20It\x20is\x20analogous\
    \x20to\x20a\x20node.\n\x20More\x20info:\x20https://kubernetes.io/docs/co\
    ncepts/storage/persistent-volumes\n\n\x0b\n\x03\x04j\x01\x12\x04\x96\x14\
    \x08\x18\n\xa0\x01\n\x04\x04j\x02\0\x12\x04\x9a\x14\x02H\x1a\x91\x01\x20\
    Standard\x20object's\x20metadata.\n\x20More\x20info:\x20https://git.k8s.\
    io/community/contributors/devel/sig-architecture/api-conventions.md#meta\
    data\n\x20+optional\n\n\r\n\x05\x04j\x02\0\x04\x12\x04\x9a\x14\x02\n\n\r\
    \n\x05\x04j\x02\0\x06\x12\x04\x9a\x14\x0b:\n\r\n\x05\x04j\x02\0\x01\x12\
    \x04\x9a\x14;C\n\r\n\x05\x04j\x02\0\x03\x12\x04\x9a\x14FG\n\xe5\x01\n\
    \x04\x04j\x02\x01\x12\x04\xa0\x14\x02)\x1a\xd6\x01\x20Spec\x20defines\
    \x20a\x20specification\x20of\x20a\x20persistent\x20volume\x20owned\x20by\
    \x20the\x20cluster.\n\x20Provisioned\x20by\x20an\x20administrator.\n\x20\
    More\x20info:\x20https://kubernetes.io/docs/concepts/storage/persistent-\
    volumes#persistent-volumes\n\x20+optional\n\n\r\n\x05\x04j\x02\x01\x04\
    \x12\x04\xa0\x14\x02\n\n\r\n\x05\x04j\x02\x01\x06\x12\x04\xa0\x14\x0b\
    \x1f\n\r\n\x05\x04j\x02\x01\x01\x12\x04\xa0\x14\x20$\n\r\n\x05\x04j\x02\
    \x01\x03\x12\x04\xa0\x14'(\n\xeb\x01\n\x04\x04j\x02\x02\x12\x04\xa7\x14\
    \x02-\x1a\xdc\x01\x20Status\x20represents\x20the\x20current\x20informati\
    on/status\x20for\x20the\x20persistent\x20volume.\n\x20Populated\x20by\
    \x20the\x20system.\n\x20Read-only.\n\x20More\x20info:\x20https://kuberne\
    tes.io/docs/concepts/storage/persistent-volumes#persistent-volumes\n\x20\
    +optional\n\n\r\n\x05\x04j\x02\x02\x04\x12\x04\xa7\x14\x02\n\n\r\n\x05\
    \x04j\x02\x02\x06\x12\x04\xa7\x14\x0b!\n\r\n\x05\x04j\x02\x02\x01\x12\
    \x04\xa7\x14\"(\n\r\n\x05\x04j\x02\x02\x03\x12\x04\xa7\x14+,\n^\n\x02\
    \x04k\x12\x06\xab\x14\0\xbb\x14\x01\x1aP\x20PersistentVolumeClaim\x20is\
    \x20a\x20user's\x20request\x20for\x20and\x20claim\x20to\x20a\x20persiste\
    nt\x20volume\n\n\x0b\n\x03\x04k\x01\x12\x04\xab\x14\x08\x1d\n\xa0\x01\n\
    \x04\x04k\x02\0\x12\x04\xaf\x14\x02H\x1a\x91\x01\x20Standard\x20object's\
    \x20metadata.\n\x20More\x20info:\x20https://git.k8s.io/community/contrib\
    utors/devel/sig-architecture/api-conventions.md#metadata\n\x20+optional\
    \n\n\r\n\x05\x04k\x02\0\x04\x12\x04\xaf\x14\x02\n\n\r\n\x05\x04k\x02\0\
    \x06\x12\x04\xaf\x14\x0b:\n\r\n\x05\x04k\x02\0\x01\x12\x04\xaf\x14;C\n\r\
    \n\x05\x04k\x02\0\x03\x12\x04\xaf\x14FG\n\xcd\x01\n\x04\x04k\x02\x01\x12\
    \x04\xb4\x14\x02.\x1a\xbe\x01\x20Spec\x20defines\x20the\x20desired\x20ch\
    aracteristics\x20of\x20a\x20volume\x20requested\x20by\x20a\x20pod\x20aut\
    hor.\n\x20More\x20info:\x20https://kubernetes.io/docs/concepts/storage/p\
    ersistent-volumes#persistentvolumeclaims\n\x20+optional\n\n\r\n\x05\x04k\
    \x02\x01\x04\x12\x04\xb4\x14\x02\n\n\r\n\x05\x04k\x02\x01\x06\x12\x04\
    \xb4\x14\x0b$\n\r\n\x05\x04k\x02\x01\x01\x12\x04\xb4\x14%)\n\r\n\x05\x04\
    k\x02\x01\x03\x12\x04\xb4\x14,-\n\xd8\x01\n\x04\x04k\x02\x02\x12\x04\xba\
    \x14\x022\x1a\xc9\x01\x20Status\x20represents\x20the\x20current\x20infor\
    mation/status\x20of\x20a\x20persistent\x20volume\x20claim.\n\x20Read-onl\
    y.\n\x20More\x20info:\x20https://kubernetes.io/docs/concepts/storage/per\
    sistent-volumes#persistentvolumeclaims\n\x20+optional\n\n\r\n\x05\x04k\
    \x02\x02\x04\x12\x04\xba\x14\x02\n\n\r\n\x05\x04k\x02\x02\x06\x12\x04\
    \xba\x14\x0b&\n\r\n\x05\x04k\x02\x02\x01\x12\x04\xba\x14'-\n\r\n\x05\x04\
    k\x02\x02\x03\x12\x04\xba\x1401\nR\n\x02\x04l\x12\x06\xbe\x14\0\xd4\x14\
    \x01\x1aD\x20PersistentVolumeClaimCondition\x20contails\x20details\x20ab\
    out\x20state\x20of\x20pvc\n\n\x0b\n\x03\x04l\x01\x12\x04\xbe\x14\x08&\n\
    \x0c\n\x04\x04l\x02\0\x12\x04\xbf\x14\x02\x1b\n\r\n\x05\x04l\x02\0\x04\
    \x12\x04\xbf\x14\x02\n\n\r\n\x05\x04l\x02\0\x05\x12\x04\xbf\x14\x0b\x11\
    \n\r\n\x05\x04l\x02\0\x01\x12\x04\xbf\x14\x12\x16\n\r\n\x05\x04l\x02\0\
    \x03\x12\x04\xbf\x14\x19\x1a\n\x0c\n\x04\x04l\x02\x01\x12\x04\xc1\x14\
    \x02\x1d\n\r\n\x05\x04l\x02\x01\x04\x12\x04\xc1\x14\x02\n\n\r\n\x05\x04l\
    \x02\x01\x05\x12\x04\xc1\x14\x0b\x11\n\r\n\x05\x04l\x02\x01\x01\x12\x04\
    \xc1\x14\x12\x18\n\r\n\x05\x04l\x02\x01\x03\x12\x04\xc1\x14\x1b\x1c\n=\n\
    \x04\x04l\x02\x02\x12\x04\xc5\x14\x02G\x1a/\x20Last\x20time\x20we\x20pro\
    bed\x20the\x20condition.\n\x20+optional\n\n\r\n\x05\x04l\x02\x02\x04\x12\
    \x04\xc5\x14\x02\n\n\r\n\x05\x04l\x02\x02\x06\x12\x04\xc5\x14\x0b4\n\r\n\
    \x05\x04l\x02\x02\x01\x12\x04\xc5\x145B\n\r\n\x05\x04l\x02\x02\x03\x12\
    \x04\xc5\x14EF\n[\n\x04\x04l\x02\x03\x12\x04\xc9\x14\x02L\x1aM\x20Last\
    \x20time\x20the\x20condition\x20transitioned\x20from\x20one\x20status\
    \x20to\x20another.\n\x20+optional\n\n\r\n\x05\x04l\x02\x03\x04\x12\x04\
    \xc9\x14\x02\n\n\r\n\x05\x04l\x02\x03\x06\x12\x04\xc9\x14\x0b4\n\r\n\x05\
    \x04l\x02\x03\x01\x12\x04\xc9\x145G\n\r\n\x05\x04l\x02\x03\x03\x12\x04\
    \xc9\x14JK\n\xee\x01\n\x04\x04l\x02\x04\x12\x04\xcf\x14\x02\x1d\x1a\xdf\
    \x01\x20Unique,\x20this\x20should\x20be\x20a\x20short,\x20machine\x20und\
    erstandable\x20string\x20that\x20gives\x20the\x20reason\n\x20for\x20cond\
    ition's\x20last\x20transition.\x20If\x20it\x20reports\x20\"ResizeStarted\
    \"\x20that\x20means\x20the\x20underlying\n\x20persistent\x20volume\x20is\
    \x20being\x20resized.\n\x20+optional\n\n\r\n\x05\x04l\x02\x04\x04\x12\
    \x04\xcf\x14\x02\n\n\r\n\x05\x04l\x02\x04\x05\x12\x04\xcf\x14\x0b\x11\n\
    \r\n\x05\x04l\x02\x04\x01\x12\x04\xcf\x14\x12\x18\n\r\n\x05\x04l\x02\x04\
    \x03\x12\x04\xcf\x14\x1b\x1c\n[\n\x04\x04l\x02\x05\x12\x04\xd3\x14\x02\
    \x1e\x1aM\x20Human-readable\x20message\x20indicating\x20details\x20about\
    \x20last\x20transition.\n\x20+optional\n\n\r\n\x05\x04l\x02\x05\x04\x12\
    \x04\xd3\x14\x02\n\n\r\n\x05\x04l\x02\x05\x05\x12\x04\xd3\x14\x0b\x11\n\
    \r\n\x05\x04l\x02\x05\x01\x12\x04\xd3\x14\x12\x19\n\r\n\x05\x04l\x02\x05\
    \x03\x12\x04\xd3\x14\x1c\x1d\nS\n\x02\x04m\x12\x06\xd7\x14\0\xe0\x14\x01\
    \x1aE\x20PersistentVolumeClaimList\x20is\x20a\x20list\x20of\x20Persisten\
    tVolumeClaim\x20items.\n\n\x0b\n\x03\x04m\x01\x12\x04\xd7\x14\x08!\n\x9f\
    \x01\n\x04\x04m\x02\0\x12\x04\xdb\x14\x02F\x1a\x90\x01\x20Standard\x20li\
    st\x20metadata.\n\x20More\x20info:\x20https://git.k8s.io/community/contr\
    ibutors/devel/sig-architecture/api-conventions.md#types-kinds\n\x20+opti\
    onal\n\n\r\n\x05\x04m\x02\0\x04\x12\x04\xdb\x14\x02\n\n\r\n\x05\x04m\x02\
    \0\x06\x12\x04\xdb\x14\x0b8\n\r\n\x05\x04m\x02\0\x01\x12\x04\xdb\x149A\n\
    \r\n\x05\x04m\x02\0\x03\x12\x04\xdb\x14DE\n\x96\x01\n\x04\x04m\x02\x01\
    \x12\x04\xdf\x14\x02+\x1a\x87\x01\x20A\x20list\x20of\x20persistent\x20vo\
    lume\x20claims.\n\x20More\x20info:\x20https://kubernetes.io/docs/concept\
    s/storage/persistent-volumes#persistentvolumeclaims\n\n\r\n\x05\x04m\x02\
    \x01\x04\x12\x04\xdf\x14\x02\n\n\r\n\x05\x04m\x02\x01\x06\x12\x04\xdf\
    \x14\x0b\x20\n\r\n\x05\x04m\x02\x01\x01\x12\x04\xdf\x14!&\n\r\n\x05\x04m\
    \x02\x01\x03\x12\x04\xdf\x14)*\n\x93\x01\n\x02\x04n\x12\x06\xe4\x14\0\
    \x8b\x15\x01\x1a\x84\x01\x20PersistentVolumeClaimSpec\x20describes\x20th\
    e\x20common\x20attributes\x20of\x20storage\x20devices\n\x20and\x20allows\
    \x20a\x20Source\x20for\x20provider-specific\x20attributes\n\n\x0b\n\x03\
    \x04n\x01\x12\x04\xe4\x14\x08!\n\xbb\x01\n\x04\x04n\x02\0\x12\x04\xe8\
    \x14\x02\"\x1a\xac\x01\x20AccessModes\x20contains\x20the\x20desired\x20a\
    ccess\x20modes\x20the\x20volume\x20should\x20have.\n\x20More\x20info:\
    \x20https://kubernetes.io/docs/concepts/storage/persistent-volumes#acces\
    s-modes-1\n\x20+optional\n\n\r\n\x05\x04n\x02\0\x04\x12\x04\xe8\x14\x02\
    \n\n\r\n\x05\x04n\x02\0\x05\x12\x04\xe8\x14\x0b\x11\n\r\n\x05\x04n\x02\0\
    \x01\x12\x04\xe8\x14\x12\x1d\n\r\n\x05\x04n\x02\0\x03\x12\x04\xe8\x14\
    \x20!\nN\n\x04\x04n\x02\x01\x12\x04\xec\x14\x02K\x1a@\x20A\x20label\x20q\
    uery\x20over\x20volumes\x20to\x20consider\x20for\x20binding.\n\x20+optio\
    nal\n\n\r\n\x05\x04n\x02\x01\x04\x12\x04\xec\x14\x02\n\n\r\n\x05\x04n\
    \x02\x01\x06\x12\x04\xec\x14\x0b=\n\r\n\x05\x04n\x02\x01\x01\x12\x04\xec\
    \x14>F\n\r\n\x05\x04n\x02\x01\x03\x12\x04\xec\x14IJ\n\xb3\x01\n\x04\x04n\
    \x02\x02\x12\x04\xf1\x14\x02.\x1a\xa4\x01\x20Resources\x20represents\x20\
    the\x20minimum\x20resources\x20the\x20volume\x20should\x20have.\n\x20Mor\
    e\x20info:\x20https://kubernetes.io/docs/concepts/storage/persistent-vol\
    umes#resources\n\x20+optional\n\n\r\n\x05\x04n\x02\x02\x04\x12\x04\xf1\
    \x14\x02\n\n\r\n\x05\x04n\x02\x02\x06\x12\x04\xf1\x14\x0b\x1f\n\r\n\x05\
    \x04n\x02\x02\x01\x12\x04\xf1\x14\x20)\n\r\n\x05\x04n\x02\x02\x03\x12\
    \x04\xf1\x14,-\nj\n\x04\x04n\x02\x03\x12\x04\xf5\x14\x02!\x1a\\\x20Volum\
    eName\x20is\x20the\x20binding\x20reference\x20to\x20the\x20PersistentVol\
    ume\x20backing\x20this\x20claim.\n\x20+optional\n\n\r\n\x05\x04n\x02\x03\
    \x04\x12\x04\xf5\x14\x02\n\n\r\n\x05\x04n\x02\x03\x05\x12\x04\xf5\x14\
    \x0b\x11\n\r\n\x05\x04n\x02\x03\x01\x12\x04\xf5\x14\x12\x1c\n\r\n\x05\
    \x04n\x02\x03\x03\x12\x04\xf5\x14\x1f\x20\n\x9e\x01\n\x04\x04n\x02\x04\
    \x12\x04\xfa\x14\x02'\x1a\x8f\x01\x20Name\x20of\x20the\x20StorageClass\
    \x20required\x20by\x20the\x20claim.\n\x20More\x20info:\x20https://kubern\
    etes.io/docs/concepts/storage/persistent-volumes#class-1\n\x20+optional\
    \n\n\r\n\x05\x04n\x02\x04\x04\x12\x04\xfa\x14\x02\n\n\r\n\x05\x04n\x02\
    \x04\x05\x12\x04\xfa\x14\x0b\x11\n\r\n\x05\x04n\x02\x04\x01\x12\x04\xfa\
    \x14\x12\"\n\r\n\x05\x04n\x02\x04\x03\x12\x04\xfa\x14%&\n\x9d\x01\n\x04\
    \x04n\x02\x05\x12\x04\xff\x14\x02!\x1a\x8e\x01\x20volumeMode\x20defines\
    \x20what\x20type\x20of\x20volume\x20is\x20required\x20by\x20the\x20claim\
    .\n\x20Value\x20of\x20Filesystem\x20is\x20implied\x20when\x20not\x20incl\
    uded\x20in\x20claim\x20spec.\n\x20+optional\n\n\r\n\x05\x04n\x02\x05\x04\
    \x12\x04\xff\x14\x02\n\n\r\n\x05\x04n\x02\x05\x05\x12\x04\xff\x14\x0b\
    \x11\n\r\n\x05\x04n\x02\x05\x01\x12\x04\xff\x14\x12\x1c\n\r\n\x05\x04n\
    \x02\x05\x03\x12\x04\xff\x14\x1f\x20\n\xa9\x04\n\x04\x04n\x02\x06\x12\
    \x04\x8a\x15\x024\x1a\x9a\x04\x20This\x20field\x20can\x20be\x20used\x20t\
    o\x20specify\x20either:\n\x20*\x20An\x20existing\x20VolumeSnapshot\x20ob\
    ject\x20(snapshot.storage.k8s.io/VolumeSnapshot)\n\x20*\x20An\x20existin\
    g\x20PVC\x20(PersistentVolumeClaim)\n\x20*\x20An\x20existing\x20custom\
    \x20resource\x20that\x20implements\x20data\x20population\x20(Alpha)\n\
    \x20In\x20order\x20to\x20use\x20custom\x20resource\x20types\x20that\x20i\
    mplement\x20data\x20population,\n\x20the\x20AnyVolumeDataSource\x20featu\
    re\x20gate\x20must\x20be\x20enabled.\n\x20If\x20the\x20provisioner\x20or\
    \x20an\x20external\x20controller\x20can\x20support\x20the\x20specified\
    \x20data\x20source,\n\x20it\x20will\x20create\x20a\x20new\x20volume\x20b\
    ased\x20on\x20the\x20contents\x20of\x20the\x20specified\x20data\x20sourc\
    e.\n\x20+optional\n\n\r\n\x05\x04n\x02\x06\x04\x12\x04\x8a\x15\x02\n\n\r\
    \n\x05\x04n\x02\x06\x06\x12\x04\x8a\x15\x0b$\n\r\n\x05\x04n\x02\x06\x01\
    \x12\x04\x8a\x15%/\n\r\n\x05\x04n\x02\x06\x03\x12\x04\x8a\x1523\n_\n\x02\
    \x04o\x12\x06\x8e\x15\0\xa2\x15\x01\x1aQ\x20PersistentVolumeClaimStatus\
    \x20is\x20the\x20current\x20status\x20of\x20a\x20persistent\x20volume\
    \x20claim.\n\n\x0b\n\x03\x04o\x01\x12\x04\x8e\x15\x08#\nW\n\x04\x04o\x02\
    \0\x12\x04\x91\x15\x02\x1c\x1aI\x20Phase\x20represents\x20the\x20current\
    \x20phase\x20of\x20PersistentVolumeClaim.\n\x20+optional\n\n\r\n\x05\x04\
    o\x02\0\x04\x12\x04\x91\x15\x02\n\n\r\n\x05\x04o\x02\0\x05\x12\x04\x91\
    \x15\x0b\x11\n\r\n\x05\x04o\x02\0\x01\x12\x04\x91\x15\x12\x17\n\r\n\x05\
    \x04o\x02\0\x03\x12\x04\x91\x15\x1a\x1b\n\xc2\x01\n\x04\x04o\x02\x01\x12\
    \x04\x96\x15\x02\"\x1a\xb3\x01\x20AccessModes\x20contains\x20the\x20actu\
    al\x20access\x20modes\x20the\x20volume\x20backing\x20the\x20PVC\x20has.\
    \n\x20More\x20info:\x20https://kubernetes.io/docs/concepts/storage/persi\
    stent-volumes#access-modes-1\n\x20+optional\n\n\r\n\x05\x04o\x02\x01\x04\
    \x12\x04\x96\x15\x02\n\n\r\n\x05\x04o\x02\x01\x05\x12\x04\x96\x15\x0b\
    \x11\n\r\n\x05\x04o\x02\x01\x01\x12\x04\x96\x15\x12\x1d\n\r\n\x05\x04o\
    \x02\x01\x03\x12\x04\x96\x15\x20!\nT\n\x04\x04o\x02\x02\x12\x04\x9a\x15\
    \x02J\x1aF\x20Represents\x20the\x20actual\x20resources\x20of\x20the\x20u\
    nderlying\x20volume.\n\x20+optional\n\n\x0f\n\x05\x04o\x02\x02\x04\x12\
    \x06\x9a\x15\x02\x96\x15\"\n\r\n\x05\x04o\x02\x02\x06\x12\x04\x9a\x15\
    \x02<\n\r\n\x05\x04o\x02\x02\x01\x12\x04\x9a\x15=E\n\r\n\x05\x04o\x02\
    \x02\x03\x12\x04\x9a\x15HI\n\xd9\x01\n\x04\x04o\x02\x03\x12\x04\xa1\x15\
    \x029\x1a\xca\x01\x20Current\x20Condition\x20of\x20persistent\x20volume\
    \x20claim.\x20If\x20underlying\x20persistent\x20volume\x20is\x20being\n\
    \x20resized\x20then\x20the\x20Condition\x20will\x20be\x20set\x20to\x20'R\
    esizeStarted'.\n\x20+optional\n\x20+patchMergeKey=type\n\x20+patchStrate\
    gy=merge\n\n\r\n\x05\x04o\x02\x03\x04\x12\x04\xa1\x15\x02\n\n\r\n\x05\
    \x04o\x02\x03\x06\x12\x04\xa1\x15\x0b)\n\r\n\x05\x04o\x02\x03\x01\x12\
    \x04\xa1\x15*4\n\r\n\x05\x04o\x02\x03\x03\x12\x04\xa1\x1578\n\x84\x01\n\
    \x02\x04p\x12\x06\xa6\x15\0\xb3\x15\x01\x1av\x20PersistentVolumeClaimTem\
    plate\x20is\x20used\x20to\x20produce\n\x20PersistentVolumeClaim\x20objec\
    ts\x20as\x20part\x20of\x20an\x20EphemeralVolumeSource.\n\n\x0b\n\x03\x04\
    p\x01\x12\x04\xa6\x15\x08%\n\xb8\x01\n\x04\x04p\x02\0\x12\x04\xac\x15\
    \x02H\x1a\xa9\x01\x20May\x20contain\x20labels\x20and\x20annotations\x20t\
    hat\x20will\x20be\x20copied\x20into\x20the\x20PVC\n\x20when\x20creating\
    \x20it.\x20No\x20other\x20fields\x20are\x20allowed\x20and\x20will\x20be\
    \x20rejected\x20during\n\x20validation.\n\n\x20+optional\n\n\r\n\x05\x04\
    p\x02\0\x04\x12\x04\xac\x15\x02\n\n\r\n\x05\x04p\x02\0\x06\x12\x04\xac\
    \x15\x0b:\n\r\n\x05\x04p\x02\0\x01\x12\x04\xac\x15;C\n\r\n\x05\x04p\x02\
    \0\x03\x12\x04\xac\x15FG\n\xe1\x01\n\x04\x04p\x02\x01\x12\x04\xb2\x15\
    \x02.\x1a\xd2\x01\x20The\x20specification\x20for\x20the\x20PersistentVol\
    umeClaim.\x20The\x20entire\x20content\x20is\n\x20copied\x20unchanged\x20\
    into\x20the\x20PVC\x20that\x20gets\x20created\x20from\x20this\n\x20templ\
    ate.\x20The\x20same\x20fields\x20as\x20in\x20a\x20PersistentVolumeClaim\
    \n\x20are\x20also\x20valid\x20here.\n\n\r\n\x05\x04p\x02\x01\x04\x12\x04\
    \xb2\x15\x02\n\n\r\n\x05\x04p\x02\x01\x06\x12\x04\xb2\x15\x0b$\n\r\n\x05\
    \x04p\x02\x01\x01\x12\x04\xb2\x15%)\n\r\n\x05\x04p\x02\x01\x03\x12\x04\
    \xb2\x15,-\n\xb2\x02\n\x02\x04q\x12\x06\xb9\x15\0\xc2\x15\x01\x1a\xa3\
    \x02\x20PersistentVolumeClaimVolumeSource\x20references\x20the\x20user's\
    \x20PVC\x20in\x20the\x20same\x20namespace.\n\x20This\x20volume\x20finds\
    \x20the\x20bound\x20PV\x20and\x20mounts\x20that\x20volume\x20for\x20the\
    \x20pod.\x20A\n\x20PersistentVolumeClaimVolumeSource\x20is,\x20essential\
    ly,\x20a\x20wrapper\x20around\x20another\n\x20type\x20of\x20volume\x20th\
    at\x20is\x20owned\x20by\x20someone\x20else\x20(the\x20system).\n\n\x0b\n\
    \x03\x04q\x01\x12\x04\xb9\x15\x08)\n\xd7\x01\n\x04\x04q\x02\0\x12\x04\
    \xbc\x15\x02\x20\x1a\xc8\x01\x20ClaimName\x20is\x20the\x20name\x20of\x20\
    a\x20PersistentVolumeClaim\x20in\x20the\x20same\x20namespace\x20as\x20th\
    e\x20pod\x20using\x20this\x20volume.\n\x20More\x20info:\x20https://kuber\
    netes.io/docs/concepts/storage/persistent-volumes#persistentvolumeclaims\
    \n\n\r\n\x05\x04q\x02\0\x04\x12\x04\xbc\x15\x02\n\n\r\n\x05\x04q\x02\0\
    \x05\x12\x04\xbc\x15\x0b\x11\n\r\n\x05\x04q\x02\0\x01\x12\x04\xbc\x15\
    \x12\x1b\n\r\n\x05\x04q\x02\0\x03\x12\x04\xbc\x15\x1e\x1f\n[\n\x04\x04q\
    \x02\x01\x12\x04\xc1\x15\x02\x1d\x1aM\x20Will\x20force\x20the\x20ReadOnl\
    y\x20setting\x20in\x20VolumeMounts.\n\x20Default\x20false.\n\x20+optiona\
    l\n\n\r\n\x05\x04q\x02\x01\x04\x12\x04\xc1\x15\x02\n\n\r\n\x05\x04q\x02\
    \x01\x05\x12\x04\xc1\x15\x0b\x0f\n\r\n\x05\x04q\x02\x01\x01\x12\x04\xc1\
    \x15\x10\x18\n\r\n\x05\x04q\x02\x01\x03\x12\x04\xc1\x15\x1b\x1c\nI\n\x02\
    \x04r\x12\x06\xc5\x15\0\xce\x15\x01\x1a;\x20PersistentVolumeList\x20is\
    \x20a\x20list\x20of\x20PersistentVolume\x20items.\n\n\x0b\n\x03\x04r\x01\
    \x12\x04\xc5\x15\x08\x1c\n\x9f\x01\n\x04\x04r\x02\0\x12\x04\xc9\x15\x02F\
    \x1a\x90\x01\x20Standard\x20list\x20metadata.\n\x20More\x20info:\x20http\
    s://git.k8s.io/community/contributors/devel/sig-architecture/api-convent\
    ions.md#types-kinds\n\x20+optional\n\n\r\n\x05\x04r\x02\0\x04\x12\x04\
    \xc9\x15\x02\n\n\r\n\x05\x04r\x02\0\x06\x12\x04\xc9\x15\x0b8\n\r\n\x05\
    \x04r\x02\0\x01\x12\x04\xc9\x159A\n\r\n\x05\x04r\x02\0\x03\x12\x04\xc9\
    \x15DE\nv\n\x04\x04r\x02\x01\x12\x04\xcd\x15\x02&\x1ah\x20List\x20of\x20\
    persistent\x20volumes.\n\x20More\x20info:\x20https://kubernetes.io/docs/\
    concepts/storage/persistent-volumes\n\n\r\n\x05\x04r\x02\x01\x04\x12\x04\
    \xcd\x15\x02\n\n\r\n\x05\x04r\x02\x01\x06\x12\x04\xcd\x15\x0b\x1b\n\r\n\
    \x05\x04r\x02\x01\x01\x12\x04\xcd\x15\x1c!\n\r\n\x05\x04r\x02\x01\x03\
    \x12\x04\xcd\x15$%\n\x9c\x01\n\x02\x04s\x12\x06\xd2\x15\0\xb9\x16\x01\
    \x1a\x8d\x01\x20PersistentVolumeSource\x20is\x20similar\x20to\x20VolumeS\
    ource\x20but\x20meant\x20for\x20the\n\x20administrator\x20who\x20creates\
    \x20PVs.\x20Exactly\x20one\x20of\x20its\x20members\x20must\x20be\x20set.\
    \n\n\x0b\n\x03\x04s\x01\x12\x04\xd2\x15\x08\x1e\n\x82\x02\n\x04\x04s\x02\
    \0\x12\x04\xd7\x15\x02?\x1a\xf3\x01\x20GCEPersistentDisk\x20represents\
    \x20a\x20GCE\x20Disk\x20resource\x20that\x20is\x20attached\x20to\x20a\n\
    \x20kubelet's\x20host\x20machine\x20and\x20then\x20exposed\x20to\x20the\
    \x20pod.\x20Provisioned\x20by\x20an\x20admin.\n\x20More\x20info:\x20http\
    s://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk\n\x20+\
    optional\n\n\r\n\x05\x04s\x02\0\x04\x12\x04\xd7\x15\x02\n\n\r\n\x05\x04s\
    \x02\0\x06\x12\x04\xd7\x15\x0b(\n\r\n\x05\x04s\x02\0\x01\x12\x04\xd7\x15\
    ):\n\r\n\x05\x04s\x02\0\x03\x12\x04\xd7\x15=>\n\xf0\x01\n\x04\x04s\x02\
    \x01\x12\x04\xdd\x15\x02E\x1a\xe1\x01\x20AWSElasticBlockStore\x20represe\
    nts\x20an\x20AWS\x20Disk\x20resource\x20that\x20is\x20attached\x20to\x20\
    a\n\x20kubelet's\x20host\x20machine\x20and\x20then\x20exposed\x20to\x20t\
    he\x20pod.\n\x20More\x20info:\x20https://kubernetes.io/docs/concepts/sto\
    rage/volumes#awselasticblockstore\n\x20+optional\n\n\r\n\x05\x04s\x02\
    \x01\x04\x12\x04\xdd\x15\x02\n\n\r\n\x05\x04s\x02\x01\x06\x12\x04\xdd\
    \x15\x0b+\n\r\n\x05\x04s\x02\x01\x01\x12\x04\xdd\x15,@\n\r\n\x05\x04s\
    \x02\x01\x03\x12\x04\xdd\x15CD\n\xce\x02\n\x04\x04s\x02\x02\x12\x04\xe5\
    \x15\x02-\x1a\xbf\x02\x20HostPath\x20represents\x20a\x20directory\x20on\
    \x20the\x20host.\n\x20Provisioned\x20by\x20a\x20developer\x20or\x20teste\
    r.\n\x20This\x20is\x20useful\x20for\x20single-node\x20development\x20and\
    \x20testing\x20only!\n\x20On-host\x20storage\x20is\x20not\x20supported\
    \x20in\x20any\x20way\x20and\x20WILL\x20NOT\x20WORK\x20in\x20a\x20multi-n\
    ode\x20cluster.\n\x20More\x20info:\x20https://kubernetes.io/docs/concept\
    s/storage/volumes#hostpath\n\x20+optional\n\n\r\n\x05\x04s\x02\x02\x04\
    \x12\x04\xe5\x15\x02\n\n\r\n\x05\x04s\x02\x02\x06\x12\x04\xe5\x15\x0b\
    \x1f\n\r\n\x05\x04s\x02\x02\x01\x12\x04\xe5\x15\x20(\n\r\n\x05\x04s\x02\
    \x02\x03\x12\x04\xe5\x15+,\n\xd0\x01\n\x04\x04s\x02\x03\x12\x04\xeb\x15\
    \x029\x1a\xc1\x01\x20Glusterfs\x20represents\x20a\x20Glusterfs\x20volume\
    \x20that\x20is\x20attached\x20to\x20a\x20host\x20and\n\x20exposed\x20to\
    \x20the\x20pod.\x20Provisioned\x20by\x20an\x20admin.\n\x20More\x20info:\
    \x20https://examples.k8s.io/volumes/glusterfs/README.md\n\x20+optional\n\
    \n\r\n\x05\x04s\x02\x03\x04\x12\x04\xeb\x15\x02\n\n\r\n\x05\x04s\x02\x03\
    \x06\x12\x04\xeb\x15\x0b*\n\r\n\x05\x04s\x02\x03\x01\x12\x04\xeb\x15+4\n\
    \r\n\x05\x04s\x02\x03\x03\x12\x04\xeb\x1578\n\xa1\x01\n\x04\x04s\x02\x04\
    \x12\x04\xf0\x15\x02#\x1a\x92\x01\x20NFS\x20represents\x20an\x20NFS\x20m\
    ount\x20on\x20the\x20host.\x20Provisioned\x20by\x20an\x20admin.\n\x20Mor\
    e\x20info:\x20https://kubernetes.io/docs/concepts/storage/volumes#nfs\n\
    \x20+optional\n\n\r\n\x05\x04s\x02\x04\x04\x12\x04\xf0\x15\x02\n\n\r\n\
    \x05\x04s\x02\x04\x06\x12\x04\xf0\x15\x0b\x1a\n\r\n\x05\x04s\x02\x04\x01\
    \x12\x04\xf0\x15\x1b\x1e\n\r\n\x05\x04s\x02\x04\x03\x12\x04\xf0\x15!\"\n\
    \xa9\x01\n\x04\x04s\x02\x05\x12\x04\xf5\x15\x02-\x1a\x9a\x01\x20RBD\x20r\
    epresents\x20a\x20Rados\x20Block\x20Device\x20mount\x20on\x20the\x20host\
    \x20that\x20shares\x20a\x20pod's\x20lifetime.\n\x20More\x20info:\x20http\
    s://examples.k8s.io/volumes/rbd/README.md\n\x20+optional\n\n\r\n\x05\x04\
    s\x02\x05\x04\x12\x04\xf5\x15\x02\n\n\r\n\x05\x04s\x02\x05\x06\x12\x04\
    \xf5\x15\x0b$\n\r\n\x05\x04s\x02\x05\x01\x12\x04\xf5\x15%(\n\r\n\x05\x04\
    s\x02\x05\x03\x12\x04\xf5\x15+,\n\xa7\x01\n\x04\x04s\x02\x06\x12\x04\xfa\
    \x15\x021\x1a\x98\x01\x20ISCSI\x20represents\x20an\x20ISCSI\x20Disk\x20r\
    esource\x20that\x20is\x20attached\x20to\x20a\n\x20kubelet's\x20host\x20m\
    achine\x20and\x20then\x20exposed\x20to\x20the\x20pod.\x20Provisioned\x20\
    by\x20an\x20admin.\n\x20+optional\n\n\r\n\x05\x04s\x02\x06\x04\x12\x04\
    \xfa\x15\x02\n\n\r\n\x05\x04s\x02\x06\x06\x12\x04\xfa\x15\x0b&\n\r\n\x05\
    \x04s\x02\x06\x01\x12\x04\xfa\x15',\n\r\n\x05\x04s\x02\x06\x03\x12\x04\
    \xfa\x15/0\n\xaa\x01\n\x04\x04s\x02\x07\x12\x04\xff\x15\x023\x1a\x9b\x01\
    \x20Cinder\x20represents\x20a\x20cinder\x20volume\x20attached\x20and\x20\
    mounted\x20on\x20kubelets\x20host\x20machine.\n\x20More\x20info:\x20http\
    s://examples.k8s.io/mysql-cinder-pd/README.md\n\x20+optional\n\n\r\n\x05\
    \x04s\x02\x07\x04\x12\x04\xff\x15\x02\n\n\r\n\x05\x04s\x02\x07\x06\x12\
    \x04\xff\x15\x0b'\n\r\n\x05\x04s\x02\x07\x01\x12\x04\xff\x15(.\n\r\n\x05\
    \x04s\x02\x07\x03\x12\x04\xff\x1512\ne\n\x04\x04s\x02\x08\x12\x04\x83\
    \x16\x023\x1aW\x20CephFS\x20represents\x20a\x20Ceph\x20FS\x20mount\x20on\
    \x20the\x20host\x20that\x20shares\x20a\x20pod's\x20lifetime\n\x20+option\
    al\n\n\r\n\x05\x04s\x02\x08\x04\x12\x04\x83\x16\x02\n\n\r\n\x05\x04s\x02\
    \x08\x06\x12\x04\x83\x16\x0b'\n\r\n\x05\x04s\x02\x08\x01\x12\x04\x83\x16\
    (.\n\r\n\x05\x04s\x02\x08\x03\x12\x04\x83\x1612\n\x8b\x01\n\x04\x04s\x02\
    \t\x12\x04\x87\x16\x02\"\x1a}\x20FC\x20represents\x20a\x20Fibre\x20Chann\
    el\x20resource\x20that\x20is\x20attached\x20to\x20a\x20kubelet's\x20host\
    \x20machine\x20and\x20then\x20exposed\x20to\x20the\x20pod.\n\x20+optiona\
    l\n\n\r\n\x05\x04s\x02\t\x04\x12\x04\x87\x16\x02\n\n\r\n\x05\x04s\x02\t\
    \x06\x12\x04\x87\x16\x0b\x19\n\r\n\x05\x04s\x02\t\x01\x12\x04\x87\x16\
    \x1a\x1c\n\r\n\x05\x04s\x02\t\x03\x12\x04\x87\x16\x1f!\n\xc4\x01\n\x04\
    \x04s\x02\n\x12\x04\x8b\x16\x02,\x1a\xb5\x01\x20Flocker\x20represents\
    \x20a\x20Flocker\x20volume\x20attached\x20to\x20a\x20kubelet's\x20host\
    \x20machine\x20and\x20exposed\x20to\x20the\x20pod\x20for\x20its\x20usage\
    .\x20This\x20depends\x20on\x20the\x20Flocker\x20control\x20service\x20be\
    ing\x20running\n\x20+optional\n\n\r\n\x05\x04s\x02\n\x04\x12\x04\x8b\x16\
    \x02\n\n\r\n\x05\x04s\x02\n\x06\x12\x04\x8b\x16\x0b\x1e\n\r\n\x05\x04s\
    \x02\n\x01\x12\x04\x8b\x16\x1f&\n\r\n\x05\x04s\x02\n\x03\x12\x04\x8b\x16\
    )+\n\x84\x01\n\x04\x04s\x02\x0b\x12\x04\x90\x16\x026\x1av\x20FlexVolume\
    \x20represents\x20a\x20generic\x20volume\x20resource\x20that\x20is\n\x20\
    provisioned/attached\x20using\x20an\x20exec\x20based\x20plugin.\n\x20+op\
    tional\n\n\r\n\x05\x04s\x02\x0b\x04\x12\x04\x90\x16\x02\n\n\r\n\x05\x04s\
    \x02\x0b\x06\x12\x04\x90\x16\x0b%\n\r\n\x05\x04s\x02\x0b\x01\x12\x04\x90\
    \x16&0\n\r\n\x05\x04s\x02\x0b\x03\x12\x04\x90\x1635\nr\n\x04\x04s\x02\
    \x0c\x12\x04\x94\x16\x02:\x1ad\x20AzureFile\x20represents\x20an\x20Azure\
    \x20File\x20Service\x20mount\x20on\x20the\x20host\x20and\x20bind\x20moun\
    t\x20to\x20the\x20pod.\n\x20+optional\n\n\r\n\x05\x04s\x02\x0c\x04\x12\
    \x04\x94\x16\x02\n\n\r\n\x05\x04s\x02\x0c\x06\x12\x04\x94\x16\x0b*\n\r\n\
    \x05\x04s\x02\x0c\x01\x12\x04\x94\x16+4\n\r\n\x05\x04s\x02\x0c\x03\x12\
    \x04\x94\x1679\nr\n\x04\x04s\x02\r\x12\x04\x98\x16\x02=\x1ad\x20VsphereV\
    olume\x20represents\x20a\x20vSphere\x20volume\x20attached\x20and\x20moun\
    ted\x20on\x20kubelets\x20host\x20machine\n\x20+optional\n\n\r\n\x05\x04s\
    \x02\r\x04\x12\x04\x98\x16\x02\n\n\r\n\x05\x04s\x02\r\x06\x12\x04\x98\
    \x16\x0b)\n\r\n\x05\x04s\x02\r\x01\x12\x04\x98\x16*7\n\r\n\x05\x04s\x02\
    \r\x03\x12\x04\x98\x16:<\nf\n\x04\x04s\x02\x0e\x12\x04\x9c\x16\x02,\x1aX\
    \x20Quobyte\x20represents\x20a\x20Quobyte\x20mount\x20on\x20the\x20host\
    \x20that\x20shares\x20a\x20pod's\x20lifetime\n\x20+optional\n\n\r\n\x05\
    \x04s\x02\x0e\x04\x12\x04\x9c\x16\x02\n\n\r\n\x05\x04s\x02\x0e\x06\x12\
    \x04\x9c\x16\x0b\x1e\n\r\n\x05\x04s\x02\x0e\x01\x12\x04\x9c\x16\x1f&\n\r\
    \n\x05\x04s\x02\x0e\x03\x12\x04\x9c\x16)+\no\n\x04\x04s\x02\x0f\x12\x04\
    \xa0\x16\x020\x1aa\x20AzureDisk\x20represents\x20an\x20Azure\x20Data\x20\
    Disk\x20mount\x20on\x20the\x20host\x20and\x20bind\x20mount\x20to\x20the\
    \x20pod.\n\x20+optional\n\n\r\n\x05\x04s\x02\x0f\x04\x12\x04\xa0\x16\x02\
    \n\n\r\n\x05\x04s\x02\x0f\x06\x12\x04\xa0\x16\x0b\x20\n\r\n\x05\x04s\x02\
    \x0f\x01\x12\x04\xa0\x16!*\n\r\n\x05\x04s\x02\x0f\x03\x12\x04\xa0\x16-/\
    \n\x80\x01\n\x04\x04s\x02\x10\x12\x04\xa3\x16\x02F\x1ar\x20PhotonPersist\
    entDisk\x20represents\x20a\x20PhotonController\x20persistent\x20disk\x20\
    attached\x20and\x20mounted\x20on\x20kubelets\x20host\x20machine\n\n\r\n\
    \x05\x04s\x02\x10\x04\x12\x04\xa3\x16\x02\n\n\r\n\x05\x04s\x02\x10\x06\
    \x12\x04\xa3\x16\x0b+\n\r\n\x05\x04s\x02\x10\x01\x12\x04\xa3\x16,@\n\r\n\
    \x05\x04s\x02\x10\x03\x12\x04\xa3\x16CE\nt\n\x04\x04s\x02\x11\x12\x04\
    \xa7\x16\x024\x1af\x20PortworxVolume\x20represents\x20a\x20portworx\x20v\
    olume\x20attached\x20and\x20mounted\x20on\x20kubelets\x20host\x20machine\
    \n\x20+optional\n\n\r\n\x05\x04s\x02\x11\x04\x12\x04\xa7\x16\x02\n\n\r\n\
    \x05\x04s\x02\x11\x06\x12\x04\xa7\x16\x0b\x1f\n\r\n\x05\x04s\x02\x11\x01\
    \x12\x04\xa7\x16\x20.\n\r\n\x05\x04s\x02\x11\x03\x12\x04\xa7\x1613\ns\n\
    \x04\x04s\x02\x12\x12\x04\xab\x16\x026\x1ae\x20ScaleIO\x20represents\x20\
    a\x20ScaleIO\x20persistent\x20volume\x20attached\x20and\x20mounted\x20on\
    \x20Kubernetes\x20nodes.\n\x20+optional\n\n\r\n\x05\x04s\x02\x12\x04\x12\
    \x04\xab\x16\x02\n\n\r\n\x05\x04s\x02\x12\x06\x12\x04\xab\x16\x0b(\n\r\n\
    \x05\x04s\x02\x12\x01\x12\x04\xab\x16)0\n\r\n\x05\x04s\x02\x12\x03\x12\
    \x04\xab\x1635\nX\n\x04\x04s\x02\x13\x12\x04\xaf\x16\x02(\x1aJ\x20Local\
    \x20represents\x20directly-attached\x20storage\x20with\x20node\x20affini\
    ty\n\x20+optional\n\n\r\n\x05\x04s\x02\x13\x04\x12\x04\xaf\x16\x02\n\n\r\
    \n\x05\x04s\x02\x13\x06\x12\x04\xaf\x16\x0b\x1c\n\r\n\x05\x04s\x02\x13\
    \x01\x12\x04\xaf\x16\x1d\"\n\r\n\x05\x04s\x02\x13\x03\x12\x04\xaf\x16%'\
    \n\xcb\x01\n\x04\x04s\x02\x14\x12\x04\xb4\x16\x02:\x1a\xbc\x01\x20Storag\
    eOS\x20represents\x20a\x20StorageOS\x20volume\x20that\x20is\x20attached\
    \x20to\x20the\x20kubelet's\x20host\x20machine\x20and\x20mounted\x20into\
    \x20the\x20pod\n\x20More\x20info:\x20https://examples.k8s.io/volumes/sto\
    rageos/README.md\n\x20+optional\n\n\r\n\x05\x04s\x02\x14\x04\x12\x04\xb4\
    \x16\x02\n\n\r\n\x05\x04s\x02\x14\x06\x12\x04\xb4\x16\x0b*\n\r\n\x05\x04\
    s\x02\x14\x01\x12\x04\xb4\x16+4\n\r\n\x05\x04s\x02\x14\x03\x12\x04\xb4\
    \x1679\nk\n\x04\x04s\x02\x15\x12\x04\xb8\x16\x02.\x1a]\x20CSI\x20represe\
    nts\x20storage\x20that\x20is\x20handled\x20by\x20an\x20external\x20CSI\
    \x20driver\x20(Beta\x20feature).\n\x20+optional\n\n\r\n\x05\x04s\x02\x15\
    \x04\x12\x04\xb8\x16\x02\n\n\r\n\x05\x04s\x02\x15\x06\x12\x04\xb8\x16\
    \x0b$\n\r\n\x05\x04s\x02\x15\x01\x12\x04\xb8\x16%(\n\r\n\x05\x04s\x02\
    \x15\x03\x12\x04\xb8\x16+-\nQ\n\x02\x04t\x12\x06\xbc\x16\0\xed\x16\x01\
    \x1aC\x20PersistentVolumeSpec\x20is\x20the\x20specification\x20of\x20a\
    \x20persistent\x20volume.\n\n\x0b\n\x03\x04t\x01\x12\x04\xbc\x16\x08\x1c\
    \n\xb0\x01\n\x04\x04t\x02\0\x12\x04\xc0\x16\x02J\x1a\xa1\x01\x20A\x20des\
    cription\x20of\x20the\x20persistent\x20volume's\x20resources\x20and\x20c\
    apacity.\n\x20More\x20info:\x20https://kubernetes.io/docs/concepts/stora\
    ge/persistent-volumes#capacity\n\x20+optional\n\n\x0f\n\x05\x04t\x02\0\
    \x04\x12\x06\xc0\x16\x02\xbc\x16\x1e\n\r\n\x05\x04t\x02\0\x06\x12\x04\
    \xc0\x16\x02<\n\r\n\x05\x04t\x02\0\x01\x12\x04\xc0\x16=E\n\r\n\x05\x04t\
    \x02\0\x03\x12\x04\xc0\x16HI\n@\n\x04\x04t\x02\x01\x12\x04\xc3\x16\x02=\
    \x1a2\x20The\x20actual\x20volume\x20backing\x20the\x20persistent\x20volu\
    me.\n\n\r\n\x05\x04t\x02\x01\x04\x12\x04\xc3\x16\x02\n\n\r\n\x05\x04t\
    \x02\x01\x06\x12\x04\xc3\x16\x0b!\n\r\n\x05\x04t\x02\x01\x01\x12\x04\xc3\
    \x16\"8\n\r\n\x05\x04t\x02\x01\x03\x12\x04\xc3\x16;<\n\xac\x01\n\x04\x04\
    t\x02\x02\x12\x04\xc8\x16\x02\"\x1a\x9d\x01\x20AccessModes\x20contains\
    \x20all\x20ways\x20the\x20volume\x20can\x20be\x20mounted.\n\x20More\x20i\
    nfo:\x20https://kubernetes.io/docs/concepts/storage/persistent-volumes#a\
    ccess-modes\n\x20+optional\n\n\r\n\x05\x04t\x02\x02\x04\x12\x04\xc8\x16\
    \x02\n\n\r\n\x05\x04t\x02\x02\x05\x12\x04\xc8\x16\x0b\x11\n\r\n\x05\x04t\
    \x02\x02\x01\x12\x04\xc8\x16\x12\x1d\n\r\n\x05\x04t\x02\x02\x03\x12\x04\
    \xc8\x16\x20!\n\xb3\x02\n\x04\x04t\x02\x03\x12\x04\xcf\x16\x02(\x1a\xa4\
    \x02\x20ClaimRef\x20is\x20part\x20of\x20a\x20bi-directional\x20binding\
    \x20between\x20PersistentVolume\x20and\x20PersistentVolumeClaim.\n\x20Ex\
    pected\x20to\x20be\x20non-nil\x20when\x20bound.\n\x20claim.VolumeName\
    \x20is\x20the\x20authoritative\x20bind\x20between\x20PV\x20and\x20PVC.\n\
    \x20More\x20info:\x20https://kubernetes.io/docs/concepts/storage/persist\
    ent-volumes#binding\n\x20+optional\n\n\r\n\x05\x04t\x02\x03\x04\x12\x04\
    \xcf\x16\x02\n\n\r\n\x05\x04t\x02\x03\x06\x12\x04\xcf\x16\x0b\x1a\n\r\n\
    \x05\x04t\x02\x03\x01\x12\x04\xcf\x16\x1b#\n\r\n\x05\x04t\x02\x03\x03\
    \x12\x04\xcf\x16&'\n\xac\x03\n\x04\x04t\x02\x04\x12\x04\xd7\x16\x024\x1a\
    \x9d\x03\x20What\x20happens\x20to\x20a\x20persistent\x20volume\x20when\
    \x20released\x20from\x20its\x20claim.\n\x20Valid\x20options\x20are\x20Re\
    tain\x20(default\x20for\x20manually\x20created\x20PersistentVolumes),\
    \x20Delete\x20(default\n\x20for\x20dynamically\x20provisioned\x20Persist\
    entVolumes),\x20and\x20Recycle\x20(deprecated).\n\x20Recycle\x20must\x20\
    be\x20supported\x20by\x20the\x20volume\x20plugin\x20underlying\x20this\
    \x20PersistentVolume.\n\x20More\x20info:\x20https://kubernetes.io/docs/c\
    oncepts/storage/persistent-volumes#reclaiming\n\x20+optional\n\n\r\n\x05\
    \x04t\x02\x04\x04\x12\x04\xd7\x16\x02\n\n\r\n\x05\x04t\x02\x04\x05\x12\
    \x04\xd7\x16\x0b\x11\n\r\n\x05\x04t\x02\x04\x01\x12\x04\xd7\x16\x12/\n\r\
    \n\x05\x04t\x02\x04\x03\x12\x04\xd7\x1623\n\xa2\x01\n\x04\x04t\x02\x05\
    \x12\x04\xdc\x16\x02'\x1a\x93\x01\x20Name\x20of\x20StorageClass\x20to\
    \x20which\x20this\x20persistent\x20volume\x20belongs.\x20Empty\x20value\
    \n\x20means\x20that\x20this\x20volume\x20does\x20not\x20belong\x20to\x20\
    any\x20StorageClass.\n\x20+optional\n\n\r\n\x05\x04t\x02\x05\x04\x12\x04\
    \xdc\x16\x02\n\n\r\n\x05\x04t\x02\x05\x05\x12\x04\xdc\x16\x0b\x11\n\r\n\
    \x05\x04t\x02\x05\x01\x12\x04\xdc\x16\x12\"\n\r\n\x05\x04t\x02\x05\x03\
    \x12\x04\xdc\x16%&\n\xde\x01\n\x04\x04t\x02\x06\x12\x04\xe2\x16\x02#\x1a\
    \xcf\x01\x20A\x20list\x20of\x20mount\x20options,\x20e.g.\x20[\"ro\",\x20\
    \"soft\"].\x20Not\x20validated\x20-\x20mount\x20will\n\x20simply\x20fail\
    \x20if\x20one\x20is\x20invalid.\n\x20More\x20info:\x20https://kubernetes\
    .io/docs/concepts/storage/persistent-volumes/#mount-options\n\x20+option\
    al\n\n\r\n\x05\x04t\x02\x06\x04\x12\x04\xe2\x16\x02\n\n\r\n\x05\x04t\x02\
    \x06\x05\x12\x04\xe2\x16\x0b\x11\n\r\n\x05\x04t\x02\x06\x01\x12\x04\xe2\
    \x16\x12\x1e\n\r\n\x05\x04t\x02\x06\x03\x12\x04\xe2\x16!\"\n\xc9\x01\n\
    \x04\x04t\x02\x07\x12\x04\xe7\x16\x02!\x1a\xba\x01\x20volumeMode\x20defi\
    nes\x20if\x20a\x20volume\x20is\x20intended\x20to\x20be\x20used\x20with\
    \x20a\x20formatted\x20filesystem\n\x20or\x20to\x20remain\x20in\x20raw\
    \x20block\x20state.\x20Value\x20of\x20Filesystem\x20is\x20implied\x20whe\
    n\x20not\x20included\x20in\x20spec.\n\x20+optional\n\n\r\n\x05\x04t\x02\
    \x07\x04\x12\x04\xe7\x16\x02\n\n\r\n\x05\x04t\x02\x07\x05\x12\x04\xe7\
    \x16\x0b\x11\n\r\n\x05\x04t\x02\x07\x01\x12\x04\xe7\x16\x12\x1c\n\r\n\
    \x05\x04t\x02\x07\x03\x12\x04\xe7\x16\x1f\x20\n\xb8\x01\n\x04\x04t\x02\
    \x08\x12\x04\xec\x16\x02/\x1a\xa9\x01\x20NodeAffinity\x20defines\x20cons\
    traints\x20that\x20limit\x20what\x20nodes\x20this\x20volume\x20can\x20be\
    \x20accessed\x20from.\n\x20This\x20field\x20influences\x20the\x20schedul\
    ing\x20of\x20pods\x20that\x20use\x20this\x20volume.\n\x20+optional\n\n\r\
    \n\x05\x04t\x02\x08\x04\x12\x04\xec\x16\x02\n\n\r\n\x05\x04t\x02\x08\x06\
    \x12\x04\xec\x16\x0b\x1d\n\r\n\x05\x04t\x02\x08\x01\x12\x04\xec\x16\x1e*\
    \n\r\n\x05\x04t\x02\x08\x03\x12\x04\xec\x16-.\nT\n\x02\x04u\x12\x06\xf0\
    \x16\0\xfe\x16\x01\x1aF\x20PersistentVolumeStatus\x20is\x20the\x20curren\
    t\x20status\x20of\x20a\x20persistent\x20volume.\n\n\x0b\n\x03\x04u\x01\
    \x12\x04\xf0\x16\x08\x1e\n\xc0\x01\n\x04\x04u\x02\0\x12\x04\xf4\x16\x02\
    \x1c\x1a\xb1\x01\x20Phase\x20indicates\x20if\x20a\x20volume\x20is\x20ava\
    ilable,\x20bound\x20to\x20a\x20claim,\x20or\x20released\x20by\x20a\x20cl\
    aim.\n\x20More\x20info:\x20https://kubernetes.io/docs/concepts/storage/p\
    ersistent-volumes#phase\n\x20+optional\n\n\r\n\x05\x04u\x02\0\x04\x12\
    \x04\xf4\x16\x02\n\n\r\n\x05\x04u\x02\0\x05\x12\x04\xf4\x16\x0b\x11\n\r\
    \n\x05\x04u\x02\0\x01\x12\x04\xf4\x16\x12\x17\n\r\n\x05\x04u\x02\0\x03\
    \x12\x04\xf4\x16\x1a\x1b\nm\n\x04\x04u\x02\x01\x12\x04\xf8\x16\x02\x1e\
    \x1a_\x20A\x20human-readable\x20message\x20indicating\x20details\x20abou\
    t\x20why\x20the\x20volume\x20is\x20in\x20this\x20state.\n\x20+optional\n\
    \n\r\n\x05\x04u\x02\x01\x04\x12\x04\xf8\x16\x02\n\n\r\n\x05\x04u\x02\x01\
    \x05\x12\x04\xf8\x16\x0b\x11\n\r\n\x05\x04u\x02\x01\x01\x12\x04\xf8\x16\
    \x12\x19\n\r\n\x05\x04u\x02\x01\x03\x12\x04\xf8\x16\x1c\x1d\n\x98\x01\n\
    \x04\x04u\x02\x02\x12\x04\xfd\x16\x02\x1d\x1a\x89\x01\x20Reason\x20is\
    \x20a\x20brief\x20CamelCase\x20string\x20that\x20describes\x20any\x20fai\
    lure\x20and\x20is\x20meant\n\x20for\x20machine\x20parsing\x20and\x20tidy\
    \x20display\x20in\x20the\x20CLI.\n\x20+optional\n\n\r\n\x05\x04u\x02\x02\
    \x04\x12\x04\xfd\x16\x02\n\n\r\n\x05\x04u\x02\x02\x05\x12\x04\xfd\x16\
    \x0b\x11\n\r\n\x05\x04u\x02\x02\x01\x12\x04\xfd\x16\x12\x18\n\r\n\x05\
    \x04u\x02\x02\x03\x12\x04\xfd\x16\x1b\x1c\nH\n\x02\x04v\x12\x06\x81\x17\
    \0\x89\x17\x01\x1a:\x20Represents\x20a\x20Photon\x20Controller\x20persis\
    tent\x20disk\x20resource.\n\n\x0b\n\x03\x04v\x01\x12\x04\x81\x17\x08(\nD\
    \n\x04\x04v\x02\0\x12\x04\x83\x17\x02\x1b\x1a6\x20ID\x20that\x20identifi\
    es\x20Photon\x20Controller\x20persistent\x20disk\n\n\r\n\x05\x04v\x02\0\
    \x04\x12\x04\x83\x17\x02\n\n\r\n\x05\x04v\x02\0\x05\x12\x04\x83\x17\x0b\
    \x11\n\r\n\x05\x04v\x02\0\x01\x12\x04\x83\x17\x12\x16\n\r\n\x05\x04v\x02\
    \0\x03\x12\x04\x83\x17\x19\x1a\n\xba\x01\n\x04\x04v\x02\x01\x12\x04\x88\
    \x17\x02\x1d\x1a\xab\x01\x20Filesystem\x20type\x20to\x20mount.\n\x20Must\
    \x20be\x20a\x20filesystem\x20type\x20supported\x20by\x20the\x20host\x20o\
    perating\x20system.\n\x20Ex.\x20\"ext4\",\x20\"xfs\",\x20\"ntfs\".\x20Im\
    plicitly\x20inferred\x20to\x20be\x20\"ext4\"\x20if\x20unspecified.\n\n\r\
    \n\x05\x04v\x02\x01\x04\x12\x04\x88\x17\x02\n\n\r\n\x05\x04v\x02\x01\x05\
    \x12\x04\x88\x17\x0b\x11\n\r\n\x05\x04v\x02\x01\x01\x12\x04\x88\x17\x12\
    \x18\n\r\n\x05\x04v\x02\x01\x03\x12\x04\x88\x17\x1b\x1c\n\x88\x01\n\x02\
    \x04w\x12\x06\x8d\x17\0\x9f\x17\x01\x1az\x20Pod\x20is\x20a\x20collection\
    \x20of\x20containers\x20that\x20can\x20run\x20on\x20a\x20host.\x20This\
    \x20resource\x20is\x20created\n\x20by\x20clients\x20and\x20scheduled\x20\
    onto\x20hosts.\n\n\x0b\n\x03\x04w\x01\x12\x04\x8d\x17\x08\x0b\n\xa0\x01\
    \n\x04\x04w\x02\0\x12\x04\x91\x17\x02H\x1a\x91\x01\x20Standard\x20object\
    's\x20metadata.\n\x20More\x20info:\x20https://git.k8s.io/community/contr\
    ibutors/devel/sig-architecture/api-conventions.md#metadata\n\x20+optiona\
    l\n\n\r\n\x05\x04w\x02\0\x04\x12\x04\x91\x17\x02\n\n\r\n\x05\x04w\x02\0\
    \x06\x12\x04\x91\x17\x0b:\n\r\n\x05\x04w\x02\0\x01\x12\x04\x91\x17;C\n\r\
    \n\x05\x04w\x02\0\x03\x12\x04\x91\x17FG\n\xbd\x01\n\x04\x04w\x02\x01\x12\
    \x04\x96\x17\x02\x1c\x1a\xae\x01\x20Specification\x20of\x20the\x20desire\
    d\x20behavior\x20of\x20the\x20pod.\n\x20More\x20info:\x20https://git.k8s\
    .io/community/contributors/devel/sig-architecture/api-conventions.md#spe\
    c-and-status\n\x20+optional\n\n\r\n\x05\x04w\x02\x01\x04\x12\x04\x96\x17\
    \x02\n\n\r\n\x05\x04w\x02\x01\x06\x12\x04\x96\x17\x0b\x12\n\r\n\x05\x04w\
    \x02\x01\x01\x12\x04\x96\x17\x13\x17\n\r\n\x05\x04w\x02\x01\x03\x12\x04\
    \x96\x17\x1a\x1b\n\xfd\x01\n\x04\x04w\x02\x02\x12\x04\x9e\x17\x02\x20\
    \x1a\xee\x01\x20Most\x20recently\x20observed\x20status\x20of\x20the\x20p\
    od.\n\x20This\x20data\x20may\x20not\x20be\x20up\x20to\x20date.\n\x20Popu\
    lated\x20by\x20the\x20system.\n\x20Read-only.\n\x20More\x20info:\x20http\
    s://git.k8s.io/community/contributors/devel/sig-architecture/api-convent\
    ions.md#spec-and-status\n\x20+optional\n\n\r\n\x05\x04w\x02\x02\x04\x12\
    \x04\x9e\x17\x02\n\n\r\n\x05\x04w\x02\x02\x06\x12\x04\x9e\x17\x0b\x14\n\
    \r\n\x05\x04w\x02\x02\x01\x12\x04\x9e\x17\x15\x1b\n\r\n\x05\x04w\x02\x02\
    \x03\x12\x04\x9e\x17\x1e\x1f\nO\n\x02\x04x\x12\x06\xa2\x17\0\xb8\x17\x01\
    \x1aA\x20Pod\x20affinity\x20is\x20a\x20group\x20of\x20inter\x20pod\x20af\
    finity\x20scheduling\x20rules.\n\n\x0b\n\x03\x04x\x01\x12\x04\xa2\x17\
    \x08\x13\n\x84\x04\n\x04\x04x\x02\0\x12\x04\xab\x17\x02N\x1a\xf5\x03\x20\
    If\x20the\x20affinity\x20requirements\x20specified\x20by\x20this\x20fiel\
    d\x20are\x20not\x20met\x20at\n\x20scheduling\x20time,\x20the\x20pod\x20w\
    ill\x20not\x20be\x20scheduled\x20onto\x20the\x20node.\n\x20If\x20the\x20\
    affinity\x20requirements\x20specified\x20by\x20this\x20field\x20cease\
    \x20to\x20be\x20met\n\x20at\x20some\x20point\x20during\x20pod\x20executi\
    on\x20(e.g.\x20due\x20to\x20a\x20pod\x20label\x20update),\x20the\n\x20sy\
    stem\x20may\x20or\x20may\x20not\x20try\x20to\x20eventually\x20evict\x20t\
    he\x20pod\x20from\x20its\x20node.\n\x20When\x20there\x20are\x20multiple\
    \x20elements,\x20the\x20lists\x20of\x20nodes\x20corresponding\x20to\x20e\
    ach\n\x20podAffinityTerm\x20are\x20intersected,\x20i.e.\x20all\x20terms\
    \x20must\x20be\x20satisfied.\n\x20+optional\n\n\r\n\x05\x04x\x02\0\x04\
    \x12\x04\xab\x17\x02\n\n\r\n\x05\x04x\x02\0\x06\x12\x04\xab\x17\x0b\x1a\
    \n\r\n\x05\x04x\x02\0\x01\x12\x04\xab\x17\x1bI\n\r\n\x05\x04x\x02\0\x03\
    \x12\x04\xab\x17LM\n\x90\x05\n\x04\x04x\x02\x01\x12\x04\xb7\x17\x02W\x1a\
    \x81\x05\x20The\x20scheduler\x20will\x20prefer\x20to\x20schedule\x20pods\
    \x20to\x20nodes\x20that\x20satisfy\n\x20the\x20affinity\x20expressions\
    \x20specified\x20by\x20this\x20field,\x20but\x20it\x20may\x20choose\n\
    \x20a\x20node\x20that\x20violates\x20one\x20or\x20more\x20of\x20the\x20e\
    xpressions.\x20The\x20node\x20that\x20is\n\x20most\x20preferred\x20is\
    \x20the\x20one\x20with\x20the\x20greatest\x20sum\x20of\x20weights,\x20i.\
    e.\n\x20for\x20each\x20node\x20that\x20meets\x20all\x20of\x20the\x20sche\
    duling\x20requirements\x20(resource\n\x20request,\x20requiredDuringSched\
    uling\x20affinity\x20expressions,\x20etc.),\n\x20compute\x20a\x20sum\x20\
    by\x20iterating\x20through\x20the\x20elements\x20of\x20this\x20field\x20\
    and\x20adding\n\x20\"weight\"\x20to\x20the\x20sum\x20if\x20the\x20node\
    \x20has\x20pods\x20which\x20matches\x20the\x20corresponding\x20podAffini\
    tyTerm;\x20the\n\x20node(s)\x20with\x20the\x20highest\x20sum\x20are\x20t\
    he\x20most\x20preferred.\n\x20+optional\n\n\r\n\x05\x04x\x02\x01\x04\x12\
    \x04\xb7\x17\x02\n\n\r\n\x05\x04x\x02\x01\x06\x12\x04\xb7\x17\x0b\"\n\r\
    \n\x05\x04x\x02\x01\x01\x12\x04\xb7\x17#R\n\r\n\x05\x04x\x02\x01\x03\x12\
    \x04\xb7\x17UV\n\xf5\x02\n\x02\x04y\x12\x06\xc0\x17\0\xd0\x17\x01\x1a\
    \xe6\x02\x20Defines\x20a\x20set\x20of\x20pods\x20(namely\x20those\x20mat\
    ching\x20the\x20labelSelector\n\x20relative\x20to\x20the\x20given\x20nam\
    espace(s))\x20that\x20this\x20pod\x20should\x20be\n\x20co-located\x20(af\
    finity)\x20or\x20not\x20co-located\x20(anti-affinity)\x20with,\n\x20wher\
    e\x20co-located\x20is\x20defined\x20as\x20running\x20on\x20a\x20node\x20\
    whose\x20value\x20of\n\x20the\x20label\x20with\x20key\x20<topologyKey>\
    \x20matches\x20that\x20of\x20any\x20node\x20on\x20which\n\x20a\x20pod\
    \x20of\x20the\x20set\x20of\x20pods\x20is\x20running\n\n\x0b\n\x03\x04y\
    \x01\x12\x04\xc0\x17\x08\x17\nT\n\x04\x04y\x02\0\x12\x04\xc3\x17\x02P\
    \x1aF\x20A\x20label\x20query\x20over\x20a\x20set\x20of\x20resources,\x20\
    in\x20this\x20case\x20pods.\n\x20+optional\n\n\r\n\x05\x04y\x02\0\x04\
    \x12\x04\xc3\x17\x02\n\n\r\n\x05\x04y\x02\0\x06\x12\x04\xc3\x17\x0b=\n\r\
    \n\x05\x04y\x02\0\x01\x12\x04\xc3\x17>K\n\r\n\x05\x04y\x02\0\x03\x12\x04\
    \xc3\x17NO\n\xa2\x01\n\x04\x04y\x02\x01\x12\x04\xc8\x17\x02!\x1a\x93\x01\
    \x20namespaces\x20specifies\x20which\x20namespaces\x20the\x20labelSelect\
    or\x20applies\x20to\x20(matches\x20against);\n\x20null\x20or\x20empty\
    \x20list\x20means\x20\"this\x20pod's\x20namespace\"\n\x20+optional\n\n\r\
    \n\x05\x04y\x02\x01\x04\x12\x04\xc8\x17\x02\n\n\r\n\x05\x04y\x02\x01\x05\
    \x12\x04\xc8\x17\x0b\x11\n\r\n\x05\x04y\x02\x01\x01\x12\x04\xc8\x17\x12\
    \x1c\n\r\n\x05\x04y\x02\x01\x03\x12\x04\xc8\x17\x1f\x20\n\xed\x02\n\x04\
    \x04y\x02\x02\x12\x04\xcf\x17\x02\"\x1a\xde\x02\x20This\x20pod\x20should\
    \x20be\x20co-located\x20(affinity)\x20or\x20not\x20co-located\x20(anti-a\
    ffinity)\x20with\x20the\x20pods\x20matching\n\x20the\x20labelSelector\
    \x20in\x20the\x20specified\x20namespaces,\x20where\x20co-located\x20is\
    \x20defined\x20as\x20running\x20on\x20a\x20node\n\x20whose\x20value\x20o\
    f\x20the\x20label\x20with\x20key\x20topologyKey\x20matches\x20that\x20of\
    \x20any\x20node\x20on\x20which\x20any\x20of\x20the\n\x20selected\x20pods\
    \x20is\x20running.\n\x20Empty\x20topologyKey\x20is\x20not\x20allowed.\n\
    \n\r\n\x05\x04y\x02\x02\x04\x12\x04\xcf\x17\x02\n\n\r\n\x05\x04y\x02\x02\
    \x05\x12\x04\xcf\x17\x0b\x11\n\r\n\x05\x04y\x02\x02\x01\x12\x04\xcf\x17\
    \x12\x1d\n\r\n\x05\x04y\x02\x02\x03\x12\x04\xcf\x17\x20!\nY\n\x02\x04z\
    \x12\x06\xd3\x17\0\xe9\x17\x01\x1aK\x20Pod\x20anti\x20affinity\x20is\x20\
    a\x20group\x20of\x20inter\x20pod\x20anti\x20affinity\x20scheduling\x20ru\
    les.\n\n\x0b\n\x03\x04z\x01\x12\x04\xd3\x17\x08\x17\n\x8e\x04\n\x04\x04z\
    \x02\0\x12\x04\xdc\x17\x02N\x1a\xff\x03\x20If\x20the\x20anti-affinity\
    \x20requirements\x20specified\x20by\x20this\x20field\x20are\x20not\x20me\
    t\x20at\n\x20scheduling\x20time,\x20the\x20pod\x20will\x20not\x20be\x20s\
    cheduled\x20onto\x20the\x20node.\n\x20If\x20the\x20anti-affinity\x20requ\
    irements\x20specified\x20by\x20this\x20field\x20cease\x20to\x20be\x20met\
    \n\x20at\x20some\x20point\x20during\x20pod\x20execution\x20(e.g.\x20due\
    \x20to\x20a\x20pod\x20label\x20update),\x20the\n\x20system\x20may\x20or\
    \x20may\x20not\x20try\x20to\x20eventually\x20evict\x20the\x20pod\x20from\
    \x20its\x20node.\n\x20When\x20there\x20are\x20multiple\x20elements,\x20t\
    he\x20lists\x20of\x20nodes\x20corresponding\x20to\x20each\n\x20podAffini\
    tyTerm\x20are\x20intersected,\x20i.e.\x20all\x20terms\x20must\x20be\x20s\
    atisfied.\n\x20+optional\n\n\r\n\x05\x04z\x02\0\x04\x12\x04\xdc\x17\x02\
    \n\n\r\n\x05\x04z\x02\0\x06\x12\x04\xdc\x17\x0b\x1a\n\r\n\x05\x04z\x02\0\
    \x01\x12\x04\xdc\x17\x1bI\n\r\n\x05\x04z\x02\0\x03\x12\x04\xdc\x17LM\n\
    \x9a\x05\n\x04\x04z\x02\x01\x12\x04\xe8\x17\x02W\x1a\x8b\x05\x20The\x20s\
    cheduler\x20will\x20prefer\x20to\x20schedule\x20pods\x20to\x20nodes\x20t\
    hat\x20satisfy\n\x20the\x20anti-affinity\x20expressions\x20specified\x20\
    by\x20this\x20field,\x20but\x20it\x20may\x20choose\n\x20a\x20node\x20tha\
    t\x20violates\x20one\x20or\x20more\x20of\x20the\x20expressions.\x20The\
    \x20node\x20that\x20is\n\x20most\x20preferred\x20is\x20the\x20one\x20wit\
    h\x20the\x20greatest\x20sum\x20of\x20weights,\x20i.e.\n\x20for\x20each\
    \x20node\x20that\x20meets\x20all\x20of\x20the\x20scheduling\x20requireme\
    nts\x20(resource\n\x20request,\x20requiredDuringScheduling\x20anti-affin\
    ity\x20expressions,\x20etc.),\n\x20compute\x20a\x20sum\x20by\x20iteratin\
    g\x20through\x20the\x20elements\x20of\x20this\x20field\x20and\x20adding\
    \n\x20\"weight\"\x20to\x20the\x20sum\x20if\x20the\x20node\x20has\x20pods\
    \x20which\x20matches\x20the\x20corresponding\x20podAffinityTerm;\x20the\
    \n\x20node(s)\x20with\x20the\x20highest\x20sum\x20are\x20the\x20most\x20\
    preferred.\n\x20+optional\n\n\r\n\x05\x04z\x02\x01\x04\x12\x04\xe8\x17\
    \x02\n\n\r\n\x05\x04z\x02\x01\x06\x12\x04\xe8\x17\x0b\"\n\r\n\x05\x04z\
    \x02\x01\x01\x12\x04\xe8\x17#R\n\r\n\x05\x04z\x02\x01\x03\x12\x04\xe8\
    \x17UV\n\x8a\x02\n\x02\x04{\x12\x06\xef\x17\0\x8a\x18\x01\x1a\xfb\x01\
    \x20PodAttachOptions\x20is\x20the\x20query\x20options\x20to\x20a\x20Pod'\
    s\x20remote\x20attach\x20call.\n\x20---\n\x20TODO:\x20merge\x20w/\x20Pod\
    ExecOptions\x20below\x20for\x20stdin,\x20stdout,\x20etc\n\x20and\x20also\
    \x20when\x20we\x20cut\x20V2,\x20we\x20should\x20export\x20a\x20\"StreamO\
    ptions\"\x20or\x20somesuch\x20that\x20contains\x20Stdin,\x20Stdout,\x20S\
    tder\x20and\x20TTY\n\n\x0b\n\x03\x04{\x01\x12\x04\xef\x17\x08\x18\n{\n\
    \x04\x04{\x02\0\x12\x04\xf3\x17\x02\x1a\x1am\x20Stdin\x20if\x20true,\x20\
    redirects\x20the\x20standard\x20input\x20stream\x20of\x20the\x20pod\x20f\
    or\x20this\x20call.\n\x20Defaults\x20to\x20false.\n\x20+optional\n\n\r\n\
    \x05\x04{\x02\0\x04\x12\x04\xf3\x17\x02\n\n\r\n\x05\x04{\x02\0\x05\x12\
    \x04\xf3\x17\x0b\x0f\n\r\n\x05\x04{\x02\0\x01\x12\x04\xf3\x17\x10\x15\n\
    \r\n\x05\x04{\x02\0\x03\x12\x04\xf3\x17\x18\x19\n{\n\x04\x04{\x02\x01\
    \x12\x04\xf8\x17\x02\x1b\x1am\x20Stdout\x20if\x20true\x20indicates\x20th\
    at\x20stdout\x20is\x20to\x20be\x20redirected\x20for\x20the\x20attach\x20\
    call.\n\x20Defaults\x20to\x20true.\n\x20+optional\n\n\r\n\x05\x04{\x02\
    \x01\x04\x12\x04\xf8\x17\x02\n\n\r\n\x05\x04{\x02\x01\x05\x12\x04\xf8\
    \x17\x0b\x0f\n\r\n\x05\x04{\x02\x01\x01\x12\x04\xf8\x17\x10\x16\n\r\n\
    \x05\x04{\x02\x01\x03\x12\x04\xf8\x17\x19\x1a\n{\n\x04\x04{\x02\x02\x12\
    \x04\xfd\x17\x02\x1b\x1am\x20Stderr\x20if\x20true\x20indicates\x20that\
    \x20stderr\x20is\x20to\x20be\x20redirected\x20for\x20the\x20attach\x20ca\
    ll.\n\x20Defaults\x20to\x20true.\n\x20+optional\n\n\r\n\x05\x04{\x02\x02\
    \x04\x12\x04\xfd\x17\x02\n\n\r\n\x05\x04{\x02\x02\x05\x12\x04\xfd\x17\
    \x0b\x0f\n\r\n\x05\x04{\x02\x02\x01\x12\x04\xfd\x17\x10\x16\n\r\n\x05\
    \x04{\x02\x02\x03\x12\x04\xfd\x17\x19\x1a\n\xeb\x01\n\x04\x04{\x02\x03\
    \x12\x04\x84\x18\x02\x18\x1a\xdc\x01\x20TTY\x20if\x20true\x20indicates\
    \x20that\x20a\x20tty\x20will\x20be\x20allocated\x20for\x20the\x20attach\
    \x20call.\n\x20This\x20is\x20passed\x20through\x20the\x20container\x20ru\
    ntime\x20so\x20the\x20tty\n\x20is\x20allocated\x20on\x20the\x20worker\
    \x20node\x20by\x20the\x20container\x20runtime.\n\x20Defaults\x20to\x20fa\
    lse.\n\x20+optional\n\n\r\n\x05\x04{\x02\x03\x04\x12\x04\x84\x18\x02\n\n\
    \r\n\x05\x04{\x02\x03\x05\x12\x04\x84\x18\x0b\x0f\n\r\n\x05\x04{\x02\x03\
    \x01\x12\x04\x84\x18\x10\x13\n\r\n\x05\x04{\x02\x03\x03\x12\x04\x84\x18\
    \x16\x17\n\x91\x01\n\x04\x04{\x02\x04\x12\x04\x89\x18\x02\x20\x1a\x82\
    \x01\x20The\x20container\x20in\x20which\x20to\x20execute\x20the\x20comma\
    nd.\n\x20Defaults\x20to\x20only\x20container\x20if\x20there\x20is\x20onl\
    y\x20one\x20container\x20in\x20the\x20pod.\n\x20+optional\n\n\r\n\x05\
    \x04{\x02\x04\x04\x12\x04\x89\x18\x02\n\n\r\n\x05\x04{\x02\x04\x05\x12\
    \x04\x89\x18\x0b\x11\n\r\n\x05\x04{\x02\x04\x01\x12\x04\x89\x18\x12\x1b\
    \n\r\n\x05\x04{\x02\x04\x03\x12\x04\x89\x18\x1e\x1f\nT\n\x02\x04|\x12\
    \x06\x8d\x18\0\xa6\x18\x01\x1aF\x20PodCondition\x20contains\x20details\
    \x20for\x20the\x20current\x20condition\x20of\x20this\x20pod.\n\n\x0b\n\
    \x03\x04|\x01\x12\x04\x8d\x18\x08\x14\n\x8f\x01\n\x04\x04|\x02\0\x12\x04\
    \x90\x18\x02\x1b\x1a\x80\x01\x20Type\x20is\x20the\x20type\x20of\x20the\
    \x20condition.\n\x20More\x20info:\x20https://kubernetes.io/docs/concepts\
    /workloads/pods/pod-lifecycle#pod-conditions\n\n\r\n\x05\x04|\x02\0\x04\
    \x12\x04\x90\x18\x02\n\n\r\n\x05\x04|\x02\0\x05\x12\x04\x90\x18\x0b\x11\
    \n\r\n\x05\x04|\x02\0\x01\x12\x04\x90\x18\x12\x16\n\r\n\x05\x04|\x02\0\
    \x03\x12\x04\x90\x18\x19\x1a\n\xb1\x01\n\x04\x04|\x02\x01\x12\x04\x95\
    \x18\x02\x1d\x1a\xa2\x01\x20Status\x20is\x20the\x20status\x20of\x20the\
    \x20condition.\n\x20Can\x20be\x20True,\x20False,\x20Unknown.\n\x20More\
    \x20info:\x20https://kubernetes.io/docs/concepts/workloads/pods/pod-life\
    cycle#pod-conditions\n\n\r\n\x05\x04|\x02\x01\x04\x12\x04\x95\x18\x02\n\
    \n\r\n\x05\x04|\x02\x01\x05\x12\x04\x95\x18\x0b\x11\n\r\n\x05\x04|\x02\
    \x01\x01\x12\x04\x95\x18\x12\x18\n\r\n\x05\x04|\x02\x01\x03\x12\x04\x95\
    \x18\x1b\x1c\n=\n\x04\x04|\x02\x02\x12\x04\x99\x18\x02G\x1a/\x20Last\x20\
    time\x20we\x20probed\x20the\x20condition.\n\x20+optional\n\n\r\n\x05\x04\
    |\x02\x02\x04\x12\x04\x99\x18\x02\n\n\r\n\x05\x04|\x02\x02\x06\x12\x04\
    \x99\x18\x0b4\n\r\n\x05\x04|\x02\x02\x01\x12\x04\x99\x185B\n\r\n\x05\x04\
    |\x02\x02\x03\x12\x04\x99\x18EF\n[\n\x04\x04|\x02\x03\x12\x04\x9d\x18\
    \x02L\x1aM\x20Last\x20time\x20the\x20condition\x20transitioned\x20from\
    \x20one\x20status\x20to\x20another.\n\x20+optional\n\n\r\n\x05\x04|\x02\
    \x03\x04\x12\x04\x9d\x18\x02\n\n\r\n\x05\x04|\x02\x03\x06\x12\x04\x9d\
    \x18\x0b4\n\r\n\x05\x04|\x02\x03\x01\x12\x04\x9d\x185G\n\r\n\x05\x04|\
    \x02\x03\x03\x12\x04\x9d\x18JK\nb\n\x04\x04|\x02\x04\x12\x04\xa1\x18\x02\
    \x1d\x1aT\x20Unique,\x20one-word,\x20CamelCase\x20reason\x20for\x20the\
    \x20condition's\x20last\x20transition.\n\x20+optional\n\n\r\n\x05\x04|\
    \x02\x04\x04\x12\x04\xa1\x18\x02\n\n\r\n\x05\x04|\x02\x04\x05\x12\x04\
    \xa1\x18\x0b\x11\n\r\n\x05\x04|\x02\x04\x01\x12\x04\xa1\x18\x12\x18\n\r\
    \n\x05\x04|\x02\x04\x03\x12\x04\xa1\x18\x1b\x1c\n[\n\x04\x04|\x02\x05\
    \x12\x04\xa5\x18\x02\x1e\x1aM\x20Human-readable\x20message\x20indicating\
    \x20details\x20about\x20last\x20transition.\n\x20+optional\n\n\r\n\x05\
    \x04|\x02\x05\x04\x12\x04\xa5\x18\x02\n\n\r\n\x05\x04|\x02\x05\x05\x12\
    \x04\xa5\x18\x0b\x11\n\r\n\x05\x04|\x02\x05\x01\x12\x04\xa5\x18\x12\x19\
    \n\r\n\x05\x04|\x02\x05\x03\x12\x04\xa5\x18\x1c\x1d\np\n\x02\x04}\x12\
    \x06\xaa\x18\0\xbd\x18\x01\x1ab\x20PodDNSConfig\x20defines\x20the\x20DNS\
    \x20parameters\x20of\x20a\x20pod\x20in\x20addition\x20to\n\x20those\x20g\
    enerated\x20from\x20DNSPolicy.\n\n\x0b\n\x03\x04}\x01\x12\x04\xaa\x18\
    \x08\x14\n\xb5\x01\n\x04\x04}\x02\0\x12\x04\xaf\x18\x02\"\x1a\xa6\x01\
    \x20A\x20list\x20of\x20DNS\x20name\x20server\x20IP\x20addresses.\n\x20Th\
    is\x20will\x20be\x20appended\x20to\x20the\x20base\x20nameservers\x20gene\
    rated\x20from\x20DNSPolicy.\n\x20Duplicated\x20nameservers\x20will\x20be\
    \x20removed.\n\x20+optional\n\n\r\n\x05\x04}\x02\0\x04\x12\x04\xaf\x18\
    \x02\n\n\r\n\x05\x04}\x02\0\x05\x12\x04\xaf\x18\x0b\x11\n\r\n\x05\x04}\
    \x02\0\x01\x12\x04\xaf\x18\x12\x1d\n\r\n\x05\x04}\x02\0\x03\x12\x04\xaf\
    \x18\x20!\n\xc2\x01\n\x04\x04}\x02\x01\x12\x04\xb5\x18\x02\x1f\x1a\xb3\
    \x01\x20A\x20list\x20of\x20DNS\x20search\x20domains\x20for\x20host-name\
    \x20lookup.\n\x20This\x20will\x20be\x20appended\x20to\x20the\x20base\x20\
    search\x20paths\x20generated\x20from\x20DNSPolicy.\n\x20Duplicated\x20se\
    arch\x20paths\x20will\x20be\x20removed.\n\x20+optional\n\n\r\n\x05\x04}\
    \x02\x01\x04\x12\x04\xb5\x18\x02\n\n\r\n\x05\x04}\x02\x01\x05\x12\x04\
    \xb5\x18\x0b\x11\n\r\n\x05\x04}\x02\x01\x01\x12\x04\xb5\x18\x12\x1a\n\r\
    \n\x05\x04}\x02\x01\x03\x12\x04\xb5\x18\x1d\x1e\n\x81\x02\n\x04\x04}\x02\
    \x02\x12\x04\xbc\x18\x02*\x1a\xf2\x01\x20A\x20list\x20of\x20DNS\x20resol\
    ver\x20options.\n\x20This\x20will\x20be\x20merged\x20with\x20the\x20base\
    \x20options\x20generated\x20from\x20DNSPolicy.\n\x20Duplicated\x20entrie\
    s\x20will\x20be\x20removed.\x20Resolution\x20options\x20given\x20in\x20O\
    ptions\n\x20will\x20override\x20those\x20that\x20appear\x20in\x20the\x20\
    base\x20DNSPolicy.\n\x20+optional\n\n\r\n\x05\x04}\x02\x02\x04\x12\x04\
    \xbc\x18\x02\n\n\r\n\x05\x04}\x02\x02\x06\x12\x04\xbc\x18\x0b\x1d\n\r\n\
    \x05\x04}\x02\x02\x01\x12\x04\xbc\x18\x1e%\n\r\n\x05\x04}\x02\x02\x03\
    \x12\x04\xbc\x18()\nI\n\x02\x04~\x12\x06\xc0\x18\0\xc6\x18\x01\x1a;\x20P\
    odDNSConfigOption\x20defines\x20DNS\x20resolver\x20options\x20of\x20a\
    \x20pod.\n\n\x0b\n\x03\x04~\x01\x12\x04\xc0\x18\x08\x1a\n\x19\n\x04\x04~\
    \x02\0\x12\x04\xc2\x18\x02\x1b\x1a\x0b\x20Required.\n\n\r\n\x05\x04~\x02\
    \0\x04\x12\x04\xc2\x18\x02\n\n\r\n\x05\x04~\x02\0\x05\x12\x04\xc2\x18\
    \x0b\x11\n\r\n\x05\x04~\x02\0\x01\x12\x04\xc2\x18\x12\x16\n\r\n\x05\x04~\
    \x02\0\x03\x12\x04\xc2\x18\x19\x1a\n\x19\n\x04\x04~\x02\x01\x12\x04\xc5\
    \x18\x02\x1c\x1a\x0b\x20+optional\n\n\r\n\x05\x04~\x02\x01\x04\x12\x04\
    \xc5\x18\x02\n\n\r\n\x05\x04~\x02\x01\x05\x12\x04\xc5\x18\x0b\x11\n\r\n\
    \x05\x04~\x02\x01\x01\x12\x04\xc5\x18\x12\x17\n\r\n\x05\x04~\x02\x01\x03\
    \x12\x04\xc5\x18\x1a\x1b\n\xb8\x02\n\x02\x04\x7f\x12\x06\xcc\x18\0\xe8\
    \x18\x01\x1a\xa9\x02\x20PodExecOptions\x20is\x20the\x20query\x20options\
    \x20to\x20a\x20Pod's\x20remote\x20exec\x20call.\n\x20---\n\x20TODO:\x20T\
    his\x20is\x20largely\x20identical\x20to\x20PodAttachOptions\x20above,\
    \x20make\x20sure\x20they\x20stay\x20in\x20sync\x20and\x20see\x20about\
    \x20merging\n\x20and\x20also\x20when\x20we\x20cut\x20V2,\x20we\x20should\
    \x20export\x20a\x20\"StreamOptions\"\x20or\x20somesuch\x20that\x20contai\
    ns\x20Stdin,\x20Stdout,\x20Stder\x20and\x20TTY\n\n\x0b\n\x03\x04\x7f\x01\
    \x12\x04\xcc\x18\x08\x16\nk\n\x04\x04\x7f\x02\0\x12\x04\xd0\x18\x02\x1a\
    \x1a]\x20Redirect\x20the\x20standard\x20input\x20stream\x20of\x20the\x20\
    pod\x20for\x20this\x20call.\n\x20Defaults\x20to\x20false.\n\x20+optional\
    \n\n\r\n\x05\x04\x7f\x02\0\x04\x12\x04\xd0\x18\x02\n\n\r\n\x05\x04\x7f\
    \x02\0\x05\x12\x04\xd0\x18\x0b\x0f\n\r\n\x05\x04\x7f\x02\0\x01\x12\x04\
    \xd0\x18\x10\x15\n\r\n\x05\x04\x7f\x02\0\x03\x12\x04\xd0\x18\x18\x19\nk\
    \n\x04\x04\x7f\x02\x01\x12\x04\xd5\x18\x02\x1b\x1a]\x20Redirect\x20the\
    \x20standard\x20output\x20stream\x20of\x20the\x20pod\x20for\x20this\x20c\
    all.\n\x20Defaults\x20to\x20true.\n\x20+optional\n\n\r\n\x05\x04\x7f\x02\
    \x01\x04\x12\x04\xd5\x18\x02\n\n\r\n\x05\x04\x7f\x02\x01\x05\x12\x04\xd5\
    \x18\x0b\x0f\n\r\n\x05\x04\x7f\x02\x01\x01\x12\x04\xd5\x18\x10\x16\n\r\n\
    \x05\x04\x7f\x02\x01\x03\x12\x04\xd5\x18\x19\x1a\nj\n\x04\x04\x7f\x02\
    \x02\x12\x04\xda\x18\x02\x1b\x1a\\\x20Redirect\x20the\x20standard\x20err\
    or\x20stream\x20of\x20the\x20pod\x20for\x20this\x20call.\n\x20Defaults\
    \x20to\x20true.\n\x20+optional\n\n\r\n\x05\x04\x7f\x02\x02\x04\x12\x04\
    \xda\x18\x02\n\n\r\n\x05\x04\x7f\x02\x02\x05\x12\x04\xda\x18\x0b\x0f\n\r\
    \n\x05\x04\x7f\x02\x02\x01\x12\x04\xda\x18\x10\x16\n\r\n\x05\x04\x7f\x02\
    \x02\x03\x12\x04\xda\x18\x19\x1a\nt\n\x04\x04\x7f\x02\x03\x12\x04\xdf\
    \x18\x02\x18\x1af\x20TTY\x20if\x20true\x20indicates\x20that\x20a\x20tty\
    \x20will\x20be\x20allocated\x20for\x20the\x20exec\x20call.\n\x20Defaults\
    \x20to\x20false.\n\x20+optional\n\n\r\n\x05\x04\x7f\x02\x03\x04\x12\x04\
    \xdf\x18\x02\n\n\r\n\x05\x04\x7f\x02\x03\x05\x12\x04\xdf\x18\x0b\x0f\n\r\
    \n\x05\x04\x7f\x02\x03\x01\x12\x04\xdf\x18\x10\x13\n\r\n\x05\x04\x7f\x02\
    \x03\x03\x12\x04\xdf\x18\x16\x17\n\x8c\x01\n\x04\x04\x7f\x02\x04\x12\x04\
    \xe4\x18\x02\x20\x1a~\x20Container\x20in\x20which\x20to\x20execute\x20th\
    e\x20command.\n\x20Defaults\x20to\x20only\x20container\x20if\x20there\
    \x20is\x20only\x20one\x20container\x20in\x20the\x20pod.\n\x20+optional\n\
    \n\r\n\x05\x04\x7f\x02\x04\x04\x12\x04\xe4\x18\x02\n\n\r\n\x05\x04\x7f\
    \x02\x04\x05\x12\x04\xe4\x18\x0b\x11\n\r\n\x05\x04\x7f\x02\x04\x01\x12\
    \x04\xe4\x18\x12\x1b\n\r\n\x05\x04\x7f\x02\x04\x03\x12\x04\xe4\x18\x1e\
    \x1f\nb\n\x04\x04\x7f\x02\x05\x12\x04\xe7\x18\x02\x1e\x1aT\x20Command\
    \x20is\x20the\x20remote\x20command\x20to\x20execute.\x20argv\x20array.\
    \x20Not\x20executed\x20within\x20a\x20shell.\n\n\r\n\x05\x04\x7f\x02\x05\
    \x04\x12\x04\xe7\x18\x02\n\n\r\n\x05\x04\x7f\x02\x05\x05\x12\x04\xe7\x18\
    \x0b\x11\n\r\n\x05\x04\x7f\x02\x05\x01\x12\x04\xe7\x18\x12\x19\n\r\n\x05\
    \x04\x7f\x02\x05\x03\x12\x04\xe7\x18\x1c\x1d\n\xba\x01\n\x03\x04\x80\x01\
    \x12\x06\xed\x18\0\xf0\x18\x01\x1a\xaa\x01\x20IP\x20address\x20informati\
    on\x20for\x20entries\x20in\x20the\x20(plural)\x20PodIPs\x20field.\n\x20E\
    ach\x20entry\x20includes:\n\x20\x20\x20\x20IP:\x20An\x20IP\x20address\
    \x20allocated\x20to\x20the\x20pod.\x20Routable\x20at\x20least\x20within\
    \x20the\x20cluster.\n\n\x0c\n\x04\x04\x80\x01\x01\x12\x04\xed\x18\x08\r\
    \nG\n\x05\x04\x80\x01\x02\0\x12\x04\xef\x18\x02\x19\x1a8\x20ip\x20is\x20\
    an\x20IP\x20address\x20(IPv4\x20or\x20IPv6)\x20assigned\x20to\x20the\x20\
    pod\n\n\x0e\n\x06\x04\x80\x01\x02\0\x04\x12\x04\xef\x18\x02\n\n\x0e\n\
    \x06\x04\x80\x01\x02\0\x05\x12\x04\xef\x18\x0b\x11\n\x0e\n\x06\x04\x80\
    \x01\x02\0\x01\x12\x04\xef\x18\x12\x14\n\x0e\n\x06\x04\x80\x01\x02\0\x03\
    \x12\x04\xef\x18\x17\x18\n+\n\x03\x04\x81\x01\x12\x06\xf3\x18\0\xfc\x18\
    \x01\x1a\x1c\x20PodList\x20is\x20a\x20list\x20of\x20Pods.\n\n\x0c\n\x04\
    \x04\x81\x01\x01\x12\x04\xf3\x18\x08\x0f\n\xa0\x01\n\x05\x04\x81\x01\x02\
    \0\x12\x04\xf7\x18\x02F\x1a\x90\x01\x20Standard\x20list\x20metadata.\n\
    \x20More\x20info:\x20https://git.k8s.io/community/contributors/devel/sig\
    -architecture/api-conventions.md#types-kinds\n\x20+optional\n\n\x0e\n\
    \x06\x04\x81\x01\x02\0\x04\x12\x04\xf7\x18\x02\n\n\x0e\n\x06\x04\x81\x01\
    \x02\0\x06\x12\x04\xf7\x18\x0b8\n\x0e\n\x06\x04\x81\x01\x02\0\x01\x12\
    \x04\xf7\x189A\n\x0e\n\x06\x04\x81\x01\x02\0\x03\x12\x04\xf7\x18DE\n~\n\
    \x05\x04\x81\x01\x02\x01\x12\x04\xfb\x18\x02\x19\x1ao\x20List\x20of\x20p\
    ods.\n\x20More\x20info:\x20https://git.k8s.io/community/contributors/dev\
    el/sig-architecture/api-conventions.md\n\n\x0e\n\x06\x04\x81\x01\x02\x01\
    \x04\x12\x04\xfb\x18\x02\n\n\x0e\n\x06\x04\x81\x01\x02\x01\x06\x12\x04\
    \xfb\x18\x0b\x0e\n\x0e\n\x06\x04\x81\x01\x02\x01\x01\x12\x04\xfb\x18\x0f\
    \x14\n\x0e\n\x06\x04\x81\x01\x02\x01\x03\x12\x04\xfb\x18\x17\x18\nO\n\
    \x03\x04\x82\x01\x12\x06\xff\x18\0\xb2\x19\x01\x1a@\x20PodLogOptions\x20\
    is\x20the\x20query\x20options\x20for\x20a\x20Pod's\x20logs\x20REST\x20ca\
    ll.\n\n\x0c\n\x04\x04\x82\x01\x01\x12\x04\xff\x18\x08\x15\n\x84\x01\n\
    \x05\x04\x82\x01\x02\0\x12\x04\x82\x19\x02\x20\x1au\x20The\x20container\
    \x20for\x20which\x20to\x20stream\x20logs.\x20Defaults\x20to\x20only\x20c\
    ontainer\x20if\x20there\x20is\x20one\x20container\x20in\x20the\x20pod.\n\
    \x20+optional\n\n\x0e\n\x06\x04\x82\x01\x02\0\x04\x12\x04\x82\x19\x02\n\
    \n\x0e\n\x06\x04\x82\x01\x02\0\x05\x12\x04\x82\x19\x0b\x11\n\x0e\n\x06\
    \x04\x82\x01\x02\0\x01\x12\x04\x82\x19\x12\x1b\n\x0e\n\x06\x04\x82\x01\
    \x02\0\x03\x12\x04\x82\x19\x1e\x1f\nP\n\x05\x04\x82\x01\x02\x01\x12\x04\
    \x86\x19\x02\x1b\x1aA\x20Follow\x20the\x20log\x20stream\x20of\x20the\x20\
    pod.\x20Defaults\x20to\x20false.\n\x20+optional\n\n\x0e\n\x06\x04\x82\
    \x01\x02\x01\x04\x12\x04\x86\x19\x02\n\n\x0e\n\x06\x04\x82\x01\x02\x01\
    \x05\x12\x04\x86\x19\x0b\x0f\n\x0e\n\x06\x04\x82\x01\x02\x01\x01\x12\x04\
    \x86\x19\x10\x16\n\x0e\n\x06\x04\x82\x01\x02\x01\x03\x12\x04\x86\x19\x19\
    \x1a\nY\n\x05\x04\x82\x01\x02\x02\x12\x04\x8a\x19\x02\x1d\x1aJ\x20Return\
    \x20previous\x20terminated\x20container\x20logs.\x20Defaults\x20to\x20fa\
    lse.\n\x20+optional\n\n\x0e\n\x06\x04\x82\x01\x02\x02\x04\x12\x04\x8a\
    \x19\x02\n\n\x0e\n\x06\x04\x82\x01\x02\x02\x05\x12\x04\x8a\x19\x0b\x0f\n\
    \x0e\n\x06\x04\x82\x01\x02\x02\x01\x12\x04\x8a\x19\x10\x18\n\x0e\n\x06\
    \x04\x82\x01\x02\x02\x03\x12\x04\x8a\x19\x1b\x1c\n\xc0\x02\n\x05\x04\x82\
    \x01\x02\x03\x12\x04\x91\x19\x02\"\x1a\xb0\x02\x20A\x20relative\x20time\
    \x20in\x20seconds\x20before\x20the\x20current\x20time\x20from\x20which\
    \x20to\x20show\x20logs.\x20If\x20this\x20value\n\x20precedes\x20the\x20t\
    ime\x20a\x20pod\x20was\x20started,\x20only\x20logs\x20since\x20the\x20po\
    d\x20start\x20will\x20be\x20returned.\n\x20If\x20this\x20value\x20is\x20\
    in\x20the\x20future,\x20no\x20logs\x20will\x20be\x20returned.\n\x20Only\
    \x20one\x20of\x20sinceSeconds\x20or\x20sinceTime\x20may\x20be\x20specifi\
    ed.\n\x20+optional\n\n\x0e\n\x06\x04\x82\x01\x02\x03\x04\x12\x04\x91\x19\
    \x02\n\n\x0e\n\x06\x04\x82\x01\x02\x03\x05\x12\x04\x91\x19\x0b\x10\n\x0e\
    \n\x06\x04\x82\x01\x02\x03\x01\x12\x04\x91\x19\x11\x1d\n\x0e\n\x06\x04\
    \x82\x01\x02\x03\x03\x12\x04\x91\x19\x20!\n\xa2\x02\n\x05\x04\x82\x01\
    \x02\x04\x12\x04\x98\x19\x02C\x1a\x92\x02\x20An\x20RFC3339\x20timestamp\
    \x20from\x20which\x20to\x20show\x20logs.\x20If\x20this\x20value\n\x20pre\
    cedes\x20the\x20time\x20a\x20pod\x20was\x20started,\x20only\x20logs\x20s\
    ince\x20the\x20pod\x20start\x20will\x20be\x20returned.\n\x20If\x20this\
    \x20value\x20is\x20in\x20the\x20future,\x20no\x20logs\x20will\x20be\x20r\
    eturned.\n\x20Only\x20one\x20of\x20sinceSeconds\x20or\x20sinceTime\x20ma\
    y\x20be\x20specified.\n\x20+optional\n\n\x0e\n\x06\x04\x82\x01\x02\x04\
    \x04\x12\x04\x98\x19\x02\n\n\x0e\n\x06\x04\x82\x01\x02\x04\x06\x12\x04\
    \x98\x19\x0b4\n\x0e\n\x06\x04\x82\x01\x02\x04\x01\x12\x04\x98\x195>\n\
    \x0e\n\x06\x04\x82\x01\x02\x04\x03\x12\x04\x98\x19AB\n\x8e\x01\n\x05\x04\
    \x82\x01\x02\x05\x12\x04\x9d\x19\x02\x1f\x1a\x7f\x20If\x20true,\x20add\
    \x20an\x20RFC3339\x20or\x20RFC3339Nano\x20timestamp\x20at\x20the\x20begi\
    nning\x20of\x20every\x20line\n\x20of\x20log\x20output.\x20Defaults\x20to\
    \x20false.\n\x20+optional\n\n\x0e\n\x06\x04\x82\x01\x02\x05\x04\x12\x04\
    \x9d\x19\x02\n\n\x0e\n\x06\x04\x82\x01\x02\x05\x05\x12\x04\x9d\x19\x0b\
    \x0f\n\x0e\n\x06\x04\x82\x01\x02\x05\x01\x12\x04\x9d\x19\x10\x1a\n\x0e\n\
    \x06\x04\x82\x01\x02\x05\x03\x12\x04\x9d\x19\x1d\x1e\n\xbc\x01\n\x05\x04\
    \x82\x01\x02\x06\x12\x04\xa2\x19\x02\x1f\x1a\xac\x01\x20If\x20set,\x20th\
    e\x20number\x20of\x20lines\x20from\x20the\x20end\x20of\x20the\x20logs\
    \x20to\x20show.\x20If\x20not\x20specified,\n\x20logs\x20are\x20shown\x20\
    from\x20the\x20creation\x20of\x20the\x20container\x20or\x20sinceSeconds\
    \x20or\x20sinceTime\n\x20+optional\n\n\x0e\n\x06\x04\x82\x01\x02\x06\x04\
    \x12\x04\xa2\x19\x02\n\n\x0e\n\x06\x04\x82\x01\x02\x06\x05\x12\x04\xa2\
    \x19\x0b\x10\n\x0e\n\x06\x04\x82\x01\x02\x06\x01\x12\x04\xa2\x19\x11\x1a\
    \n\x0e\n\x06\x04\x82\x01\x02\x06\x03\x12\x04\xa2\x19\x1d\x1e\n\xf4\x01\n\
    \x05\x04\x82\x01\x02\x07\x12\x04\xa8\x19\x02\x20\x1a\xe4\x01\x20If\x20se\
    t,\x20the\x20number\x20of\x20bytes\x20to\x20read\x20from\x20the\x20serve\
    r\x20before\x20terminating\x20the\n\x20log\x20output.\x20This\x20may\x20\
    not\x20display\x20a\x20complete\x20final\x20line\x20of\x20logging,\x20an\
    d\x20may\x20return\n\x20slightly\x20more\x20or\x20slightly\x20less\x20th\
    an\x20the\x20specified\x20limit.\n\x20+optional\n\n\x0e\n\x06\x04\x82\
    \x01\x02\x07\x04\x12\x04\xa8\x19\x02\n\n\x0e\n\x06\x04\x82\x01\x02\x07\
    \x05\x12\x04\xa8\x19\x0b\x10\n\x0e\n\x06\x04\x82\x01\x02\x07\x01\x12\x04\
    \xa8\x19\x11\x1b\n\x0e\n\x06\x04\x82\x01\x02\x07\x03\x12\x04\xa8\x19\x1e\
    \x1f\n\xf1\x04\n\x05\x04\x82\x01\x02\x08\x12\x04\xb1\x19\x021\x1a\xe1\
    \x04\x20insecureSkipTLSVerifyBackend\x20indicates\x20that\x20the\x20apis\
    erver\x20should\x20not\x20confirm\x20the\x20validity\x20of\x20the\n\x20s\
    erving\x20certificate\x20of\x20the\x20backend\x20it\x20is\x20connecting\
    \x20to.\x20\x20This\x20will\x20make\x20the\x20HTTPS\x20connection\x20bet\
    ween\x20the\x20apiserver\n\x20and\x20the\x20backend\x20insecure.\x20This\
    \x20means\x20the\x20apiserver\x20cannot\x20verify\x20the\x20log\x20data\
    \x20it\x20is\x20receiving\x20came\x20from\x20the\x20real\n\x20kubelet.\
    \x20\x20If\x20the\x20kubelet\x20is\x20configured\x20to\x20verify\x20the\
    \x20apiserver's\x20TLS\x20credentials,\x20it\x20does\x20not\x20mean\x20t\
    he\n\x20connection\x20to\x20the\x20real\x20kubelet\x20is\x20vulnerable\
    \x20to\x20a\x20man\x20in\x20the\x20middle\x20attack\x20(e.g.\x20an\x20at\
    tacker\x20could\x20not\x20intercept\n\x20the\x20actual\x20log\x20data\
    \x20coming\x20from\x20the\x20real\x20kubelet).\n\x20+optional\n\n\x0e\n\
    \x06\x04\x82\x01\x02\x08\x04\x12\x04\xb1\x19\x02\n\n\x0e\n\x06\x04\x82\
    \x01\x02\x08\x05\x12\x04\xb1\x19\x0b\x0f\n\x0e\n\x06\x04\x82\x01\x02\x08\
    \x01\x12\x04\xb1\x19\x10,\n\x0e\n\x06\x04\x82\x01\x02\x08\x03\x12\x04\
    \xb1\x19/0\n\xd3\x02\n\x03\x04\x83\x01\x12\x06\xba\x19\0\xbf\x19\x01\x1a\
    \xc3\x02\x20PodPortForwardOptions\x20is\x20the\x20query\x20options\x20to\
    \x20a\x20Pod's\x20port\x20forward\x20call\n\x20when\x20using\x20WebSocke\
    ts.\n\x20The\x20`port`\x20query\x20parameter\x20must\x20specify\x20the\
    \x20port\x20or\n\x20ports\x20(comma\x20separated)\x20to\x20forward\x20ov\
    er.\n\x20Port\x20forwarding\x20over\x20SPDY\x20does\x20not\x20use\x20the\
    se\x20options.\x20It\x20requires\x20the\x20port\n\x20to\x20be\x20passed\
    \x20in\x20the\x20`port`\x20header\x20as\x20part\x20of\x20request.\n\n\
    \x0c\n\x04\x04\x83\x01\x01\x12\x04\xba\x19\x08\x1d\nT\n\x05\x04\x83\x01\
    \x02\0\x12\x04\xbe\x19\x02\x1b\x1aE\x20List\x20of\x20ports\x20to\x20forw\
    ard\n\x20Required\x20when\x20using\x20WebSockets\n\x20+optional\n\n\x0e\
    \n\x06\x04\x83\x01\x02\0\x04\x12\x04\xbe\x19\x02\n\n\x0e\n\x06\x04\x83\
    \x01\x02\0\x05\x12\x04\xbe\x19\x0b\x10\n\x0e\n\x06\x04\x83\x01\x02\0\x01\
    \x12\x04\xbe\x19\x11\x16\n\x0e\n\x06\x04\x83\x01\x02\0\x03\x12\x04\xbe\
    \x19\x19\x1a\nL\n\x03\x04\x84\x01\x12\x06\xc2\x19\0\xc6\x19\x01\x1a=\x20\
    PodProxyOptions\x20is\x20the\x20query\x20options\x20to\x20a\x20Pod's\x20\
    proxy\x20call.\n\n\x0c\n\x04\x04\x84\x01\x01\x12\x04\xc2\x19\x08\x17\n]\
    \n\x05\x04\x84\x01\x02\0\x12\x04\xc5\x19\x02\x1b\x1aN\x20Path\x20is\x20t\
    he\x20URL\x20path\x20to\x20use\x20for\x20the\x20current\x20proxy\x20requ\
    est\x20to\x20pod.\n\x20+optional\n\n\x0e\n\x06\x04\x84\x01\x02\0\x04\x12\
    \x04\xc5\x19\x02\n\n\x0e\n\x06\x04\x84\x01\x02\0\x05\x12\x04\xc5\x19\x0b\
    \x11\n\x0e\n\x06\x04\x84\x01\x02\0\x01\x12\x04\xc5\x19\x12\x16\n\x0e\n\
    \x06\x04\x84\x01\x02\0\x03\x12\x04\xc5\x19\x19\x1a\nK\n\x03\x04\x85\x01\
    \x12\x06\xc9\x19\0\xcc\x19\x01\x1a<\x20PodReadinessGate\x20contains\x20t\
    he\x20reference\x20to\x20a\x20pod\x20condition\n\n\x0c\n\x04\x04\x85\x01\
    \x01\x12\x04\xc9\x19\x08\x18\nd\n\x05\x04\x85\x01\x02\0\x12\x04\xcb\x19\
    \x02$\x1aU\x20ConditionType\x20refers\x20to\x20a\x20condition\x20in\x20t\
    he\x20pod's\x20condition\x20list\x20with\x20matching\x20type.\n\n\x0e\n\
    \x06\x04\x85\x01\x02\0\x04\x12\x04\xcb\x19\x02\n\n\x0e\n\x06\x04\x85\x01\
    \x02\0\x05\x12\x04\xcb\x19\x0b\x11\n\x0e\n\x06\x04\x85\x01\x02\0\x01\x12\
    \x04\xcb\x19\x12\x1f\n\x0e\n\x06\x04\x85\x01\x02\0\x03\x12\x04\xcb\x19\"\
    #\n\x88\x02\n\x03\x04\x86\x01\x12\x06\xd1\x19\0\x9c\x1a\x01\x1a\xf8\x01\
    \x20PodSecurityContext\x20holds\x20pod-level\x20security\x20attributes\
    \x20and\x20common\x20container\x20settings.\n\x20Some\x20fields\x20are\
    \x20also\x20present\x20in\x20container.securityContext.\x20\x20Field\x20\
    values\x20of\n\x20container.securityContext\x20take\x20precedence\x20ove\
    r\x20field\x20values\x20of\x20PodSecurityContext.\n\n\x0c\n\x04\x04\x86\
    \x01\x01\x12\x04\xd1\x19\x08\x1a\n\xdf\x02\n\x05\x04\x86\x01\x02\0\x12\
    \x04\xd8\x19\x02-\x1a\xcf\x02\x20The\x20SELinux\x20context\x20to\x20be\
    \x20applied\x20to\x20all\x20containers.\n\x20If\x20unspecified,\x20the\
    \x20container\x20runtime\x20will\x20allocate\x20a\x20random\x20SELinux\
    \x20context\x20for\x20each\n\x20container.\x20\x20May\x20also\x20be\x20s\
    et\x20in\x20SecurityContext.\x20\x20If\x20set\x20in\n\x20both\x20Securit\
    yContext\x20and\x20PodSecurityContext,\x20the\x20value\x20specified\x20i\
    n\x20SecurityContext\n\x20takes\x20precedence\x20for\x20that\x20containe\
    r.\n\x20+optional\n\n\x0e\n\x06\x04\x86\x01\x02\0\x04\x12\x04\xd8\x19\
    \x02\n\n\x0e\n\x06\x04\x86\x01\x02\0\x06\x12\x04\xd8\x19\x0b\x19\n\x0e\n\
    \x06\x04\x86\x01\x02\0\x01\x12\x04\xd8\x19\x1a(\n\x0e\n\x06\x04\x86\x01\
    \x02\0\x03\x12\x04\xd8\x19+,\n\x96\x02\n\x05\x04\x86\x01\x02\x01\x12\x04\
    \xde\x19\x02<\x1a\x86\x02\x20The\x20Windows\x20specific\x20settings\x20a\
    pplied\x20to\x20all\x20containers.\n\x20If\x20unspecified,\x20the\x20opt\
    ions\x20within\x20a\x20container's\x20SecurityContext\x20will\x20be\x20u\
    sed.\n\x20If\x20set\x20in\x20both\x20SecurityContext\x20and\x20PodSecuri\
    tyContext,\x20the\x20value\x20specified\x20in\x20SecurityContext\x20take\
    s\x20precedence.\n\x20+optional\n\n\x0e\n\x06\x04\x86\x01\x02\x01\x04\
    \x12\x04\xde\x19\x02\n\n\x0e\n\x06\x04\x86\x01\x02\x01\x06\x12\x04\xde\
    \x19\x0b(\n\x0e\n\x06\x04\x86\x01\x02\x01\x01\x12\x04\xde\x19)7\n\x0e\n\
    \x06\x04\x86\x01\x02\x01\x03\x12\x04\xde\x19:;\n\xbd\x02\n\x05\x04\x86\
    \x01\x02\x02\x12\x04\xe6\x19\x02\x1f\x1a\xad\x02\x20The\x20UID\x20to\x20\
    run\x20the\x20entrypoint\x20of\x20the\x20container\x20process.\n\x20Defa\
    ults\x20to\x20user\x20specified\x20in\x20image\x20metadata\x20if\x20unsp\
    ecified.\n\x20May\x20also\x20be\x20set\x20in\x20SecurityContext.\x20\x20\
    If\x20set\x20in\x20both\x20SecurityContext\x20and\n\x20PodSecurityContex\
    t,\x20the\x20value\x20specified\x20in\x20SecurityContext\x20takes\x20pre\
    cedence\n\x20for\x20that\x20container.\n\x20+optional\n\n\x0e\n\x06\x04\
    \x86\x01\x02\x02\x04\x12\x04\xe6\x19\x02\n\n\x0e\n\x06\x04\x86\x01\x02\
    \x02\x05\x12\x04\xe6\x19\x0b\x10\n\x0e\n\x06\x04\x86\x01\x02\x02\x01\x12\
    \x04\xe6\x19\x11\x1a\n\x0e\n\x06\x04\x86\x01\x02\x02\x03\x12\x04\xe6\x19\
    \x1d\x1e\n\x9f\x02\n\x05\x04\x86\x01\x02\x03\x12\x04\xee\x19\x02\x20\x1a\
    \x8f\x02\x20The\x20GID\x20to\x20run\x20the\x20entrypoint\x20of\x20the\
    \x20container\x20process.\n\x20Uses\x20runtime\x20default\x20if\x20unset\
    .\n\x20May\x20also\x20be\x20set\x20in\x20SecurityContext.\x20\x20If\x20s\
    et\x20in\x20both\x20SecurityContext\x20and\n\x20PodSecurityContext,\x20t\
    he\x20value\x20specified\x20in\x20SecurityContext\x20takes\x20precedence\
    \n\x20for\x20that\x20container.\n\x20+optional\n\n\x0e\n\x06\x04\x86\x01\
    \x02\x03\x04\x12\x04\xee\x19\x02\n\n\x0e\n\x06\x04\x86\x01\x02\x03\x05\
    \x12\x04\xee\x19\x0b\x10\n\x0e\n\x06\x04\x86\x01\x02\x03\x01\x12\x04\xee\
    \x19\x11\x1b\n\x0e\n\x06\x04\x86\x01\x02\x03\x03\x12\x04\xee\x19\x1e\x1f\
    \n\xbc\x03\n\x05\x04\x86\x01\x02\x04\x12\x04\xf7\x19\x02!\x1a\xac\x03\
    \x20Indicates\x20that\x20the\x20container\x20must\x20run\x20as\x20a\x20n\
    on-root\x20user.\n\x20If\x20true,\x20the\x20Kubelet\x20will\x20validate\
    \x20the\x20image\x20at\x20runtime\x20to\x20ensure\x20that\x20it\n\x20doe\
    s\x20not\x20run\x20as\x20UID\x200\x20(root)\x20and\x20fail\x20to\x20star\
    t\x20the\x20container\x20if\x20it\x20does.\n\x20If\x20unset\x20or\x20fal\
    se,\x20no\x20such\x20validation\x20will\x20be\x20performed.\n\x20May\x20\
    also\x20be\x20set\x20in\x20SecurityContext.\x20\x20If\x20set\x20in\x20bo\
    th\x20SecurityContext\x20and\n\x20PodSecurityContext,\x20the\x20value\
    \x20specified\x20in\x20SecurityContext\x20takes\x20precedence.\n\x20+opt\
    ional\n\n\x0e\n\x06\x04\x86\x01\x02\x04\x04\x12\x04\xf7\x19\x02\n\n\x0e\
    \n\x06\x04\x86\x01\x02\x04\x05\x12\x04\xf7\x19\x0b\x0f\n\x0e\n\x06\x04\
    \x86\x01\x02\x04\x01\x12\x04\xf7\x19\x10\x1c\n\x0e\n\x06\x04\x86\x01\x02\
    \x04\x03\x12\x04\xf7\x19\x1f\x20\n\xca\x01\n\x05\x04\x86\x01\x02\x05\x12\
    \x04\xfd\x19\x02(\x1a\xba\x01\x20A\x20list\x20of\x20groups\x20applied\
    \x20to\x20the\x20first\x20process\x20run\x20in\x20each\x20container,\x20\
    in\x20addition\n\x20to\x20the\x20container's\x20primary\x20GID.\x20\x20I\
    f\x20unspecified,\x20no\x20groups\x20will\x20be\x20added\x20to\n\x20any\
    \x20container.\n\x20+optional\n\n\x0e\n\x06\x04\x86\x01\x02\x05\x04\x12\
    \x04\xfd\x19\x02\n\n\x0e\n\x06\x04\x86\x01\x02\x05\x05\x12\x04\xfd\x19\
    \x0b\x10\n\x0e\n\x06\x04\x86\x01\x02\x05\x01\x12\x04\xfd\x19\x11#\n\x0e\
    \n\x06\x04\x86\x01\x02\x05\x03\x12\x04\xfd\x19&'\n\xc9\x03\n\x05\x04\x86\
    \x01\x02\x06\x12\x04\x89\x1a\x02\x1d\x1a\xb9\x03\x20A\x20special\x20supp\
    lemental\x20group\x20that\x20applies\x20to\x20all\x20containers\x20in\
    \x20a\x20pod.\n\x20Some\x20volume\x20types\x20allow\x20the\x20Kubelet\
    \x20to\x20change\x20the\x20ownership\x20of\x20that\x20volume\n\x20to\x20\
    be\x20owned\x20by\x20the\x20pod:\n\n\x201.\x20The\x20owning\x20GID\x20wi\
    ll\x20be\x20the\x20FSGroup\n\x202.\x20The\x20setgid\x20bit\x20is\x20set\
    \x20(new\x20files\x20created\x20in\x20the\x20volume\x20will\x20be\x20own\
    ed\x20by\x20FSGroup)\n\x203.\x20The\x20permission\x20bits\x20are\x20OR'd\
    \x20with\x20rw-rw----\n\n\x20If\x20unset,\x20the\x20Kubelet\x20will\x20n\
    ot\x20modify\x20the\x20ownership\x20and\x20permissions\x20of\x20any\x20v\
    olume.\n\x20+optional\n\n\x0e\n\x06\x04\x86\x01\x02\x06\x04\x12\x04\x89\
    \x1a\x02\n\n\x0e\n\x06\x04\x86\x01\x02\x06\x05\x12\x04\x89\x1a\x0b\x10\n\
    \x0e\n\x06\x04\x86\x01\x02\x06\x01\x12\x04\x89\x1a\x11\x18\n\x0e\n\x06\
    \x04\x86\x01\x02\x06\x03\x12\x04\x89\x1a\x1b\x1c\n\xa8\x01\n\x05\x04\x86\
    \x01\x02\x07\x12\x04\x8e\x1a\x02\x1e\x1a\x98\x01\x20Sysctls\x20hold\x20a\
    \x20list\x20of\x20namespaced\x20sysctls\x20used\x20for\x20the\x20pod.\
    \x20Pods\x20with\x20unsupported\n\x20sysctls\x20(by\x20the\x20container\
    \x20runtime)\x20might\x20fail\x20to\x20launch.\n\x20+optional\n\n\x0e\n\
    \x06\x04\x86\x01\x02\x07\x04\x12\x04\x8e\x1a\x02\n\n\x0e\n\x06\x04\x86\
    \x01\x02\x07\x06\x12\x04\x8e\x1a\x0b\x11\n\x0e\n\x06\x04\x86\x01\x02\x07\
    \x01\x12\x04\x8e\x1a\x12\x19\n\x0e\n\x06\x04\x86\x01\x02\x07\x03\x12\x04\
    \x8e\x1a\x1c\x1d\n\xac\x03\n\x05\x04\x86\x01\x02\x08\x12\x04\x97\x1a\x02\
    *\x1a\x9c\x03\x20fsGroupChangePolicy\x20defines\x20behavior\x20of\x20cha\
    nging\x20ownership\x20and\x20permission\x20of\x20the\x20volume\n\x20befo\
    re\x20being\x20exposed\x20inside\x20Pod.\x20This\x20field\x20will\x20onl\
    y\x20apply\x20to\n\x20volume\x20types\x20which\x20support\x20fsGroup\x20\
    based\x20ownership(and\x20permissions).\n\x20It\x20will\x20have\x20no\
    \x20effect\x20on\x20ephemeral\x20volume\x20types\x20such\x20as:\x20secre\
    t,\x20configmaps\n\x20and\x20emptydir.\n\x20Valid\x20values\x20are\x20\"\
    OnRootMismatch\"\x20and\x20\"Always\".\x20If\x20not\x20specified,\x20\"A\
    lways\"\x20is\x20used.\n\x20+optional\n\n\x0e\n\x06\x04\x86\x01\x02\x08\
    \x04\x12\x04\x97\x1a\x02\n\n\x0e\n\x06\x04\x86\x01\x02\x08\x05\x12\x04\
    \x97\x1a\x0b\x11\n\x0e\n\x06\x04\x86\x01\x02\x08\x01\x12\x04\x97\x1a\x12\
    %\n\x0e\n\x06\x04\x86\x01\x02\x08\x03\x12\x04\x97\x1a()\nU\n\x05\x04\x86\
    \x01\x02\t\x12\x04\x9b\x1a\x02.\x1aF\x20The\x20seccomp\x20options\x20to\
    \x20use\x20by\x20the\x20containers\x20in\x20this\x20pod.\n\x20+optional\
    \n\n\x0e\n\x06\x04\x86\x01\x02\t\x04\x12\x04\x9b\x1a\x02\n\n\x0e\n\x06\
    \x04\x86\x01\x02\t\x06\x12\x04\x9b\x1a\x0b\x19\n\x0e\n\x06\x04\x86\x01\
    \x02\t\x01\x12\x04\x9b\x1a\x1a(\n\x0e\n\x06\x04\x86\x01\x02\t\x03\x12\
    \x04\x9b\x1a+-\nk\n\x03\x04\x87\x01\x12\x06\xa0\x1a\0\xa4\x1a\x01\x1a\\\
    \x20Describes\x20the\x20class\x20of\x20pods\x20that\x20should\x20avoid\
    \x20this\x20node.\n\x20Exactly\x20one\x20field\x20should\x20be\x20set.\n\
    \n\x0c\n\x04\x04\x87\x01\x01\x12\x04\xa0\x1a\x08\x14\nV\n\x05\x04\x87\
    \x01\x02\0\x12\x04\xa3\x1a\x02Q\x1aG\x20Reference\x20to\x20controller\
    \x20whose\x20pods\x20should\x20avoid\x20this\x20node.\n\x20+optional\n\n\
    \x0e\n\x06\x04\x87\x01\x02\0\x04\x12\x04\xa3\x1a\x02\n\n\x0e\n\x06\x04\
    \x87\x01\x02\0\x06\x12\x04\xa3\x1a\x0b>\n\x0e\n\x06\x04\x87\x01\x02\0\
    \x01\x12\x04\xa3\x1a?L\n\x0e\n\x06\x04\x87\x01\x02\0\x03\x12\x04\xa3\x1a\
    OP\n3\n\x03\x04\x88\x01\x12\x06\xa7\x1a\0\xa6\x1c\x01\x1a$\x20PodSpec\
    \x20is\x20a\x20description\x20of\x20a\x20pod.\n\n\x0c\n\x04\x04\x88\x01\
    \x01\x12\x04\xa7\x1a\x08\x0f\n\xda\x01\n\x05\x04\x88\x01\x02\0\x12\x04\
    \xad\x1a\x02\x1e\x1a\xca\x01\x20List\x20of\x20volumes\x20that\x20can\x20\
    be\x20mounted\x20by\x20containers\x20belonging\x20to\x20the\x20pod.\n\
    \x20More\x20info:\x20https://kubernetes.io/docs/concepts/storage/volumes\
    \n\x20+optional\n\x20+patchMergeKey=name\n\x20+patchStrategy=merge,retai\
    nKeys\n\n\x0e\n\x06\x04\x88\x01\x02\0\x04\x12\x04\xad\x1a\x02\n\n\x0e\n\
    \x06\x04\x88\x01\x02\0\x06\x12\x04\xad\x1a\x0b\x11\n\x0e\n\x06\x04\x88\
    \x01\x02\0\x01\x12\x04\xad\x1a\x12\x19\n\x0e\n\x06\x04\x88\x01\x02\0\x03\
    \x12\x04\xad\x1a\x1c\x1d\n\xad\x07\n\x05\x04\x88\x01\x02\x01\x12\x04\xbe\
    \x1a\x02)\x1a\x9d\x07\x20List\x20of\x20initialization\x20containers\x20b\
    elonging\x20to\x20the\x20pod.\n\x20Init\x20containers\x20are\x20executed\
    \x20in\x20order\x20prior\x20to\x20containers\x20being\x20started.\x20If\
    \x20any\n\x20init\x20container\x20fails,\x20the\x20pod\x20is\x20consider\
    ed\x20to\x20have\x20failed\x20and\x20is\x20handled\x20according\n\x20to\
    \x20its\x20restartPolicy.\x20The\x20name\x20for\x20an\x20init\x20contain\
    er\x20or\x20normal\x20container\x20must\x20be\n\x20unique\x20among\x20al\
    l\x20containers.\n\x20Init\x20containers\x20may\x20not\x20have\x20Lifecy\
    cle\x20actions,\x20Readiness\x20probes,\x20Liveness\x20probes,\x20or\x20\
    Startup\x20probes.\n\x20The\x20resourceRequirements\x20of\x20an\x20init\
    \x20container\x20are\x20taken\x20into\x20account\x20during\x20scheduling\
    \n\x20by\x20finding\x20the\x20highest\x20request/limit\x20for\x20each\
    \x20resource\x20type,\x20and\x20then\x20using\x20the\x20max\x20of\n\x20o\
    f\x20that\x20value\x20or\x20the\x20sum\x20of\x20the\x20normal\x20contain\
    ers.\x20Limits\x20are\x20applied\x20to\x20init\x20containers\n\x20in\x20\
    a\x20similar\x20fashion.\n\x20Init\x20containers\x20cannot\x20currently\
    \x20be\x20added\x20or\x20removed.\n\x20Cannot\x20be\x20updated.\n\x20Mor\
    e\x20info:\x20https://kubernetes.io/docs/concepts/workloads/pods/init-co\
    ntainers/\n\x20+patchMergeKey=name\n\x20+patchStrategy=merge\n\n\x0e\n\
    \x06\x04\x88\x01\x02\x01\x04\x12\x04\xbe\x1a\x02\n\n\x0e\n\x06\x04\x88\
    \x01\x02\x01\x06\x12\x04\xbe\x1a\x0b\x14\n\x0e\n\x06\x04\x88\x01\x02\x01\
    \x01\x12\x04\xbe\x1a\x15#\n\x0e\n\x06\x04\x88\x01\x02\x01\x03\x12\x04\
    \xbe\x1a&(\n\xdb\x01\n\x05\x04\x88\x01\x02\x02\x12\x04\xc6\x1a\x02$\x1a\
    \xcb\x01\x20List\x20of\x20containers\x20belonging\x20to\x20the\x20pod.\n\
    \x20Containers\x20cannot\x20currently\x20be\x20added\x20or\x20removed.\n\
    \x20There\x20must\x20be\x20at\x20least\x20one\x20container\x20in\x20a\
    \x20Pod.\n\x20Cannot\x20be\x20updated.\n\x20+patchMergeKey=name\n\x20+pa\
    tchStrategy=merge\n\n\x0e\n\x06\x04\x88\x01\x02\x02\x04\x12\x04\xc6\x1a\
    \x02\n\n\x0e\n\x06\x04\x88\x01\x02\x02\x06\x12\x04\xc6\x1a\x0b\x14\n\x0e\
    \n\x06\x04\x88\x01\x02\x02\x01\x12\x04\xc6\x1a\x15\x1f\n\x0e\n\x06\x04\
    \x88\x01\x02\x02\x03\x12\x04\xc6\x1a\"#\n\x98\x04\n\x05\x04\x88\x01\x02\
    \x03\x12\x04\xd0\x1a\x027\x1a\x88\x04\x20List\x20of\x20ephemeral\x20cont\
    ainers\x20run\x20in\x20this\x20pod.\x20Ephemeral\x20containers\x20may\
    \x20be\x20run\x20in\x20an\x20existing\n\x20pod\x20to\x20perform\x20user-\
    initiated\x20actions\x20such\x20as\x20debugging.\x20This\x20list\x20cann\
    ot\x20be\x20specified\x20when\n\x20creating\x20a\x20pod,\x20and\x20it\
    \x20cannot\x20be\x20modified\x20by\x20updating\x20the\x20pod\x20spec.\
    \x20In\x20order\x20to\x20add\x20an\n\x20ephemeral\x20container\x20to\x20\
    an\x20existing\x20pod,\x20use\x20the\x20pod's\x20ephemeralcontainers\x20\
    subresource.\n\x20This\x20field\x20is\x20alpha-level\x20and\x20is\x20onl\
    y\x20honored\x20by\x20servers\x20that\x20enable\x20the\x20EphemeralConta\
    iners\x20feature.\n\x20+optional\n\x20+patchMergeKey=name\n\x20+patchStr\
    ategy=merge\n\n\x0e\n\x06\x04\x88\x01\x02\x03\x04\x12\x04\xd0\x1a\x02\n\
    \n\x0e\n\x06\x04\x88\x01\x02\x03\x06\x12\x04\xd0\x1a\x0b\x1d\n\x0e\n\x06\
    \x04\x88\x01\x02\x03\x01\x12\x04\xd0\x1a\x1e1\n\x0e\n\x06\x04\x88\x01\
    \x02\x03\x03\x12\x04\xd0\x1a46\n\xe1\x01\n\x05\x04\x88\x01\x02\x04\x12\
    \x04\xd7\x1a\x02$\x1a\xd1\x01\x20Restart\x20policy\x20for\x20all\x20cont\
    ainers\x20within\x20the\x20pod.\n\x20One\x20of\x20Always,\x20OnFailure,\
    \x20Never.\n\x20Default\x20to\x20Always.\n\x20More\x20info:\x20https://k\
    ubernetes.io/docs/concepts/workloads/pods/pod-lifecycle/#restart-policy\
    \n\x20+optional\n\n\x0e\n\x06\x04\x88\x01\x02\x04\x04\x12\x04\xd7\x1a\
    \x02\n\n\x0e\n\x06\x04\x88\x01\x02\x04\x05\x12\x04\xd7\x1a\x0b\x11\n\x0e\
    \n\x06\x04\x88\x01\x02\x04\x01\x12\x04\xd7\x1a\x12\x1f\n\x0e\n\x06\x04\
    \x88\x01\x02\x04\x03\x12\x04\xd7\x1a\"#\n\xb8\x04\n\x05\x04\x88\x01\x02\
    \x05\x12\x04\xe1\x1a\x023\x1a\xa8\x04\x20Optional\x20duration\x20in\x20s\
    econds\x20the\x20pod\x20needs\x20to\x20terminate\x20gracefully.\x20May\
    \x20be\x20decreased\x20in\x20delete\x20request.\n\x20Value\x20must\x20be\
    \x20non-negative\x20integer.\x20The\x20value\x20zero\x20indicates\x20del\
    ete\x20immediately.\n\x20If\x20this\x20value\x20is\x20nil,\x20the\x20def\
    ault\x20grace\x20period\x20will\x20be\x20used\x20instead.\n\x20The\x20gr\
    ace\x20period\x20is\x20the\x20duration\x20in\x20seconds\x20after\x20the\
    \x20processes\x20running\x20in\x20the\x20pod\x20are\x20sent\n\x20a\x20te\
    rmination\x20signal\x20and\x20the\x20time\x20when\x20the\x20processes\
    \x20are\x20forcibly\x20halted\x20with\x20a\x20kill\x20signal.\n\x20Set\
    \x20this\x20value\x20longer\x20than\x20the\x20expected\x20cleanup\x20tim\
    e\x20for\x20your\x20process.\n\x20Defaults\x20to\x2030\x20seconds.\n\x20\
    +optional\n\n\x0e\n\x06\x04\x88\x01\x02\x05\x04\x12\x04\xe1\x1a\x02\n\n\
    \x0e\n\x06\x04\x88\x01\x02\x05\x05\x12\x04\xe1\x1a\x0b\x10\n\x0e\n\x06\
    \x04\x88\x01\x02\x05\x01\x12\x04\xe1\x1a\x11.\n\x0e\n\x06\x04\x88\x01\
    \x02\x05\x03\x12\x04\xe1\x1a12\n\xeb\x01\n\x05\x04\x88\x01\x02\x06\x12\
    \x04\xe7\x1a\x02+\x1a\xdb\x01\x20Optional\x20duration\x20in\x20seconds\
    \x20the\x20pod\x20may\x20be\x20active\x20on\x20the\x20node\x20relative\
    \x20to\n\x20StartTime\x20before\x20the\x20system\x20will\x20actively\x20\
    try\x20to\x20mark\x20it\x20failed\x20and\x20kill\x20associated\x20contai\
    ners.\n\x20Value\x20must\x20be\x20a\x20positive\x20integer.\n\x20+option\
    al\n\n\x0e\n\x06\x04\x88\x01\x02\x06\x04\x12\x04\xe7\x1a\x02\n\n\x0e\n\
    \x06\x04\x88\x01\x02\x06\x05\x12\x04\xe7\x1a\x0b\x10\n\x0e\n\x06\x04\x88\
    \x01\x02\x06\x01\x12\x04\xe7\x1a\x11&\n\x0e\n\x06\x04\x88\x01\x02\x06\
    \x03\x12\x04\xe7\x1a)*\n\xfc\x02\n\x05\x04\x88\x01\x02\x07\x12\x04\xf0\
    \x1a\x02\x20\x1a\xec\x02\x20Set\x20DNS\x20policy\x20for\x20the\x20pod.\n\
    \x20Defaults\x20to\x20\"ClusterFirst\".\n\x20Valid\x20values\x20are\x20'\
    ClusterFirstWithHostNet',\x20'ClusterFirst',\x20'Default'\x20or\x20'None\
    '.\n\x20DNS\x20parameters\x20given\x20in\x20DNSConfig\x20will\x20be\x20m\
    erged\x20with\x20the\x20policy\x20selected\x20with\x20DNSPolicy.\n\x20To\
    \x20have\x20DNS\x20options\x20set\x20along\x20with\x20hostNetwork,\x20yo\
    u\x20have\x20to\x20specify\x20DNS\x20policy\n\x20explicitly\x20to\x20'Cl\
    usterFirstWithHostNet'.\n\x20+optional\n\n\x0e\n\x06\x04\x88\x01\x02\x07\
    \x04\x12\x04\xf0\x1a\x02\n\n\x0e\n\x06\x04\x88\x01\x02\x07\x05\x12\x04\
    \xf0\x1a\x0b\x11\n\x0e\n\x06\x04\x88\x01\x02\x07\x01\x12\x04\xf0\x1a\x12\
    \x1b\n\x0e\n\x06\x04\x88\x01\x02\x07\x03\x12\x04\xf0\x1a\x1e\x1f\n\x8c\
    \x02\n\x05\x04\x88\x01\x02\x08\x12\x04\xf6\x1a\x02'\x1a\xfc\x01\x20NodeS\
    elector\x20is\x20a\x20selector\x20which\x20must\x20be\x20true\x20for\x20\
    the\x20pod\x20to\x20fit\x20on\x20a\x20node.\n\x20Selector\x20which\x20mu\
    st\x20match\x20a\x20node's\x20labels\x20for\x20the\x20pod\x20to\x20be\
    \x20scheduled\x20on\x20that\x20node.\n\x20More\x20info:\x20https://kuber\
    netes.io/docs/concepts/configuration/assign-pod-node/\n\x20+optional\n\n\
    \x10\n\x06\x04\x88\x01\x02\x08\x04\x12\x06\xf6\x1a\x02\xf0\x1a\x20\n\x0e\
    \n\x06\x04\x88\x01\x02\x08\x06\x12\x04\xf6\x1a\x02\x15\n\x0e\n\x06\x04\
    \x88\x01\x02\x08\x01\x12\x04\xf6\x1a\x16\"\n\x0e\n\x06\x04\x88\x01\x02\
    \x08\x03\x12\x04\xf6\x1a%&\n\xc9\x01\n\x05\x04\x88\x01\x02\t\x12\x04\xfb\
    \x1a\x02)\x1a\xb9\x01\x20ServiceAccountName\x20is\x20the\x20name\x20of\
    \x20the\x20ServiceAccount\x20to\x20use\x20to\x20run\x20this\x20pod.\n\
    \x20More\x20info:\x20https://kubernetes.io/docs/tasks/configure-pod-cont\
    ainer/configure-service-account/\n\x20+optional\n\n\x0e\n\x06\x04\x88\
    \x01\x02\t\x04\x12\x04\xfb\x1a\x02\n\n\x0e\n\x06\x04\x88\x01\x02\t\x05\
    \x12\x04\xfb\x1a\x0b\x11\n\x0e\n\x06\x04\x88\x01\x02\t\x01\x12\x04\xfb\
    \x1a\x12$\n\x0e\n\x06\x04\x88\x01\x02\t\x03\x12\x04\xfb\x1a'(\n\xac\x01\
    \n\x05\x04\x88\x01\x02\n\x12\x04\x81\x1b\x02%\x1a\x9c\x01\x20DeprecatedS\
    erviceAccount\x20is\x20a\x20depreciated\x20alias\x20for\x20ServiceAccoun\
    tName.\n\x20Deprecated:\x20Use\x20serviceAccountName\x20instead.\n\x20+k\
    8s:conversion-gen=false\n\x20+optional\n\n\x0e\n\x06\x04\x88\x01\x02\n\
    \x04\x12\x04\x81\x1b\x02\n\n\x0e\n\x06\x04\x88\x01\x02\n\x05\x12\x04\x81\
    \x1b\x0b\x11\n\x0e\n\x06\x04\x88\x01\x02\n\x01\x12\x04\x81\x1b\x12\x20\n\
    \x0e\n\x06\x04\x88\x01\x02\n\x03\x12\x04\x81\x1b#$\n\x83\x01\n\x05\x04\
    \x88\x01\x02\x0b\x12\x04\x85\x1b\x022\x1at\x20AutomountServiceAccountTok\
    en\x20indicates\x20whether\x20a\x20service\x20account\x20token\x20should\
    \x20be\x20automatically\x20mounted.\n\x20+optional\n\n\x0e\n\x06\x04\x88\
    \x01\x02\x0b\x04\x12\x04\x85\x1b\x02\n\n\x0e\n\x06\x04\x88\x01\x02\x0b\
    \x05\x12\x04\x85\x1b\x0b\x0f\n\x0e\n\x06\x04\x88\x01\x02\x0b\x01\x12\x04\
    \x85\x1b\x10,\n\x0e\n\x06\x04\x88\x01\x02\x0b\x03\x12\x04\x85\x1b/1\n\
    \xd8\x01\n\x05\x04\x88\x01\x02\x0c\x12\x04\x8b\x1b\x02\x20\x1a\xc8\x01\
    \x20NodeName\x20is\x20a\x20request\x20to\x20schedule\x20this\x20pod\x20o\
    nto\x20a\x20specific\x20node.\x20If\x20it\x20is\x20non-empty,\n\x20the\
    \x20scheduler\x20simply\x20schedules\x20this\x20pod\x20onto\x20that\x20n\
    ode,\x20assuming\x20that\x20it\x20fits\x20resource\n\x20requirements.\n\
    \x20+optional\n\n\x0e\n\x06\x04\x88\x01\x02\x0c\x04\x12\x04\x8b\x1b\x02\
    \n\n\x0e\n\x06\x04\x88\x01\x02\x0c\x05\x12\x04\x8b\x1b\x0b\x11\n\x0e\n\
    \x06\x04\x88\x01\x02\x0c\x01\x12\x04\x8b\x1b\x12\x1a\n\x0e\n\x06\x04\x88\
    \x01\x02\x0c\x03\x12\x04\x8b\x1b\x1d\x1f\n\xdb\x01\n\x05\x04\x88\x01\x02\
    \r\x12\x04\x92\x1b\x02!\x1a\xcb\x01\x20Host\x20networking\x20requested\
    \x20for\x20this\x20pod.\x20Use\x20the\x20host's\x20network\x20namespace.\
    \n\x20If\x20this\x20option\x20is\x20set,\x20the\x20ports\x20that\x20will\
    \x20be\x20used\x20must\x20be\x20specified.\n\x20Default\x20to\x20false.\
    \n\x20+k8s:conversion-gen=false\n\x20+optional\n\n\x0e\n\x06\x04\x88\x01\
    \x02\r\x04\x12\x04\x92\x1b\x02\n\n\x0e\n\x06\x04\x88\x01\x02\r\x05\x12\
    \x04\x92\x1b\x0b\x0f\n\x0e\n\x06\x04\x88\x01\x02\r\x01\x12\x04\x92\x1b\
    \x10\x1b\n\x0e\n\x06\x04\x88\x01\x02\r\x03\x12\x04\x92\x1b\x1e\x20\nq\n\
    \x05\x04\x88\x01\x02\x0e\x12\x04\x98\x1b\x02\x1d\x1ab\x20Use\x20the\x20h\
    ost's\x20pid\x20namespace.\n\x20Optional:\x20Default\x20to\x20false.\n\
    \x20+k8s:conversion-gen=false\n\x20+optional\n\n\x0e\n\x06\x04\x88\x01\
    \x02\x0e\x04\x12\x04\x98\x1b\x02\n\n\x0e\n\x06\x04\x88\x01\x02\x0e\x05\
    \x12\x04\x98\x1b\x0b\x0f\n\x0e\n\x06\x04\x88\x01\x02\x0e\x01\x12\x04\x98\
    \x1b\x10\x17\n\x0e\n\x06\x04\x88\x01\x02\x0e\x03\x12\x04\x98\x1b\x1a\x1c\
    \nq\n\x05\x04\x88\x01\x02\x0f\x12\x04\x9e\x1b\x02\x1d\x1ab\x20Use\x20the\
    \x20host's\x20ipc\x20namespace.\n\x20Optional:\x20Default\x20to\x20false\
    .\n\x20+k8s:conversion-gen=false\n\x20+optional\n\n\x0e\n\x06\x04\x88\
    \x01\x02\x0f\x04\x12\x04\x9e\x1b\x02\n\n\x0e\n\x06\x04\x88\x01\x02\x0f\
    \x05\x12\x04\x9e\x1b\x0b\x0f\n\x0e\n\x06\x04\x88\x01\x02\x0f\x01\x12\x04\
    \x9e\x1b\x10\x17\n\x0e\n\x06\x04\x88\x01\x02\x0f\x03\x12\x04\x9e\x1b\x1a\
    \x1c\n\x87\x03\n\x05\x04\x88\x01\x02\x10\x12\x04\xa7\x1b\x02+\x1a\xf7\
    \x02\x20Share\x20a\x20single\x20process\x20namespace\x20between\x20all\
    \x20of\x20the\x20containers\x20in\x20a\x20pod.\n\x20When\x20this\x20is\
    \x20set\x20containers\x20will\x20be\x20able\x20to\x20view\x20and\x20sign\
    al\x20processes\x20from\x20other\x20containers\n\x20in\x20the\x20same\
    \x20pod,\x20and\x20the\x20first\x20process\x20in\x20each\x20container\
    \x20will\x20not\x20be\x20assigned\x20PID\x201.\n\x20HostPID\x20and\x20Sh\
    areProcessNamespace\x20cannot\x20both\x20be\x20set.\n\x20Optional:\x20De\
    fault\x20to\x20false.\n\x20+k8s:conversion-gen=false\n\x20+optional\n\n\
    \x0e\n\x06\x04\x88\x01\x02\x10\x04\x12\x04\xa7\x1b\x02\n\n\x0e\n\x06\x04\
    \x88\x01\x02\x10\x05\x12\x04\xa7\x1b\x0b\x0f\n\x0e\n\x06\x04\x88\x01\x02\
    \x10\x01\x12\x04\xa7\x1b\x10%\n\x0e\n\x06\x04\x88\x01\x02\x10\x03\x12\
    \x04\xa7\x1b(*\n\xc5\x01\n\x05\x04\x88\x01\x02\x11\x12\x04\xac\x1b\x023\
    \x1a\xb5\x01\x20SecurityContext\x20holds\x20pod-level\x20security\x20att\
    ributes\x20and\x20common\x20container\x20settings.\n\x20Optional:\x20Def\
    aults\x20to\x20empty.\x20\x20See\x20type\x20description\x20for\x20defaul\
    t\x20values\x20of\x20each\x20field.\n\x20+optional\n\n\x0e\n\x06\x04\x88\
    \x01\x02\x11\x04\x12\x04\xac\x1b\x02\n\n\x0e\n\x06\x04\x88\x01\x02\x11\
    \x06\x12\x04\xac\x1b\x0b\x1d\n\x0e\n\x06\x04\x88\x01\x02\x11\x01\x12\x04\
    \xac\x1b\x1e-\n\x0e\n\x06\x04\x88\x01\x02\x11\x03\x12\x04\xac\x1b02\n\
    \xf0\x03\n\x05\x04\x88\x01\x02\x12\x12\x04\xb5\x1b\x026\x1a\xe0\x03\x20I\
    magePullSecrets\x20is\x20an\x20optional\x20list\x20of\x20references\x20t\
    o\x20secrets\x20in\x20the\x20same\x20namespace\x20to\x20use\x20for\x20pu\
    lling\x20any\x20of\x20the\x20images\x20used\x20by\x20this\x20PodSpec.\n\
    \x20If\x20specified,\x20these\x20secrets\x20will\x20be\x20passed\x20to\
    \x20individual\x20puller\x20implementations\x20for\x20them\x20to\x20use.\
    \x20For\x20example,\n\x20in\x20the\x20case\x20of\x20docker,\x20only\x20D\
    ockerConfig\x20type\x20secrets\x20are\x20honored.\n\x20More\x20info:\x20\
    https://kubernetes.io/docs/concepts/containers/images#specifying-imagepu\
    llsecrets-on-a-pod\n\x20+optional\n\x20+patchMergeKey=name\n\x20+patchSt\
    rategy=merge\n\n\x0e\n\x06\x04\x88\x01\x02\x12\x04\x12\x04\xb5\x1b\x02\n\
    \n\x0e\n\x06\x04\x88\x01\x02\x12\x06\x12\x04\xb5\x1b\x0b\x1f\n\x0e\n\x06\
    \x04\x88\x01\x02\x12\x01\x12\x04\xb5\x1b\x200\n\x0e\n\x06\x04\x88\x01\
    \x02\x12\x03\x12\x04\xb5\x1b35\n\x8a\x01\n\x05\x04\x88\x01\x02\x13\x12\
    \x04\xba\x1b\x02\x20\x1a{\x20Specifies\x20the\x20hostname\x20of\x20the\
    \x20Pod\n\x20If\x20not\x20specified,\x20the\x20pod's\x20hostname\x20will\
    \x20be\x20set\x20to\x20a\x20system-defined\x20value.\n\x20+optional\n\n\
    \x0e\n\x06\x04\x88\x01\x02\x13\x04\x12\x04\xba\x1b\x02\n\n\x0e\n\x06\x04\
    \x88\x01\x02\x13\x05\x12\x04\xba\x1b\x0b\x11\n\x0e\n\x06\x04\x88\x01\x02\
    \x13\x01\x12\x04\xba\x1b\x12\x1a\n\x0e\n\x06\x04\x88\x01\x02\x13\x03\x12\
    \x04\xba\x1b\x1d\x1f\n\xd0\x01\n\x05\x04\x88\x01\x02\x14\x12\x04\xbf\x1b\
    \x02!\x1a\xc0\x01\x20If\x20specified,\x20the\x20fully\x20qualified\x20Po\
    d\x20hostname\x20will\x20be\x20\"<hostname>.<subdomain>.<pod\x20namespac\
    e>.svc.<cluster\x20domain>\".\n\x20If\x20not\x20specified,\x20the\x20pod\
    \x20will\x20not\x20have\x20a\x20domainname\x20at\x20all.\n\x20+optional\
    \n\n\x0e\n\x06\x04\x88\x01\x02\x14\x04\x12\x04\xbf\x1b\x02\n\n\x0e\n\x06\
    \x04\x88\x01\x02\x14\x05\x12\x04\xbf\x1b\x0b\x11\n\x0e\n\x06\x04\x88\x01\
    \x02\x14\x01\x12\x04\xbf\x1b\x12\x1b\n\x0e\n\x06\x04\x88\x01\x02\x14\x03\
    \x12\x04\xbf\x1b\x1e\x20\nJ\n\x05\x04\x88\x01\x02\x15\x12\x04\xc3\x1b\
    \x02\"\x1a;\x20If\x20specified,\x20the\x20pod's\x20scheduling\x20constra\
    ints\n\x20+optional\n\n\x0e\n\x06\x04\x88\x01\x02\x15\x04\x12\x04\xc3\
    \x1b\x02\n\n\x0e\n\x06\x04\x88\x01\x02\x15\x06\x12\x04\xc3\x1b\x0b\x13\n\
    \x0e\n\x06\x04\x88\x01\x02\x15\x01\x12\x04\xc3\x1b\x14\x1c\n\x0e\n\x06\
    \x04\x88\x01\x02\x15\x03\x12\x04\xc3\x1b\x1f!\n\xa1\x01\n\x05\x04\x88\
    \x01\x02\x16\x12\x04\xc8\x1b\x02%\x1a\x91\x01\x20If\x20specified,\x20the\
    \x20pod\x20will\x20be\x20dispatched\x20by\x20specified\x20scheduler.\n\
    \x20If\x20not\x20specified,\x20the\x20pod\x20will\x20be\x20dispatched\
    \x20by\x20default\x20scheduler.\n\x20+optional\n\n\x0e\n\x06\x04\x88\x01\
    \x02\x16\x04\x12\x04\xc8\x1b\x02\n\n\x0e\n\x06\x04\x88\x01\x02\x16\x05\
    \x12\x04\xc8\x1b\x0b\x11\n\x0e\n\x06\x04\x88\x01\x02\x16\x01\x12\x04\xc8\
    \x1b\x12\x1f\n\x0e\n\x06\x04\x88\x01\x02\x16\x03\x12\x04\xc8\x1b\"$\n@\n\
    \x05\x04\x88\x01\x02\x17\x12\x04\xcc\x1b\x02'\x1a1\x20If\x20specified,\
    \x20the\x20pod's\x20tolerations.\n\x20+optional\n\n\x0e\n\x06\x04\x88\
    \x01\x02\x17\x04\x12\x04\xcc\x1b\x02\n\n\x0e\n\x06\x04\x88\x01\x02\x17\
    \x06\x12\x04\xcc\x1b\x0b\x15\n\x0e\n\x06\x04\x88\x01\x02\x17\x01\x12\x04\
    \xcc\x1b\x16!\n\x0e\n\x06\x04\x88\x01\x02\x17\x03\x12\x04\xcc\x1b$&\n\
    \xe2\x01\n\x05\x04\x88\x01\x02\x18\x12\x04\xd3\x1b\x02&\x1a\xd2\x01\x20H\
    ostAliases\x20is\x20an\x20optional\x20list\x20of\x20hosts\x20and\x20IPs\
    \x20that\x20will\x20be\x20injected\x20into\x20the\x20pod's\x20hosts\n\
    \x20file\x20if\x20specified.\x20This\x20is\x20only\x20valid\x20for\x20no\
    n-hostNetwork\x20pods.\n\x20+optional\n\x20+patchMergeKey=ip\n\x20+patch\
    Strategy=merge\n\n\x0e\n\x06\x04\x88\x01\x02\x18\x04\x12\x04\xd3\x1b\x02\
    \n\n\x0e\n\x06\x04\x88\x01\x02\x18\x06\x12\x04\xd3\x1b\x0b\x14\n\x0e\n\
    \x06\x04\x88\x01\x02\x18\x01\x12\x04\xd3\x1b\x15\x20\n\x0e\n\x06\x04\x88\
    \x01\x02\x18\x03\x12\x04\xd3\x1b#%\n\x92\x03\n\x05\x04\x88\x01\x02\x19\
    \x12\x04\xdc\x1b\x02)\x1a\x82\x03\x20If\x20specified,\x20indicates\x20th\
    e\x20pod's\x20priority.\x20\"system-node-critical\"\x20and\n\x20\"system\
    -cluster-critical\"\x20are\x20two\x20special\x20keywords\x20which\x20ind\
    icate\x20the\n\x20highest\x20priorities\x20with\x20the\x20former\x20bein\
    g\x20the\x20highest\x20priority.\x20Any\x20other\n\x20name\x20must\x20be\
    \x20defined\x20by\x20creating\x20a\x20PriorityClass\x20object\x20with\
    \x20that\x20name.\n\x20If\x20not\x20specified,\x20the\x20pod\x20priority\
    \x20will\x20be\x20default\x20or\x20zero\x20if\x20there\x20is\x20no\n\x20\
    default.\n\x20+optional\n\n\x0e\n\x06\x04\x88\x01\x02\x19\x04\x12\x04\
    \xdc\x1b\x02\n\n\x0e\n\x06\x04\x88\x01\x02\x19\x05\x12\x04\xdc\x1b\x0b\
    \x11\n\x0e\n\x06\x04\x88\x01\x02\x19\x01\x12\x04\xdc\x1b\x12#\n\x0e\n\
    \x06\x04\x88\x01\x02\x19\x03\x12\x04\xdc\x1b&(\n\xcd\x02\n\x05\x04\x88\
    \x01\x02\x1a\x12\x04\xe4\x1b\x02\x1f\x1a\xbd\x02\x20The\x20priority\x20v\
    alue.\x20Various\x20system\x20components\x20use\x20this\x20field\x20to\
    \x20find\x20the\n\x20priority\x20of\x20the\x20pod.\x20When\x20Priority\
    \x20Admission\x20Controller\x20is\x20enabled,\x20it\n\x20prevents\x20use\
    rs\x20from\x20setting\x20this\x20field.\x20The\x20admission\x20controlle\
    r\x20populates\n\x20this\x20field\x20from\x20PriorityClassName.\n\x20The\
    \x20higher\x20the\x20value,\x20the\x20higher\x20the\x20priority.\n\x20+o\
    ptional\n\n\x0e\n\x06\x04\x88\x01\x02\x1a\x04\x12\x04\xe4\x1b\x02\n\n\
    \x0e\n\x06\x04\x88\x01\x02\x1a\x05\x12\x04\xe4\x1b\x0b\x10\n\x0e\n\x06\
    \x04\x88\x01\x02\x1a\x01\x12\x04\xe4\x1b\x11\x19\n\x0e\n\x06\x04\x88\x01\
    \x02\x1a\x03\x12\x04\xe4\x1b\x1c\x1e\n\xa5\x01\n\x05\x04\x88\x01\x02\x1b\
    \x12\x04\xea\x1b\x02'\x1a\x95\x01\x20Specifies\x20the\x20DNS\x20paramete\
    rs\x20of\x20a\x20pod.\n\x20Parameters\x20specified\x20here\x20will\x20be\
    \x20merged\x20to\x20the\x20generated\x20DNS\n\x20configuration\x20based\
    \x20on\x20DNSPolicy.\n\x20+optional\n\n\x0e\n\x06\x04\x88\x01\x02\x1b\
    \x04\x12\x04\xea\x1b\x02\n\n\x0e\n\x06\x04\x88\x01\x02\x1b\x06\x12\x04\
    \xea\x1b\x0b\x17\n\x0e\n\x06\x04\x88\x01\x02\x1b\x01\x12\x04\xea\x1b\x18\
    !\n\x0e\n\x06\x04\x88\x01\x02\x1b\x03\x12\x04\xea\x1b$&\n\xbb\x02\n\x05\
    \x04\x88\x01\x02\x1c\x12\x04\xf1\x1b\x020\x1a\xab\x02\x20If\x20specified\
    ,\x20all\x20readiness\x20gates\x20will\x20be\x20evaluated\x20for\x20pod\
    \x20readiness.\n\x20A\x20pod\x20is\x20ready\x20when\x20all\x20its\x20con\
    tainers\x20are\x20ready\x20AND\n\x20all\x20conditions\x20specified\x20in\
    \x20the\x20readiness\x20gates\x20have\x20status\x20equal\x20to\x20\"True\
    \"\n\x20More\x20info:\x20https://git.k8s.io/enhancements/keps/sig-networ\
    k/0007-pod-ready%2B%2B.md\n\x20+optional\n\n\x0e\n\x06\x04\x88\x01\x02\
    \x1c\x04\x12\x04\xf1\x1b\x02\n\n\x0e\n\x06\x04\x88\x01\x02\x1c\x06\x12\
    \x04\xf1\x1b\x0b\x1b\n\x0e\n\x06\x04\x88\x01\x02\x1c\x01\x12\x04\xf1\x1b\
    \x1c*\n\x0e\n\x06\x04\x88\x01\x02\x1c\x03\x12\x04\xf1\x1b-/\n\xf0\x03\n\
    \x05\x04\x88\x01\x02\x1d\x12\x04\xfa\x1b\x02(\x1a\xe0\x03\x20RuntimeClas\
    sName\x20refers\x20to\x20a\x20RuntimeClass\x20object\x20in\x20the\x20nod\
    e.k8s.io\x20group,\x20which\x20should\x20be\x20used\n\x20to\x20run\x20th\
    is\x20pod.\x20\x20If\x20no\x20RuntimeClass\x20resource\x20matches\x20the\
    \x20named\x20class,\x20the\x20pod\x20will\x20not\x20be\x20run.\n\x20If\
    \x20unset\x20or\x20empty,\x20the\x20\"legacy\"\x20RuntimeClass\x20will\
    \x20be\x20used,\x20which\x20is\x20an\x20implicit\x20class\x20with\x20an\
    \n\x20empty\x20definition\x20that\x20uses\x20the\x20default\x20runtime\
    \x20handler.\n\x20More\x20info:\x20https://git.k8s.io/enhancements/keps/\
    sig-node/runtime-class.md\n\x20This\x20is\x20a\x20beta\x20feature\x20as\
    \x20of\x20Kubernetes\x20v1.14.\n\x20+optional\n\n\x0e\n\x06\x04\x88\x01\
    \x02\x1d\x04\x12\x04\xfa\x1b\x02\n\n\x0e\n\x06\x04\x88\x01\x02\x1d\x05\
    \x12\x04\xfa\x1b\x0b\x11\n\x0e\n\x06\x04\x88\x01\x02\x1d\x01\x12\x04\xfa\
    \x1b\x12\"\n\x0e\n\x06\x04\x88\x01\x02\x1d\x03\x12\x04\xfa\x1b%'\n\xd4\
    \x01\n\x05\x04\x88\x01\x02\x1e\x12\x04\x80\x1c\x02(\x1a\xc4\x01\x20Enabl\
    eServiceLinks\x20indicates\x20whether\x20information\x20about\x20service\
    s\x20should\x20be\x20injected\x20into\x20pod's\n\x20environment\x20varia\
    bles,\x20matching\x20the\x20syntax\x20of\x20Docker\x20links.\n\x20Option\
    al:\x20Defaults\x20to\x20true.\n\x20+optional\n\n\x0e\n\x06\x04\x88\x01\
    \x02\x1e\x04\x12\x04\x80\x1c\x02\n\n\x0e\n\x06\x04\x88\x01\x02\x1e\x05\
    \x12\x04\x80\x1c\x0b\x0f\n\x0e\n\x06\x04\x88\x01\x02\x1e\x01\x12\x04\x80\
    \x1c\x10\"\n\x0e\n\x06\x04\x88\x01\x02\x1e\x03\x12\x04\x80\x1c%'\n\x81\
    \x02\n\x05\x04\x88\x01\x02\x1f\x12\x04\x87\x1c\x02(\x1a\xf1\x01\x20Preem\
    ptionPolicy\x20is\x20the\x20Policy\x20for\x20preempting\x20pods\x20with\
    \x20lower\x20priority.\n\x20One\x20of\x20Never,\x20PreemptLowerPriority.\
    \n\x20Defaults\x20to\x20PreemptLowerPriority\x20if\x20unset.\n\x20This\
    \x20field\x20is\x20beta-level,\x20gated\x20by\x20the\x20NonPreemptingPri\
    ority\x20feature-gate.\n\x20+optional\n\n\x0e\n\x06\x04\x88\x01\x02\x1f\
    \x04\x12\x04\x87\x1c\x02\n\n\x0e\n\x06\x04\x88\x01\x02\x1f\x05\x12\x04\
    \x87\x1c\x0b\x11\n\x0e\n\x06\x04\x88\x01\x02\x1f\x01\x12\x04\x87\x1c\x12\
    \"\n\x0e\n\x06\x04\x88\x01\x02\x1f\x03\x12\x04\x87\x1c%'\n\xb7\x06\n\x05\
    \x04\x88\x01\x02\x20\x12\x04\x92\x1c\x02K\x1a\xa7\x06\x20Overhead\x20rep\
    resents\x20the\x20resource\x20overhead\x20associated\x20with\x20running\
    \x20a\x20pod\x20for\x20a\x20given\x20RuntimeClass.\n\x20This\x20field\
    \x20will\x20be\x20autopopulated\x20at\x20admission\x20time\x20by\x20the\
    \x20RuntimeClass\x20admission\x20controller.\x20If\n\x20the\x20RuntimeCl\
    ass\x20admission\x20controller\x20is\x20enabled,\x20overhead\x20must\x20\
    not\x20be\x20set\x20in\x20Pod\x20create\x20requests.\n\x20The\x20Runtime\
    Class\x20admission\x20controller\x20will\x20reject\x20Pod\x20create\x20r\
    equests\x20which\x20have\x20the\x20overhead\x20already\n\x20set.\x20If\
    \x20RuntimeClass\x20is\x20configured\x20and\x20selected\x20in\x20the\x20\
    PodSpec,\x20Overhead\x20will\x20be\x20set\x20to\x20the\x20value\n\x20def\
    ined\x20in\x20the\x20corresponding\x20RuntimeClass,\x20otherwise\x20it\
    \x20will\x20remain\x20unset\x20and\x20treated\x20as\x20zero.\n\x20More\
    \x20info:\x20https://git.k8s.io/enhancements/keps/sig-node/20190226-pod-\
    overhead.md\n\x20This\x20field\x20is\x20alpha-level\x20as\x20of\x20Kuber\
    netes\x20v1.16,\x20and\x20is\x20only\x20honored\x20by\x20servers\x20that\
    \x20enable\x20the\x20PodOverhead\x20feature.\n\x20+optional\n\n\x10\n\
    \x06\x04\x88\x01\x02\x20\x04\x12\x06\x92\x1c\x02\x87\x1c(\n\x0e\n\x06\
    \x04\x88\x01\x02\x20\x06\x12\x04\x92\x1c\x02<\n\x0e\n\x06\x04\x88\x01\
    \x02\x20\x01\x12\x04\x92\x1c=E\n\x0e\n\x06\x04\x88\x01\x02\x20\x03\x12\
    \x04\x92\x1cHJ\n\xe8\x02\n\x05\x04\x88\x01\x02!\x12\x04\x9d\x1c\x02C\x1a\
    \xd8\x02\x20TopologySpreadConstraints\x20describes\x20how\x20a\x20group\
    \x20of\x20pods\x20ought\x20to\x20spread\x20across\x20topology\n\x20domai\
    ns.\x20Scheduler\x20will\x20schedule\x20pods\x20in\x20a\x20way\x20which\
    \x20abides\x20by\x20the\x20constraints.\n\x20All\x20topologySpreadConstr\
    aints\x20are\x20ANDed.\n\x20+optional\n\x20+patchMergeKey=topologyKey\n\
    \x20+patchStrategy=merge\n\x20+listType=map\n\x20+listMapKey=topologyKey\
    \n\x20+listMapKey=whenUnsatisfiable\n\n\x0e\n\x06\x04\x88\x01\x02!\x04\
    \x12\x04\x9d\x1c\x02\n\n\x0e\n\x06\x04\x88\x01\x02!\x06\x12\x04\x9d\x1c\
    \x0b#\n\x0e\n\x06\x04\x88\x01\x02!\x01\x12\x04\x9d\x1c$=\n\x0e\n\x06\x04\
    \x88\x01\x02!\x03\x12\x04\x9d\x1c@B\n\xfc\x03\n\x05\x04\x88\x01\x02\"\
    \x12\x04\xa5\x1c\x02'\x1a\xec\x03\x20If\x20true\x20the\x20pod's\x20hostn\
    ame\x20will\x20be\x20configured\x20as\x20the\x20pod's\x20FQDN,\x20rather\
    \x20than\x20the\x20leaf\x20name\x20(the\x20default).\n\x20In\x20Linux\
    \x20containers,\x20this\x20means\x20setting\x20the\x20FQDN\x20in\x20the\
    \x20hostname\x20field\x20of\x20the\x20kernel\x20(the\x20nodename\x20fiel\
    d\x20of\x20struct\x20utsname).\n\x20In\x20Windows\x20containers,\x20this\
    \x20means\x20setting\x20the\x20registry\x20value\x20of\x20hostname\x20fo\
    r\x20the\x20registry\x20key\x20HKEY_LOCAL_MACHINE\\\\SYSTEM\\\\CurrentCo\
    ntrolSet\\\\Services\\\\Tcpip\\\\Parameters\x20to\x20FQDN.\n\x20If\x20a\
    \x20pod\x20does\x20not\x20have\x20FQDN,\x20this\x20has\x20no\x20effect.\
    \n\x20Default\x20to\x20false.\n\x20+optional\n\n\x0e\n\x06\x04\x88\x01\
    \x02\"\x04\x12\x04\xa5\x1c\x02\n\n\x0e\n\x06\x04\x88\x01\x02\"\x05\x12\
    \x04\xa5\x1c\x0b\x0f\n\x0e\n\x06\x04\x88\x01\x02\"\x01\x12\x04\xa5\x1c\
    \x10!\n\x0e\n\x06\x04\x88\x01\x02\"\x03\x12\x04\xa5\x1c$&\n\xca\x01\n\
    \x03\x04\x89\x01\x12\x06\xab\x1c\0\x87\x1d\x01\x1a\xba\x01\x20PodStatus\
    \x20represents\x20information\x20about\x20the\x20status\x20of\x20a\x20po\
    d.\x20Status\x20may\x20trail\x20the\x20actual\n\x20state\x20of\x20a\x20s\
    ystem,\x20especially\x20if\x20the\x20node\x20that\x20hosts\x20the\x20pod\
    \x20cannot\x20contact\x20the\x20control\n\x20plane.\n\n\x0c\n\x04\x04\
    \x89\x01\x01\x12\x04\xab\x1c\x08\x11\n\xda\t\n\x05\x04\x89\x01\x02\0\x12\
    \x04\xbf\x1c\x02\x1c\x1a\xca\t\x20The\x20phase\x20of\x20a\x20Pod\x20is\
    \x20a\x20simple,\x20high-level\x20summary\x20of\x20where\x20the\x20Pod\
    \x20is\x20in\x20its\x20lifecycle.\n\x20The\x20conditions\x20array,\x20th\
    e\x20reason\x20and\x20message\x20fields,\x20and\x20the\x20individual\x20\
    container\x20status\n\x20arrays\x20contain\x20more\x20detail\x20about\
    \x20the\x20pod's\x20status.\n\x20There\x20are\x20five\x20possible\x20pha\
    se\x20values:\n\n\x20Pending:\x20The\x20pod\x20has\x20been\x20accepted\
    \x20by\x20the\x20Kubernetes\x20system,\x20but\x20one\x20or\x20more\x20of\
    \x20the\n\x20container\x20images\x20has\x20not\x20been\x20created.\x20Th\
    is\x20includes\x20time\x20before\x20being\x20scheduled\x20as\n\x20well\
    \x20as\x20time\x20spent\x20downloading\x20images\x20over\x20the\x20netwo\
    rk,\x20which\x20could\x20take\x20a\x20while.\n\x20Running:\x20The\x20pod\
    \x20has\x20been\x20bound\x20to\x20a\x20node,\x20and\x20all\x20of\x20the\
    \x20containers\x20have\x20been\x20created.\n\x20At\x20least\x20one\x20co\
    ntainer\x20is\x20still\x20running,\x20or\x20is\x20in\x20the\x20process\
    \x20of\x20starting\x20or\x20restarting.\n\x20Succeeded:\x20All\x20contai\
    ners\x20in\x20the\x20pod\x20have\x20terminated\x20in\x20success,\x20and\
    \x20will\x20not\x20be\x20restarted.\n\x20Failed:\x20All\x20containers\
    \x20in\x20the\x20pod\x20have\x20terminated,\x20and\x20at\x20least\x20one\
    \x20container\x20has\n\x20terminated\x20in\x20failure.\x20The\x20contain\
    er\x20either\x20exited\x20with\x20non-zero\x20status\x20or\x20was\x20ter\
    minated\n\x20by\x20the\x20system.\n\x20Unknown:\x20For\x20some\x20reason\
    \x20the\x20state\x20of\x20the\x20pod\x20could\x20not\x20be\x20obtained,\
    \x20typically\x20due\x20to\x20an\n\x20error\x20in\x20communicating\x20wi\
    th\x20the\x20host\x20of\x20the\x20pod.\n\n\x20More\x20info:\x20https://k\
    ubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-phase\n\x20+\
    optional\n\n\x0e\n\x06\x04\x89\x01\x02\0\x04\x12\x04\xbf\x1c\x02\n\n\x0e\
    \n\x06\x04\x89\x01\x02\0\x05\x12\x04\xbf\x1c\x0b\x11\n\x0e\n\x06\x04\x89\
    \x01\x02\0\x01\x12\x04\xbf\x1c\x12\x17\n\x0e\n\x06\x04\x89\x01\x02\0\x03\
    \x12\x04\xbf\x1c\x1a\x1b\n\xc1\x01\n\x05\x04\x89\x01\x02\x01\x12\x04\xc6\
    \x1c\x02'\x1a\xb1\x01\x20Current\x20service\x20state\x20of\x20pod.\n\x20\
    More\x20info:\x20https://kubernetes.io/docs/concepts/workloads/pods/pod-\
    lifecycle#pod-conditions\n\x20+optional\n\x20+patchMergeKey=type\n\x20+p\
    atchStrategy=merge\n\n\x0e\n\x06\x04\x89\x01\x02\x01\x04\x12\x04\xc6\x1c\
    \x02\n\n\x0e\n\x06\x04\x89\x01\x02\x01\x06\x12\x04\xc6\x1c\x0b\x17\n\x0e\
    \n\x06\x04\x89\x01\x02\x01\x01\x12\x04\xc6\x1c\x18\"\n\x0e\n\x06\x04\x89\
    \x01\x02\x01\x03\x12\x04\xc6\x1c%&\no\n\x05\x04\x89\x01\x02\x02\x12\x04\
    \xca\x1c\x02\x1e\x1a`\x20A\x20human\x20readable\x20message\x20indicating\
    \x20details\x20about\x20why\x20the\x20pod\x20is\x20in\x20this\x20conditi\
    on.\n\x20+optional\n\n\x0e\n\x06\x04\x89\x01\x02\x02\x04\x12\x04\xca\x1c\
    \x02\n\n\x0e\n\x06\x04\x89\x01\x02\x02\x05\x12\x04\xca\x1c\x0b\x11\n\x0e\
    \n\x06\x04\x89\x01\x02\x02\x01\x12\x04\xca\x1c\x12\x19\n\x0e\n\x06\x04\
    \x89\x01\x02\x02\x03\x12\x04\xca\x1c\x1c\x1d\n|\n\x05\x04\x89\x01\x02\
    \x03\x12\x04\xcf\x1c\x02\x1d\x1am\x20A\x20brief\x20CamelCase\x20message\
    \x20indicating\x20details\x20about\x20why\x20the\x20pod\x20is\x20in\x20t\
    his\x20state.\n\x20e.g.\x20'Evicted'\n\x20+optional\n\n\x0e\n\x06\x04\
    \x89\x01\x02\x03\x04\x12\x04\xcf\x1c\x02\n\n\x0e\n\x06\x04\x89\x01\x02\
    \x03\x05\x12\x04\xcf\x1c\x0b\x11\n\x0e\n\x06\x04\x89\x01\x02\x03\x01\x12\
    \x04\xcf\x1c\x12\x18\n\x0e\n\x06\x04\x89\x01\x02\x03\x03\x12\x04\xcf\x1c\
    \x1b\x1c\n\xcc\x04\n\x05\x04\x89\x01\x02\x04\x12\x04\xd9\x1c\x02)\x1a\
    \xbc\x04\x20nominatedNodeName\x20is\x20set\x20only\x20when\x20this\x20po\
    d\x20preempts\x20other\x20pods\x20on\x20the\x20node,\x20but\x20it\x20can\
    not\x20be\n\x20scheduled\x20right\x20away\x20as\x20preemption\x20victims\
    \x20receive\x20their\x20graceful\x20termination\x20periods.\n\x20This\
    \x20field\x20does\x20not\x20guarantee\x20that\x20the\x20pod\x20will\x20b\
    e\x20scheduled\x20on\x20this\x20node.\x20Scheduler\x20may\x20decide\n\
    \x20to\x20place\x20the\x20pod\x20elsewhere\x20if\x20other\x20nodes\x20be\
    come\x20available\x20sooner.\x20Scheduler\x20may\x20also\x20decide\x20to\
    \n\x20give\x20the\x20resources\x20on\x20this\x20node\x20to\x20a\x20highe\
    r\x20priority\x20pod\x20that\x20is\x20created\x20after\x20preemption.\n\
    \x20As\x20a\x20result,\x20this\x20field\x20may\x20be\x20different\x20tha\
    n\x20PodSpec.nodeName\x20when\x20the\x20pod\x20is\n\x20scheduled.\n\x20+\
    optional\n\n\x0e\n\x06\x04\x89\x01\x02\x04\x04\x12\x04\xd9\x1c\x02\n\n\
    \x0e\n\x06\x04\x89\x01\x02\x04\x05\x12\x04\xd9\x1c\x0b\x11\n\x0e\n\x06\
    \x04\x89\x01\x02\x04\x01\x12\x04\xd9\x1c\x12#\n\x0e\n\x06\x04\x89\x01\
    \x02\x04\x03\x12\x04\xd9\x1c&(\nl\n\x05\x04\x89\x01\x02\x05\x12\x04\xdd\
    \x1c\x02\x1d\x1a]\x20IP\x20address\x20of\x20the\x20host\x20to\x20which\
    \x20the\x20pod\x20is\x20assigned.\x20Empty\x20if\x20not\x20yet\x20schedu\
    led.\n\x20+optional\n\n\x0e\n\x06\x04\x89\x01\x02\x05\x04\x12\x04\xdd\
    \x1c\x02\n\n\x0e\n\x06\x04\x89\x01\x02\x05\x05\x12\x04\xdd\x1c\x0b\x11\n\
    \x0e\n\x06\x04\x89\x01\x02\x05\x01\x12\x04\xdd\x1c\x12\x18\n\x0e\n\x06\
    \x04\x89\x01\x02\x05\x03\x12\x04\xdd\x1c\x1b\x1c\n\x7f\n\x05\x04\x89\x01\
    \x02\x06\x12\x04\xe2\x1c\x02\x1c\x1ap\x20IP\x20address\x20allocated\x20t\
    o\x20the\x20pod.\x20Routable\x20at\x20least\x20within\x20the\x20cluster.\
    \n\x20Empty\x20if\x20not\x20yet\x20allocated.\n\x20+optional\n\n\x0e\n\
    \x06\x04\x89\x01\x02\x06\x04\x12\x04\xe2\x1c\x02\n\n\x0e\n\x06\x04\x89\
    \x01\x02\x06\x05\x12\x04\xe2\x1c\x0b\x11\n\x0e\n\x06\x04\x89\x01\x02\x06\
    \x01\x12\x04\xe2\x1c\x12\x17\n\x0e\n\x06\x04\x89\x01\x02\x06\x03\x12\x04\
    \xe2\x1c\x1a\x1b\n\xb8\x02\n\x05\x04\x89\x01\x02\x07\x12\x04\xea\x1c\x02\
    \x1d\x1a\xa8\x02\x20podIPs\x20holds\x20the\x20IP\x20addresses\x20allocat\
    ed\x20to\x20the\x20pod.\x20If\x20this\x20field\x20is\x20specified,\x20th\
    e\x200th\x20entry\x20must\n\x20match\x20the\x20podIP\x20field.\x20Pods\
    \x20may\x20be\x20allocated\x20at\x20most\x201\x20value\x20for\x20each\
    \x20of\x20IPv4\x20and\x20IPv6.\x20This\x20list\n\x20is\x20empty\x20if\
    \x20no\x20IPs\x20have\x20been\x20allocated\x20yet.\n\x20+optional\n\x20+\
    patchStrategy=merge\n\x20+patchMergeKey=ip\n\n\x0e\n\x06\x04\x89\x01\x02\
    \x07\x04\x12\x04\xea\x1c\x02\n\n\x0e\n\x06\x04\x89\x01\x02\x07\x06\x12\
    \x04\xea\x1c\x0b\x10\n\x0e\n\x06\x04\x89\x01\x02\x07\x01\x12\x04\xea\x1c\
    \x11\x17\n\x0e\n\x06\x04\x89\x01\x02\x07\x03\x12\x04\xea\x1c\x1a\x1c\n\
    \xaf\x01\n\x05\x04\x89\x01\x02\x08\x12\x04\xef\x1c\x02C\x1a\x9f\x01\x20R\
    FC\x203339\x20date\x20and\x20time\x20at\x20which\x20the\x20object\x20was\
    \x20acknowledged\x20by\x20the\x20Kubelet.\n\x20This\x20is\x20before\x20t\
    he\x20Kubelet\x20pulled\x20the\x20container\x20image(s)\x20for\x20the\
    \x20pod.\n\x20+optional\n\n\x0e\n\x06\x04\x89\x01\x02\x08\x04\x12\x04\
    \xef\x1c\x02\n\n\x0e\n\x06\x04\x89\x01\x02\x08\x06\x12\x04\xef\x1c\x0b4\
    \n\x0e\n\x06\x04\x89\x01\x02\x08\x01\x12\x04\xef\x1c5>\n\x0e\n\x06\x04\
    \x89\x01\x02\x08\x03\x12\x04\xef\x1cAB\n\xb3\x02\n\x05\x04\x89\x01\x02\t\
    \x12\x04\xf5\x1c\x026\x1a\xa3\x02\x20The\x20list\x20has\x20one\x20entry\
    \x20per\x20init\x20container\x20in\x20the\x20manifest.\x20The\x20most\
    \x20recent\x20successful\n\x20init\x20container\x20will\x20have\x20ready\
    \x20=\x20true,\x20the\x20most\x20recently\x20started\x20container\x20wil\
    l\x20have\n\x20startTime\x20set.\n\x20More\x20info:\x20https://kubernete\
    s.io/docs/concepts/workloads/pods/pod-lifecycle#pod-and-container-status\
    \n\n\x0e\n\x06\x04\x89\x01\x02\t\x04\x12\x04\xf5\x1c\x02\n\n\x0e\n\x06\
    \x04\x89\x01\x02\t\x06\x12\x04\xf5\x1c\x0b\x1a\n\x0e\n\x06\x04\x89\x01\
    \x02\t\x01\x12\x04\xf5\x1c\x1b0\n\x0e\n\x06\x04\x89\x01\x02\t\x03\x12\
    \x04\xf5\x1c35\n\xf1\x01\n\x05\x04\x89\x01\x02\n\x12\x04\xfb\x1c\x021\
    \x1a\xe1\x01\x20The\x20list\x20has\x20one\x20entry\x20per\x20container\
    \x20in\x20the\x20manifest.\x20Each\x20entry\x20is\x20currently\x20the\
    \x20output\n\x20of\x20`docker\x20inspect`.\n\x20More\x20info:\x20https:/\
    /kubernetes.io/docs/concepts/workloads/pods/pod-lifecycle#pod-and-contai\
    ner-status\n\x20+optional\n\n\x0e\n\x06\x04\x89\x01\x02\n\x04\x12\x04\
    \xfb\x1c\x02\n\n\x0e\n\x06\x04\x89\x01\x02\n\x06\x12\x04\xfb\x1c\x0b\x1a\
    \n\x0e\n\x06\x04\x89\x01\x02\n\x01\x12\x04\xfb\x1c\x1b,\n\x0e\n\x06\x04\
    \x89\x01\x02\n\x03\x12\x04\xfb\x1c/0\n\x87\x02\n\x05\x04\x89\x01\x02\x0b\
    \x12\x04\x81\x1d\x02\x1f\x1a\xf7\x01\x20The\x20Quality\x20of\x20Service\
    \x20(QOS)\x20classification\x20assigned\x20to\x20the\x20pod\x20based\x20\
    on\x20resource\x20requirements\n\x20See\x20PodQOSClass\x20type\x20for\
    \x20available\x20QOS\x20classes\n\x20More\x20info:\x20https://git.k8s.io\
    /community/contributors/design-proposals/node/resource-qos.md\n\x20+opti\
    onal\n\n\x0e\n\x06\x04\x89\x01\x02\x0b\x04\x12\x04\x81\x1d\x02\n\n\x0e\n\
    \x06\x04\x89\x01\x02\x0b\x05\x12\x04\x81\x1d\x0b\x11\n\x0e\n\x06\x04\x89\
    \x01\x02\x0b\x01\x12\x04\x81\x1d\x12\x1a\n\x0e\n\x06\x04\x89\x01\x02\x0b\
    \x03\x12\x04\x81\x1d\x1d\x1e\n\xc4\x01\n\x05\x04\x89\x01\x02\x0c\x12\x04\
    \x86\x1d\x02;\x1a\xb4\x01\x20Status\x20for\x20any\x20ephemeral\x20contai\
    ners\x20that\x20have\x20run\x20in\x20this\x20pod.\n\x20This\x20field\x20\
    is\x20alpha-level\x20and\x20is\x20only\x20populated\x20by\x20servers\x20\
    that\x20enable\x20the\x20EphemeralContainers\x20feature.\n\x20+optional\
    \n\n\x0e\n\x06\x04\x89\x01\x02\x0c\x04\x12\x04\x86\x1d\x02\n\n\x0e\n\x06\
    \x04\x89\x01\x02\x0c\x06\x12\x04\x86\x1d\x0b\x1a\n\x0e\n\x06\x04\x89\x01\
    \x02\x0c\x01\x12\x04\x86\x1d\x1b5\n\x0e\n\x06\x04\x89\x01\x02\x0c\x03\
    \x12\x04\x86\x1d8:\nj\n\x03\x04\x8a\x01\x12\x06\x8a\x1d\0\x97\x1d\x01\
    \x1a[\x20PodStatusResult\x20is\x20a\x20wrapper\x20for\x20PodStatus\x20re\
    turned\x20by\x20kubelet\x20that\x20can\x20be\x20encode/decoded\n\n\x0c\n\
    \x04\x04\x8a\x01\x01\x12\x04\x8a\x1d\x08\x17\n\xa1\x01\n\x05\x04\x8a\x01\
    \x02\0\x12\x04\x8e\x1d\x02H\x1a\x91\x01\x20Standard\x20object's\x20metad\
    ata.\n\x20More\x20info:\x20https://git.k8s.io/community/contributors/dev\
    el/sig-architecture/api-conventions.md#metadata\n\x20+optional\n\n\x0e\n\
    \x06\x04\x8a\x01\x02\0\x04\x12\x04\x8e\x1d\x02\n\n\x0e\n\x06\x04\x8a\x01\
    \x02\0\x06\x12\x04\x8e\x1d\x0b:\n\x0e\n\x06\x04\x8a\x01\x02\0\x01\x12\
    \x04\x8e\x1d;C\n\x0e\n\x06\x04\x8a\x01\x02\0\x03\x12\x04\x8e\x1dFG\n\xfe\
    \x01\n\x05\x04\x8a\x01\x02\x01\x12\x04\x96\x1d\x02\x20\x1a\xee\x01\x20Mo\
    st\x20recently\x20observed\x20status\x20of\x20the\x20pod.\n\x20This\x20d\
    ata\x20may\x20not\x20be\x20up\x20to\x20date.\n\x20Populated\x20by\x20the\
    \x20system.\n\x20Read-only.\n\x20More\x20info:\x20https://git.k8s.io/com\
    munity/contributors/devel/sig-architecture/api-conventions.md#spec-and-s\
    tatus\n\x20+optional\n\n\x0e\n\x06\x04\x8a\x01\x02\x01\x04\x12\x04\x96\
    \x1d\x02\n\n\x0e\n\x06\x04\x8a\x01\x02\x01\x06\x12\x04\x96\x1d\x0b\x14\n\
    \x0e\n\x06\x04\x8a\x01\x02\x01\x01\x12\x04\x96\x1d\x15\x1b\n\x0e\n\x06\
    \x04\x8a\x01\x02\x01\x03\x12\x04\x96\x1d\x1e\x1f\nZ\n\x03\x04\x8b\x01\
    \x12\x06\x9a\x1d\0\xa4\x1d\x01\x1aK\x20PodTemplate\x20describes\x20a\x20\
    template\x20for\x20creating\x20copies\x20of\x20a\x20predefined\x20pod.\n\
    \n\x0c\n\x04\x04\x8b\x01\x01\x12\x04\x9a\x1d\x08\x13\n\xa1\x01\n\x05\x04\
    \x8b\x01\x02\0\x12\x04\x9e\x1d\x02H\x1a\x91\x01\x20Standard\x20object's\
    \x20metadata.\n\x20More\x20info:\x20https://git.k8s.io/community/contrib\
    utors/devel/sig-architecture/api-conventions.md#metadata\n\x20+optional\
    \n\n\x0e\n\x06\x04\x8b\x01\x02\0\x04\x12\x04\x9e\x1d\x02\n\n\x0e\n\x06\
    \x04\x8b\x01\x02\0\x06\x12\x04\x9e\x1d\x0b:\n\x0e\n\x06\x04\x8b\x01\x02\
    \0\x01\x12\x04\x9e\x1d;C\n\x0e\n\x06\x04\x8b\x01\x02\0\x03\x12\x04\x9e\
    \x1dFG\n\xc8\x01\n\x05\x04\x8b\x01\x02\x01\x12\x04\xa3\x1d\x02(\x1a\xb8\
    \x01\x20Template\x20defines\x20the\x20pods\x20that\x20will\x20be\x20crea\
    ted\x20from\x20this\x20pod\x20template.\n\x20https://git.k8s.io/communit\
    y/contributors/devel/sig-architecture/api-conventions.md#spec-and-status\
    \n\x20+optional\n\n\x0e\n\x06\x04\x8b\x01\x02\x01\x04\x12\x04\xa3\x1d\
    \x02\n\n\x0e\n\x06\x04\x8b\x01\x02\x01\x06\x12\x04\xa3\x1d\x0b\x1a\n\x0e\
    \n\x06\x04\x8b\x01\x02\x01\x01\x12\x04\xa3\x1d\x1b#\n\x0e\n\x06\x04\x8b\
    \x01\x02\x01\x03\x12\x04\xa3\x1d&'\n;\n\x03\x04\x8c\x01\x12\x06\xa7\x1d\
    \0\xaf\x1d\x01\x1a,\x20PodTemplateList\x20is\x20a\x20list\x20of\x20PodTe\
    mplates.\n\n\x0c\n\x04\x04\x8c\x01\x01\x12\x04\xa7\x1d\x08\x17\n\xa0\x01\
    \n\x05\x04\x8c\x01\x02\0\x12\x04\xab\x1d\x02F\x1a\x90\x01\x20Standard\
    \x20list\x20metadata.\n\x20More\x20info:\x20https://git.k8s.io/community\
    /contributors/devel/sig-architecture/api-conventions.md#types-kinds\n\
    \x20+optional\n\n\x0e\n\x06\x04\x8c\x01\x02\0\x04\x12\x04\xab\x1d\x02\n\
    \n\x0e\n\x06\x04\x8c\x01\x02\0\x06\x12\x04\xab\x1d\x0b8\n\x0e\n\x06\x04\
    \x8c\x01\x02\0\x01\x12\x04\xab\x1d9A\n\x0e\n\x06\x04\x8c\x01\x02\0\x03\
    \x12\x04\xab\x1dDE\n&\n\x05\x04\x8c\x01\x02\x01\x12\x04\xae\x1d\x02!\x1a\
    \x17\x20List\x20of\x20pod\x20templates\n\n\x0e\n\x06\x04\x8c\x01\x02\x01\
    \x04\x12\x04\xae\x1d\x02\n\n\x0e\n\x06\x04\x8c\x01\x02\x01\x06\x12\x04\
    \xae\x1d\x0b\x16\n\x0e\n\x06\x04\x8c\x01\x02\x01\x01\x12\x04\xae\x1d\x17\
    \x1c\n\x0e\n\x06\x04\x8c\x01\x02\x01\x03\x12\x04\xae\x1d\x1f\x20\nb\n\
    \x03\x04\x8d\x01\x12\x06\xb2\x1d\0\xbc\x1d\x01\x1aS\x20PodTemplateSpec\
    \x20describes\x20the\x20data\x20a\x20pod\x20should\x20have\x20when\x20cr\
    eated\x20from\x20a\x20template\n\n\x0c\n\x04\x04\x8d\x01\x01\x12\x04\xb2\
    \x1d\x08\x17\n\xa1\x01\n\x05\x04\x8d\x01\x02\0\x12\x04\xb6\x1d\x02H\x1a\
    \x91\x01\x20Standard\x20object's\x20metadata.\n\x20More\x20info:\x20http\
    s://git.k8s.io/community/contributors/devel/sig-architecture/api-convent\
    ions.md#metadata\n\x20+optional\n\n\x0e\n\x06\x04\x8d\x01\x02\0\x04\x12\
    \x04\xb6\x1d\x02\n\n\x0e\n\x06\x04\x8d\x01\x02\0\x06\x12\x04\xb6\x1d\x0b\
    :\n\x0e\n\x06\x04\x8d\x01\x02\0\x01\x12\x04\xb6\x1d;C\n\x0e\n\x06\x04\
    \x8d\x01\x02\0\x03\x12\x04\xb6\x1dFG\n\xbe\x01\n\x05\x04\x8d\x01\x02\x01\
    \x12\x04\xbb\x1d\x02\x1c\x1a\xae\x01\x20Specification\x20of\x20the\x20de\
    sired\x20behavior\x20of\x20the\x20pod.\n\x20More\x20info:\x20https://git\
    .k8s.io/community/contributors/devel/sig-architecture/api-conventions.md\
    #spec-and-status\n\x20+optional\n\n\x0e\n\x06\x04\x8d\x01\x02\x01\x04\
    \x12\x04\xbb\x1d\x02\n\n\x0e\n\x06\x04\x8d\x01\x02\x01\x06\x12\x04\xbb\
    \x1d\x0b\x12\n\x0e\n\x06\x04\x8d\x01\x02\x01\x01\x12\x04\xbb\x1d\x13\x17\
    \n\x0e\n\x06\x04\x8d\x01\x02\x01\x03\x12\x04\xbb\x1d\x1a\x1b\n\r\n\x03\
    \x04\x8e\x01\x12\x06\xbe\x1d\0\xd3\x1d\x01\n\x0c\n\x04\x04\x8e\x01\x01\
    \x12\x04\xbe\x1d\x08\x12\n]\n\x05\x04\x8e\x01\x02\0\x12\x04\xc0\x1d\x02\
    \x1a\x1aN\x20Port\x20is\x20the\x20port\x20number\x20of\x20the\x20service\
    \x20port\x20of\x20which\x20status\x20is\x20recorded\x20here\n\n\x0e\n\
    \x06\x04\x8e\x01\x02\0\x04\x12\x04\xc0\x1d\x02\n\n\x0e\n\x06\x04\x8e\x01\
    \x02\0\x05\x12\x04\xc0\x1d\x0b\x10\n\x0e\n\x06\x04\x8e\x01\x02\0\x01\x12\
    \x04\xc0\x1d\x11\x15\n\x0e\n\x06\x04\x8e\x01\x02\0\x03\x12\x04\xc0\x1d\
    \x18\x19\n\x8e\x01\n\x05\x04\x8e\x01\x02\x01\x12\x04\xc4\x1d\x02\x1f\x1a\
    \x7f\x20Protocol\x20is\x20the\x20protocol\x20of\x20the\x20service\x20por\
    t\x20of\x20which\x20status\x20is\x20recorded\x20here\n\x20The\x20support\
    ed\x20values\x20are:\x20\"TCP\",\x20\"UDP\",\x20\"SCTP\"\n\n\x0e\n\x06\
    \x04\x8e\x01\x02\x01\x04\x12\x04\xc4\x1d\x02\n\n\x0e\n\x06\x04\x8e\x01\
    \x02\x01\x05\x12\x04\xc4\x1d\x0b\x11\n\x0e\n\x06\x04\x8e\x01\x02\x01\x01\
    \x12\x04\xc4\x1d\x12\x1a\n\x0e\n\x06\x04\x8e\x01\x02\x01\x03\x12\x04\xc4\
    \x1d\x1d\x1e\n\x87\x05\n\x05\x04\x8e\x01\x02\x02\x12\x04\xd2\x1d\x02\x1c\
    \x1a\xf7\x04\x20Error\x20is\x20to\x20record\x20the\x20problem\x20with\
    \x20the\x20service\x20port\n\x20The\x20format\x20of\x20the\x20error\x20s\
    hall\x20comply\x20with\x20the\x20following\x20rules:\n\x20-\x20built-in\
    \x20error\x20values\x20shall\x20be\x20specified\x20in\x20this\x20file\
    \x20and\x20those\x20shall\x20use\n\x20\x20\x20CamelCase\x20names\n\x20-\
    \x20cloud\x20provider\x20specific\x20error\x20values\x20must\x20have\x20\
    names\x20that\x20comply\x20with\x20the\n\x20\x20\x20format\x20foo.exampl\
    e.com/CamelCase.\n\x20---\n\x20The\x20regex\x20it\x20matches\x20is\x20(d\
    ns1123SubdomainFmt/)?(qualifiedNameFmt)\n\x20+optional\n\x20+kubebuilder\
    :validation:Required\n\x20+kubebuilder:validation:Pattern=`^([a-z0-9]([-\
    a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][-A\
    -Za-z0-9_.]*)?[A-Za-z0-9])$`\n\x20+kubebuilder:validation:MaxLength=316\
    \n\n\x0e\n\x06\x04\x8e\x01\x02\x02\x04\x12\x04\xd2\x1d\x02\n\n\x0e\n\x06\
    \x04\x8e\x01\x02\x02\x05\x12\x04\xd2\x1d\x0b\x11\n\x0e\n\x06\x04\x8e\x01\
    \x02\x02\x01\x12\x04\xd2\x1d\x12\x17\n\x0e\n\x06\x04\x8e\x01\x02\x02\x03\
    \x12\x04\xd2\x1d\x1a\x1b\nL\n\x03\x04\x8f\x01\x12\x06\xd6\x1d\0\xe3\x1d\
    \x01\x1a=\x20PortworxVolumeSource\x20represents\x20a\x20Portworx\x20volu\
    me\x20resource.\n\n\x0c\n\x04\x04\x8f\x01\x01\x12\x04\xd6\x1d\x08\x1c\n?\
    \n\x05\x04\x8f\x01\x02\0\x12\x04\xd8\x1d\x02\x1f\x1a0\x20VolumeID\x20uni\
    quely\x20identifies\x20a\x20Portworx\x20volume\n\n\x0e\n\x06\x04\x8f\x01\
    \x02\0\x04\x12\x04\xd8\x1d\x02\n\n\x0e\n\x06\x04\x8f\x01\x02\0\x05\x12\
    \x04\xd8\x1d\x0b\x11\n\x0e\n\x06\x04\x8f\x01\x02\0\x01\x12\x04\xd8\x1d\
    \x12\x1a\n\x0e\n\x06\x04\x8f\x01\x02\0\x03\x12\x04\xd8\x1d\x1d\x1e\n\xc8\
    \x01\n\x05\x04\x8f\x01\x02\x01\x12\x04\xdd\x1d\x02\x1d\x1a\xb8\x01\x20FS\
    Type\x20represents\x20the\x20filesystem\x20type\x20to\x20mount\n\x20Must\
    \x20be\x20a\x20filesystem\x20type\x20supported\x20by\x20the\x20host\x20o\
    perating\x20system.\n\x20Ex.\x20\"ext4\",\x20\"xfs\".\x20Implicitly\x20i\
    nferred\x20to\x20be\x20\"ext4\"\x20if\x20unspecified.\n\n\x0e\n\x06\x04\
    \x8f\x01\x02\x01\x04\x12\x04\xdd\x1d\x02\n\n\x0e\n\x06\x04\x8f\x01\x02\
    \x01\x05\x12\x04\xdd\x1d\x0b\x11\n\x0e\n\x06\x04\x8f\x01\x02\x01\x01\x12\
    \x04\xdd\x1d\x12\x18\n\x0e\n\x06\x04\x8f\x01\x02\x01\x03\x12\x04\xdd\x1d\
    \x1b\x1c\n{\n\x05\x04\x8f\x01\x02\x02\x12\x04\xe2\x1d\x02\x1d\x1al\x20De\
    faults\x20to\x20false\x20(read/write).\x20ReadOnly\x20here\x20will\x20fo\
    rce\n\x20the\x20ReadOnly\x20setting\x20in\x20VolumeMounts.\n\x20+optiona\
    l\n\n\x0e\n\x06\x04\x8f\x01\x02\x02\x04\x12\x04\xe2\x1d\x02\n\n\x0e\n\
    \x06\x04\x8f\x01\x02\x02\x05\x12\x04\xe2\x1d\x0b\x0f\n\x0e\n\x06\x04\x8f\
    \x01\x02\x02\x01\x12\x04\xe2\x1d\x10\x18\n\x0e\n\x06\x04\x8f\x01\x02\x02\
    \x03\x12\x04\xe2\x1d\x1b\x1c\n\x83\x01\n\x03\x04\x90\x01\x12\x06\xe7\x1d\
    \0\xeb\x1d\x01\x1at\x20Preconditions\x20must\x20be\x20fulfilled\x20befor\
    e\x20an\x20operation\x20(update,\x20delete,\x20etc.)\x20is\x20carried\
    \x20out.\n\x20+k8s:openapi-gen=false\n\n\x0c\n\x04\x04\x90\x01\x01\x12\
    \x04\xe7\x1d\x08\x15\n5\n\x05\x04\x90\x01\x02\0\x12\x04\xea\x1d\x02\x1a\
    \x1a&\x20Specifies\x20the\x20target\x20UID.\n\x20+optional\n\n\x0e\n\x06\
    \x04\x90\x01\x02\0\x04\x12\x04\xea\x1d\x02\n\n\x0e\n\x06\x04\x90\x01\x02\
    \0\x05\x12\x04\xea\x1d\x0b\x11\n\x0e\n\x06\x04\x90\x01\x02\0\x01\x12\x04\
    \xea\x1d\x12\x15\n\x0e\n\x06\x04\x90\x01\x02\0\x03\x12\x04\xea\x1d\x18\
    \x19\nG\n\x03\x04\x91\x01\x12\x06\xee\x1d\0\xfd\x1d\x01\x1a8\x20Describe\
    s\x20a\x20class\x20of\x20pods\x20that\x20should\x20avoid\x20this\x20node\
    .\n\n\x0c\n\x04\x04\x91\x01\x01\x12\x04\xee\x1d\x08\x1c\n#\n\x05\x04\x91\
    \x01\x02\0\x12\x04\xf0\x1d\x02)\x1a\x14\x20The\x20class\x20of\x20pods.\n\
    \n\x0e\n\x06\x04\x91\x01\x02\0\x04\x12\x04\xf0\x1d\x02\n\n\x0e\n\x06\x04\
    \x91\x01\x02\0\x06\x12\x04\xf0\x1d\x0b\x17\n\x0e\n\x06\x04\x91\x01\x02\0\
    \x01\x12\x04\xf0\x1d\x18$\n\x0e\n\x06\x04\x91\x01\x02\0\x03\x12\x04\xf0\
    \x1d'(\nK\n\x05\x04\x91\x01\x02\x01\x12\x04\xf4\x1d\x02F\x1a<\x20Time\
    \x20at\x20which\x20this\x20entry\x20was\x20added\x20to\x20the\x20list.\n\
    \x20+optional\n\n\x0e\n\x06\x04\x91\x01\x02\x01\x04\x12\x04\xf4\x1d\x02\
    \n\n\x0e\n\x06\x04\x91\x01\x02\x01\x06\x12\x04\xf4\x1d\x0b4\n\x0e\n\x06\
    \x04\x91\x01\x02\x01\x01\x12\x04\xf4\x1d5A\n\x0e\n\x06\x04\x91\x01\x02\
    \x01\x03\x12\x04\xf4\x1dDE\nP\n\x05\x04\x91\x01\x02\x02\x12\x04\xf8\x1d\
    \x02\x1d\x1aA\x20(brief)\x20reason\x20why\x20this\x20entry\x20was\x20add\
    ed\x20to\x20the\x20list.\n\x20+optional\n\n\x0e\n\x06\x04\x91\x01\x02\
    \x02\x04\x12\x04\xf8\x1d\x02\n\n\x0e\n\x06\x04\x91\x01\x02\x02\x05\x12\
    \x04\xf8\x1d\x0b\x11\n\x0e\n\x06\x04\x91\x01\x02\x02\x01\x12\x04\xf8\x1d\
    \x12\x18\n\x0e\n\x06\x04\x91\x01\x02\x02\x03\x12\x04\xf8\x1d\x1b\x1c\nc\
    \n\x05\x04\x91\x01\x02\x03\x12\x04\xfc\x1d\x02\x1e\x1aT\x20Human\x20read\
    able\x20message\x20indicating\x20why\x20this\x20entry\x20was\x20added\
    \x20to\x20the\x20list.\n\x20+optional\n\n\x0e\n\x06\x04\x91\x01\x02\x03\
    \x04\x12\x04\xfc\x1d\x02\n\n\x0e\n\x06\x04\x91\x01\x02\x03\x05\x12\x04\
    \xfc\x1d\x0b\x11\n\x0e\n\x06\x04\x91\x01\x02\x03\x01\x12\x04\xfc\x1d\x12\
    \x19\n\x0e\n\x06\x04\x91\x01\x02\x03\x03\x12\x04\xfc\x1d\x1c\x1d\n\xc1\
    \x01\n\x03\x04\x92\x01\x12\x06\x81\x1e\0\x87\x1e\x01\x1a\xb1\x01\x20An\
    \x20empty\x20preferred\x20scheduling\x20term\x20matches\x20all\x20object\
    s\x20with\x20implicit\x20weight\x200\n\x20(i.e.\x20it's\x20a\x20no-op).\
    \x20A\x20null\x20preferred\x20scheduling\x20term\x20matches\x20no\x20obj\
    ects\x20(i.e.\x20is\x20also\x20a\x20no-op).\n\n\x0c\n\x04\x04\x92\x01\
    \x01\x12\x04\x81\x1e\x08\x1f\nh\n\x05\x04\x92\x01\x02\0\x12\x04\x83\x1e\
    \x02\x1c\x1aY\x20Weight\x20associated\x20with\x20matching\x20the\x20corr\
    esponding\x20nodeSelectorTerm,\x20in\x20the\x20range\x201-100.\n\n\x0e\n\
    \x06\x04\x92\x01\x02\0\x04\x12\x04\x83\x1e\x02\n\n\x0e\n\x06\x04\x92\x01\
    \x02\0\x05\x12\x04\x83\x1e\x0b\x10\n\x0e\n\x06\x04\x92\x01\x02\0\x01\x12\
    \x04\x83\x1e\x11\x17\n\x0e\n\x06\x04\x92\x01\x02\0\x03\x12\x04\x83\x1e\
    \x1a\x1b\nP\n\x05\x04\x92\x01\x02\x01\x12\x04\x86\x1e\x02+\x1aA\x20A\x20\
    node\x20selector\x20term,\x20associated\x20with\x20the\x20corresponding\
    \x20weight.\n\n\x0e\n\x06\x04\x92\x01\x02\x01\x04\x12\x04\x86\x1e\x02\n\
    \n\x0e\n\x06\x04\x92\x01\x02\x01\x06\x12\x04\x86\x1e\x0b\x1b\n\x0e\n\x06\
    \x04\x92\x01\x02\x01\x01\x12\x04\x86\x1e\x1c&\n\x0e\n\x06\x04\x92\x01\
    \x02\x01\x03\x12\x04\x86\x1e)*\n\x93\x01\n\x03\x04\x93\x01\x12\x06\x8b\
    \x1e\0\xa8\x1e\x01\x1a\x83\x01\x20Probe\x20describes\x20a\x20health\x20c\
    heck\x20to\x20be\x20performed\x20against\x20a\x20container\x20to\x20dete\
    rmine\x20whether\x20it\x20is\n\x20alive\x20or\x20ready\x20to\x20receive\
    \x20traffic.\n\n\x0c\n\x04\x04\x93\x01\x01\x12\x04\x8b\x1e\x08\r\nH\n\
    \x05\x04\x93\x01\x02\0\x12\x04\x8d\x1e\x02\x1f\x1a9\x20The\x20action\x20\
    taken\x20to\x20determine\x20the\x20health\x20of\x20a\x20container\n\n\
    \x0e\n\x06\x04\x93\x01\x02\0\x04\x12\x04\x8d\x1e\x02\n\n\x0e\n\x06\x04\
    \x93\x01\x02\0\x06\x12\x04\x8d\x1e\x0b\x12\n\x0e\n\x06\x04\x93\x01\x02\0\
    \x01\x12\x04\x8d\x1e\x13\x1a\n\x0e\n\x06\x04\x93\x01\x02\0\x03\x12\x04\
    \x8d\x1e\x1d\x1e\n\xd2\x01\n\x05\x04\x93\x01\x02\x01\x12\x04\x92\x1e\x02\
    )\x1a\xc2\x01\x20Number\x20of\x20seconds\x20after\x20the\x20container\
    \x20has\x20started\x20before\x20liveness\x20probes\x20are\x20initiated.\
    \n\x20More\x20info:\x20https://kubernetes.io/docs/concepts/workloads/pod\
    s/pod-lifecycle#container-probes\n\x20+optional\n\n\x0e\n\x06\x04\x93\
    \x01\x02\x01\x04\x12\x04\x92\x1e\x02\n\n\x0e\n\x06\x04\x93\x01\x02\x01\
    \x05\x12\x04\x92\x1e\x0b\x10\n\x0e\n\x06\x04\x93\x01\x02\x01\x01\x12\x04\
    \x92\x1e\x11$\n\x0e\n\x06\x04\x93\x01\x02\x01\x03\x12\x04\x92\x1e'(\n\
    \xd8\x01\n\x05\x04\x93\x01\x02\x02\x12\x04\x98\x1e\x02$\x1a\xc8\x01\x20N\
    umber\x20of\x20seconds\x20after\x20which\x20the\x20probe\x20times\x20out\
    .\n\x20Defaults\x20to\x201\x20second.\x20Minimum\x20value\x20is\x201.\n\
    \x20More\x20info:\x20https://kubernetes.io/docs/concepts/workloads/pods/\
    pod-lifecycle#container-probes\n\x20+optional\n\n\x0e\n\x06\x04\x93\x01\
    \x02\x02\x04\x12\x04\x98\x1e\x02\n\n\x0e\n\x06\x04\x93\x01\x02\x02\x05\
    \x12\x04\x98\x1e\x0b\x10\n\x0e\n\x06\x04\x93\x01\x02\x02\x01\x12\x04\x98\
    \x1e\x11\x1f\n\x0e\n\x06\x04\x93\x01\x02\x02\x03\x12\x04\x98\x1e\"#\nt\n\
    \x05\x04\x93\x01\x02\x03\x12\x04\x9d\x1e\x02#\x1ae\x20How\x20often\x20(i\
    n\x20seconds)\x20to\x20perform\x20the\x20probe.\n\x20Default\x20to\x2010\
    \x20seconds.\x20Minimum\x20value\x20is\x201.\n\x20+optional\n\n\x0e\n\
    \x06\x04\x93\x01\x02\x03\x04\x12\x04\x9d\x1e\x02\n\n\x0e\n\x06\x04\x93\
    \x01\x02\x03\x05\x12\x04\x9d\x1e\x0b\x10\n\x0e\n\x06\x04\x93\x01\x02\x03\
    \x01\x12\x04\x9d\x1e\x11\x1e\n\x0e\n\x06\x04\x93\x01\x02\x03\x03\x12\x04\
    \x9d\x1e!\"\n\xc1\x01\n\x05\x04\x93\x01\x02\x04\x12\x04\xa2\x1e\x02&\x1a\
    \xb1\x01\x20Minimum\x20consecutive\x20successes\x20for\x20the\x20probe\
    \x20to\x20be\x20considered\x20successful\x20after\x20having\x20failed.\n\
    \x20Defaults\x20to\x201.\x20Must\x20be\x201\x20for\x20liveness\x20and\
    \x20startup.\x20Minimum\x20value\x20is\x201.\n\x20+optional\n\n\x0e\n\
    \x06\x04\x93\x01\x02\x04\x04\x12\x04\xa2\x1e\x02\n\n\x0e\n\x06\x04\x93\
    \x01\x02\x04\x05\x12\x04\xa2\x1e\x0b\x10\n\x0e\n\x06\x04\x93\x01\x02\x04\
    \x01\x12\x04\xa2\x1e\x11!\n\x0e\n\x06\x04\x93\x01\x02\x04\x03\x12\x04\
    \xa2\x1e$%\n\x9b\x01\n\x05\x04\x93\x01\x02\x05\x12\x04\xa7\x1e\x02&\x1a\
    \x8b\x01\x20Minimum\x20consecutive\x20failures\x20for\x20the\x20probe\
    \x20to\x20be\x20considered\x20failed\x20after\x20having\x20succeeded.\n\
    \x20Defaults\x20to\x203.\x20Minimum\x20value\x20is\x201.\n\x20+optional\
    \n\n\x0e\n\x06\x04\x93\x01\x02\x05\x04\x12\x04\xa7\x1e\x02\n\n\x0e\n\x06\
    \x04\x93\x01\x02\x05\x05\x12\x04\xa7\x1e\x0b\x10\n\x0e\n\x06\x04\x93\x01\
    \x02\x05\x01\x12\x04\xa7\x1e\x11!\n\x0e\n\x06\x04\x93\x01\x02\x05\x03\
    \x12\x04\xa7\x1e$%\n5\n\x03\x04\x94\x01\x12\x06\xab\x1e\0\xb8\x1e\x01\
    \x1a&\x20Represents\x20a\x20projected\x20volume\x20source\n\n\x0c\n\x04\
    \x04\x94\x01\x01\x12\x04\xab\x1e\x08\x1d\n6\n\x05\x04\x94\x01\x02\0\x12\
    \x04\xae\x1e\x02(\x1a'\x20list\x20of\x20volume\x20projections\n\x20+opti\
    onal\n\n\x0e\n\x06\x04\x94\x01\x02\0\x04\x12\x04\xae\x1e\x02\n\n\x0e\n\
    \x06\x04\x94\x01\x02\0\x06\x12\x04\xae\x1e\x0b\x1b\n\x0e\n\x06\x04\x94\
    \x01\x02\0\x01\x12\x04\xae\x1e\x1c#\n\x0e\n\x06\x04\x94\x01\x02\0\x03\
    \x12\x04\xae\x1e&'\n\xca\x03\n\x05\x04\x94\x01\x02\x01\x12\x04\xb7\x1e\
    \x02!\x1a\xba\x03\x20Mode\x20bits\x20used\x20to\x20set\x20permissions\
    \x20on\x20created\x20files\x20by\x20default.\n\x20Must\x20be\x20an\x20oc\
    tal\x20value\x20between\x200000\x20and\x200777\x20or\x20a\x20decimal\x20\
    value\x20between\x200\x20and\x20511.\n\x20YAML\x20accepts\x20both\x20oct\
    al\x20and\x20decimal\x20values,\x20JSON\x20requires\x20decimal\x20values\
    \x20for\x20mode\x20bits.\n\x20Directories\x20within\x20the\x20path\x20ar\
    e\x20not\x20affected\x20by\x20this\x20setting.\n\x20This\x20might\x20be\
    \x20in\x20conflict\x20with\x20other\x20options\x20that\x20affect\x20the\
    \x20file\n\x20mode,\x20like\x20fsGroup,\x20and\x20the\x20result\x20can\
    \x20be\x20other\x20mode\x20bits\x20set.\n\x20+optional\n\n\x0e\n\x06\x04\
    \x94\x01\x02\x01\x04\x12\x04\xb7\x1e\x02\n\n\x0e\n\x06\x04\x94\x01\x02\
    \x01\x05\x12\x04\xb7\x1e\x0b\x10\n\x0e\n\x06\x04\x94\x01\x02\x01\x01\x12\
    \x04\xb7\x1e\x11\x1c\n\x0e\n\x06\x04\x94\x01\x02\x01\x03\x12\x04\xb7\x1e\
    \x1f\x20\n\x9a\x01\n\x03\x04\x95\x01\x12\x06\xbc\x1e\0\xd8\x1e\x01\x1a\
    \x8a\x01\x20Represents\x20a\x20Quobyte\x20mount\x20that\x20lasts\x20the\
    \x20lifetime\x20of\x20a\x20pod.\n\x20Quobyte\x20volumes\x20do\x20not\x20\
    support\x20ownership\x20management\x20or\x20SELinux\x20relabeling.\n\n\
    \x0c\n\x04\x04\x95\x01\x01\x12\x04\xbc\x1e\x08\x1b\n\xda\x01\n\x05\x04\
    \x95\x01\x02\0\x12\x04\xc0\x1e\x02\x1f\x1a\xca\x01\x20Registry\x20repres\
    ents\x20a\x20single\x20or\x20multiple\x20Quobyte\x20Registry\x20services\
    \n\x20specified\x20as\x20a\x20string\x20as\x20host:port\x20pair\x20(mult\
    iple\x20entries\x20are\x20separated\x20with\x20commas)\n\x20which\x20act\
    s\x20as\x20the\x20central\x20registry\x20for\x20volumes\n\n\x0e\n\x06\
    \x04\x95\x01\x02\0\x04\x12\x04\xc0\x1e\x02\n\n\x0e\n\x06\x04\x95\x01\x02\
    \0\x05\x12\x04\xc0\x1e\x0b\x11\n\x0e\n\x06\x04\x95\x01\x02\0\x01\x12\x04\
    \xc0\x1e\x12\x1a\n\x0e\n\x06\x04\x95\x01\x02\0\x03\x12\x04\xc0\x1e\x1d\
    \x1e\n^\n\x05\x04\x95\x01\x02\x01\x12\x04\xc3\x1e\x02\x1d\x1aO\x20Volume\
    \x20is\x20a\x20string\x20that\x20references\x20an\x20already\x20created\
    \x20Quobyte\x20volume\x20by\x20name.\n\n\x0e\n\x06\x04\x95\x01\x02\x01\
    \x04\x12\x04\xc3\x1e\x02\n\n\x0e\n\x06\x04\x95\x01\x02\x01\x05\x12\x04\
    \xc3\x1e\x0b\x11\n\x0e\n\x06\x04\x95\x01\x02\x01\x01\x12\x04\xc3\x1e\x12\
    \x18\n\x0e\n\x06\x04\x95\x01\x02\x01\x03\x12\x04\xc3\x1e\x1b\x1c\n\x85\
    \x01\n\x05\x04\x95\x01\x02\x02\x12\x04\xc8\x1e\x02\x1d\x1av\x20ReadOnly\
    \x20here\x20will\x20force\x20the\x20Quobyte\x20volume\x20to\x20be\x20mou\
    nted\x20with\x20read-only\x20permissions.\n\x20Defaults\x20to\x20false.\
    \n\x20+optional\n\n\x0e\n\x06\x04\x95\x01\x02\x02\x04\x12\x04\xc8\x1e\
    \x02\n\n\x0e\n\x06\x04\x95\x01\x02\x02\x05\x12\x04\xc8\x1e\x0b\x0f\n\x0e\
    \n\x06\x04\x95\x01\x02\x02\x01\x12\x04\xc8\x1e\x10\x18\n\x0e\n\x06\x04\
    \x95\x01\x02\x02\x03\x12\x04\xc8\x1e\x1b\x1c\nY\n\x05\x04\x95\x01\x02\
    \x03\x12\x04\xcd\x1e\x02\x1b\x1aJ\x20User\x20to\x20map\x20volume\x20acce\
    ss\x20to\n\x20Defaults\x20to\x20serivceaccount\x20user\n\x20+optional\n\
    \n\x0e\n\x06\x04\x95\x01\x02\x03\x04\x12\x04\xcd\x1e\x02\n\n\x0e\n\x06\
    \x04\x95\x01\x02\x03\x05\x12\x04\xcd\x1e\x0b\x11\n\x0e\n\x06\x04\x95\x01\
    \x02\x03\x01\x12\x04\xcd\x1e\x12\x16\n\x0e\n\x06\x04\x95\x01\x02\x03\x03\
    \x12\x04\xcd\x1e\x19\x1a\nN\n\x05\x04\x95\x01\x02\x04\x12\x04\xd2\x1e\
    \x02\x1c\x1a?\x20Group\x20to\x20map\x20volume\x20access\x20to\n\x20Defau\
    lt\x20is\x20no\x20group\n\x20+optional\n\n\x0e\n\x06\x04\x95\x01\x02\x04\
    \x04\x12\x04\xd2\x1e\x02\n\n\x0e\n\x06\x04\x95\x01\x02\x04\x05\x12\x04\
    \xd2\x1e\x0b\x11\n\x0e\n\x06\x04\x95\x01\x02\x04\x01\x12\x04\xd2\x1e\x12\
    \x17\n\x0e\n\x06\x04\x95\x01\x02\x04\x03\x12\x04\xd2\x1e\x1a\x1b\n\xa1\
    \x01\n\x05\x04\x95\x01\x02\x05\x12\x04\xd7\x1e\x02\x1d\x1a\x91\x01\x20Te\
    nant\x20owning\x20the\x20given\x20Quobyte\x20volume\x20in\x20the\x20Back\
    end\n\x20Used\x20with\x20dynamically\x20provisioned\x20Quobyte\x20volume\
    s,\x20value\x20is\x20set\x20by\x20the\x20plugin\n\x20+optional\n\n\x0e\n\
    \x06\x04\x95\x01\x02\x05\x04\x12\x04\xd7\x1e\x02\n\n\x0e\n\x06\x04\x95\
    \x01\x02\x05\x05\x12\x04\xd7\x1e\x0b\x11\n\x0e\n\x06\x04\x95\x01\x02\x05\
    \x01\x12\x04\xd7\x1e\x12\x18\n\x0e\n\x06\x04\x95\x01\x02\x05\x03\x12\x04\
    \xd7\x1e\x1b\x1c\n\x9b\x01\n\x03\x04\x96\x01\x12\x06\xdc\x1e\0\x8b\x1f\
    \x01\x1a\x8b\x01\x20Represents\x20a\x20Rados\x20Block\x20Device\x20mount\
    \x20that\x20lasts\x20the\x20lifetime\x20of\x20a\x20pod.\n\x20RBD\x20volu\
    mes\x20support\x20ownership\x20management\x20and\x20SELinux\x20relabelin\
    g.\n\n\x0c\n\x04\x04\x96\x01\x01\x12\x04\xdc\x1e\x08!\nw\n\x05\x04\x96\
    \x01\x02\0\x12\x04\xdf\x1e\x02\x1f\x1ah\x20A\x20collection\x20of\x20Ceph\
    \x20monitors.\n\x20More\x20info:\x20https://examples.k8s.io/volumes/rbd/\
    README.md#how-to-use-it\n\n\x0e\n\x06\x04\x96\x01\x02\0\x04\x12\x04\xdf\
    \x1e\x02\n\n\x0e\n\x06\x04\x96\x01\x02\0\x05\x12\x04\xdf\x1e\x0b\x11\n\
    \x0e\n\x06\x04\x96\x01\x02\0\x01\x12\x04\xdf\x1e\x12\x1a\n\x0e\n\x06\x04\
    \x96\x01\x02\0\x03\x12\x04\xdf\x1e\x1d\x1e\nn\n\x05\x04\x96\x01\x02\x01\
    \x12\x04\xe3\x1e\x02\x1c\x1a_\x20The\x20rados\x20image\x20name.\n\x20Mor\
    e\x20info:\x20https://examples.k8s.io/volumes/rbd/README.md#how-to-use-i\
    t\n\n\x0e\n\x06\x04\x96\x01\x02\x01\x04\x12\x04\xe3\x1e\x02\n\n\x0e\n\
    \x06\x04\x96\x01\x02\x01\x05\x12\x04\xe3\x1e\x0b\x11\n\x0e\n\x06\x04\x96\
    \x01\x02\x01\x01\x12\x04\xe3\x1e\x12\x17\n\x0e\n\x06\x04\x96\x01\x02\x01\
    \x03\x12\x04\xe3\x1e\x1a\x1b\n\x8a\x03\n\x05\x04\x96\x01\x02\x02\x12\x04\
    \xeb\x1e\x02\x1d\x1a\xfa\x02\x20Filesystem\x20type\x20of\x20the\x20volum\
    e\x20that\x20you\x20want\x20to\x20mount.\n\x20Tip:\x20Ensure\x20that\x20\
    the\x20filesystem\x20type\x20is\x20supported\x20by\x20the\x20host\x20ope\
    rating\x20system.\n\x20Examples:\x20\"ext4\",\x20\"xfs\",\x20\"ntfs\".\
    \x20Implicitly\x20inferred\x20to\x20be\x20\"ext4\"\x20if\x20unspecified.\
    \n\x20More\x20info:\x20https://kubernetes.io/docs/concepts/storage/volum\
    es#rbd\n\x20TODO:\x20how\x20do\x20we\x20prevent\x20errors\x20in\x20the\
    \x20filesystem\x20from\x20compromising\x20the\x20machine\n\x20+optional\
    \n\n\x0e\n\x06\x04\x96\x01\x02\x02\x04\x12\x04\xeb\x1e\x02\n\n\x0e\n\x06\
    \x04\x96\x01\x02\x02\x05\x12\x04\xeb\x1e\x0b\x11\n\x0e\n\x06\x04\x96\x01\
    \x02\x02\x01\x12\x04\xeb\x1e\x12\x18\n\x0e\n\x06\x04\x96\x01\x02\x02\x03\
    \x12\x04\xeb\x1e\x1b\x1c\n\x89\x01\n\x05\x04\x96\x01\x02\x03\x12\x04\xf1\
    \x1e\x02\x1b\x1az\x20The\x20rados\x20pool\x20name.\n\x20Default\x20is\
    \x20rbd.\n\x20More\x20info:\x20https://examples.k8s.io/volumes/rbd/READM\
    E.md#how-to-use-it\n\x20+optional\n\n\x0e\n\x06\x04\x96\x01\x02\x03\x04\
    \x12\x04\xf1\x1e\x02\n\n\x0e\n\x06\x04\x96\x01\x02\x03\x05\x12\x04\xf1\
    \x1e\x0b\x11\n\x0e\n\x06\x04\x96\x01\x02\x03\x01\x12\x04\xf1\x1e\x12\x16\
    \n\x0e\n\x06\x04\x96\x01\x02\x03\x03\x12\x04\xf1\x1e\x19\x1a\n\x8b\x01\n\
    \x05\x04\x96\x01\x02\x04\x12\x04\xf7\x1e\x02\x1b\x1a|\x20The\x20rados\
    \x20user\x20name.\n\x20Default\x20is\x20admin.\n\x20More\x20info:\x20htt\
    ps://examples.k8s.io/volumes/rbd/README.md#how-to-use-it\n\x20+optional\
    \n\n\x0e\n\x06\x04\x96\x01\x02\x04\x04\x12\x04\xf7\x1e\x02\n\n\x0e\n\x06\
    \x04\x96\x01\x02\x04\x05\x12\x04\xf7\x1e\x0b\x11\n\x0e\n\x06\x04\x96\x01\
    \x02\x04\x01\x12\x04\xf7\x1e\x12\x16\n\x0e\n\x06\x04\x96\x01\x02\x04\x03\
    \x12\x04\xf7\x1e\x19\x1a\n\xb0\x01\n\x05\x04\x96\x01\x02\x05\x12\x04\xfd\
    \x1e\x02\x1e\x1a\xa0\x01\x20Keyring\x20is\x20the\x20path\x20to\x20key\
    \x20ring\x20for\x20RBDUser.\n\x20Default\x20is\x20/etc/ceph/keyring.\n\
    \x20More\x20info:\x20https://examples.k8s.io/volumes/rbd/README.md#how-t\
    o-use-it\n\x20+optional\n\n\x0e\n\x06\x04\x96\x01\x02\x05\x04\x12\x04\
    \xfd\x1e\x02\n\n\x0e\n\x06\x04\x96\x01\x02\x05\x05\x12\x04\xfd\x1e\x0b\
    \x11\n\x0e\n\x06\x04\x96\x01\x02\x05\x01\x12\x04\xfd\x1e\x12\x19\n\x0e\n\
    \x06\x04\x96\x01\x02\x05\x03\x12\x04\xfd\x1e\x1c\x1d\n\xd1\x01\n\x05\x04\
    \x96\x01\x02\x06\x12\x04\x84\x1f\x02)\x1a\xc1\x01\x20SecretRef\x20is\x20\
    name\x20of\x20the\x20authentication\x20secret\x20for\x20RBDUser.\x20If\
    \x20provided\n\x20overrides\x20keyring.\n\x20Default\x20is\x20nil.\n\x20\
    More\x20info:\x20https://examples.k8s.io/volumes/rbd/README.md#how-to-us\
    e-it\n\x20+optional\n\n\x0e\n\x06\x04\x96\x01\x02\x06\x04\x12\x04\x84\
    \x1f\x02\n\n\x0e\n\x06\x04\x96\x01\x02\x06\x06\x12\x04\x84\x1f\x0b\x1a\n\
    \x0e\n\x06\x04\x96\x01\x02\x06\x01\x12\x04\x84\x1f\x1b$\n\x0e\n\x06\x04\
    \x96\x01\x02\x06\x03\x12\x04\x84\x1f'(\n\xb7\x01\n\x05\x04\x96\x01\x02\
    \x07\x12\x04\x8a\x1f\x02\x1d\x1a\xa7\x01\x20ReadOnly\x20here\x20will\x20\
    force\x20the\x20ReadOnly\x20setting\x20in\x20VolumeMounts.\n\x20Defaults\
    \x20to\x20false.\n\x20More\x20info:\x20https://examples.k8s.io/volumes/r\
    bd/README.md#how-to-use-it\n\x20+optional\n\n\x0e\n\x06\x04\x96\x01\x02\
    \x07\x04\x12\x04\x8a\x1f\x02\n\n\x0e\n\x06\x04\x96\x01\x02\x07\x05\x12\
    \x04\x8a\x1f\x0b\x0f\n\x0e\n\x06\x04\x96\x01\x02\x07\x01\x12\x04\x8a\x1f\
    \x10\x18\n\x0e\n\x06\x04\x96\x01\x02\x07\x03\x12\x04\x8a\x1f\x1b\x1c\n\
    \x9b\x01\n\x03\x04\x97\x01\x12\x06\x8f\x1f\0\xbe\x1f\x01\x1a\x8b\x01\x20\
    Represents\x20a\x20Rados\x20Block\x20Device\x20mount\x20that\x20lasts\
    \x20the\x20lifetime\x20of\x20a\x20pod.\n\x20RBD\x20volumes\x20support\
    \x20ownership\x20management\x20and\x20SELinux\x20relabeling.\n\n\x0c\n\
    \x04\x04\x97\x01\x01\x12\x04\x8f\x1f\x08\x17\nw\n\x05\x04\x97\x01\x02\0\
    \x12\x04\x92\x1f\x02\x1f\x1ah\x20A\x20collection\x20of\x20Ceph\x20monito\
    rs.\n\x20More\x20info:\x20https://examples.k8s.io/volumes/rbd/README.md#\
    how-to-use-it\n\n\x0e\n\x06\x04\x97\x01\x02\0\x04\x12\x04\x92\x1f\x02\n\
    \n\x0e\n\x06\x04\x97\x01\x02\0\x05\x12\x04\x92\x1f\x0b\x11\n\x0e\n\x06\
    \x04\x97\x01\x02\0\x01\x12\x04\x92\x1f\x12\x1a\n\x0e\n\x06\x04\x97\x01\
    \x02\0\x03\x12\x04\x92\x1f\x1d\x1e\nn\n\x05\x04\x97\x01\x02\x01\x12\x04\
    \x96\x1f\x02\x1c\x1a_\x20The\x20rados\x20image\x20name.\n\x20More\x20inf\
    o:\x20https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it\n\n\
    \x0e\n\x06\x04\x97\x01\x02\x01\x04\x12\x04\x96\x1f\x02\n\n\x0e\n\x06\x04\
    \x97\x01\x02\x01\x05\x12\x04\x96\x1f\x0b\x11\n\x0e\n\x06\x04\x97\x01\x02\
    \x01\x01\x12\x04\x96\x1f\x12\x17\n\x0e\n\x06\x04\x97\x01\x02\x01\x03\x12\
    \x04\x96\x1f\x1a\x1b\n\x8a\x03\n\x05\x04\x97\x01\x02\x02\x12\x04\x9e\x1f\
    \x02\x1d\x1a\xfa\x02\x20Filesystem\x20type\x20of\x20the\x20volume\x20tha\
    t\x20you\x20want\x20to\x20mount.\n\x20Tip:\x20Ensure\x20that\x20the\x20f\
    ilesystem\x20type\x20is\x20supported\x20by\x20the\x20host\x20operating\
    \x20system.\n\x20Examples:\x20\"ext4\",\x20\"xfs\",\x20\"ntfs\".\x20Impl\
    icitly\x20inferred\x20to\x20be\x20\"ext4\"\x20if\x20unspecified.\n\x20Mo\
    re\x20info:\x20https://kubernetes.io/docs/concepts/storage/volumes#rbd\n\
    \x20TODO:\x20how\x20do\x20we\x20prevent\x20errors\x20in\x20the\x20filesy\
    stem\x20from\x20compromising\x20the\x20machine\n\x20+optional\n\n\x0e\n\
    \x06\x04\x97\x01\x02\x02\x04\x12\x04\x9e\x1f\x02\n\n\x0e\n\x06\x04\x97\
    \x01\x02\x02\x05\x12\x04\x9e\x1f\x0b\x11\n\x0e\n\x06\x04\x97\x01\x02\x02\
    \x01\x12\x04\x9e\x1f\x12\x18\n\x0e\n\x06\x04\x97\x01\x02\x02\x03\x12\x04\
    \x9e\x1f\x1b\x1c\n\x89\x01\n\x05\x04\x97\x01\x02\x03\x12\x04\xa4\x1f\x02\
    \x1b\x1az\x20The\x20rados\x20pool\x20name.\n\x20Default\x20is\x20rbd.\n\
    \x20More\x20info:\x20https://examples.k8s.io/volumes/rbd/README.md#how-t\
    o-use-it\n\x20+optional\n\n\x0e\n\x06\x04\x97\x01\x02\x03\x04\x12\x04\
    \xa4\x1f\x02\n\n\x0e\n\x06\x04\x97\x01\x02\x03\x05\x12\x04\xa4\x1f\x0b\
    \x11\n\x0e\n\x06\x04\x97\x01\x02\x03\x01\x12\x04\xa4\x1f\x12\x16\n\x0e\n\
    \x06\x04\x97\x01\x02\x03\x03\x12\x04\xa4\x1f\x19\x1a\n\x8b\x01\n\x05\x04\
    \x97\x01\x02\x04\x12\x04\xaa\x1f\x02\x1b\x1a|\x20The\x20rados\x20user\
    \x20name.\n\x20Default\x20is\x20admin.\n\x20More\x20info:\x20https://exa\
    mples.k8s.io/volumes/rbd/README.md#how-to-use-it\n\x20+optional\n\n\x0e\
    \n\x06\x04\x97\x01\x02\x04\x04\x12\x04\xaa\x1f\x02\n\n\x0e\n\x06\x04\x97\
    \x01\x02\x04\x05\x12\x04\xaa\x1f\x0b\x11\n\x0e\n\x06\x04\x97\x01\x02\x04\
    \x01\x12\x04\xaa\x1f\x12\x16\n\x0e\n\x06\x04\x97\x01\x02\x04\x03\x12\x04\
    \xaa\x1f\x19\x1a\n\xb0\x01\n\x05\x04\x97\x01\x02\x05\x12\x04\xb0\x1f\x02\
    \x1e\x1a\xa0\x01\x20Keyring\x20is\x20the\x20path\x20to\x20key\x20ring\
    \x20for\x20RBDUser.\n\x20Default\x20is\x20/etc/ceph/keyring.\n\x20More\
    \x20info:\x20https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it\
    \n\x20+optional\n\n\x0e\n\x06\x04\x97\x01\x02\x05\x04\x12\x04\xb0\x1f\
    \x02\n\n\x0e\n\x06\x04\x97\x01\x02\x05\x05\x12\x04\xb0\x1f\x0b\x11\n\x0e\
    \n\x06\x04\x97\x01\x02\x05\x01\x12\x04\xb0\x1f\x12\x19\n\x0e\n\x06\x04\
    \x97\x01\x02\x05\x03\x12\x04\xb0\x1f\x1c\x1d\n\xd1\x01\n\x05\x04\x97\x01\
    \x02\x06\x12\x04\xb7\x1f\x02.\x1a\xc1\x01\x20SecretRef\x20is\x20name\x20\
    of\x20the\x20authentication\x20secret\x20for\x20RBDUser.\x20If\x20provid\
    ed\n\x20overrides\x20keyring.\n\x20Default\x20is\x20nil.\n\x20More\x20in\
    fo:\x20https://examples.k8s.io/volumes/rbd/README.md#how-to-use-it\n\x20\
    +optional\n\n\x0e\n\x06\x04\x97\x01\x02\x06\x04\x12\x04\xb7\x1f\x02\n\n\
    \x0e\n\x06\x04\x97\x01\x02\x06\x06\x12\x04\xb7\x1f\x0b\x1f\n\x0e\n\x06\
    \x04\x97\x01\x02\x06\x01\x12\x04\xb7\x1f\x20)\n\x0e\n\x06\x04\x97\x01\
    \x02\x06\x03\x12\x04\xb7\x1f,-\n\xb7\x01\n\x05\x04\x97\x01\x02\x07\x12\
    \x04\xbd\x1f\x02\x1d\x1a\xa7\x01\x20ReadOnly\x20here\x20will\x20force\
    \x20the\x20ReadOnly\x20setting\x20in\x20VolumeMounts.\n\x20Defaults\x20t\
    o\x20false.\n\x20More\x20info:\x20https://examples.k8s.io/volumes/rbd/RE\
    ADME.md#how-to-use-it\n\x20+optional\n\n\x0e\n\x06\x04\x97\x01\x02\x07\
    \x04\x12\x04\xbd\x1f\x02\n\n\x0e\n\x06\x04\x97\x01\x02\x07\x05\x12\x04\
    \xbd\x1f\x0b\x0f\n\x0e\n\x06\x04\x97\x01\x02\x07\x01\x12\x04\xbd\x1f\x10\
    \x18\n\x0e\n\x06\x04\x97\x01\x02\x07\x03\x12\x04\xbd\x1f\x1b\x1c\n6\n\
    \x03\x04\x98\x01\x12\x06\xc1\x1f\0\xcc\x1f\x01\x1a'\x20RangeAllocation\
    \x20is\x20not\x20a\x20public\x20type.\n\n\x0c\n\x04\x04\x98\x01\x01\x12\
    \x04\xc1\x1f\x08\x17\n\xa1\x01\n\x05\x04\x98\x01\x02\0\x12\x04\xc5\x1f\
    \x02H\x1a\x91\x01\x20Standard\x20object's\x20metadata.\n\x20More\x20info\
    :\x20https://git.k8s.io/community/contributors/devel/sig-architecture/ap\
    i-conventions.md#metadata\n\x20+optional\n\n\x0e\n\x06\x04\x98\x01\x02\0\
    \x04\x12\x04\xc5\x1f\x02\n\n\x0e\n\x06\x04\x98\x01\x02\0\x06\x12\x04\xc5\
    \x1f\x0b:\n\x0e\n\x06\x04\x98\x01\x02\0\x01\x12\x04\xc5\x1f;C\n\x0e\n\
    \x06\x04\x98\x01\x02\0\x03\x12\x04\xc5\x1fFG\nQ\n\x05\x04\x98\x01\x02\
    \x01\x12\x04\xc8\x1f\x02\x1c\x1aB\x20Range\x20is\x20string\x20that\x20id\
    entifies\x20the\x20range\x20represented\x20by\x20'data'.\n\n\x0e\n\x06\
    \x04\x98\x01\x02\x01\x04\x12\x04\xc8\x1f\x02\n\n\x0e\n\x06\x04\x98\x01\
    \x02\x01\x05\x12\x04\xc8\x1f\x0b\x11\n\x0e\n\x06\x04\x98\x01\x02\x01\x01\
    \x12\x04\xc8\x1f\x12\x17\n\x0e\n\x06\x04\x98\x01\x02\x01\x03\x12\x04\xc8\
    \x1f\x1a\x1b\n`\n\x05\x04\x98\x01\x02\x02\x12\x04\xcb\x1f\x02\x1a\x1aQ\
    \x20Data\x20is\x20a\x20bit\x20array\x20containing\x20all\x20allocated\
    \x20addresses\x20in\x20the\x20previous\x20segment.\n\n\x0e\n\x06\x04\x98\
    \x01\x02\x02\x04\x12\x04\xcb\x1f\x02\n\n\x0e\n\x06\x04\x98\x01\x02\x02\
    \x05\x12\x04\xcb\x1f\x0b\x10\n\x0e\n\x06\x04\x98\x01\x02\x02\x01\x12\x04\
    \xcb\x1f\x11\x15\n\x0e\n\x06\x04\x98\x01\x02\x02\x03\x12\x04\xcb\x1f\x18\
    \x19\n`\n\x03\x04\x99\x01\x12\x06\xcf\x1f\0\xe2\x1f\x01\x1aQ\x20Replicat\
    ionController\x20represents\x20the\x20configuration\x20of\x20a\x20replic\
    ation\x20controller.\n\n\x0c\n\x04\x04\x99\x01\x01\x12\x04\xcf\x1f\x08\
    \x1d\n\xaf\x02\n\x05\x04\x99\x01\x02\0\x12\x04\xd4\x1f\x02H\x1a\x9f\x02\
    \x20If\x20the\x20Labels\x20of\x20a\x20ReplicationController\x20are\x20em\
    pty,\x20they\x20are\x20defaulted\x20to\n\x20be\x20the\x20same\x20as\x20t\
    he\x20Pod(s)\x20that\x20the\x20replication\x20controller\x20manages.\n\
    \x20Standard\x20object's\x20metadata.\x20More\x20info:\x20https://git.k8\
    s.io/community/contributors/devel/sig-architecture/api-conventions.md#me\
    tadata\n\x20+optional\n\n\x0e\n\x06\x04\x99\x01\x02\0\x04\x12\x04\xd4\
    \x1f\x02\n\n\x0e\n\x06\x04\x99\x01\x02\0\x06\x12\x04\xd4\x1f\x0b:\n\x0e\
    \n\x06\x04\x99\x01\x02\0\x01\x12\x04\xd4\x1f;C\n\x0e\n\x06\x04\x99\x01\
    \x02\0\x03\x12\x04\xd4\x1fFG\n\xe2\x01\n\x05\x04\x99\x01\x02\x01\x12\x04\
    \xd9\x1f\x02.\x1a\xd2\x01\x20Spec\x20defines\x20the\x20specification\x20\
    of\x20the\x20desired\x20behavior\x20of\x20the\x20replication\x20controll\
    er.\n\x20More\x20info:\x20https://git.k8s.io/community/contributors/deve\
    l/sig-architecture/api-conventions.md#spec-and-status\n\x20+optional\n\n\
    \x0e\n\x06\x04\x99\x01\x02\x01\x04\x12\x04\xd9\x1f\x02\n\n\x0e\n\x06\x04\
    \x99\x01\x02\x01\x06\x12\x04\xd9\x1f\x0b$\n\x0e\n\x06\x04\x99\x01\x02\
    \x01\x01\x12\x04\xd9\x1f%)\n\x0e\n\x06\x04\x99\x01\x02\x01\x03\x12\x04\
    \xd9\x1f,-\n\xb3\x02\n\x05\x04\x99\x01\x02\x02\x12\x04\xe1\x1f\x022\x1a\
    \xa3\x02\x20Status\x20is\x20the\x20most\x20recently\x20observed\x20statu\
    s\x20of\x20the\x20replication\x20controller.\n\x20This\x20data\x20may\
    \x20be\x20out\x20of\x20date\x20by\x20some\x20window\x20of\x20time.\n\x20\
    Populated\x20by\x20the\x20system.\n\x20Read-only.\n\x20More\x20info:\x20\
    https://git.k8s.io/community/contributors/devel/sig-architecture/api-con\
    ventions.md#spec-and-status\n\x20+optional\n\n\x0e\n\x06\x04\x99\x01\x02\
    \x02\x04\x12\x04\xe1\x1f\x02\n\n\x0e\n\x06\x04\x99\x01\x02\x02\x06\x12\
    \x04\xe1\x1f\x0b&\n\x0e\n\x06\x04\x99\x01\x02\x02\x01\x12\x04\xe1\x1f'-\
    \n\x0e\n\x06\x04\x99\x01\x02\x02\x03\x12\x04\xe1\x1f01\ns\n\x03\x04\x9a\
    \x01\x12\x06\xe5\x1f\0\xf7\x1f\x01\x1ad\x20ReplicationControllerConditio\
    n\x20describes\x20the\x20state\x20of\x20a\x20replication\x20controller\
    \x20at\x20a\x20certain\x20point.\n\n\x0c\n\x04\x04\x9a\x01\x01\x12\x04\
    \xe5\x1f\x08&\n:\n\x05\x04\x9a\x01\x02\0\x12\x04\xe7\x1f\x02\x1b\x1a+\
    \x20Type\x20of\x20replication\x20controller\x20condition.\n\n\x0e\n\x06\
    \x04\x9a\x01\x02\0\x04\x12\x04\xe7\x1f\x02\n\n\x0e\n\x06\x04\x9a\x01\x02\
    \0\x05\x12\x04\xe7\x1f\x0b\x11\n\x0e\n\x06\x04\x9a\x01\x02\0\x01\x12\x04\
    \xe7\x1f\x12\x16\n\x0e\n\x06\x04\x9a\x01\x02\0\x03\x12\x04\xe7\x1f\x19\
    \x1a\nF\n\x05\x04\x9a\x01\x02\x01\x12\x04\xea\x1f\x02\x1d\x1a7\x20Status\
    \x20of\x20the\x20condition,\x20one\x20of\x20True,\x20False,\x20Unknown.\
    \n\n\x0e\n\x06\x04\x9a\x01\x02\x01\x04\x12\x04\xea\x1f\x02\n\n\x0e\n\x06\
    \x04\x9a\x01\x02\x01\x05\x12\x04\xea\x1f\x0b\x11\n\x0e\n\x06\x04\x9a\x01\
    \x02\x01\x01\x12\x04\xea\x1f\x12\x18\n\x0e\n\x06\x04\x9a\x01\x02\x01\x03\
    \x12\x04\xea\x1f\x1b\x1c\n`\n\x05\x04\x9a\x01\x02\x02\x12\x04\xee\x1f\
    \x02L\x1aQ\x20The\x20last\x20time\x20the\x20condition\x20transitioned\
    \x20from\x20one\x20status\x20to\x20another.\n\x20+optional\n\n\x0e\n\x06\
    \x04\x9a\x01\x02\x02\x04\x12\x04\xee\x1f\x02\n\n\x0e\n\x06\x04\x9a\x01\
    \x02\x02\x06\x12\x04\xee\x1f\x0b4\n\x0e\n\x06\x04\x9a\x01\x02\x02\x01\
    \x12\x04\xee\x1f5G\n\x0e\n\x06\x04\x9a\x01\x02\x02\x03\x12\x04\xee\x1fJK\
    \nK\n\x05\x04\x9a\x01\x02\x03\x12\x04\xf2\x1f\x02\x1d\x1a<\x20The\x20rea\
    son\x20for\x20the\x20condition's\x20last\x20transition.\n\x20+optional\n\
    \n\x0e\n\x06\x04\x9a\x01\x02\x03\x04\x12\x04\xf2\x1f\x02\n\n\x0e\n\x06\
    \x04\x9a\x01\x02\x03\x05\x12\x04\xf2\x1f\x0b\x11\n\x0e\n\x06\x04\x9a\x01\
    \x02\x03\x01\x12\x04\xf2\x1f\x12\x18\n\x0e\n\x06\x04\x9a\x01\x02\x03\x03\
    \x12\x04\xf2\x1f\x1b\x1c\n]\n\x05\x04\x9a\x01\x02\x04\x12\x04\xf6\x1f\
    \x02\x1e\x1aN\x20A\x20human\x20readable\x20message\x20indicating\x20deta\
    ils\x20about\x20the\x20transition.\n\x20+optional\n\n\x0e\n\x06\x04\x9a\
    \x01\x02\x04\x04\x12\x04\xf6\x1f\x02\n\n\x0e\n\x06\x04\x9a\x01\x02\x04\
    \x05\x12\x04\xf6\x1f\x0b\x11\n\x0e\n\x06\x04\x9a\x01\x02\x04\x01\x12\x04\
    \xf6\x1f\x12\x19\n\x0e\n\x06\x04\x9a\x01\x02\x04\x03\x12\x04\xf6\x1f\x1c\
    \x1d\nV\n\x03\x04\x9b\x01\x12\x06\xfa\x1f\0\x83\x20\x01\x1aG\x20Replicat\
    ionControllerList\x20is\x20a\x20collection\x20of\x20replication\x20contr\
    ollers.\n\n\x0c\n\x04\x04\x9b\x01\x01\x12\x04\xfa\x1f\x08!\n\xa0\x01\n\
    \x05\x04\x9b\x01\x02\0\x12\x04\xfe\x1f\x02F\x1a\x90\x01\x20Standard\x20l\
    ist\x20metadata.\n\x20More\x20info:\x20https://git.k8s.io/community/cont\
    ributors/devel/sig-architecture/api-conventions.md#types-kinds\n\x20+opt\
    ional\n\n\x0e\n\x06\x04\x9b\x01\x02\0\x04\x12\x04\xfe\x1f\x02\n\n\x0e\n\
    \x06\x04\x9b\x01\x02\0\x06\x12\x04\xfe\x1f\x0b8\n\x0e\n\x06\x04\x9b\x01\
    \x02\0\x01\x12\x04\xfe\x1f9A\n\x0e\n\x06\x04\x9b\x01\x02\0\x03\x12\x04\
    \xfe\x1fDE\n\x8d\x01\n\x05\x04\x9b\x01\x02\x01\x12\x04\x82\x20\x02+\x1a~\
    \x20List\x20of\x20replication\x20controllers.\n\x20More\x20info:\x20http\
    s://kubernetes.io/docs/concepts/workloads/controllers/replicationcontrol\
    ler\n\n\x0e\n\x06\x04\x9b\x01\x02\x01\x04\x12\x04\x82\x20\x02\n\n\x0e\n\
    \x06\x04\x9b\x01\x02\x01\x06\x12\x04\x82\x20\x0b\x20\n\x0e\n\x06\x04\x9b\
    \x01\x02\x01\x01\x12\x04\x82\x20!&\n\x0e\n\x06\x04\x9b\x01\x02\x01\x03\
    \x12\x04\x82\x20)*\n\\\n\x03\x04\x9c\x01\x12\x06\x86\x20\0\xa1\x20\x01\
    \x1aM\x20ReplicationControllerSpec\x20is\x20the\x20specification\x20of\
    \x20a\x20replication\x20controller.\n\n\x0c\n\x04\x04\x9c\x01\x01\x12\
    \x04\x86\x20\x08!\n\x9d\x02\n\x05\x04\x9c\x01\x02\0\x12\x04\x8c\x20\x02\
    \x1e\x1a\x8d\x02\x20Replicas\x20is\x20the\x20number\x20of\x20desired\x20\
    replicas.\n\x20This\x20is\x20a\x20pointer\x20to\x20distinguish\x20betwee\
    n\x20explicit\x20zero\x20and\x20unspecified.\n\x20Defaults\x20to\x201.\n\
    \x20More\x20info:\x20https://kubernetes.io/docs/concepts/workloads/contr\
    ollers/replicationcontroller#what-is-a-replicationcontroller\n\x20+optio\
    nal\n\n\x0e\n\x06\x04\x9c\x01\x02\0\x04\x12\x04\x8c\x20\x02\n\n\x0e\n\
    \x06\x04\x9c\x01\x02\0\x05\x12\x04\x8c\x20\x0b\x10\n\x0e\n\x06\x04\x9c\
    \x01\x02\0\x01\x12\x04\x8c\x20\x11\x19\n\x0e\n\x06\x04\x9c\x01\x02\0\x03\
    \x12\x04\x8c\x20\x1c\x1d\n\xf8\x01\n\x05\x04\x9c\x01\x02\x01\x12\x04\x92\
    \x20\x02%\x1a\xe8\x01\x20Minimum\x20number\x20of\x20seconds\x20for\x20wh\
    ich\x20a\x20newly\x20created\x20pod\x20should\x20be\x20ready\n\x20withou\
    t\x20any\x20of\x20its\x20container\x20crashing,\x20for\x20it\x20to\x20be\
    \x20considered\x20available.\n\x20Defaults\x20to\x200\x20(pod\x20will\
    \x20be\x20considered\x20available\x20as\x20soon\x20as\x20it\x20is\x20rea\
    dy)\n\x20+optional\n\n\x0e\n\x06\x04\x9c\x01\x02\x01\x04\x12\x04\x92\x20\
    \x02\n\n\x0e\n\x06\x04\x9c\x01\x02\x01\x05\x12\x04\x92\x20\x0b\x10\n\x0e\
    \n\x06\x04\x9c\x01\x02\x01\x01\x12\x04\x92\x20\x11\x20\n\x0e\n\x06\x04\
    \x9c\x01\x02\x01\x03\x12\x04\x92\x20#$\n\xae\x03\n\x05\x04\x9c\x01\x02\
    \x02\x12\x04\x9a\x20\x02#\x1a\x9e\x03\x20Selector\x20is\x20a\x20label\
    \x20query\x20over\x20pods\x20that\x20should\x20match\x20the\x20Replicas\
    \x20count.\n\x20If\x20Selector\x20is\x20empty,\x20it\x20is\x20defaulted\
    \x20to\x20the\x20labels\x20present\x20on\x20the\x20Pod\x20template.\n\
    \x20Label\x20keys\x20and\x20values\x20that\x20must\x20match\x20in\x20ord\
    er\x20to\x20be\x20controlled\x20by\x20this\x20replication\n\x20controlle\
    r,\x20if\x20empty\x20defaulted\x20to\x20labels\x20on\x20Pod\x20template.\
    \n\x20More\x20info:\x20https://kubernetes.io/docs/concepts/overview/work\
    ing-with-objects/labels/#label-selectors\n\x20+optional\n\n\x10\n\x06\
    \x04\x9c\x01\x02\x02\x04\x12\x06\x9a\x20\x02\x92\x20%\n\x0e\n\x06\x04\
    \x9c\x01\x02\x02\x06\x12\x04\x9a\x20\x02\x15\n\x0e\n\x06\x04\x9c\x01\x02\
    \x02\x01\x12\x04\x9a\x20\x16\x1e\n\x0e\n\x06\x04\x9c\x01\x02\x02\x03\x12\
    \x04\x9a\x20!\"\n\x9a\x02\n\x05\x04\x9c\x01\x02\x03\x12\x04\xa0\x20\x02(\
    \x1a\x8a\x02\x20Template\x20is\x20the\x20object\x20that\x20describes\x20\
    the\x20pod\x20that\x20will\x20be\x20created\x20if\n\x20insufficient\x20r\
    eplicas\x20are\x20detected.\x20This\x20takes\x20precedence\x20over\x20a\
    \x20TemplateRef.\n\x20More\x20info:\x20https://kubernetes.io/docs/concep\
    ts/workloads/controllers/replicationcontroller#pod-template\n\x20+option\
    al\n\n\x0e\n\x06\x04\x9c\x01\x02\x03\x04\x12\x04\xa0\x20\x02\n\n\x0e\n\
    \x06\x04\x9c\x01\x02\x03\x06\x12\x04\xa0\x20\x0b\x1a\n\x0e\n\x06\x04\x9c\
    \x01\x02\x03\x01\x12\x04\xa0\x20\x1b#\n\x0e\n\x06\x04\x9c\x01\x02\x03\
    \x03\x12\x04\xa0\x20&'\nh\n\x03\x04\x9d\x01\x12\x06\xa5\x20\0\xbf\x20\
    \x01\x1aY\x20ReplicationControllerStatus\x20represents\x20the\x20current\
    \x20status\x20of\x20a\x20replication\n\x20controller.\n\n\x0c\n\x04\x04\
    \x9d\x01\x01\x12\x04\xa5\x20\x08#\n\xc7\x01\n\x05\x04\x9d\x01\x02\0\x12\
    \x04\xa8\x20\x02\x1e\x1a\xb7\x01\x20Replicas\x20is\x20the\x20most\x20rec\
    ently\x20oberved\x20number\x20of\x20replicas.\n\x20More\x20info:\x20http\
    s://kubernetes.io/docs/concepts/workloads/controllers/replicationcontrol\
    ler#what-is-a-replicationcontroller\n\n\x0e\n\x06\x04\x9d\x01\x02\0\x04\
    \x12\x04\xa8\x20\x02\n\n\x0e\n\x06\x04\x9d\x01\x02\0\x05\x12\x04\xa8\x20\
    \x0b\x10\n\x0e\n\x06\x04\x9d\x01\x02\0\x01\x12\x04\xa8\x20\x11\x19\n\x0e\
    \n\x06\x04\x9d\x01\x02\0\x03\x12\x04\xa8\x20\x1c\x1d\n\x86\x01\n\x05\x04\
    \x9d\x01\x02\x01\x12\x04\xac\x20\x02*\x1aw\x20The\x20number\x20of\x20pod\
    s\x20that\x20have\x20labels\x20matching\x20the\x20labels\x20of\x20the\
    \x20pod\x20template\x20of\x20the\x20replication\x20controller.\n\x20+opt\
    ional\n\n\x0e\n\x06\x04\x9d\x01\x02\x01\x04\x12\x04\xac\x20\x02\n\n\x0e\
    \n\x06\x04\x9d\x01\x02\x01\x05\x12\x04\xac\x20\x0b\x10\n\x0e\n\x06\x04\
    \x9d\x01\x02\x01\x01\x12\x04\xac\x20\x11%\n\x0e\n\x06\x04\x9d\x01\x02\
    \x01\x03\x12\x04\xac\x20()\nY\n\x05\x04\x9d\x01\x02\x02\x12\x04\xb0\x20\
    \x02#\x1aJ\x20The\x20number\x20of\x20ready\x20replicas\x20for\x20this\
    \x20replication\x20controller.\n\x20+optional\n\n\x0e\n\x06\x04\x9d\x01\
    \x02\x02\x04\x12\x04\xb0\x20\x02\n\n\x0e\n\x06\x04\x9d\x01\x02\x02\x05\
    \x12\x04\xb0\x20\x0b\x10\n\x0e\n\x06\x04\x9d\x01\x02\x02\x01\x12\x04\xb0\
    \x20\x11\x1e\n\x0e\n\x06\x04\x9d\x01\x02\x02\x03\x12\x04\xb0\x20!\"\n\
    \x82\x01\n\x05\x04\x9d\x01\x02\x03\x12\x04\xb4\x20\x02'\x1as\x20The\x20n\
    umber\x20of\x20available\x20replicas\x20(ready\x20for\x20at\x20least\x20\
    minReadySeconds)\x20for\x20this\x20replication\x20controller.\n\x20+opti\
    onal\n\n\x0e\n\x06\x04\x9d\x01\x02\x03\x04\x12\x04\xb4\x20\x02\n\n\x0e\n\
    \x06\x04\x9d\x01\x02\x03\x05\x12\x04\xb4\x20\x0b\x10\n\x0e\n\x06\x04\x9d\
    \x01\x02\x03\x01\x12\x04\xb4\x20\x11\"\n\x0e\n\x06\x04\x9d\x01\x02\x03\
    \x03\x12\x04\xb4\x20%&\n|\n\x05\x04\x9d\x01\x02\x04\x12\x04\xb8\x20\x02(\
    \x1am\x20ObservedGeneration\x20reflects\x20the\x20generation\x20of\x20th\
    e\x20most\x20recently\x20observed\x20replication\x20controller.\n\x20+op\
    tional\n\n\x0e\n\x06\x04\x9d\x01\x02\x04\x04\x12\x04\xb8\x20\x02\n\n\x0e\
    \n\x06\x04\x9d\x01\x02\x04\x05\x12\x04\xb8\x20\x0b\x10\n\x0e\n\x06\x04\
    \x9d\x01\x02\x04\x01\x12\x04\xb8\x20\x11#\n\x0e\n\x06\x04\x9d\x01\x02\
    \x04\x03\x12\x04\xb8\x20&'\n\xa1\x01\n\x05\x04\x9d\x01\x02\x05\x12\x04\
    \xbe\x20\x029\x1a\x91\x01\x20Represents\x20the\x20latest\x20available\
    \x20observations\x20of\x20a\x20replication\x20controller's\x20current\
    \x20state.\n\x20+optional\n\x20+patchMergeKey=type\n\x20+patchStrategy=m\
    erge\n\n\x0e\n\x06\x04\x9d\x01\x02\x05\x04\x12\x04\xbe\x20\x02\n\n\x0e\n\
    \x06\x04\x9d\x01\x02\x05\x06\x12\x04\xbe\x20\x0b)\n\x0e\n\x06\x04\x9d\
    \x01\x02\x05\x01\x12\x04\xbe\x20*4\n\x0e\n\x06\x04\x9d\x01\x02\x05\x03\
    \x12\x04\xbe\x2078\nk\n\x03\x04\x9e\x01\x12\x06\xc2\x20\0\xcd\x20\x01\
    \x1a\\\x20ResourceFieldSelector\x20represents\x20container\x20resources\
    \x20(cpu,\x20memory)\x20and\x20their\x20output\x20format\n\n\x0c\n\x04\
    \x04\x9e\x01\x01\x12\x04\xc2\x20\x08\x1d\nW\n\x05\x04\x9e\x01\x02\0\x12\
    \x04\xc5\x20\x02$\x1aH\x20Container\x20name:\x20required\x20for\x20volum\
    es,\x20optional\x20for\x20env\x20vars\n\x20+optional\n\n\x0e\n\x06\x04\
    \x9e\x01\x02\0\x04\x12\x04\xc5\x20\x02\n\n\x0e\n\x06\x04\x9e\x01\x02\0\
    \x05\x12\x04\xc5\x20\x0b\x11\n\x0e\n\x06\x04\x9e\x01\x02\0\x01\x12\x04\
    \xc5\x20\x12\x1f\n\x0e\n\x06\x04\x9e\x01\x02\0\x03\x12\x04\xc5\x20\"#\n-\
    \n\x05\x04\x9e\x01\x02\x01\x12\x04\xc8\x20\x02\x1f\x1a\x1e\x20Required:\
    \x20resource\x20to\x20select\n\n\x0e\n\x06\x04\x9e\x01\x02\x01\x04\x12\
    \x04\xc8\x20\x02\n\n\x0e\n\x06\x04\x9e\x01\x02\x01\x05\x12\x04\xc8\x20\
    \x0b\x11\n\x0e\n\x06\x04\x9e\x01\x02\x01\x01\x12\x04\xc8\x20\x12\x1a\n\
    \x0e\n\x06\x04\x9e\x01\x02\x01\x03\x12\x04\xc8\x20\x1d\x1e\na\n\x05\x04\
    \x9e\x01\x02\x02\x12\x04\xcc\x20\x02E\x1aR\x20Specifies\x20the\x20output\
    \x20format\x20of\x20the\x20exposed\x20resources,\x20defaults\x20to\x20\"\
    1\"\n\x20+optional\n\n\x0e\n\x06\x04\x9e\x01\x02\x02\x04\x12\x04\xcc\x20\
    \x02\n\n\x0e\n\x06\x04\x9e\x01\x02\x02\x06\x12\x04\xcc\x20\x0b8\n\x0e\n\
    \x06\x04\x9e\x01\x02\x02\x01\x12\x04\xcc\x209@\n\x0e\n\x06\x04\x9e\x01\
    \x02\x02\x03\x12\x04\xcc\x20CD\nW\n\x03\x04\x9f\x01\x12\x06\xd0\x20\0\
    \xdf\x20\x01\x1aH\x20ResourceQuota\x20sets\x20aggregate\x20quota\x20rest\
    rictions\x20enforced\x20per\x20namespace\n\n\x0c\n\x04\x04\x9f\x01\x01\
    \x12\x04\xd0\x20\x08\x15\n\xa1\x01\n\x05\x04\x9f\x01\x02\0\x12\x04\xd4\
    \x20\x02H\x1a\x91\x01\x20Standard\x20object's\x20metadata.\n\x20More\x20\
    info:\x20https://git.k8s.io/community/contributors/devel/sig-architectur\
    e/api-conventions.md#metadata\n\x20+optional\n\n\x0e\n\x06\x04\x9f\x01\
    \x02\0\x04\x12\x04\xd4\x20\x02\n\n\x0e\n\x06\x04\x9f\x01\x02\0\x06\x12\
    \x04\xd4\x20\x0b:\n\x0e\n\x06\x04\x9f\x01\x02\0\x01\x12\x04\xd4\x20;C\n\
    \x0e\n\x06\x04\x9f\x01\x02\0\x03\x12\x04\xd4\x20FG\n\xa1\x01\n\x05\x04\
    \x9f\x01\x02\x01\x12\x04\xd9\x20\x02&\x1a\x91\x01\x20Spec\x20defines\x20\
    the\x20desired\x20quota.\n\x20https://git.k8s.io/community/contributors/\
    devel/sig-architecture/api-conventions.md#spec-and-status\n\x20+optional\
    \n\n\x0e\n\x06\x04\x9f\x01\x02\x01\x04\x12\x04\xd9\x20\x02\n\n\x0e\n\x06\
    \x04\x9f\x01\x02\x01\x06\x12\x04\xd9\x20\x0b\x1c\n\x0e\n\x06\x04\x9f\x01\
    \x02\x01\x01\x12\x04\xd9\x20\x1d!\n\x0e\n\x06\x04\x9f\x01\x02\x01\x03\
    \x12\x04\xd9\x20$%\n\xc1\x01\n\x05\x04\x9f\x01\x02\x02\x12\x04\xde\x20\
    \x02*\x1a\xb1\x01\x20Status\x20defines\x20the\x20actual\x20enforced\x20q\
    uota\x20and\x20its\x20current\x20usage.\n\x20https://git.k8s.io/communit\
    y/contributors/devel/sig-architecture/api-conventions.md#spec-and-status\
    \n\x20+optional\n\n\x0e\n\x06\x04\x9f\x01\x02\x02\x04\x12\x04\xde\x20\
    \x02\n\n\x0e\n\x06\x04\x9f\x01\x02\x02\x06\x12\x04\xde\x20\x0b\x1e\n\x0e\
    \n\x06\x04\x9f\x01\x02\x02\x01\x12\x04\xde\x20\x1f%\n\x0e\n\x06\x04\x9f\
    \x01\x02\x02\x03\x12\x04\xde\x20()\nD\n\x03\x04\xa0\x01\x12\x06\xe2\x20\
    \0\xeb\x20\x01\x1a5\x20ResourceQuotaList\x20is\x20a\x20list\x20of\x20Res\
    ourceQuota\x20items.\n\n\x0c\n\x04\x04\xa0\x01\x01\x12\x04\xe2\x20\x08\
    \x19\n\xa0\x01\n\x05\x04\xa0\x01\x02\0\x12\x04\xe6\x20\x02F\x1a\x90\x01\
    \x20Standard\x20list\x20metadata.\n\x20More\x20info:\x20https://git.k8s.\
    io/community/contributors/devel/sig-architecture/api-conventions.md#type\
    s-kinds\n\x20+optional\n\n\x0e\n\x06\x04\xa0\x01\x02\0\x04\x12\x04\xe6\
    \x20\x02\n\n\x0e\n\x06\x04\xa0\x01\x02\0\x06\x12\x04\xe6\x20\x0b8\n\x0e\
    \n\x06\x04\xa0\x01\x02\0\x01\x12\x04\xe6\x209A\n\x0e\n\x06\x04\xa0\x01\
    \x02\0\x03\x12\x04\xe6\x20DE\n\x82\x01\n\x05\x04\xa0\x01\x02\x01\x12\x04\
    \xea\x20\x02#\x1as\x20Items\x20is\x20a\x20list\x20of\x20ResourceQuota\
    \x20objects.\n\x20More\x20info:\x20https://kubernetes.io/docs/concepts/p\
    olicy/resource-quotas/\n\n\x0e\n\x06\x04\xa0\x01\x02\x01\x04\x12\x04\xea\
    \x20\x02\n\n\x0e\n\x06\x04\xa0\x01\x02\x01\x06\x12\x04\xea\x20\x0b\x18\n\
    \x0e\n\x06\x04\xa0\x01\x02\x01\x01\x12\x04\xea\x20\x19\x1e\n\x0e\n\x06\
    \x04\xa0\x01\x02\x01\x03\x12\x04\xea\x20!\"\nX\n\x03\x04\xa1\x01\x12\x06\
    \xee\x20\0\xfe\x20\x01\x1aI\x20ResourceQuotaSpec\x20defines\x20the\x20de\
    sired\x20hard\x20limits\x20to\x20enforce\x20for\x20Quota.\n\n\x0c\n\x04\
    \x04\xa1\x01\x01\x12\x04\xee\x20\x08\x19\n\xa4\x01\n\x05\x04\xa1\x01\x02\
    \0\x12\x04\xf2\x20\x02F\x1a\x94\x01\x20hard\x20is\x20the\x20set\x20of\
    \x20desired\x20hard\x20limits\x20for\x20each\x20named\x20resource.\n\x20\
    More\x20info:\x20https://kubernetes.io/docs/concepts/policy/resource-quo\
    tas/\n\x20+optional\n\n\x10\n\x06\x04\xa1\x01\x02\0\x04\x12\x06\xf2\x20\
    \x02\xee\x20\x1b\n\x0e\n\x06\x04\xa1\x01\x02\0\x06\x12\x04\xf2\x20\x02<\
    \n\x0e\n\x06\x04\xa1\x01\x02\0\x01\x12\x04\xf2\x20=A\n\x0e\n\x06\x04\xa1\
    \x01\x02\0\x03\x12\x04\xf2\x20DE\n\x96\x01\n\x05\x04\xa1\x01\x02\x01\x12\
    \x04\xf7\x20\x02\x1d\x1a\x86\x01\x20A\x20collection\x20of\x20filters\x20\
    that\x20must\x20match\x20each\x20object\x20tracked\x20by\x20a\x20quota.\
    \n\x20If\x20not\x20specified,\x20the\x20quota\x20matches\x20all\x20objec\
    ts.\n\x20+optional\n\n\x0e\n\x06\x04\xa1\x01\x02\x01\x04\x12\x04\xf7\x20\
    \x02\n\n\x0e\n\x06\x04\xa1\x01\x02\x01\x05\x12\x04\xf7\x20\x0b\x11\n\x0e\
    \n\x06\x04\xa1\x01\x02\x01\x01\x12\x04\xf7\x20\x12\x18\n\x0e\n\x06\x04\
    \xa1\x01\x02\x01\x03\x12\x04\xf7\x20\x1b\x1c\n\xb6\x02\n\x05\x04\xa1\x01\
    \x02\x02\x12\x04\xfd\x20\x02+\x1a\xa6\x02\x20scopeSelector\x20is\x20also\
    \x20a\x20collection\x20of\x20filters\x20like\x20scopes\x20that\x20must\
    \x20match\x20each\x20object\x20tracked\x20by\x20a\x20quota\n\x20but\x20e\
    xpressed\x20using\x20ScopeSelectorOperator\x20in\x20combination\x20with\
    \x20possible\x20values.\n\x20For\x20a\x20resource\x20to\x20match,\x20bot\
    h\x20scopes\x20AND\x20scopeSelector\x20(if\x20specified\x20in\x20spec),\
    \x20must\x20be\x20matched.\n\x20+optional\n\n\x0e\n\x06\x04\xa1\x01\x02\
    \x02\x04\x12\x04\xfd\x20\x02\n\n\x0e\n\x06\x04\xa1\x01\x02\x02\x06\x12\
    \x04\xfd\x20\x0b\x18\n\x0e\n\x06\x04\xa1\x01\x02\x02\x01\x12\x04\xfd\x20\
    \x19&\n\x0e\n\x06\x04\xa1\x01\x02\x02\x03\x12\x04\xfd\x20)*\nW\n\x03\x04\
    \xa2\x01\x12\x06\x81!\0\x8a!\x01\x1aH\x20ResourceQuotaStatus\x20defines\
    \x20the\x20enforced\x20hard\x20limits\x20and\x20observed\x20use.\n\n\x0c\
    \n\x04\x04\xa2\x01\x01\x12\x04\x81!\x08\x1b\n\xa5\x01\n\x05\x04\xa2\x01\
    \x02\0\x12\x04\x85!\x02F\x1a\x95\x01\x20Hard\x20is\x20the\x20set\x20of\
    \x20enforced\x20hard\x20limits\x20for\x20each\x20named\x20resource.\n\
    \x20More\x20info:\x20https://kubernetes.io/docs/concepts/policy/resource\
    -quotas/\n\x20+optional\n\n\x10\n\x06\x04\xa2\x01\x02\0\x04\x12\x06\x85!\
    \x02\x81!\x1d\n\x0e\n\x06\x04\xa2\x01\x02\0\x06\x12\x04\x85!\x02<\n\x0e\
    \n\x06\x04\xa2\x01\x02\0\x01\x12\x04\x85!=A\n\x0e\n\x06\x04\xa2\x01\x02\
    \0\x03\x12\x04\x85!DE\nf\n\x05\x04\xa2\x01\x02\x01\x12\x04\x89!\x02F\x1a\
    W\x20Used\x20is\x20the\x20current\x20observed\x20total\x20usage\x20of\
    \x20the\x20resource\x20in\x20the\x20namespace.\n\x20+optional\n\n\x10\n\
    \x06\x04\xa2\x01\x02\x01\x04\x12\x06\x89!\x02\x85!F\n\x0e\n\x06\x04\xa2\
    \x01\x02\x01\x06\x12\x04\x89!\x02<\n\x0e\n\x06\x04\xa2\x01\x02\x01\x01\
    \x12\x04\x89!=A\n\x0e\n\x06\x04\xa2\x01\x02\x01\x03\x12\x04\x89!DE\nR\n\
    \x03\x04\xa3\x01\x12\x06\x8d!\0\x99!\x01\x1aC\x20ResourceRequirements\
    \x20describes\x20the\x20compute\x20resource\x20requirements.\n\n\x0c\n\
    \x04\x04\xa3\x01\x01\x12\x04\x8d!\x08\x1c\n\xc0\x01\n\x05\x04\xa3\x01\
    \x02\0\x12\x04\x91!\x02H\x1a\xb0\x01\x20Limits\x20describes\x20the\x20ma\
    ximum\x20amount\x20of\x20compute\x20resources\x20allowed.\n\x20More\x20i\
    nfo:\x20https://kubernetes.io/docs/concepts/configuration/manage-compute\
    -resources-container/\n\x20+optional\n\n\x10\n\x06\x04\xa3\x01\x02\0\x04\
    \x12\x06\x91!\x02\x8d!\x1e\n\x0e\n\x06\x04\xa3\x01\x02\0\x06\x12\x04\x91\
    !\x02<\n\x0e\n\x06\x04\xa3\x01\x02\0\x01\x12\x04\x91!=C\n\x0e\n\x06\x04\
    \xa3\x01\x02\0\x03\x12\x04\x91!FG\n\xd2\x02\n\x05\x04\xa3\x01\x02\x01\
    \x12\x04\x98!\x02J\x1a\xc2\x02\x20Requests\x20describes\x20the\x20minimu\
    m\x20amount\x20of\x20compute\x20resources\x20required.\n\x20If\x20Reques\
    ts\x20is\x20omitted\x20for\x20a\x20container,\x20it\x20defaults\x20to\
    \x20Limits\x20if\x20that\x20is\x20explicitly\x20specified,\n\x20otherwis\
    e\x20to\x20an\x20implementation-defined\x20value.\n\x20More\x20info:\x20\
    https://kubernetes.io/docs/concepts/configuration/manage-compute-resourc\
    es-container/\n\x20+optional\n\n\x10\n\x06\x04\xa3\x01\x02\x01\x04\x12\
    \x06\x98!\x02\x91!H\n\x0e\n\x06\x04\xa3\x01\x02\x01\x06\x12\x04\x98!\x02\
    <\n\x0e\n\x06\x04\xa3\x01\x02\x01\x01\x12\x04\x98!=E\n\x0e\n\x06\x04\xa3\
    \x01\x02\x01\x03\x12\x04\x98!HI\nM\n\x03\x04\xa4\x01\x12\x06\x9c!\0\xac!\
    \x01\x1a>\x20SELinuxOptions\x20are\x20the\x20labels\x20to\x20be\x20appli\
    ed\x20to\x20the\x20container\n\n\x0c\n\x04\x04\xa4\x01\x01\x12\x04\x9c!\
    \x08\x16\nW\n\x05\x04\xa4\x01\x02\0\x12\x04\x9f!\x02\x1b\x1aH\x20User\
    \x20is\x20a\x20SELinux\x20user\x20label\x20that\x20applies\x20to\x20the\
    \x20container.\n\x20+optional\n\n\x0e\n\x06\x04\xa4\x01\x02\0\x04\x12\
    \x04\x9f!\x02\n\n\x0e\n\x06\x04\xa4\x01\x02\0\x05\x12\x04\x9f!\x0b\x11\n\
    \x0e\n\x06\x04\xa4\x01\x02\0\x01\x12\x04\x9f!\x12\x16\n\x0e\n\x06\x04\
    \xa4\x01\x02\0\x03\x12\x04\x9f!\x19\x1a\nW\n\x05\x04\xa4\x01\x02\x01\x12\
    \x04\xa3!\x02\x1b\x1aH\x20Role\x20is\x20a\x20SELinux\x20role\x20label\
    \x20that\x20applies\x20to\x20the\x20container.\n\x20+optional\n\n\x0e\n\
    \x06\x04\xa4\x01\x02\x01\x04\x12\x04\xa3!\x02\n\n\x0e\n\x06\x04\xa4\x01\
    \x02\x01\x05\x12\x04\xa3!\x0b\x11\n\x0e\n\x06\x04\xa4\x01\x02\x01\x01\
    \x12\x04\xa3!\x12\x16\n\x0e\n\x06\x04\xa4\x01\x02\x01\x03\x12\x04\xa3!\
    \x19\x1a\nW\n\x05\x04\xa4\x01\x02\x02\x12\x04\xa7!\x02\x1b\x1aH\x20Type\
    \x20is\x20a\x20SELinux\x20type\x20label\x20that\x20applies\x20to\x20the\
    \x20container.\n\x20+optional\n\n\x0e\n\x06\x04\xa4\x01\x02\x02\x04\x12\
    \x04\xa7!\x02\n\n\x0e\n\x06\x04\xa4\x01\x02\x02\x05\x12\x04\xa7!\x0b\x11\
    \n\x0e\n\x06\x04\xa4\x01\x02\x02\x01\x12\x04\xa7!\x12\x16\n\x0e\n\x06\
    \x04\xa4\x01\x02\x02\x03\x12\x04\xa7!\x19\x1a\nW\n\x05\x04\xa4\x01\x02\
    \x03\x12\x04\xab!\x02\x1c\x1aH\x20Level\x20is\x20SELinux\x20level\x20lab\
    el\x20that\x20applies\x20to\x20the\x20container.\n\x20+optional\n\n\x0e\
    \n\x06\x04\xa4\x01\x02\x03\x04\x12\x04\xab!\x02\n\n\x0e\n\x06\x04\xa4\
    \x01\x02\x03\x05\x12\x04\xab!\x0b\x11\n\x0e\n\x06\x04\xa4\x01\x02\x03\
    \x01\x12\x04\xab!\x12\x17\n\x0e\n\x06\x04\xa4\x01\x02\x03\x03\x12\x04\
    \xab!\x1a\x1b\nU\n\x03\x04\xa5\x01\x12\x06\xaf!\0\xda!\x01\x1aF\x20Scale\
    IOPersistentVolumeSource\x20represents\x20a\x20persistent\x20ScaleIO\x20\
    volume\n\n\x0c\n\x04\x04\xa5\x01\x01\x12\x04\xaf!\x08%\n=\n\x05\x04\xa5\
    \x01\x02\0\x12\x04\xb1!\x02\x1e\x1a.\x20The\x20host\x20address\x20of\x20\
    the\x20ScaleIO\x20API\x20Gateway.\n\n\x0e\n\x06\x04\xa5\x01\x02\0\x04\
    \x12\x04\xb1!\x02\n\n\x0e\n\x06\x04\xa5\x01\x02\0\x05\x12\x04\xb1!\x0b\
    \x11\n\x0e\n\x06\x04\xa5\x01\x02\0\x01\x12\x04\xb1!\x12\x19\n\x0e\n\x06\
    \x04\xa5\x01\x02\0\x03\x12\x04\xb1!\x1c\x1d\nI\n\x05\x04\xa5\x01\x02\x01\
    \x12\x04\xb4!\x02\x1d\x1a:\x20The\x20name\x20of\x20the\x20storage\x20sys\
    tem\x20as\x20configured\x20in\x20ScaleIO.\n\n\x0e\n\x06\x04\xa5\x01\x02\
    \x01\x04\x12\x04\xb4!\x02\n\n\x0e\n\x06\x04\xa5\x01\x02\x01\x05\x12\x04\
    \xb4!\x0b\x11\n\x0e\n\x06\x04\xa5\x01\x02\x01\x01\x12\x04\xb4!\x12\x18\n\
    \x0e\n\x06\x04\xa5\x01\x02\x01\x03\x12\x04\xb4!\x1b\x1c\n\x9b\x01\n\x05\
    \x04\xa5\x01\x02\x02\x12\x04\xb8!\x02)\x1a\x8b\x01\x20SecretRef\x20refer\
    ences\x20to\x20the\x20secret\x20for\x20ScaleIO\x20user\x20and\x20other\n\
    \x20sensitive\x20information.\x20If\x20this\x20is\x20not\x20provided,\
    \x20Login\x20operation\x20will\x20fail.\n\n\x0e\n\x06\x04\xa5\x01\x02\
    \x02\x04\x12\x04\xb8!\x02\n\n\x0e\n\x06\x04\xa5\x01\x02\x02\x06\x12\x04\
    \xb8!\x0b\x1a\n\x0e\n\x06\x04\xa5\x01\x02\x02\x01\x12\x04\xb8!\x1b$\n\
    \x0e\n\x06\x04\xa5\x01\x02\x02\x03\x12\x04\xb8!'(\n`\n\x05\x04\xa5\x01\
    \x02\x03\x12\x04\xbc!\x02\x1f\x1aQ\x20Flag\x20to\x20enable/disable\x20SS\
    L\x20communication\x20with\x20Gateway,\x20default\x20false\n\x20+optiona\
    l\n\n\x0e\n\x06\x04\xa5\x01\x02\x03\x04\x12\x04\xbc!\x02\n\n\x0e\n\x06\
    \x04\xa5\x01\x02\x03\x05\x12\x04\xbc!\x0b\x0f\n\x0e\n\x06\x04\xa5\x01\
    \x02\x03\x01\x12\x04\xbc!\x10\x1a\n\x0e\n\x06\x04\xa5\x01\x02\x03\x03\
    \x12\x04\xbc!\x1d\x1e\na\n\x05\x04\xa5\x01\x02\x04\x12\x04\xc0!\x02'\x1a\
    R\x20The\x20name\x20of\x20the\x20ScaleIO\x20Protection\x20Domain\x20for\
    \x20the\x20configured\x20storage.\n\x20+optional\n\n\x0e\n\x06\x04\xa5\
    \x01\x02\x04\x04\x12\x04\xc0!\x02\n\n\x0e\n\x06\x04\xa5\x01\x02\x04\x05\
    \x12\x04\xc0!\x0b\x11\n\x0e\n\x06\x04\xa5\x01\x02\x04\x01\x12\x04\xc0!\
    \x12\"\n\x0e\n\x06\x04\xa5\x01\x02\x04\x03\x12\x04\xc0!%&\n[\n\x05\x04\
    \xa5\x01\x02\x05\x12\x04\xc4!\x02\"\x1aL\x20The\x20ScaleIO\x20Storage\
    \x20Pool\x20associated\x20with\x20the\x20protection\x20domain.\n\x20+opt\
    ional\n\n\x0e\n\x06\x04\xa5\x01\x02\x05\x04\x12\x04\xc4!\x02\n\n\x0e\n\
    \x06\x04\xa5\x01\x02\x05\x05\x12\x04\xc4!\x0b\x11\n\x0e\n\x06\x04\xa5\
    \x01\x02\x05\x01\x12\x04\xc4!\x12\x1d\n\x0e\n\x06\x04\xa5\x01\x02\x05\
    \x03\x12\x04\xc4!\x20!\n\x93\x01\n\x05\x04\xa5\x01\x02\x06\x12\x04\xc9!\
    \x02\"\x1a\x83\x01\x20Indicates\x20whether\x20the\x20storage\x20for\x20a\
    \x20volume\x20should\x20be\x20ThickProvisioned\x20or\x20ThinProvisioned.\
    \n\x20Default\x20is\x20ThinProvisioned.\n\x20+optional\n\n\x0e\n\x06\x04\
    \xa5\x01\x02\x06\x04\x12\x04\xc9!\x02\n\n\x0e\n\x06\x04\xa5\x01\x02\x06\
    \x05\x12\x04\xc9!\x0b\x11\n\x0e\n\x06\x04\xa5\x01\x02\x06\x01\x12\x04\
    \xc9!\x12\x1d\n\x0e\n\x06\x04\xa5\x01\x02\x06\x03\x12\x04\xc9!\x20!\nx\n\
    \x05\x04\xa5\x01\x02\x07\x12\x04\xcd!\x02!\x1ai\x20The\x20name\x20of\x20\
    a\x20volume\x20already\x20created\x20in\x20the\x20ScaleIO\x20system\n\
    \x20that\x20is\x20associated\x20with\x20this\x20volume\x20source.\n\n\
    \x0e\n\x06\x04\xa5\x01\x02\x07\x04\x12\x04\xcd!\x02\n\n\x0e\n\x06\x04\
    \xa5\x01\x02\x07\x05\x12\x04\xcd!\x0b\x11\n\x0e\n\x06\x04\xa5\x01\x02\
    \x07\x01\x12\x04\xcd!\x12\x1c\n\x0e\n\x06\x04\xa5\x01\x02\x07\x03\x12\
    \x04\xcd!\x1f\x20\n\xa7\x01\n\x05\x04\xa5\x01\x02\x08\x12\x04\xd4!\x02\
    \x1d\x1a\x97\x01\x20Filesystem\x20type\x20to\x20mount.\n\x20Must\x20be\
    \x20a\x20filesystem\x20type\x20supported\x20by\x20the\x20host\x20operati\
    ng\x20system.\n\x20Ex.\x20\"ext4\",\x20\"xfs\",\x20\"ntfs\".\n\x20Defaul\
    t\x20is\x20\"xfs\"\n\x20+optional\n\n\x0e\n\x06\x04\xa5\x01\x02\x08\x04\
    \x12\x04\xd4!\x02\n\n\x0e\n\x06\x04\xa5\x01\x02\x08\x05\x12\x04\xd4!\x0b\
    \x11\n\x0e\n\x06\x04\xa5\x01\x02\x08\x01\x12\x04\xd4!\x12\x18\n\x0e\n\
    \x06\x04\xa5\x01\x02\x08\x03\x12\x04\xd4!\x1b\x1c\n{\n\x05\x04\xa5\x01\
    \x02\t\x12\x04\xd9!\x02\x1e\x1al\x20Defaults\x20to\x20false\x20(read/wri\
    te).\x20ReadOnly\x20here\x20will\x20force\n\x20the\x20ReadOnly\x20settin\
    g\x20in\x20VolumeMounts.\n\x20+optional\n\n\x0e\n\x06\x04\xa5\x01\x02\t\
    \x04\x12\x04\xd9!\x02\n\n\x0e\n\x06\x04\xa5\x01\x02\t\x05\x12\x04\xd9!\
    \x0b\x0f\n\x0e\n\x06\x04\xa5\x01\x02\t\x01\x12\x04\xd9!\x10\x18\n\x0e\n\
    \x06\x04\xa5\x01\x02\t\x03\x12\x04\xd9!\x1b\x1d\nK\n\x03\x04\xa6\x01\x12\
    \x06\xdd!\0\x88\"\x01\x1a<\x20ScaleIOVolumeSource\x20represents\x20a\x20\
    persistent\x20ScaleIO\x20volume\n\n\x0c\n\x04\x04\xa6\x01\x01\x12\x04\
    \xdd!\x08\x1b\n=\n\x05\x04\xa6\x01\x02\0\x12\x04\xdf!\x02\x1e\x1a.\x20Th\
    e\x20host\x20address\x20of\x20the\x20ScaleIO\x20API\x20Gateway.\n\n\x0e\
    \n\x06\x04\xa6\x01\x02\0\x04\x12\x04\xdf!\x02\n\n\x0e\n\x06\x04\xa6\x01\
    \x02\0\x05\x12\x04\xdf!\x0b\x11\n\x0e\n\x06\x04\xa6\x01\x02\0\x01\x12\
    \x04\xdf!\x12\x19\n\x0e\n\x06\x04\xa6\x01\x02\0\x03\x12\x04\xdf!\x1c\x1d\
    \nI\n\x05\x04\xa6\x01\x02\x01\x12\x04\xe2!\x02\x1d\x1a:\x20The\x20name\
    \x20of\x20the\x20storage\x20system\x20as\x20configured\x20in\x20ScaleIO.\
    \n\n\x0e\n\x06\x04\xa6\x01\x02\x01\x04\x12\x04\xe2!\x02\n\n\x0e\n\x06\
    \x04\xa6\x01\x02\x01\x05\x12\x04\xe2!\x0b\x11\n\x0e\n\x06\x04\xa6\x01\
    \x02\x01\x01\x12\x04\xe2!\x12\x18\n\x0e\n\x06\x04\xa6\x01\x02\x01\x03\
    \x12\x04\xe2!\x1b\x1c\n\x9b\x01\n\x05\x04\xa6\x01\x02\x02\x12\x04\xe6!\
    \x02.\x1a\x8b\x01\x20SecretRef\x20references\x20to\x20the\x20secret\x20f\
    or\x20ScaleIO\x20user\x20and\x20other\n\x20sensitive\x20information.\x20\
    If\x20this\x20is\x20not\x20provided,\x20Login\x20operation\x20will\x20fa\
    il.\n\n\x0e\n\x06\x04\xa6\x01\x02\x02\x04\x12\x04\xe6!\x02\n\n\x0e\n\x06\
    \x04\xa6\x01\x02\x02\x06\x12\x04\xe6!\x0b\x1f\n\x0e\n\x06\x04\xa6\x01\
    \x02\x02\x01\x12\x04\xe6!\x20)\n\x0e\n\x06\x04\xa6\x01\x02\x02\x03\x12\
    \x04\xe6!,-\n`\n\x05\x04\xa6\x01\x02\x03\x12\x04\xea!\x02\x1f\x1aQ\x20Fl\
    ag\x20to\x20enable/disable\x20SSL\x20communication\x20with\x20Gateway,\
    \x20default\x20false\n\x20+optional\n\n\x0e\n\x06\x04\xa6\x01\x02\x03\
    \x04\x12\x04\xea!\x02\n\n\x0e\n\x06\x04\xa6\x01\x02\x03\x05\x12\x04\xea!\
    \x0b\x0f\n\x0e\n\x06\x04\xa6\x01\x02\x03\x01\x12\x04\xea!\x10\x1a\n\x0e\
    \n\x06\x04\xa6\x01\x02\x03\x03\x12\x04\xea!\x1d\x1e\na\n\x05\x04\xa6\x01\
    \x02\x04\x12\x04\xee!\x02'\x1aR\x20The\x20name\x20of\x20the\x20ScaleIO\
    \x20Protection\x20Domain\x20for\x20the\x20configured\x20storage.\n\x20+o\
    ptional\n\n\x0e\n\x06\x04\xa6\x01\x02\x04\x04\x12\x04\xee!\x02\n\n\x0e\n\
    \x06\x04\xa6\x01\x02\x04\x05\x12\x04\xee!\x0b\x11\n\x0e\n\x06\x04\xa6\
    \x01\x02\x04\x01\x12\x04\xee!\x12\"\n\x0e\n\x06\x04\xa6\x01\x02\x04\x03\
    \x12\x04\xee!%&\n[\n\x05\x04\xa6\x01\x02\x05\x12\x04\xf2!\x02\"\x1aL\x20\
    The\x20ScaleIO\x20Storage\x20Pool\x20associated\x20with\x20the\x20protec\
    tion\x20domain.\n\x20+optional\n\n\x0e\n\x06\x04\xa6\x01\x02\x05\x04\x12\
    \x04\xf2!\x02\n\n\x0e\n\x06\x04\xa6\x01\x02\x05\x05\x12\x04\xf2!\x0b\x11\
    \n\x0e\n\x06\x04\xa6\x01\x02\x05\x01\x12\x04\xf2!\x12\x1d\n\x0e\n\x06\
    \x04\xa6\x01\x02\x05\x03\x12\x04\xf2!\x20!\n\x93\x01\n\x05\x04\xa6\x01\
    \x02\x06\x12\x04\xf7!\x02\"\x1a\x83\x01\x20Indicates\x20whether\x20the\
    \x20storage\x20for\x20a\x20volume\x20should\x20be\x20ThickProvisioned\
    \x20or\x20ThinProvisioned.\n\x20Default\x20is\x20ThinProvisioned.\n\x20+\
    optional\n\n\x0e\n\x06\x04\xa6\x01\x02\x06\x04\x12\x04\xf7!\x02\n\n\x0e\
    \n\x06\x04\xa6\x01\x02\x06\x05\x12\x04\xf7!\x0b\x11\n\x0e\n\x06\x04\xa6\
    \x01\x02\x06\x01\x12\x04\xf7!\x12\x1d\n\x0e\n\x06\x04\xa6\x01\x02\x06\
    \x03\x12\x04\xf7!\x20!\nx\n\x05\x04\xa6\x01\x02\x07\x12\x04\xfb!\x02!\
    \x1ai\x20The\x20name\x20of\x20a\x20volume\x20already\x20created\x20in\
    \x20the\x20ScaleIO\x20system\n\x20that\x20is\x20associated\x20with\x20th\
    is\x20volume\x20source.\n\n\x0e\n\x06\x04\xa6\x01\x02\x07\x04\x12\x04\
    \xfb!\x02\n\n\x0e\n\x06\x04\xa6\x01\x02\x07\x05\x12\x04\xfb!\x0b\x11\n\
    \x0e\n\x06\x04\xa6\x01\x02\x07\x01\x12\x04\xfb!\x12\x1c\n\x0e\n\x06\x04\
    \xa6\x01\x02\x07\x03\x12\x04\xfb!\x1f\x20\n\xa8\x01\n\x05\x04\xa6\x01\
    \x02\x08\x12\x04\x82\"\x02\x1d\x1a\x98\x01\x20Filesystem\x20type\x20to\
    \x20mount.\n\x20Must\x20be\x20a\x20filesystem\x20type\x20supported\x20by\
    \x20the\x20host\x20operating\x20system.\n\x20Ex.\x20\"ext4\",\x20\"xfs\"\
    ,\x20\"ntfs\".\n\x20Default\x20is\x20\"xfs\".\n\x20+optional\n\n\x0e\n\
    \x06\x04\xa6\x01\x02\x08\x04\x12\x04\x82\"\x02\n\n\x0e\n\x06\x04\xa6\x01\
    \x02\x08\x05\x12\x04\x82\"\x0b\x11\n\x0e\n\x06\x04\xa6\x01\x02\x08\x01\
    \x12\x04\x82\"\x12\x18\n\x0e\n\x06\x04\xa6\x01\x02\x08\x03\x12\x04\x82\"\
    \x1b\x1c\n{\n\x05\x04\xa6\x01\x02\t\x12\x04\x87\"\x02\x1e\x1al\x20Defaul\
    ts\x20to\x20false\x20(read/write).\x20ReadOnly\x20here\x20will\x20force\
    \n\x20the\x20ReadOnly\x20setting\x20in\x20VolumeMounts.\n\x20+optional\n\
    \n\x0e\n\x06\x04\xa6\x01\x02\t\x04\x12\x04\x87\"\x02\n\n\x0e\n\x06\x04\
    \xa6\x01\x02\t\x05\x12\x04\x87\"\x0b\x0f\n\x0e\n\x06\x04\xa6\x01\x02\t\
    \x01\x12\x04\x87\"\x10\x18\n\x0e\n\x06\x04\xa6\x01\x02\t\x03\x12\x04\x87\
    \"\x1b\x1d\n\x80\x01\n\x03\x04\xa7\x01\x12\x06\x8c\"\0\x90\"\x01\x1aq\
    \x20A\x20scope\x20selector\x20represents\x20the\x20AND\x20of\x20the\x20s\
    electors\x20represented\n\x20by\x20the\x20scoped-resource\x20selector\
    \x20requirements.\n\n\x0c\n\x04\x04\xa7\x01\x01\x12\x04\x8c\"\x08\x15\n\
    \\\n\x05\x04\xa7\x01\x02\0\x12\x04\x8f\"\x02B\x1aM\x20A\x20list\x20of\
    \x20scope\x20selector\x20requirements\x20by\x20scope\x20of\x20the\x20res\
    ources.\n\x20+optional\n\n\x0e\n\x06\x04\xa7\x01\x02\0\x04\x12\x04\x8f\"\
    \x02\n\n\x0e\n\x06\x04\xa7\x01\x02\0\x06\x12\x04\x8f\"\x0b,\n\x0e\n\x06\
    \x04\xa7\x01\x02\0\x01\x12\x04\x8f\"-=\n\x0e\n\x06\x04\xa7\x01\x02\0\x03\
    \x12\x04\x8f\"@A\n\xa3\x01\n\x03\x04\xa8\x01\x12\x06\x94\"\0\xa2\"\x01\
    \x1a\x93\x01\x20A\x20scoped-resource\x20selector\x20requirement\x20is\
    \x20a\x20selector\x20that\x20contains\x20values,\x20a\x20scope\x20name,\
    \x20and\x20an\x20operator\n\x20that\x20relates\x20the\x20scope\x20name\
    \x20and\x20values.\n\n\x0c\n\x04\x04\xa8\x01\x01\x12\x04\x94\"\x08)\nD\n\
    \x05\x04\xa8\x01\x02\0\x12\x04\x96\"\x02\x20\x1a5\x20The\x20name\x20of\
    \x20the\x20scope\x20that\x20the\x20selector\x20applies\x20to.\n\n\x0e\n\
    \x06\x04\xa8\x01\x02\0\x04\x12\x04\x96\"\x02\n\n\x0e\n\x06\x04\xa8\x01\
    \x02\0\x05\x12\x04\x96\"\x0b\x11\n\x0e\n\x06\x04\xa8\x01\x02\0\x01\x12\
    \x04\x96\"\x12\x1b\n\x0e\n\x06\x04\xa8\x01\x02\0\x03\x12\x04\x96\"\x1e\
    \x1f\n|\n\x05\x04\xa8\x01\x02\x01\x12\x04\x9a\"\x02\x1f\x1am\x20Represen\
    ts\x20a\x20scope's\x20relationship\x20to\x20a\x20set\x20of\x20values.\n\
    \x20Valid\x20operators\x20are\x20In,\x20NotIn,\x20Exists,\x20DoesNotExis\
    t.\n\n\x0e\n\x06\x04\xa8\x01\x02\x01\x04\x12\x04\x9a\"\x02\n\n\x0e\n\x06\
    \x04\xa8\x01\x02\x01\x05\x12\x04\x9a\"\x0b\x11\n\x0e\n\x06\x04\xa8\x01\
    \x02\x01\x01\x12\x04\x9a\"\x12\x1a\n\x0e\n\x06\x04\xa8\x01\x02\x01\x03\
    \x12\x04\x9a\"\x1d\x1e\n\x80\x02\n\x05\x04\xa8\x01\x02\x02\x12\x04\xa1\"\
    \x02\x1d\x1a\xf0\x01\x20An\x20array\x20of\x20string\x20values.\x20If\x20\
    the\x20operator\x20is\x20In\x20or\x20NotIn,\n\x20the\x20values\x20array\
    \x20must\x20be\x20non-empty.\x20If\x20the\x20operator\x20is\x20Exists\
    \x20or\x20DoesNotExist,\n\x20the\x20values\x20array\x20must\x20be\x20emp\
    ty.\n\x20This\x20array\x20is\x20replaced\x20during\x20a\x20strategic\x20\
    merge\x20patch.\n\x20+optional\n\n\x0e\n\x06\x04\xa8\x01\x02\x02\x04\x12\
    \x04\xa1\"\x02\n\n\x0e\n\x06\x04\xa8\x01\x02\x02\x05\x12\x04\xa1\"\x0b\
    \x11\n\x0e\n\x06\x04\xa8\x01\x02\x02\x01\x12\x04\xa1\"\x12\x18\n\x0e\n\
    \x06\x04\xa8\x01\x02\x02\x03\x12\x04\xa1\"\x1b\x1c\n\x80\x01\n\x03\x04\
    \xa9\x01\x12\x06\xa7\"\0\xb7\"\x01\x1aq\x20SeccompProfile\x20defines\x20\
    a\x20pod/container's\x20seccomp\x20profile\x20settings.\n\x20Only\x20one\
    \x20profile\x20source\x20may\x20be\x20set.\n\x20+union\n\n\x0c\n\x04\x04\
    \xa9\x01\x01\x12\x04\xa7\"\x08\x16\n\xb2\x02\n\x05\x04\xa9\x01\x02\0\x12\
    \x04\xaf\"\x02\x1b\x1a\xa2\x02\x20type\x20indicates\x20which\x20kind\x20\
    of\x20seccomp\x20profile\x20will\x20be\x20applied.\n\x20Valid\x20options\
    \x20are:\n\n\x20Localhost\x20-\x20a\x20profile\x20defined\x20in\x20a\x20\
    file\x20on\x20the\x20node\x20should\x20be\x20used.\n\x20RuntimeDefault\
    \x20-\x20the\x20container\x20runtime\x20default\x20profile\x20should\x20\
    be\x20used.\n\x20Unconfined\x20-\x20no\x20profile\x20should\x20be\x20app\
    lied.\n\x20+unionDiscriminator\n\n\x0e\n\x06\x04\xa9\x01\x02\0\x04\x12\
    \x04\xaf\"\x02\n\n\x0e\n\x06\x04\xa9\x01\x02\0\x05\x12\x04\xaf\"\x0b\x11\
    \n\x0e\n\x06\x04\xa9\x01\x02\0\x01\x12\x04\xaf\"\x12\x16\n\x0e\n\x06\x04\
    \xa9\x01\x02\0\x03\x12\x04\xaf\"\x19\x1a\n\xac\x02\n\x05\x04\xa9\x01\x02\
    \x01\x12\x04\xb6\"\x02'\x1a\x9c\x02\x20localhostProfile\x20indicates\x20\
    a\x20profile\x20defined\x20in\x20a\x20file\x20on\x20the\x20node\x20shoul\
    d\x20be\x20used.\n\x20The\x20profile\x20must\x20be\x20preconfigured\x20o\
    n\x20the\x20node\x20to\x20work.\n\x20Must\x20be\x20a\x20descending\x20pa\
    th,\x20relative\x20to\x20the\x20kubelet's\x20configured\x20seccomp\x20pr\
    ofile\x20location.\n\x20Must\x20only\x20be\x20set\x20if\x20type\x20is\
    \x20\"Localhost\".\n\x20+optional\n\n\x0e\n\x06\x04\xa9\x01\x02\x01\x04\
    \x12\x04\xb6\"\x02\n\n\x0e\n\x06\x04\xa9\x01\x02\x01\x05\x12\x04\xb6\"\
    \x0b\x11\n\x0e\n\x06\x04\xa9\x01\x02\x01\x01\x12\x04\xb6\"\x12\"\n\x0e\n\
    \x06\x04\xa9\x01\x02\x01\x03\x12\x04\xb6\"%&\n\x95\x01\n\x03\x04\xaa\x01\
    \x12\x06\xbb\"\0\xdb\"\x01\x1a\x85\x01\x20Secret\x20holds\x20secret\x20d\
    ata\x20of\x20a\x20certain\x20type.\x20The\x20total\x20bytes\x20of\x20the\
    \x20values\x20in\n\x20the\x20Data\x20field\x20must\x20be\x20less\x20than\
    \x20MaxSecretSize\x20bytes.\n\n\x0c\n\x04\x04\xaa\x01\x01\x12\x04\xbb\"\
    \x08\x0e\n\xa1\x01\n\x05\x04\xaa\x01\x02\0\x12\x04\xbf\"\x02H\x1a\x91\
    \x01\x20Standard\x20object's\x20metadata.\n\x20More\x20info:\x20https://\
    git.k8s.io/community/contributors/devel/sig-architecture/api-conventions\
    .md#metadata\n\x20+optional\n\n\x0e\n\x06\x04\xaa\x01\x02\0\x04\x12\x04\
    \xbf\"\x02\n\n\x0e\n\x06\x04\xaa\x01\x02\0\x06\x12\x04\xbf\"\x0b:\n\x0e\
    \n\x06\x04\xaa\x01\x02\0\x01\x12\x04\xbf\";C\n\x0e\n\x06\x04\xaa\x01\x02\
    \0\x03\x12\x04\xbf\"FG\n\xb1\x02\n\x05\x04\xaa\x01\x02\x01\x12\x04\xc7\"\
    \x02\x1e\x1a\xa1\x02\x20Immutable,\x20if\x20set\x20to\x20true,\x20ensure\
    s\x20that\x20data\x20stored\x20in\x20the\x20Secret\x20cannot\n\x20be\x20\
    updated\x20(only\x20object\x20metadata\x20can\x20be\x20modified).\n\x20I\
    f\x20not\x20set\x20to\x20true,\x20the\x20field\x20can\x20be\x20modified\
    \x20at\x20any\x20time.\n\x20Defaulted\x20to\x20nil.\n\x20This\x20is\x20a\
    \x20beta\x20field\x20enabled\x20by\x20ImmutableEphemeralVolumes\x20featu\
    re\x20gate.\n\x20+optional\n\n\x0e\n\x06\x04\xaa\x01\x02\x01\x04\x12\x04\
    \xc7\"\x02\n\n\x0e\n\x06\x04\xaa\x01\x02\x01\x05\x12\x04\xc7\"\x0b\x0f\n\
    \x0e\n\x06\x04\xaa\x01\x02\x01\x01\x12\x04\xc7\"\x10\x19\n\x0e\n\x06\x04\
    \xaa\x01\x02\x01\x03\x12\x04\xc7\"\x1c\x1d\n\xc1\x02\n\x05\x04\xaa\x01\
    \x02\x02\x12\x04\xce\"\x02\x1e\x1a\xb1\x02\x20Data\x20contains\x20the\
    \x20secret\x20data.\x20Each\x20key\x20must\x20consist\x20of\x20alphanume\
    ric\n\x20characters,\x20'-',\x20'_'\x20or\x20'.'.\x20The\x20serialized\
    \x20form\x20of\x20the\x20secret\x20data\x20is\x20a\n\x20base64\x20encode\
    d\x20string,\x20representing\x20the\x20arbitrary\x20(possibly\x20non-str\
    ing)\n\x20data\x20value\x20here.\x20Described\x20in\x20https://tools.iet\
    f.org/html/rfc4648#section-4\n\x20+optional\n\n\x10\n\x06\x04\xaa\x01\
    \x02\x02\x04\x12\x06\xce\"\x02\xc7\"\x1e\n\x0e\n\x06\x04\xaa\x01\x02\x02\
    \x06\x12\x04\xce\"\x02\x14\n\x0e\n\x06\x04\xaa\x01\x02\x02\x01\x12\x04\
    \xce\"\x15\x19\n\x0e\n\x06\x04\xaa\x01\x02\x02\x03\x12\x04\xce\"\x1c\x1d\
    \n\xbd\x02\n\x05\x04\xaa\x01\x02\x03\x12\x04\xd6\"\x02%\x1a\xad\x02\x20s\
    tringData\x20allows\x20specifying\x20non-binary\x20secret\x20data\x20in\
    \x20string\x20form.\n\x20It\x20is\x20provided\x20as\x20a\x20write-only\
    \x20convenience\x20method.\n\x20All\x20keys\x20and\x20values\x20are\x20m\
    erged\x20into\x20the\x20data\x20field\x20on\x20write,\x20overwriting\x20\
    any\x20existing\x20values.\n\x20It\x20is\x20never\x20output\x20when\x20r\
    eading\x20from\x20the\x20API.\n\x20+k8s:conversion-gen=false\n\x20+optio\
    nal\n\n\x10\n\x06\x04\xaa\x01\x02\x03\x04\x12\x06\xd6\"\x02\xce\"\x1e\n\
    \x0e\n\x06\x04\xaa\x01\x02\x03\x06\x12\x04\xd6\"\x02\x15\n\x0e\n\x06\x04\
    \xaa\x01\x02\x03\x01\x12\x04\xd6\"\x16\x20\n\x0e\n\x06\x04\xaa\x01\x02\
    \x03\x03\x12\x04\xd6\"#$\nT\n\x05\x04\xaa\x01\x02\x04\x12\x04\xda\"\x02\
    \x1b\x1aE\x20Used\x20to\x20facilitate\x20programmatic\x20handling\x20of\
    \x20secret\x20data.\n\x20+optional\n\n\x0e\n\x06\x04\xaa\x01\x02\x04\x04\
    \x12\x04\xda\"\x02\n\n\x0e\n\x06\x04\xaa\x01\x02\x04\x05\x12\x04\xda\"\
    \x0b\x11\n\x0e\n\x06\x04\xaa\x01\x02\x04\x01\x12\x04\xda\"\x12\x16\n\x0e\
    \n\x06\x04\xaa\x01\x02\x04\x03\x12\x04\xda\"\x19\x1a\n\xce\x01\n\x03\x04\
    \xab\x01\x12\x06\xe2\"\0\xe9\"\x01\x1a\xbe\x01\x20SecretEnvSource\x20sel\
    ects\x20a\x20Secret\x20to\x20populate\x20the\x20environment\n\x20variabl\
    es\x20with.\n\n\x20The\x20contents\x20of\x20the\x20target\x20Secret's\
    \x20Data\x20field\x20will\x20represent\x20the\n\x20key-value\x20pairs\
    \x20as\x20environment\x20variables.\n\n\x0c\n\x04\x04\xab\x01\x01\x12\
    \x04\xe2\"\x08\x17\n+\n\x05\x04\xab\x01\x02\0\x12\x04\xe4\"\x029\x1a\x1c\
    \x20The\x20Secret\x20to\x20select\x20from.\n\n\x0e\n\x06\x04\xab\x01\x02\
    \0\x04\x12\x04\xe4\"\x02\n\n\x0e\n\x06\x04\xab\x01\x02\0\x06\x12\x04\xe4\
    \"\x0b\x1f\n\x0e\n\x06\x04\xab\x01\x02\0\x01\x12\x04\xe4\"\x204\n\x0e\n\
    \x06\x04\xab\x01\x02\0\x03\x12\x04\xe4\"78\nF\n\x05\x04\xab\x01\x02\x01\
    \x12\x04\xe8\"\x02\x1d\x1a7\x20Specify\x20whether\x20the\x20Secret\x20mu\
    st\x20be\x20defined\n\x20+optional\n\n\x0e\n\x06\x04\xab\x01\x02\x01\x04\
    \x12\x04\xe8\"\x02\n\n\x0e\n\x06\x04\xab\x01\x02\x01\x05\x12\x04\xe8\"\
    \x0b\x0f\n\x0e\n\x06\x04\xab\x01\x02\x01\x01\x12\x04\xe8\"\x10\x18\n\x0e\
    \n\x06\x04\xab\x01\x02\x01\x03\x12\x04\xe8\"\x1b\x1c\n=\n\x03\x04\xac\
    \x01\x12\x06\xec\"\0\xf6\"\x01\x1a.\x20SecretKeySelector\x20selects\x20a\
    \x20key\x20of\x20a\x20Secret.\n\n\x0c\n\x04\x04\xac\x01\x01\x12\x04\xec\
    \"\x08\x19\nN\n\x05\x04\xac\x01\x02\0\x12\x04\xee\"\x029\x1a?\x20The\x20\
    name\x20of\x20the\x20secret\x20in\x20the\x20pod's\x20namespace\x20to\x20\
    select\x20from.\n\n\x0e\n\x06\x04\xac\x01\x02\0\x04\x12\x04\xee\"\x02\n\
    \n\x0e\n\x06\x04\xac\x01\x02\0\x06\x12\x04\xee\"\x0b\x1f\n\x0e\n\x06\x04\
    \xac\x01\x02\0\x01\x12\x04\xee\"\x204\n\x0e\n\x06\x04\xac\x01\x02\0\x03\
    \x12\x04\xee\"78\nS\n\x05\x04\xac\x01\x02\x01\x12\x04\xf1\"\x02\x1a\x1aD\
    \x20The\x20key\x20of\x20the\x20secret\x20to\x20select\x20from.\x20\x20Mu\
    st\x20be\x20a\x20valid\x20secret\x20key.\n\n\x0e\n\x06\x04\xac\x01\x02\
    \x01\x04\x12\x04\xf1\"\x02\n\n\x0e\n\x06\x04\xac\x01\x02\x01\x05\x12\x04\
    \xf1\"\x0b\x11\n\x0e\n\x06\x04\xac\x01\x02\x01\x01\x12\x04\xf1\"\x12\x15\
    \n\x0e\n\x06\x04\xac\x01\x02\x01\x03\x12\x04\xf1\"\x18\x19\nQ\n\x05\x04\
    \xac\x01\x02\x02\x12\x04\xf5\"\x02\x1d\x1aB\x20Specify\x20whether\x20the\
    \x20Secret\x20or\x20its\x20key\x20must\x20be\x20defined\n\x20+optional\n\
    \n\x0e\n\x06\x04\xac\x01\x02\x02\x04\x12\x04\xf5\"\x02\n\n\x0e\n\x06\x04\
    \xac\x01\x02\x02\x05\x12\x04\xf5\"\x0b\x0f\n\x0e\n\x06\x04\xac\x01\x02\
    \x02\x01\x12\x04\xf5\"\x10\x18\n\x0e\n\x06\x04\xac\x01\x02\x02\x03\x12\
    \x04\xf5\"\x1b\x1c\n0\n\x03\x04\xad\x01\x12\x06\xf9\"\0\x82#\x01\x1a!\
    \x20SecretList\x20is\x20a\x20list\x20of\x20Secret.\n\n\x0c\n\x04\x04\xad\
    \x01\x01\x12\x04\xf9\"\x08\x12\n\xa0\x01\n\x05\x04\xad\x01\x02\0\x12\x04\
    \xfd\"\x02F\x1a\x90\x01\x20Standard\x20list\x20metadata.\n\x20More\x20in\
    fo:\x20https://git.k8s.io/community/contributors/devel/sig-architecture/\
    api-conventions.md#types-kinds\n\x20+optional\n\n\x0e\n\x06\x04\xad\x01\
    \x02\0\x04\x12\x04\xfd\"\x02\n\n\x0e\n\x06\x04\xad\x01\x02\0\x06\x12\x04\
    \xfd\"\x0b8\n\x0e\n\x06\x04\xad\x01\x02\0\x01\x12\x04\xfd\"9A\n\x0e\n\
    \x06\x04\xad\x01\x02\0\x03\x12\x04\xfd\"DE\nx\n\x05\x04\xad\x01\x02\x01\
    \x12\x04\x81#\x02\x1c\x1ai\x20Items\x20is\x20a\x20list\x20of\x20secret\
    \x20objects.\n\x20More\x20info:\x20https://kubernetes.io/docs/concepts/c\
    onfiguration/secret\n\n\x0e\n\x06\x04\xad\x01\x02\x01\x04\x12\x04\x81#\
    \x02\n\n\x0e\n\x06\x04\xad\x01\x02\x01\x06\x12\x04\x81#\x0b\x11\n\x0e\n\
    \x06\x04\xad\x01\x02\x01\x01\x12\x04\x81#\x12\x17\n\x0e\n\x06\x04\xad\
    \x01\x02\x01\x03\x12\x04\x81#\x1a\x1b\n\xa3\x02\n\x03\x04\xae\x01\x12\
    \x06\x8a#\0\x9a#\x01\x1a\x93\x02\x20Adapts\x20a\x20secret\x20into\x20a\
    \x20projected\x20volume.\n\n\x20The\x20contents\x20of\x20the\x20target\
    \x20Secret's\x20Data\x20field\x20will\x20be\x20presented\x20in\x20a\n\
    \x20projected\x20volume\x20as\x20files\x20using\x20the\x20keys\x20in\x20\
    the\x20Data\x20field\x20as\x20the\x20file\x20names.\n\x20Note\x20that\
    \x20this\x20is\x20identical\x20to\x20a\x20secret\x20volume\x20source\x20\
    without\x20the\x20default\n\x20mode.\n\n\x0c\n\x04\x04\xae\x01\x01\x12\
    \x04\x8a#\x08\x18\n\r\n\x05\x04\xae\x01\x02\0\x12\x04\x8b#\x029\n\x0e\n\
    \x06\x04\xae\x01\x02\0\x04\x12\x04\x8b#\x02\n\n\x0e\n\x06\x04\xae\x01\
    \x02\0\x06\x12\x04\x8b#\x0b\x1f\n\x0e\n\x06\x04\xae\x01\x02\0\x01\x12\
    \x04\x8b#\x204\n\x0e\n\x06\x04\xae\x01\x02\0\x03\x12\x04\x8b#78\n\xff\
    \x03\n\x05\x04\xae\x01\x02\x01\x12\x04\x95#\x02\x1f\x1a\xef\x03\x20If\
    \x20unspecified,\x20each\x20key-value\x20pair\x20in\x20the\x20Data\x20fi\
    eld\x20of\x20the\x20referenced\n\x20Secret\x20will\x20be\x20projected\
    \x20into\x20the\x20volume\x20as\x20a\x20file\x20whose\x20name\x20is\x20t\
    he\n\x20key\x20and\x20content\x20is\x20the\x20value.\x20If\x20specified,\
    \x20the\x20listed\x20keys\x20will\x20be\n\x20projected\x20into\x20the\
    \x20specified\x20paths,\x20and\x20unlisted\x20keys\x20will\x20not\x20be\
    \n\x20present.\x20If\x20a\x20key\x20is\x20specified\x20which\x20is\x20no\
    t\x20present\x20in\x20the\x20Secret,\n\x20the\x20volume\x20setup\x20will\
    \x20error\x20unless\x20it\x20is\x20marked\x20optional.\x20Paths\x20must\
    \x20be\n\x20relative\x20and\x20may\x20not\x20contain\x20the\x20'..'\x20p\
    ath\x20or\x20start\x20with\x20'..'.\n\x20+optional\n\n\x0e\n\x06\x04\xae\
    \x01\x02\x01\x04\x12\x04\x95#\x02\n\n\x0e\n\x06\x04\xae\x01\x02\x01\x06\
    \x12\x04\x95#\x0b\x14\n\x0e\n\x06\x04\xae\x01\x02\x01\x01\x12\x04\x95#\
    \x15\x1a\n\x0e\n\x06\x04\xae\x01\x02\x01\x03\x12\x04\x95#\x1d\x1e\nQ\n\
    \x05\x04\xae\x01\x02\x02\x12\x04\x99#\x02\x1d\x1aB\x20Specify\x20whether\
    \x20the\x20Secret\x20or\x20its\x20key\x20must\x20be\x20defined\n\x20+opt\
    ional\n\n\x0e\n\x06\x04\xae\x01\x02\x02\x04\x12\x04\x99#\x02\n\n\x0e\n\
    \x06\x04\xae\x01\x02\x02\x05\x12\x04\x99#\x0b\x0f\n\x0e\n\x06\x04\xae\
    \x01\x02\x02\x01\x12\x04\x99#\x10\x18\n\x0e\n\x06\x04\xae\x01\x02\x02\
    \x03\x12\x04\x99#\x1b\x1c\n~\n\x03\x04\xaf\x01\x12\x06\x9e#\0\xa6#\x01\
    \x1ao\x20SecretReference\x20represents\x20a\x20Secret\x20Reference.\x20I\
    t\x20has\x20enough\x20information\x20to\x20retrieve\x20secret\n\x20in\
    \x20any\x20namespace\n\n\x0c\n\x04\x04\xaf\x01\x01\x12\x04\x9e#\x08\x17\
    \n]\n\x05\x04\xaf\x01\x02\0\x12\x04\xa1#\x02\x1b\x1aN\x20Name\x20is\x20u\
    nique\x20within\x20a\x20namespace\x20to\x20reference\x20a\x20secret\x20r\
    esource.\n\x20+optional\n\n\x0e\n\x06\x04\xaf\x01\x02\0\x04\x12\x04\xa1#\
    \x02\n\n\x0e\n\x06\x04\xaf\x01\x02\0\x05\x12\x04\xa1#\x0b\x11\n\x0e\n\
    \x06\x04\xaf\x01\x02\0\x01\x12\x04\xa1#\x12\x16\n\x0e\n\x06\x04\xaf\x01\
    \x02\0\x03\x12\x04\xa1#\x19\x1a\nd\n\x05\x04\xaf\x01\x02\x01\x12\x04\xa5\
    #\x02\x20\x1aU\x20Namespace\x20defines\x20the\x20space\x20within\x20whic\
    h\x20the\x20secret\x20name\x20must\x20be\x20unique.\n\x20+optional\n\n\
    \x0e\n\x06\x04\xaf\x01\x02\x01\x04\x12\x04\xa5#\x02\n\n\x0e\n\x06\x04\
    \xaf\x01\x02\x01\x05\x12\x04\xa5#\x0b\x11\n\x0e\n\x06\x04\xaf\x01\x02\
    \x01\x01\x12\x04\xa5#\x12\x1b\n\x0e\n\x06\x04\xaf\x01\x02\x01\x03\x12\
    \x04\xa5#\x1e\x1f\n\x82\x02\n\x03\x04\xb0\x01\x12\x06\xad#\0\xca#\x01\
    \x1a\xf2\x01\x20Adapts\x20a\x20Secret\x20into\x20a\x20volume.\n\n\x20The\
    \x20contents\x20of\x20the\x20target\x20Secret's\x20Data\x20field\x20will\
    \x20be\x20presented\x20in\x20a\x20volume\n\x20as\x20files\x20using\x20th\
    e\x20keys\x20in\x20the\x20Data\x20field\x20as\x20the\x20file\x20names.\n\
    \x20Secret\x20volumes\x20support\x20ownership\x20management\x20and\x20SE\
    Linux\x20relabeling.\n\n\x0c\n\x04\x04\xb0\x01\x01\x12\x04\xad#\x08\x1a\
    \n\x95\x01\n\x05\x04\xb0\x01\x02\0\x12\x04\xb1#\x02!\x1a\x85\x01\x20Name\
    \x20of\x20the\x20secret\x20in\x20the\x20pod's\x20namespace\x20to\x20use.\
    \n\x20More\x20info:\x20https://kubernetes.io/docs/concepts/storage/volum\
    es#secret\n\x20+optional\n\n\x0e\n\x06\x04\xb0\x01\x02\0\x04\x12\x04\xb1\
    #\x02\n\n\x0e\n\x06\x04\xb0\x01\x02\0\x05\x12\x04\xb1#\x0b\x11\n\x0e\n\
    \x06\x04\xb0\x01\x02\0\x01\x12\x04\xb1#\x12\x1c\n\x0e\n\x06\x04\xb0\x01\
    \x02\0\x03\x12\x04\xb1#\x1f\x20\n\xff\x03\n\x05\x04\xb0\x01\x02\x01\x12\
    \x04\xbb#\x02\x1f\x1a\xef\x03\x20If\x20unspecified,\x20each\x20key-value\
    \x20pair\x20in\x20the\x20Data\x20field\x20of\x20the\x20referenced\n\x20S\
    ecret\x20will\x20be\x20projected\x20into\x20the\x20volume\x20as\x20a\x20\
    file\x20whose\x20name\x20is\x20the\n\x20key\x20and\x20content\x20is\x20t\
    he\x20value.\x20If\x20specified,\x20the\x20listed\x20keys\x20will\x20be\
    \n\x20projected\x20into\x20the\x20specified\x20paths,\x20and\x20unlisted\
    \x20keys\x20will\x20not\x20be\n\x20present.\x20If\x20a\x20key\x20is\x20s\
    pecified\x20which\x20is\x20not\x20present\x20in\x20the\x20Secret,\n\x20t\
    he\x20volume\x20setup\x20will\x20error\x20unless\x20it\x20is\x20marked\
    \x20optional.\x20Paths\x20must\x20be\n\x20relative\x20and\x20may\x20not\
    \x20contain\x20the\x20'..'\x20path\x20or\x20start\x20with\x20'..'.\n\x20\
    +optional\n\n\x0e\n\x06\x04\xb0\x01\x02\x01\x04\x12\x04\xbb#\x02\n\n\x0e\
    \n\x06\x04\xb0\x01\x02\x01\x06\x12\x04\xbb#\x0b\x14\n\x0e\n\x06\x04\xb0\
    \x01\x02\x01\x01\x12\x04\xbb#\x15\x1a\n\x0e\n\x06\x04\xb0\x01\x02\x01\
    \x03\x12\x04\xbb#\x1d\x1e\n\xe7\x03\n\x05\x04\xb0\x01\x02\x02\x12\x04\
    \xc5#\x02!\x1a\xd7\x03\x20Optional:\x20mode\x20bits\x20used\x20to\x20set\
    \x20permissions\x20on\x20created\x20files\x20by\x20default.\n\x20Must\
    \x20be\x20an\x20octal\x20value\x20between\x200000\x20and\x200777\x20or\
    \x20a\x20decimal\x20value\x20between\x200\x20and\x20511.\n\x20YAML\x20ac\
    cepts\x20both\x20octal\x20and\x20decimal\x20values,\x20JSON\x20requires\
    \x20decimal\x20values\n\x20for\x20mode\x20bits.\x20Defaults\x20to\x20064\
    4.\n\x20Directories\x20within\x20the\x20path\x20are\x20not\x20affected\
    \x20by\x20this\x20setting.\n\x20This\x20might\x20be\x20in\x20conflict\
    \x20with\x20other\x20options\x20that\x20affect\x20the\x20file\n\x20mode,\
    \x20like\x20fsGroup,\x20and\x20the\x20result\x20can\x20be\x20other\x20mo\
    de\x20bits\x20set.\n\x20+optional\n\n\x0e\n\x06\x04\xb0\x01\x02\x02\x04\
    \x12\x04\xc5#\x02\n\n\x0e\n\x06\x04\xb0\x01\x02\x02\x05\x12\x04\xc5#\x0b\
    \x10\n\x0e\n\x06\x04\xb0\x01\x02\x02\x01\x12\x04\xc5#\x11\x1c\n\x0e\n\
    \x06\x04\xb0\x01\x02\x02\x03\x12\x04\xc5#\x1f\x20\nR\n\x05\x04\xb0\x01\
    \x02\x03\x12\x04\xc9#\x02\x1d\x1aC\x20Specify\x20whether\x20the\x20Secre\
    t\x20or\x20its\x20keys\x20must\x20be\x20defined\n\x20+optional\n\n\x0e\n\
    \x06\x04\xb0\x01\x02\x03\x04\x12\x04\xc9#\x02\n\n\x0e\n\x06\x04\xb0\x01\
    \x02\x03\x05\x12\x04\xc9#\x0b\x0f\n\x0e\n\x06\x04\xb0\x01\x02\x03\x01\
    \x12\x04\xc9#\x10\x18\n\x0e\n\x06\x04\xb0\x01\x02\x03\x03\x12\x04\xc9#\
    \x1b\x1c\n\xf0\x01\n\x03\x04\xb1\x01\x12\x06\xcf#\0\x99$\x01\x1a\xe0\x01\
    \x20SecurityContext\x20holds\x20security\x20configuration\x20that\x20wil\
    l\x20be\x20applied\x20to\x20a\x20container.\n\x20Some\x20fields\x20are\
    \x20present\x20in\x20both\x20SecurityContext\x20and\x20PodSecurityContex\
    t.\x20\x20When\x20both\n\x20are\x20set,\x20the\x20values\x20in\x20Securi\
    tyContext\x20take\x20precedence.\n\n\x0c\n\x04\x04\xb1\x01\x01\x12\x04\
    \xcf#\x08\x17\n\xa1\x01\n\x05\x04\xb1\x01\x02\0\x12\x04\xd3#\x02)\x1a\
    \x91\x01\x20The\x20capabilities\x20to\x20add/drop\x20when\x20running\x20\
    containers.\n\x20Defaults\x20to\x20the\x20default\x20set\x20of\x20capabi\
    lities\x20granted\x20by\x20the\x20container\x20runtime.\n\x20+optional\n\
    \n\x0e\n\x06\x04\xb1\x01\x02\0\x04\x12\x04\xd3#\x02\n\n\x0e\n\x06\x04\
    \xb1\x01\x02\0\x06\x12\x04\xd3#\x0b\x17\n\x0e\n\x06\x04\xb1\x01\x02\0\
    \x01\x12\x04\xd3#\x18$\n\x0e\n\x06\x04\xb1\x01\x02\0\x03\x12\x04\xd3#'(\
    \n\xa6\x01\n\x05\x04\xb1\x01\x02\x01\x12\x04\xd9#\x02\x1f\x1a\x96\x01\
    \x20Run\x20container\x20in\x20privileged\x20mode.\n\x20Processes\x20in\
    \x20privileged\x20containers\x20are\x20essentially\x20equivalent\x20to\
    \x20root\x20on\x20the\x20host.\n\x20Defaults\x20to\x20false.\n\x20+optio\
    nal\n\n\x0e\n\x06\x04\xb1\x01\x02\x01\x04\x12\x04\xd9#\x02\n\n\x0e\n\x06\
    \x04\xb1\x01\x02\x01\x05\x12\x04\xd9#\x0b\x0f\n\x0e\n\x06\x04\xb1\x01\
    \x02\x01\x01\x12\x04\xd9#\x10\x1a\n\x0e\n\x06\x04\xb1\x01\x02\x01\x03\
    \x12\x04\xd9#\x1d\x1e\n\xcd\x02\n\x05\x04\xb1\x01\x02\x02\x12\x04\xe0#\
    \x02-\x1a\xbd\x02\x20The\x20SELinux\x20context\x20to\x20be\x20applied\
    \x20to\x20the\x20container.\n\x20If\x20unspecified,\x20the\x20container\
    \x20runtime\x20will\x20allocate\x20a\x20random\x20SELinux\x20context\x20\
    for\x20each\n\x20container.\x20\x20May\x20also\x20be\x20set\x20in\x20Pod\
    SecurityContext.\x20\x20If\x20set\x20in\x20both\x20SecurityContext\x20an\
    d\n\x20PodSecurityContext,\x20the\x20value\x20specified\x20in\x20Securit\
    yContext\x20takes\x20precedence.\n\x20+optional\n\n\x0e\n\x06\x04\xb1\
    \x01\x02\x02\x04\x12\x04\xe0#\x02\n\n\x0e\n\x06\x04\xb1\x01\x02\x02\x06\
    \x12\x04\xe0#\x0b\x19\n\x0e\n\x06\x04\xb1\x01\x02\x02\x01\x12\x04\xe0#\
    \x1a(\n\x0e\n\x06\x04\xb1\x01\x02\x02\x03\x12\x04\xe0#+,\n\x8d\x02\n\x05\
    \x04\xb1\x01\x02\x03\x12\x04\xe6#\x02=\x1a\xfd\x01\x20The\x20Windows\x20\
    specific\x20settings\x20applied\x20to\x20all\x20containers.\n\x20If\x20u\
    nspecified,\x20the\x20options\x20from\x20the\x20PodSecurityContext\x20wi\
    ll\x20be\x20used.\n\x20If\x20set\x20in\x20both\x20SecurityContext\x20and\
    \x20PodSecurityContext,\x20the\x20value\x20specified\x20in\x20SecurityCo\
    ntext\x20takes\x20precedence.\n\x20+optional\n\n\x0e\n\x06\x04\xb1\x01\
    \x02\x03\x04\x12\x04\xe6#\x02\n\n\x0e\n\x06\x04\xb1\x01\x02\x03\x06\x12\
    \x04\xe6#\x0b(\n\x0e\n\x06\x04\xb1\x01\x02\x03\x01\x12\x04\xe6#)7\n\x0e\
    \n\x06\x04\xb1\x01\x02\x03\x03\x12\x04\xe6#:<\n\xac\x02\n\x05\x04\xb1\
    \x01\x02\x04\x12\x04\xed#\x02\x1f\x1a\x9c\x02\x20The\x20UID\x20to\x20run\
    \x20the\x20entrypoint\x20of\x20the\x20container\x20process.\n\x20Default\
    s\x20to\x20user\x20specified\x20in\x20image\x20metadata\x20if\x20unspeci\
    fied.\n\x20May\x20also\x20be\x20set\x20in\x20PodSecurityContext.\x20\x20\
    If\x20set\x20in\x20both\x20SecurityContext\x20and\n\x20PodSecurityContex\
    t,\x20the\x20value\x20specified\x20in\x20SecurityContext\x20takes\x20pre\
    cedence.\n\x20+optional\n\n\x0e\n\x06\x04\xb1\x01\x02\x04\x04\x12\x04\
    \xed#\x02\n\n\x0e\n\x06\x04\xb1\x01\x02\x04\x05\x12\x04\xed#\x0b\x10\n\
    \x0e\n\x06\x04\xb1\x01\x02\x04\x01\x12\x04\xed#\x11\x1a\n\x0e\n\x06\x04\
    \xb1\x01\x02\x04\x03\x12\x04\xed#\x1d\x1e\n\x8e\x02\n\x05\x04\xb1\x01\
    \x02\x05\x12\x04\xf4#\x02\x20\x1a\xfe\x01\x20The\x20GID\x20to\x20run\x20\
    the\x20entrypoint\x20of\x20the\x20container\x20process.\n\x20Uses\x20run\
    time\x20default\x20if\x20unset.\n\x20May\x20also\x20be\x20set\x20in\x20P\
    odSecurityContext.\x20\x20If\x20set\x20in\x20both\x20SecurityContext\x20\
    and\n\x20PodSecurityContext,\x20the\x20value\x20specified\x20in\x20Secur\
    ityContext\x20takes\x20precedence.\n\x20+optional\n\n\x0e\n\x06\x04\xb1\
    \x01\x02\x05\x04\x12\x04\xf4#\x02\n\n\x0e\n\x06\x04\xb1\x01\x02\x05\x05\
    \x12\x04\xf4#\x0b\x10\n\x0e\n\x06\x04\xb1\x01\x02\x05\x01\x12\x04\xf4#\
    \x11\x1b\n\x0e\n\x06\x04\xb1\x01\x02\x05\x03\x12\x04\xf4#\x1e\x1f\n\xbf\
    \x03\n\x05\x04\xb1\x01\x02\x06\x12\x04\xfd#\x02!\x1a\xaf\x03\x20Indicate\
    s\x20that\x20the\x20container\x20must\x20run\x20as\x20a\x20non-root\x20u\
    ser.\n\x20If\x20true,\x20the\x20Kubelet\x20will\x20validate\x20the\x20im\
    age\x20at\x20runtime\x20to\x20ensure\x20that\x20it\n\x20does\x20not\x20r\
    un\x20as\x20UID\x200\x20(root)\x20and\x20fail\x20to\x20start\x20the\x20c\
    ontainer\x20if\x20it\x20does.\n\x20If\x20unset\x20or\x20false,\x20no\x20\
    such\x20validation\x20will\x20be\x20performed.\n\x20May\x20also\x20be\
    \x20set\x20in\x20PodSecurityContext.\x20\x20If\x20set\x20in\x20both\x20S\
    ecurityContext\x20and\n\x20PodSecurityContext,\x20the\x20value\x20specif\
    ied\x20in\x20SecurityContext\x20takes\x20precedence.\n\x20+optional\n\n\
    \x0e\n\x06\x04\xb1\x01\x02\x06\x04\x12\x04\xfd#\x02\n\n\x0e\n\x06\x04\
    \xb1\x01\x02\x06\x05\x12\x04\xfd#\x0b\x0f\n\x0e\n\x06\x04\xb1\x01\x02\
    \x06\x01\x12\x04\xfd#\x10\x1c\n\x0e\n\x06\x04\xb1\x01\x02\x06\x03\x12\
    \x04\xfd#\x1f\x20\nf\n\x05\x04\xb1\x01\x02\x07\x12\x04\x82$\x02+\x1aW\
    \x20Whether\x20this\x20container\x20has\x20a\x20read-only\x20root\x20fil\
    esystem.\n\x20Default\x20is\x20false.\n\x20+optional\n\n\x0e\n\x06\x04\
    \xb1\x01\x02\x07\x04\x12\x04\x82$\x02\n\n\x0e\n\x06\x04\xb1\x01\x02\x07\
    \x05\x12\x04\x82$\x0b\x0f\n\x0e\n\x06\x04\xb1\x01\x02\x07\x01\x12\x04\
    \x82$\x10&\n\x0e\n\x06\x04\xb1\x01\x02\x07\x03\x12\x04\x82$)*\n\xcb\x02\
    \n\x05\x04\xb1\x01\x02\x08\x12\x04\x8b$\x02-\x1a\xbb\x02\x20AllowPrivile\
    geEscalation\x20controls\x20whether\x20a\x20process\x20can\x20gain\x20mo\
    re\n\x20privileges\x20than\x20its\x20parent\x20process.\x20This\x20bool\
    \x20directly\x20controls\x20if\n\x20the\x20no_new_privs\x20flag\x20will\
    \x20be\x20set\x20on\x20the\x20container\x20process.\n\x20AllowPrivilegeE\
    scalation\x20is\x20true\x20always\x20when\x20the\x20container\x20is:\n\
    \x201)\x20run\x20as\x20Privileged\n\x202)\x20has\x20CAP_SYS_ADMIN\n\x20+\
    optional\n\n\x0e\n\x06\x04\xb1\x01\x02\x08\x04\x12\x04\x8b$\x02\n\n\x0e\
    \n\x06\x04\xb1\x01\x02\x08\x05\x12\x04\x8b$\x0b\x0f\n\x0e\n\x06\x04\xb1\
    \x01\x02\x08\x01\x12\x04\x8b$\x10(\n\x0e\n\x06\x04\xb1\x01\x02\x08\x03\
    \x12\x04\x8b$+,\n\x8e\x02\n\x05\x04\xb1\x01\x02\t\x12\x04\x92$\x02\x20\
    \x1a\xfe\x01\x20procMount\x20denotes\x20the\x20type\x20of\x20proc\x20mou\
    nt\x20to\x20use\x20for\x20the\x20containers.\n\x20The\x20default\x20is\
    \x20DefaultProcMount\x20which\x20uses\x20the\x20container\x20runtime\x20\
    defaults\x20for\n\x20readonly\x20paths\x20and\x20masked\x20paths.\n\x20T\
    his\x20requires\x20the\x20ProcMountType\x20feature\x20flag\x20to\x20be\
    \x20enabled.\n\x20+optional\n\n\x0e\n\x06\x04\xb1\x01\x02\t\x04\x12\x04\
    \x92$\x02\n\n\x0e\n\x06\x04\xb1\x01\x02\t\x05\x12\x04\x92$\x0b\x11\n\x0e\
    \n\x06\x04\xb1\x01\x02\t\x01\x12\x04\x92$\x12\x1b\n\x0e\n\x06\x04\xb1\
    \x01\x02\t\x03\x12\x04\x92$\x1e\x1f\n\xbf\x01\n\x05\x04\xb1\x01\x02\n\
    \x12\x04\x98$\x02.\x1a\xaf\x01\x20The\x20seccomp\x20options\x20to\x20use\
    \x20by\x20this\x20container.\x20If\x20seccomp\x20options\x20are\n\x20pro\
    vided\x20at\x20both\x20the\x20pod\x20&\x20container\x20level,\x20the\x20\
    container\x20options\n\x20override\x20the\x20pod\x20options.\n\x20+optio\
    nal\n\n\x0e\n\x06\x04\xb1\x01\x02\n\x04\x12\x04\x98$\x02\n\n\x0e\n\x06\
    \x04\xb1\x01\x02\n\x06\x12\x04\x98$\x0b\x19\n\x0e\n\x06\x04\xb1\x01\x02\
    \n\x01\x12\x04\x98$\x1a(\n\x0e\n\x06\x04\xb1\x01\x02\n\x03\x12\x04\x98$+\
    -\nI\n\x03\x04\xb2\x01\x12\x06\x9c$\0\xa0$\x01\x1a:\x20SerializedReferen\
    ce\x20is\x20a\x20reference\x20to\x20serialized\x20object.\n\n\x0c\n\x04\
    \x04\xb2\x01\x01\x12\x04\x9c$\x08\x1b\nE\n\x05\x04\xb2\x01\x02\0\x12\x04\
    \x9f$\x02)\x1a6\x20The\x20reference\x20to\x20an\x20object\x20in\x20the\
    \x20system.\n\x20+optional\n\n\x0e\n\x06\x04\xb2\x01\x02\0\x04\x12\x04\
    \x9f$\x02\n\n\x0e\n\x06\x04\xb2\x01\x02\0\x06\x12\x04\x9f$\x0b\x1a\n\x0e\
    \n\x06\x04\xb2\x01\x02\0\x01\x12\x04\x9f$\x1b$\n\x0e\n\x06\x04\xb2\x01\
    \x02\0\x03\x12\x04\x9f$'(\n\xfb\x01\n\x03\x04\xb3\x01\x12\x06\xa5$\0\xb6\
    $\x01\x1a\xeb\x01\x20Service\x20is\x20a\x20named\x20abstraction\x20of\
    \x20software\x20service\x20(for\x20example,\x20mysql)\x20consisting\x20o\
    f\x20local\x20port\n\x20(for\x20example\x203306)\x20that\x20the\x20proxy\
    \x20listens\x20on,\x20and\x20the\x20selector\x20that\x20determines\x20wh\
    ich\x20pods\n\x20will\x20answer\x20requests\x20sent\x20through\x20the\
    \x20proxy.\n\n\x0c\n\x04\x04\xb3\x01\x01\x12\x04\xa5$\x08\x0f\n\xa1\x01\
    \n\x05\x04\xb3\x01\x02\0\x12\x04\xa9$\x02H\x1a\x91\x01\x20Standard\x20ob\
    ject's\x20metadata.\n\x20More\x20info:\x20https://git.k8s.io/community/c\
    ontributors/devel/sig-architecture/api-conventions.md#metadata\n\x20+opt\
    ional\n\n\x0e\n\x06\x04\xb3\x01\x02\0\x04\x12\x04\xa9$\x02\n\n\x0e\n\x06\
    \x04\xb3\x01\x02\0\x06\x12\x04\xa9$\x0b:\n\x0e\n\x06\x04\xb3\x01\x02\0\
    \x01\x12\x04\xa9$;C\n\x0e\n\x06\x04\xb3\x01\x02\0\x03\x12\x04\xa9$FG\n\
    \xa9\x01\n\x05\x04\xb3\x01\x02\x01\x12\x04\xae$\x02\x20\x1a\x99\x01\x20S\
    pec\x20defines\x20the\x20behavior\x20of\x20a\x20service.\n\x20https://gi\
    t.k8s.io/community/contributors/devel/sig-architecture/api-conventions.m\
    d#spec-and-status\n\x20+optional\n\n\x0e\n\x06\x04\xb3\x01\x02\x01\x04\
    \x12\x04\xae$\x02\n\n\x0e\n\x06\x04\xb3\x01\x02\x01\x06\x12\x04\xae$\x0b\
    \x16\n\x0e\n\x06\x04\xb3\x01\x02\x01\x01\x12\x04\xae$\x17\x1b\n\x0e\n\
    \x06\x04\xb3\x01\x02\x01\x03\x12\x04\xae$\x1e\x1f\n\xe0\x01\n\x05\x04\
    \xb3\x01\x02\x02\x12\x04\xb5$\x02$\x1a\xd0\x01\x20Most\x20recently\x20ob\
    served\x20status\x20of\x20the\x20service.\n\x20Populated\x20by\x20the\
    \x20system.\n\x20Read-only.\n\x20More\x20info:\x20https://git.k8s.io/com\
    munity/contributors/devel/sig-architecture/api-conventions.md#spec-and-s\
    tatus\n\x20+optional\n\n\x0e\n\x06\x04\xb3\x01\x02\x02\x04\x12\x04\xb5$\
    \x02\n\n\x0e\n\x06\x04\xb3\x01\x02\x02\x06\x12\x04\xb5$\x0b\x18\n\x0e\n\
    \x06\x04\xb3\x01\x02\x02\x01\x12\x04\xb5$\x19\x1f\n\x0e\n\x06\x04\xb3\
    \x01\x02\x02\x03\x12\x04\xb5$\"#\n\xcf\x01\n\x03\x04\xb4\x01\x12\x06\xbc\
    $\0\xd4$\x01\x1a\xbf\x01\x20ServiceAccount\x20binds\x20together:\n\x20*\
    \x20a\x20name,\x20understood\x20by\x20users,\x20and\x20perhaps\x20by\x20\
    peripheral\x20systems,\x20for\x20an\x20identity\n\x20*\x20a\x20principal\
    \x20that\x20can\x20be\x20authenticated\x20and\x20authorized\n\x20*\x20a\
    \x20set\x20of\x20secrets\n\n\x0c\n\x04\x04\xb4\x01\x01\x12\x04\xbc$\x08\
    \x16\n\xa1\x01\n\x05\x04\xb4\x01\x02\0\x12\x04\xc0$\x02H\x1a\x91\x01\x20\
    Standard\x20object's\x20metadata.\n\x20More\x20info:\x20https://git.k8s.\
    io/community/contributors/devel/sig-architecture/api-conventions.md#meta\
    data\n\x20+optional\n\n\x0e\n\x06\x04\xb4\x01\x02\0\x04\x12\x04\xc0$\x02\
    \n\n\x0e\n\x06\x04\xb4\x01\x02\0\x06\x12\x04\xc0$\x0b:\n\x0e\n\x06\x04\
    \xb4\x01\x02\0\x01\x12\x04\xc0$;C\n\x0e\n\x06\x04\xb4\x01\x02\0\x03\x12\
    \x04\xc0$FG\n\xe9\x01\n\x05\x04\xb4\x01\x02\x01\x12\x04\xc7$\x02'\x1a\
    \xd9\x01\x20Secrets\x20is\x20the\x20list\x20of\x20secrets\x20allowed\x20\
    to\x20be\x20used\x20by\x20pods\x20running\x20using\x20this\x20ServiceAcc\
    ount.\n\x20More\x20info:\x20https://kubernetes.io/docs/concepts/configur\
    ation/secret\n\x20+optional\n\x20+patchMergeKey=name\n\x20+patchStrategy\
    =merge\n\n\x0e\n\x06\x04\xb4\x01\x02\x01\x04\x12\x04\xc7$\x02\n\n\x0e\n\
    \x06\x04\xb4\x01\x02\x01\x06\x12\x04\xc7$\x0b\x1a\n\x0e\n\x06\x04\xb4\
    \x01\x02\x01\x01\x12\x04\xc7$\x1b\"\n\x0e\n\x06\x04\xb4\x01\x02\x01\x03\
    \x12\x04\xc7$%&\n\xa7\x03\n\x05\x04\xb4\x01\x02\x02\x12\x04\xce$\x025\
    \x1a\x97\x03\x20ImagePullSecrets\x20is\x20a\x20list\x20of\x20references\
    \x20to\x20secrets\x20in\x20the\x20same\x20namespace\x20to\x20use\x20for\
    \x20pulling\x20any\x20images\n\x20in\x20pods\x20that\x20reference\x20thi\
    s\x20ServiceAccount.\x20ImagePullSecrets\x20are\x20distinct\x20from\x20S\
    ecrets\x20because\x20Secrets\n\x20can\x20be\x20mounted\x20in\x20the\x20p\
    od,\x20but\x20ImagePullSecrets\x20are\x20only\x20accessed\x20by\x20the\
    \x20kubelet.\n\x20More\x20info:\x20https://kubernetes.io/docs/concepts/c\
    ontainers/images/#specifying-imagepullsecrets-on-a-pod\n\x20+optional\n\
    \n\x0e\n\x06\x04\xb4\x01\x02\x02\x04\x12\x04\xce$\x02\n\n\x0e\n\x06\x04\
    \xb4\x01\x02\x02\x06\x12\x04\xce$\x0b\x1f\n\x0e\n\x06\x04\xb4\x01\x02\
    \x02\x01\x12\x04\xce$\x200\n\x0e\n\x06\x04\xb4\x01\x02\x02\x03\x12\x04\
    \xce$34\n\xc5\x01\n\x05\x04\xb4\x01\x02\x03\x12\x04\xd3$\x021\x1a\xb5\
    \x01\x20AutomountServiceAccountToken\x20indicates\x20whether\x20pods\x20\
    running\x20as\x20this\x20service\x20account\x20should\x20have\x20an\x20A\
    PI\x20token\x20automatically\x20mounted.\n\x20Can\x20be\x20overridden\
    \x20at\x20the\x20pod\x20level.\n\x20+optional\n\n\x0e\n\x06\x04\xb4\x01\
    \x02\x03\x04\x12\x04\xd3$\x02\n\n\x0e\n\x06\x04\xb4\x01\x02\x03\x05\x12\
    \x04\xd3$\x0b\x0f\n\x0e\n\x06\x04\xb4\x01\x02\x03\x01\x12\x04\xd3$\x10,\
    \n\x0e\n\x06\x04\xb4\x01\x02\x03\x03\x12\x04\xd3$/0\nG\n\x03\x04\xb5\x01\
    \x12\x06\xd7$\0\xe0$\x01\x1a8\x20ServiceAccountList\x20is\x20a\x20list\
    \x20of\x20ServiceAccount\x20objects\n\n\x0c\n\x04\x04\xb5\x01\x01\x12\
    \x04\xd7$\x08\x1a\n\xa0\x01\n\x05\x04\xb5\x01\x02\0\x12\x04\xdb$\x02F\
    \x1a\x90\x01\x20Standard\x20list\x20metadata.\n\x20More\x20info:\x20http\
    s://git.k8s.io/community/contributors/devel/sig-architecture/api-convent\
    ions.md#types-kinds\n\x20+optional\n\n\x0e\n\x06\x04\xb5\x01\x02\0\x04\
    \x12\x04\xdb$\x02\n\n\x0e\n\x06\x04\xb5\x01\x02\0\x06\x12\x04\xdb$\x0b8\
    \n\x0e\n\x06\x04\xb5\x01\x02\0\x01\x12\x04\xdb$9A\n\x0e\n\x06\x04\xb5\
    \x01\x02\0\x03\x12\x04\xdb$DE\n\x89\x01\n\x05\x04\xb5\x01\x02\x01\x12\
    \x04\xdf$\x02$\x1az\x20List\x20of\x20ServiceAccounts.\n\x20More\x20info:\
    \x20https://kubernetes.io/docs/tasks/configure-pod-container/configure-s\
    ervice-account/\n\n\x0e\n\x06\x04\xb5\x01\x02\x01\x04\x12\x04\xdf$\x02\n\
    \n\x0e\n\x06\x04\xb5\x01\x02\x01\x06\x12\x04\xdf$\x0b\x19\n\x0e\n\x06\
    \x04\xb5\x01\x02\x01\x01\x12\x04\xdf$\x1a\x1f\n\x0e\n\x06\x04\xb5\x01\
    \x02\x01\x03\x12\x04\xdf$\"#\n\x81\x02\n\x03\x04\xb6\x01\x12\x06\xe6$\0\
    \xfa$\x01\x1a\xf1\x01\x20ServiceAccountTokenProjection\x20represents\x20\
    a\x20projected\x20service\x20account\x20token\n\x20volume.\x20This\x20pr\
    ojection\x20can\x20be\x20used\x20to\x20insert\x20a\x20service\x20account\
    \x20token\x20into\n\x20the\x20pods\x20runtime\x20filesystem\x20for\x20us\
    e\x20against\x20APIs\x20(Kubernetes\x20API\x20Server\x20or\n\x20otherwis\
    e).\n\n\x0c\n\x04\x04\xb6\x01\x01\x12\x04\xe6$\x08%\n\x97\x02\n\x05\x04\
    \xb6\x01\x02\0\x12\x04\xec$\x02\x1f\x1a\x87\x02\x20Audience\x20is\x20the\
    \x20intended\x20audience\x20of\x20the\x20token.\x20A\x20recipient\x20of\
    \x20a\x20token\n\x20must\x20identify\x20itself\x20with\x20an\x20identifi\
    er\x20specified\x20in\x20the\x20audience\x20of\x20the\n\x20token,\x20and\
    \x20otherwise\x20should\x20reject\x20the\x20token.\x20The\x20audience\
    \x20defaults\x20to\x20the\n\x20identifier\x20of\x20the\x20apiserver.\n\
    \x20+optional\n\n\x0e\n\x06\x04\xb6\x01\x02\0\x04\x12\x04\xec$\x02\n\n\
    \x0e\n\x06\x04\xb6\x01\x02\0\x05\x12\x04\xec$\x0b\x11\n\x0e\n\x06\x04\
    \xb6\x01\x02\0\x01\x12\x04\xec$\x12\x1a\n\x0e\n\x06\x04\xb6\x01\x02\0\
    \x03\x12\x04\xec$\x1d\x1e\n\xaf\x03\n\x05\x04\xb6\x01\x02\x01\x12\x04\
    \xf5$\x02'\x1a\x9f\x03\x20ExpirationSeconds\x20is\x20the\x20requested\
    \x20duration\x20of\x20validity\x20of\x20the\x20service\n\x20account\x20t\
    oken.\x20As\x20the\x20token\x20approaches\x20expiration,\x20the\x20kubel\
    et\x20volume\n\x20plugin\x20will\x20proactively\x20rotate\x20the\x20serv\
    ice\x20account\x20token.\x20The\x20kubelet\x20will\n\x20start\x20trying\
    \x20to\x20rotate\x20the\x20token\x20if\x20the\x20token\x20is\x20older\
    \x20than\x2080\x20percent\x20of\n\x20its\x20time\x20to\x20live\x20or\x20\
    if\x20the\x20token\x20is\x20older\x20than\x2024\x20hours.Defaults\x20to\
    \x201\x20hour\n\x20and\x20must\x20be\x20at\x20least\x2010\x20minutes.\n\
    \x20+optional\n\n\x0e\n\x06\x04\xb6\x01\x02\x01\x04\x12\x04\xf5$\x02\n\n\
    \x0e\n\x06\x04\xb6\x01\x02\x01\x05\x12\x04\xf5$\x0b\x10\n\x0e\n\x06\x04\
    \xb6\x01\x02\x01\x01\x12\x04\xf5$\x11\"\n\x0e\n\x06\x04\xb6\x01\x02\x01\
    \x03\x12\x04\xf5$%&\ne\n\x05\x04\xb6\x01\x02\x02\x12\x04\xf9$\x02\x1b\
    \x1aV\x20Path\x20is\x20the\x20path\x20relative\x20to\x20the\x20mount\x20\
    point\x20of\x20the\x20file\x20to\x20project\x20the\n\x20token\x20into.\n\
    \n\x0e\n\x06\x04\xb6\x01\x02\x02\x04\x12\x04\xf9$\x02\n\n\x0e\n\x06\x04\
    \xb6\x01\x02\x02\x05\x12\x04\xf9$\x0b\x11\n\x0e\n\x06\x04\xb6\x01\x02\
    \x02\x01\x12\x04\xf9$\x12\x16\n\x0e\n\x06\x04\xb6\x01\x02\x02\x03\x12\
    \x04\xf9$\x19\x1a\n6\n\x03\x04\xb7\x01\x12\x06\xfd$\0\x85%\x01\x1a'\x20S\
    erviceList\x20holds\x20a\x20list\x20of\x20services.\n\n\x0c\n\x04\x04\
    \xb7\x01\x01\x12\x04\xfd$\x08\x13\n\xa0\x01\n\x05\x04\xb7\x01\x02\0\x12\
    \x04\x81%\x02F\x1a\x90\x01\x20Standard\x20list\x20metadata.\n\x20More\
    \x20info:\x20https://git.k8s.io/community/contributors/devel/sig-archite\
    cture/api-conventions.md#types-kinds\n\x20+optional\n\n\x0e\n\x06\x04\
    \xb7\x01\x02\0\x04\x12\x04\x81%\x02\n\n\x0e\n\x06\x04\xb7\x01\x02\0\x06\
    \x12\x04\x81%\x0b8\n\x0e\n\x06\x04\xb7\x01\x02\0\x01\x12\x04\x81%9A\n\
    \x0e\n\x06\x04\xb7\x01\x02\0\x03\x12\x04\x81%DE\n!\n\x05\x04\xb7\x01\x02\
    \x01\x12\x04\x84%\x02\x1d\x1a\x12\x20List\x20of\x20services\n\n\x0e\n\
    \x06\x04\xb7\x01\x02\x01\x04\x12\x04\x84%\x02\n\n\x0e\n\x06\x04\xb7\x01\
    \x02\x01\x06\x12\x04\x84%\x0b\x12\n\x0e\n\x06\x04\xb7\x01\x02\x01\x01\
    \x12\x04\x84%\x13\x18\n\x0e\n\x06\x04\xb7\x01\x02\x01\x03\x12\x04\x84%\
    \x1b\x1c\nD\n\x03\x04\xb8\x01\x12\x06\x88%\0\xba%\x01\x1a5\x20ServicePor\
    t\x20contains\x20information\x20on\x20service's\x20port.\n\n\x0c\n\x04\
    \x04\xb8\x01\x01\x12\x04\x88%\x08\x13\n\xbc\x02\n\x05\x04\xb8\x01\x02\0\
    \x12\x04\x8f%\x02\x1b\x1a\xac\x02\x20The\x20name\x20of\x20this\x20port\
    \x20within\x20the\x20service.\x20This\x20must\x20be\x20a\x20DNS_LABEL.\n\
    \x20All\x20ports\x20within\x20a\x20ServiceSpec\x20must\x20have\x20unique\
    \x20names.\x20When\x20considering\n\x20the\x20endpoints\x20for\x20a\x20S\
    ervice,\x20this\x20must\x20match\x20the\x20'name'\x20field\x20in\x20the\
    \n\x20EndpointPort.\n\x20Optional\x20if\x20only\x20one\x20ServicePort\
    \x20is\x20defined\x20on\x20this\x20service.\n\x20+optional\n\n\x0e\n\x06\
    \x04\xb8\x01\x02\0\x04\x12\x04\x8f%\x02\n\n\x0e\n\x06\x04\xb8\x01\x02\0\
    \x05\x12\x04\x8f%\x0b\x11\n\x0e\n\x06\x04\xb8\x01\x02\0\x01\x12\x04\x8f%\
    \x12\x16\n\x0e\n\x06\x04\xb8\x01\x02\0\x03\x12\x04\x8f%\x19\x1a\nn\n\x05\
    \x04\xb8\x01\x02\x01\x12\x04\x94%\x02\x1f\x1a_\x20The\x20IP\x20protocol\
    \x20for\x20this\x20port.\x20Supports\x20\"TCP\",\x20\"UDP\",\x20and\x20\
    \"SCTP\".\n\x20Default\x20is\x20TCP.\n\x20+optional\n\n\x0e\n\x06\x04\
    \xb8\x01\x02\x01\x04\x12\x04\x94%\x02\n\n\x0e\n\x06\x04\xb8\x01\x02\x01\
    \x05\x12\x04\x94%\x0b\x11\n\x0e\n\x06\x04\xb8\x01\x02\x01\x01\x12\x04\
    \x94%\x12\x1a\n\x0e\n\x06\x04\xb8\x01\x02\x01\x03\x12\x04\x94%\x1d\x1e\n\
    \xc3\x03\n\x05\x04\xb8\x01\x02\x02\x12\x04\x9f%\x02\"\x1a\xb3\x03\x20The\
    \x20application\x20protocol\x20for\x20this\x20port.\n\x20This\x20field\
    \x20follows\x20standard\x20Kubernetes\x20label\x20syntax.\n\x20Un-prefix\
    ed\x20names\x20are\x20reserved\x20for\x20IANA\x20standard\x20service\x20\
    names\x20(as\x20per\n\x20RFC-6335\x20and\x20http://www.iana.org/assignme\
    nts/service-names).\n\x20Non-standard\x20protocols\x20should\x20use\x20p\
    refixed\x20names\x20such\x20as\n\x20mycompany.com/my-custom-protocol.\n\
    \x20This\x20is\x20a\x20beta\x20field\x20that\x20is\x20guarded\x20by\x20t\
    he\x20ServiceAppProtocol\x20feature\n\x20gate\x20and\x20enabled\x20by\
    \x20default.\n\x20+optional\n\n\x0e\n\x06\x04\xb8\x01\x02\x02\x04\x12\
    \x04\x9f%\x02\n\n\x0e\n\x06\x04\xb8\x01\x02\x02\x05\x12\x04\x9f%\x0b\x11\
    \n\x0e\n\x06\x04\xb8\x01\x02\x02\x01\x12\x04\x9f%\x12\x1d\n\x0e\n\x06\
    \x04\xb8\x01\x02\x02\x03\x12\x04\x9f%\x20!\n?\n\x05\x04\xb8\x01\x02\x03\
    \x12\x04\xa2%\x02\x1a\x1a0\x20The\x20port\x20that\x20will\x20be\x20expos\
    ed\x20by\x20this\x20service.\n\n\x0e\n\x06\x04\xb8\x01\x02\x03\x04\x12\
    \x04\xa2%\x02\n\n\x0e\n\x06\x04\xb8\x01\x02\x03\x05\x12\x04\xa2%\x0b\x10\
    \n\x0e\n\x06\x04\xb8\x01\x02\x03\x01\x12\x04\xa2%\x11\x15\n\x0e\n\x06\
    \x04\xb8\x01\x02\x03\x03\x12\x04\xa2%\x18\x19\n\xb5\x04\n\x05\x04\xb8\
    \x01\x02\x04\x12\x04\xad%\x02J\x1a\xa5\x04\x20Number\x20or\x20name\x20of\
    \x20the\x20port\x20to\x20access\x20on\x20the\x20pods\x20targeted\x20by\
    \x20the\x20service.\n\x20Number\x20must\x20be\x20in\x20the\x20range\x201\
    \x20to\x2065535.\x20Name\x20must\x20be\x20an\x20IANA_SVC_NAME.\n\x20If\
    \x20this\x20is\x20a\x20string,\x20it\x20will\x20be\x20looked\x20up\x20as\
    \x20a\x20named\x20port\x20in\x20the\n\x20target\x20Pod's\x20container\
    \x20ports.\x20If\x20this\x20is\x20not\x20specified,\x20the\x20value\n\
    \x20of\x20the\x20'port'\x20field\x20is\x20used\x20(an\x20identity\x20map\
    ).\n\x20This\x20field\x20is\x20ignored\x20for\x20services\x20with\x20clu\
    sterIP=None,\x20and\x20should\x20be\n\x20omitted\x20or\x20set\x20equal\
    \x20to\x20the\x20'port'\x20field.\n\x20More\x20info:\x20https://kubernet\
    es.io/docs/concepts/services-networking/service/#defining-a-service\n\
    \x20+optional\n\n\x0e\n\x06\x04\xb8\x01\x02\x04\x04\x12\x04\xad%\x02\n\n\
    \x0e\n\x06\x04\xb8\x01\x02\x04\x06\x12\x04\xad%\x0b:\n\x0e\n\x06\x04\xb8\
    \x01\x02\x04\x01\x12\x04\xad%;E\n\x0e\n\x06\x04\xb8\x01\x02\x04\x03\x12\
    \x04\xad%HI\n\x84\x05\n\x05\x04\xb8\x01\x02\x05\x12\x04\xb9%\x02\x1e\x1a\
    \xf4\x04\x20The\x20port\x20on\x20each\x20node\x20on\x20which\x20this\x20\
    service\x20is\x20exposed\x20when\x20type\x20is\n\x20NodePort\x20or\x20Lo\
    adBalancer.\x20\x20Usually\x20assigned\x20by\x20the\x20system.\x20If\x20\
    a\x20value\x20is\n\x20specified,\x20in-range,\x20and\x20not\x20in\x20use\
    \x20it\x20will\x20be\x20used,\x20otherwise\x20the\n\x20operation\x20will\
    \x20fail.\x20\x20If\x20not\x20specified,\x20a\x20port\x20will\x20be\x20a\
    llocated\x20if\x20this\n\x20Service\x20requires\x20one.\x20\x20If\x20thi\
    s\x20field\x20is\x20specified\x20when\x20creating\x20a\n\x20Service\x20w\
    hich\x20does\x20not\x20need\x20it,\x20creation\x20will\x20fail.\x20This\
    \x20field\x20will\x20be\n\x20wiped\x20when\x20updating\x20a\x20Service\
    \x20to\x20no\x20longer\x20need\x20it\x20(e.g.\x20changing\x20type\n\x20f\
    rom\x20NodePort\x20to\x20ClusterIP).\n\x20More\x20info:\x20https://kuber\
    netes.io/docs/concepts/services-networking/service/#type-nodeport\n\x20+\
    optional\n\n\x0e\n\x06\x04\xb8\x01\x02\x05\x04\x12\x04\xb9%\x02\n\n\x0e\
    \n\x06\x04\xb8\x01\x02\x05\x05\x12\x04\xb9%\x0b\x10\n\x0e\n\x06\x04\xb8\
    \x01\x02\x05\x01\x12\x04\xb9%\x11\x19\n\x0e\n\x06\x04\xb8\x01\x02\x05\
    \x03\x12\x04\xb9%\x1c\x1d\nT\n\x03\x04\xb9\x01\x12\x06\xbd%\0\xc5%\x01\
    \x1aE\x20ServiceProxyOptions\x20is\x20the\x20query\x20options\x20to\x20a\
    \x20Service's\x20proxy\x20call.\n\n\x0c\n\x04\x04\xb9\x01\x01\x12\x04\
    \xbd%\x08\x1b\n\xcd\x02\n\x05\x04\xb9\x01\x02\0\x12\x04\xc4%\x02\x1b\x1a\
    \xbd\x02\x20Path\x20is\x20the\x20part\x20of\x20URLs\x20that\x20include\
    \x20service\x20endpoints,\x20suffixes,\n\x20and\x20parameters\x20to\x20u\
    se\x20for\x20the\x20current\x20proxy\x20request\x20to\x20service.\n\x20F\
    or\x20example,\x20the\x20whole\x20request\x20URL\x20is\n\x20http://local\
    host/api/v1/namespaces/kube-system/services/elasticsearch-logging/_searc\
    h?q=user:kimchy.\n\x20Path\x20is\x20_search?q=user:kimchy.\n\x20+optiona\
    l\n\n\x0e\n\x06\x04\xb9\x01\x02\0\x04\x12\x04\xc4%\x02\n\n\x0e\n\x06\x04\
    \xb9\x01\x02\0\x05\x12\x04\xc4%\x0b\x11\n\x0e\n\x06\x04\xb9\x01\x02\0\
    \x01\x12\x04\xc4%\x12\x16\n\x0e\n\x06\x04\xb9\x01\x02\0\x03\x12\x04\xc4%\
    \x19\x1a\nW\n\x03\x04\xba\x01\x12\x06\xc8%\0\xa1'\x01\x1aH\x20ServiceSpe\
    c\x20describes\x20the\x20attributes\x20that\x20a\x20user\x20creates\x20o\
    n\x20a\x20service.\n\n\x0c\n\x04\x04\xba\x01\x01\x12\x04\xc8%\x08\x13\n\
    \x94\x02\n\x05\x04\xba\x01\x02\0\x12\x04\xd0%\x02!\x1a\x84\x02\x20The\
    \x20list\x20of\x20ports\x20that\x20are\x20exposed\x20by\x20this\x20servi\
    ce.\n\x20More\x20info:\x20https://kubernetes.io/docs/concepts/services-n\
    etworking/service/#virtual-ips-and-service-proxies\n\x20+patchMergeKey=p\
    ort\n\x20+patchStrategy=merge\n\x20+listType=map\n\x20+listMapKey=port\n\
    \x20+listMapKey=protocol\n\n\x0e\n\x06\x04\xba\x01\x02\0\x04\x12\x04\xd0\
    %\x02\n\n\x0e\n\x06\x04\xba\x01\x02\0\x06\x12\x04\xd0%\x0b\x16\n\x0e\n\
    \x06\x04\xba\x01\x02\0\x01\x12\x04\xd0%\x17\x1c\n\x0e\n\x06\x04\xba\x01\
    \x02\0\x03\x12\x04\xd0%\x1f\x20\n\xa2\x03\n\x05\x04\xba\x01\x02\x01\x12\
    \x04\xd9%\x02#\x1a\x92\x03\x20Route\x20service\x20traffic\x20to\x20pods\
    \x20with\x20label\x20keys\x20and\x20values\x20matching\x20this\n\x20sele\
    ctor.\x20If\x20empty\x20or\x20not\x20present,\x20the\x20service\x20is\
    \x20assumed\x20to\x20have\x20an\n\x20external\x20process\x20managing\x20\
    its\x20endpoints,\x20which\x20Kubernetes\x20will\x20not\n\x20modify.\x20\
    Only\x20applies\x20to\x20types\x20ClusterIP,\x20NodePort,\x20and\x20Load\
    Balancer.\n\x20Ignored\x20if\x20type\x20is\x20ExternalName.\n\x20More\
    \x20info:\x20https://kubernetes.io/docs/concepts/services-networking/ser\
    vice/\n\x20+optional\n\n\x10\n\x06\x04\xba\x01\x02\x01\x04\x12\x06\xd9%\
    \x02\xd0%!\n\x0e\n\x06\x04\xba\x01\x02\x01\x06\x12\x04\xd9%\x02\x15\n\
    \x0e\n\x06\x04\xba\x01\x02\x01\x01\x12\x04\xd9%\x16\x1e\n\x0e\n\x06\x04\
    \xba\x01\x02\x01\x03\x12\x04\xd9%!\"\n\xf0\x08\n\x05\x04\xba\x01\x02\x02\
    \x12\x04\xeb%\x02\x20\x1a\xe0\x08\x20clusterIP\x20is\x20the\x20IP\x20add\
    ress\x20of\x20the\x20service\x20and\x20is\x20usually\x20assigned\n\x20ra\
    ndomly.\x20If\x20an\x20address\x20is\x20specified\x20manually,\x20is\x20\
    in-range\x20(as\x20per\n\x20system\x20configuration),\x20and\x20is\x20no\
    t\x20in\x20use,\x20it\x20will\x20be\x20allocated\x20to\x20the\n\x20servi\
    ce;\x20otherwise\x20creation\x20of\x20the\x20service\x20will\x20fail.\
    \x20This\x20field\x20may\x20not\n\x20be\x20changed\x20through\x20updates\
    \x20unless\x20the\x20type\x20field\x20is\x20also\x20being\x20changed\n\
    \x20to\x20ExternalName\x20(which\x20requires\x20this\x20field\x20to\x20b\
    e\x20blank)\x20or\x20the\x20type\n\x20field\x20is\x20being\x20changed\
    \x20from\x20ExternalName\x20(in\x20which\x20case\x20this\x20field\x20may\
    \n\x20optionally\x20be\x20specified,\x20as\x20describe\x20above).\x20\
    \x20Valid\x20values\x20are\x20\"None\",\n\x20empty\x20string\x20(\"\"),\
    \x20or\x20a\x20valid\x20IP\x20address.\x20Setting\x20this\x20to\x20\"Non\
    e\"\x20makes\x20a\n\x20\"headless\x20service\"\x20(no\x20virtual\x20IP),\
    \x20which\x20is\x20useful\x20when\x20direct\x20endpoint\n\x20connections\
    \x20are\x20preferred\x20and\x20proxying\x20is\x20not\x20required.\x20\
    \x20Only\x20applies\x20to\n\x20types\x20ClusterIP,\x20NodePort,\x20and\
    \x20LoadBalancer.\x20If\x20this\x20field\x20is\x20specified\n\x20when\
    \x20creating\x20a\x20Service\x20of\x20type\x20ExternalName,\x20creation\
    \x20will\x20fail.\x20This\n\x20field\x20will\x20be\x20wiped\x20when\x20u\
    pdating\x20a\x20Service\x20to\x20type\x20ExternalName.\n\x20More\x20info\
    :\x20https://kubernetes.io/docs/concepts/services-networking/service/#vi\
    rtual-ips-and-service-proxies\n\x20+optional\n\n\x0e\n\x06\x04\xba\x01\
    \x02\x02\x04\x12\x04\xeb%\x02\n\n\x0e\n\x06\x04\xba\x01\x02\x02\x05\x12\
    \x04\xeb%\x0b\x11\n\x0e\n\x06\x04\xba\x01\x02\x02\x01\x12\x04\xeb%\x12\
    \x1b\n\x0e\n\x06\x04\xba\x01\x02\x02\x03\x12\x04\xeb%\x1e\x1f\n\xe0\r\n\
    \x05\x04\xba\x01\x02\x03\x12\x04\x89&\x02\"\x1a\xd0\r\x20ClusterIPs\x20i\
    s\x20a\x20list\x20of\x20IP\x20addresses\x20assigned\x20to\x20this\x20ser\
    vice,\x20and\x20are\n\x20usually\x20assigned\x20randomly.\x20\x20If\x20a\
    n\x20address\x20is\x20specified\x20manually,\x20is\n\x20in-range\x20(as\
    \x20per\x20system\x20configuration),\x20and\x20is\x20not\x20in\x20use,\
    \x20it\x20will\x20be\n\x20allocated\x20to\x20the\x20service;\x20otherwis\
    e\x20creation\x20of\x20the\x20service\x20will\x20fail.\n\x20This\x20fiel\
    d\x20may\x20not\x20be\x20changed\x20through\x20updates\x20unless\x20the\
    \x20type\x20field\x20is\n\x20also\x20being\x20changed\x20to\x20ExternalN\
    ame\x20(which\x20requires\x20this\x20field\x20to\x20be\n\x20empty)\x20or\
    \x20the\x20type\x20field\x20is\x20being\x20changed\x20from\x20ExternalNa\
    me\x20(in\x20which\n\x20case\x20this\x20field\x20may\x20optionally\x20be\
    \x20specified,\x20as\x20describe\x20above).\x20\x20Valid\n\x20values\x20\
    are\x20\"None\",\x20empty\x20string\x20(\"\"),\x20or\x20a\x20valid\x20IP\
    \x20address.\x20\x20Setting\n\x20this\x20to\x20\"None\"\x20makes\x20a\
    \x20\"headless\x20service\"\x20(no\x20virtual\x20IP),\x20which\x20is\n\
    \x20useful\x20when\x20direct\x20endpoint\x20connections\x20are\x20prefer\
    red\x20and\x20proxying\x20is\n\x20not\x20required.\x20\x20Only\x20applie\
    s\x20to\x20types\x20ClusterIP,\x20NodePort,\x20and\n\x20LoadBalancer.\
    \x20If\x20this\x20field\x20is\x20specified\x20when\x20creating\x20a\x20S\
    ervice\x20of\x20type\n\x20ExternalName,\x20creation\x20will\x20fail.\x20\
    This\x20field\x20will\x20be\x20wiped\x20when\x20updating\n\x20a\x20Servi\
    ce\x20to\x20type\x20ExternalName.\x20\x20If\x20this\x20field\x20is\x20no\
    t\x20specified,\x20it\x20will\n\x20be\x20initialized\x20from\x20the\x20c\
    lusterIP\x20field.\x20\x20If\x20this\x20field\x20is\x20specified,\n\x20c\
    lients\x20must\x20ensure\x20that\x20clusterIPs[0]\x20and\x20clusterIP\
    \x20have\x20the\x20same\n\x20value.\n\n\x20Unless\x20the\x20\"IPv6DualSt\
    ack\"\x20feature\x20gate\x20is\x20enabled,\x20this\x20field\x20is\n\x20l\
    imited\x20to\x20one\x20value,\x20which\x20must\x20be\x20the\x20same\x20a\
    s\x20the\x20clusterIP\x20field.\x20\x20If\n\x20the\x20feature\x20gate\
    \x20is\x20enabled,\x20this\x20field\x20may\x20hold\x20a\x20maximum\x20of\
    \x20two\n\x20entries\x20(dual-stack\x20IPs,\x20in\x20either\x20order).\
    \x20\x20These\x20IPs\x20must\x20correspond\x20to\n\x20the\x20values\x20o\
    f\x20the\x20ipFamilies\x20field.\x20Both\x20clusterIPs\x20and\x20ipFamil\
    ies\x20are\n\x20governed\x20by\x20the\x20ipFamilyPolicy\x20field.\n\x20M\
    ore\x20info:\x20https://kubernetes.io/docs/concepts/services-networking/\
    service/#virtual-ips-and-service-proxies\n\x20+listType=atomic\n\x20+opt\
    ional\n\n\x0e\n\x06\x04\xba\x01\x02\x03\x04\x12\x04\x89&\x02\n\n\x0e\n\
    \x06\x04\xba\x01\x02\x03\x05\x12\x04\x89&\x0b\x11\n\x0e\n\x06\x04\xba\
    \x01\x02\x03\x01\x12\x04\x89&\x12\x1c\n\x0e\n\x06\x04\xba\x01\x02\x03\
    \x03\x12\x04\x89&\x1f!\n\xa0\x08\n\x05\x04\xba\x01\x02\x04\x12\x04\x9c&\
    \x02\x1b\x1a\x90\x08\x20type\x20determines\x20how\x20the\x20Service\x20i\
    s\x20exposed.\x20Defaults\x20to\x20ClusterIP.\x20Valid\n\x20options\x20a\
    re\x20ExternalName,\x20ClusterIP,\x20NodePort,\x20and\x20LoadBalancer.\n\
    \x20\"ClusterIP\"\x20allocates\x20a\x20cluster-internal\x20IP\x20address\
    \x20for\x20load-balancing\n\x20to\x20endpoints.\x20Endpoints\x20are\x20d\
    etermined\x20by\x20the\x20selector\x20or\x20if\x20that\x20is\x20not\n\
    \x20specified,\x20by\x20manual\x20construction\x20of\x20an\x20Endpoints\
    \x20object\x20or\n\x20EndpointSlice\x20objects.\x20If\x20clusterIP\x20is\
    \x20\"None\",\x20no\x20virtual\x20IP\x20is\n\x20allocated\x20and\x20the\
    \x20endpoints\x20are\x20published\x20as\x20a\x20set\x20of\x20endpoints\
    \x20rather\n\x20than\x20a\x20virtual\x20IP.\n\x20\"NodePort\"\x20builds\
    \x20on\x20ClusterIP\x20and\x20allocates\x20a\x20port\x20on\x20every\x20n\
    ode\x20which\n\x20routes\x20to\x20the\x20same\x20endpoints\x20as\x20the\
    \x20clusterIP.\n\x20\"LoadBalancer\"\x20builds\x20on\x20NodePort\x20and\
    \x20creates\x20an\x20external\x20load-balancer\n\x20(if\x20supported\x20\
    in\x20the\x20current\x20cloud)\x20which\x20routes\x20to\x20the\x20same\
    \x20endpoints\n\x20as\x20the\x20clusterIP.\n\x20\"ExternalName\"\x20alia\
    ses\x20this\x20service\x20to\x20the\x20specified\x20externalName.\n\x20S\
    everal\x20other\x20fields\x20do\x20not\x20apply\x20to\x20ExternalName\
    \x20services.\n\x20More\x20info:\x20https://kubernetes.io/docs/concepts/\
    services-networking/service/#publishing-services-service-types\n\x20+opt\
    ional\n\n\x0e\n\x06\x04\xba\x01\x02\x04\x04\x12\x04\x9c&\x02\n\n\x0e\n\
    \x06\x04\xba\x01\x02\x04\x05\x12\x04\x9c&\x0b\x11\n\x0e\n\x06\x04\xba\
    \x01\x02\x04\x01\x12\x04\x9c&\x12\x16\n\x0e\n\x06\x04\xba\x01\x02\x04\
    \x03\x12\x04\x9c&\x19\x1a\n\xe6\x02\n\x05\x04\xba\x01\x02\x05\x12\x04\
    \xa4&\x02\"\x1a\xd6\x02\x20externalIPs\x20is\x20a\x20list\x20of\x20IP\
    \x20addresses\x20for\x20which\x20nodes\x20in\x20the\x20cluster\n\x20will\
    \x20also\x20accept\x20traffic\x20for\x20this\x20service.\x20\x20These\
    \x20IPs\x20are\x20not\x20managed\x20by\n\x20Kubernetes.\x20\x20The\x20us\
    er\x20is\x20responsible\x20for\x20ensuring\x20that\x20traffic\x20arrives\
    \n\x20at\x20a\x20node\x20with\x20this\x20IP.\x20\x20A\x20common\x20examp\
    le\x20is\x20external\x20load-balancers\n\x20that\x20are\x20not\x20part\
    \x20of\x20the\x20Kubernetes\x20system.\n\x20+optional\n\n\x0e\n\x06\x04\
    \xba\x01\x02\x05\x04\x12\x04\xa4&\x02\n\n\x0e\n\x06\x04\xba\x01\x02\x05\
    \x05\x12\x04\xa4&\x0b\x11\n\x0e\n\x06\x04\xba\x01\x02\x05\x01\x12\x04\
    \xa4&\x12\x1d\n\x0e\n\x06\x04\xba\x01\x02\x05\x03\x12\x04\xa4&\x20!\n\
    \xa4\x02\n\x05\x04\xba\x01\x02\x06\x12\x04\xac&\x02&\x1a\x94\x02\x20Supp\
    orts\x20\"ClientIP\"\x20and\x20\"None\".\x20Used\x20to\x20maintain\x20se\
    ssion\x20affinity.\n\x20Enable\x20client\x20IP\x20based\x20session\x20af\
    finity.\n\x20Must\x20be\x20ClientIP\x20or\x20None.\n\x20Defaults\x20to\
    \x20None.\n\x20More\x20info:\x20https://kubernetes.io/docs/concepts/serv\
    ices-networking/service/#virtual-ips-and-service-proxies\n\x20+optional\
    \n\n\x0e\n\x06\x04\xba\x01\x02\x06\x04\x12\x04\xac&\x02\n\n\x0e\n\x06\
    \x04\xba\x01\x02\x06\x05\x12\x04\xac&\x0b\x11\n\x0e\n\x06\x04\xba\x01\
    \x02\x06\x01\x12\x04\xac&\x12!\n\x0e\n\x06\x04\xba\x01\x02\x06\x03\x12\
    \x04\xac&$%\n\xe3\x02\n\x05\x04\xba\x01\x02\x07\x12\x04\xb4&\x02%\x1a\
    \xd3\x02\x20Only\x20applies\x20to\x20Service\x20Type:\x20LoadBalancer\n\
    \x20LoadBalancer\x20will\x20get\x20created\x20with\x20the\x20IP\x20speci\
    fied\x20in\x20this\x20field.\n\x20This\x20feature\x20depends\x20on\x20wh\
    ether\x20the\x20underlying\x20cloud-provider\x20supports\x20specifying\n\
    \x20the\x20loadBalancerIP\x20when\x20a\x20load\x20balancer\x20is\x20crea\
    ted.\n\x20This\x20field\x20will\x20be\x20ignored\x20if\x20the\x20cloud-p\
    rovider\x20does\x20not\x20support\x20the\x20feature.\n\x20+optional\n\n\
    \x0e\n\x06\x04\xba\x01\x02\x07\x04\x12\x04\xb4&\x02\n\n\x0e\n\x06\x04\
    \xba\x01\x02\x07\x05\x12\x04\xb4&\x0b\x11\n\x0e\n\x06\x04\xba\x01\x02\
    \x07\x01\x12\x04\xb4&\x12\x20\n\x0e\n\x06\x04\xba\x01\x02\x07\x03\x12\
    \x04\xb4&#$\n\xf9\x02\n\x05\x04\xba\x01\x02\x08\x12\x04\xbb&\x02/\x1a\
    \xe9\x02\x20If\x20specified\x20and\x20supported\x20by\x20the\x20platform\
    ,\x20this\x20will\x20restrict\x20traffic\x20through\x20the\x20cloud-prov\
    ider\n\x20load-balancer\x20will\x20be\x20restricted\x20to\x20the\x20spec\
    ified\x20client\x20IPs.\x20This\x20field\x20will\x20be\x20ignored\x20if\
    \x20the\n\x20cloud-provider\x20does\x20not\x20support\x20the\x20feature.\
    \"\n\x20More\x20info:\x20https://kubernetes.io/docs/tasks/access-applica\
    tion-cluster/configure-cloud-provider-firewall/\n\x20+optional\n\n\x0e\n\
    \x06\x04\xba\x01\x02\x08\x04\x12\x04\xbb&\x02\n\n\x0e\n\x06\x04\xba\x01\
    \x02\x08\x05\x12\x04\xbb&\x0b\x11\n\x0e\n\x06\x04\xba\x01\x02\x08\x01\
    \x12\x04\xbb&\x12*\n\x0e\n\x06\x04\xba\x01\x02\x08\x03\x12\x04\xbb&-.\n\
    \xa7\x02\n\x05\x04\xba\x01\x02\t\x12\x04\xc2&\x02$\x1a\x97\x02\x20extern\
    alName\x20is\x20the\x20external\x20reference\x20that\x20discovery\x20mec\
    hanisms\x20will\n\x20return\x20as\x20an\x20alias\x20for\x20this\x20servi\
    ce\x20(e.g.\x20a\x20DNS\x20CNAME\x20record).\x20No\n\x20proxying\x20will\
    \x20be\x20involved.\x20\x20Must\x20be\x20a\x20lowercase\x20RFC-1123\x20h\
    ostname\n\x20(https://tools.ietf.org/html/rfc1123)\x20and\x20requires\
    \x20Type\x20to\x20be\n\x20+optional\n\n\x0e\n\x06\x04\xba\x01\x02\t\x04\
    \x12\x04\xc2&\x02\n\n\x0e\n\x06\x04\xba\x01\x02\t\x05\x12\x04\xc2&\x0b\
    \x11\n\x0e\n\x06\x04\xba\x01\x02\t\x01\x12\x04\xc2&\x12\x1e\n\x0e\n\x06\
    \x04\xba\x01\x02\t\x03\x12\x04\xc2&!#\n\xbb\x03\n\x05\x04\xba\x01\x02\n\
    \x12\x04\xcb&\x02-\x1a\xab\x03\x20externalTrafficPolicy\x20denotes\x20if\
    \x20this\x20Service\x20desires\x20to\x20route\x20external\n\x20traffic\
    \x20to\x20node-local\x20or\x20cluster-wide\x20endpoints.\x20\"Local\"\
    \x20preserves\x20the\n\x20client\x20source\x20IP\x20and\x20avoids\x20a\
    \x20second\x20hop\x20for\x20LoadBalancer\x20and\x20Nodeport\n\x20type\
    \x20services,\x20but\x20risks\x20potentially\x20imbalanced\x20traffic\
    \x20spreading.\n\x20\"Cluster\"\x20obscures\x20the\x20client\x20source\
    \x20IP\x20and\x20may\x20cause\x20a\x20second\x20hop\x20to\n\x20another\
    \x20node,\x20but\x20should\x20have\x20good\x20overall\x20load-spreading.\
    \n\x20+optional\n\n\x0e\n\x06\x04\xba\x01\x02\n\x04\x12\x04\xcb&\x02\n\n\
    \x0e\n\x06\x04\xba\x01\x02\n\x05\x12\x04\xcb&\x0b\x11\n\x0e\n\x06\x04\
    \xba\x01\x02\n\x01\x12\x04\xcb&\x12'\n\x0e\n\x06\x04\xba\x01\x02\n\x03\
    \x12\x04\xcb&*,\n\x8c\x05\n\x05\x04\xba\x01\x02\x0b\x12\x04\xd7&\x02*\
    \x1a\xfc\x04\x20healthCheckNodePort\x20specifies\x20the\x20healthcheck\
    \x20nodePort\x20for\x20the\x20service.\n\x20This\x20only\x20applies\x20w\
    hen\x20type\x20is\x20set\x20to\x20LoadBalancer\x20and\n\x20externalTraff\
    icPolicy\x20is\x20set\x20to\x20Local.\x20If\x20a\x20value\x20is\x20speci\
    fied,\x20is\n\x20in-range,\x20and\x20is\x20not\x20in\x20use,\x20it\x20wi\
    ll\x20be\x20used.\x20\x20If\x20not\x20specified,\x20a\x20value\n\x20will\
    \x20be\x20automatically\x20allocated.\x20\x20External\x20systems\x20(e.g\
    .\x20load-balancers)\n\x20can\x20use\x20this\x20port\x20to\x20determine\
    \x20if\x20a\x20given\x20node\x20holds\x20endpoints\x20for\x20this\n\x20s\
    ervice\x20or\x20not.\x20\x20If\x20this\x20field\x20is\x20specified\x20wh\
    en\x20creating\x20a\x20Service\n\x20which\x20does\x20not\x20need\x20it,\
    \x20creation\x20will\x20fail.\x20This\x20field\x20will\x20be\x20wiped\n\
    \x20when\x20updating\x20a\x20Service\x20to\x20no\x20longer\x20need\x20it\
    \x20(e.g.\x20changing\x20type).\n\x20+optional\n\n\x0e\n\x06\x04\xba\x01\
    \x02\x0b\x04\x12\x04\xd7&\x02\n\n\x0e\n\x06\x04\xba\x01\x02\x0b\x05\x12\
    \x04\xd7&\x0b\x10\n\x0e\n\x06\x04\xba\x01\x02\x0b\x01\x12\x04\xd7&\x11$\
    \n\x0e\n\x06\x04\xba\x01\x02\x0b\x03\x12\x04\xd7&')\n\xa4\x05\n\x05\x04\
    \xba\x01\x02\x0c\x12\x04\xe2&\x02.\x1a\x94\x05\x20publishNotReadyAddress\
    es\x20indicates\x20that\x20any\x20agent\x20which\x20deals\x20with\x20end\
    points\x20for\x20this\n\x20Service\x20should\x20disregard\x20any\x20indi\
    cations\x20of\x20ready/not-ready.\n\x20The\x20primary\x20use\x20case\x20\
    for\x20setting\x20this\x20field\x20is\x20for\x20a\x20StatefulSet's\x20He\
    adless\x20Service\x20to\n\x20propagate\x20SRV\x20DNS\x20records\x20for\
    \x20its\x20Pods\x20for\x20the\x20purpose\x20of\x20peer\x20discovery.\n\
    \x20The\x20Kubernetes\x20controllers\x20that\x20generate\x20Endpoints\
    \x20and\x20EndpointSlice\x20resources\x20for\n\x20Services\x20interpret\
    \x20this\x20to\x20mean\x20that\x20all\x20endpoints\x20are\x20considered\
    \x20\"ready\"\x20even\x20if\x20the\n\x20Pods\x20themselves\x20are\x20not\
    .\x20Agents\x20which\x20consume\x20only\x20Kubernetes\x20generated\x20en\
    dpoints\n\x20through\x20the\x20Endpoints\x20or\x20EndpointSlice\x20resou\
    rces\x20can\x20safely\x20assume\x20this\x20behavior.\n\x20+optional\n\n\
    \x0e\n\x06\x04\xba\x01\x02\x0c\x04\x12\x04\xe2&\x02\n\n\x0e\n\x06\x04\
    \xba\x01\x02\x0c\x05\x12\x04\xe2&\x0b\x0f\n\x0e\n\x06\x04\xba\x01\x02\
    \x0c\x01\x12\x04\xe2&\x10(\n\x0e\n\x06\x04\xba\x01\x02\x0c\x03\x12\x04\
    \xe2&+-\nb\n\x05\x04\xba\x01\x02\r\x12\x04\xe6&\x02<\x1aS\x20sessionAffi\
    nityConfig\x20contains\x20the\x20configurations\x20of\x20session\x20affi\
    nity.\n\x20+optional\n\n\x0e\n\x06\x04\xba\x01\x02\r\x04\x12\x04\xe6&\
    \x02\n\n\x0e\n\x06\x04\xba\x01\x02\r\x06\x12\x04\xe6&\x0b\x20\n\x0e\n\
    \x06\x04\xba\x01\x02\r\x01\x12\x04\xe6&!6\n\x0e\n\x06\x04\xba\x01\x02\r\
    \x03\x12\x04\xe6&9;\n\x8e\x07\n\x05\x04\xba\x01\x02\x0e\x12\x04\xf6&\x02\
    $\x1a\xfe\x06\x20topologyKeys\x20is\x20a\x20preference-order\x20list\x20\
    of\x20topology\x20keys\x20which\n\x20implementations\x20of\x20services\
    \x20should\x20use\x20to\x20preferentially\x20sort\x20endpoints\n\x20when\
    \x20accessing\x20this\x20Service,\x20it\x20can\x20not\x20be\x20used\x20a\
    t\x20the\x20same\x20time\x20as\n\x20externalTrafficPolicy=Local.\n\x20To\
    pology\x20keys\x20must\x20be\x20valid\x20label\x20keys\x20and\x20at\x20m\
    ost\x2016\x20keys\x20may\x20be\x20specified.\n\x20Endpoints\x20are\x20ch\
    osen\x20based\x20on\x20the\x20first\x20topology\x20key\x20with\x20availa\
    ble\x20backends.\n\x20If\x20this\x20field\x20is\x20specified\x20and\x20a\
    ll\x20entries\x20have\x20no\x20backends\x20that\x20match\n\x20the\x20top\
    ology\x20of\x20the\x20client,\x20the\x20service\x20has\x20no\x20backends\
    \x20for\x20that\x20client\n\x20and\x20connections\x20should\x20fail.\n\
    \x20The\x20special\x20value\x20\"*\"\x20may\x20be\x20used\x20to\x20mean\
    \x20\"any\x20topology\".\x20This\x20catch-all\n\x20value,\x20if\x20used,\
    \x20only\x20makes\x20sense\x20as\x20the\x20last\x20value\x20in\x20the\
    \x20list.\n\x20If\x20this\x20is\x20not\x20specified\x20or\x20empty,\x20n\
    o\x20topology\x20constraints\x20will\x20be\x20applied.\n\x20This\x20fiel\
    d\x20is\x20alpha-level\x20and\x20is\x20only\x20honored\x20by\x20servers\
    \x20that\x20enable\x20the\x20ServiceTopology\x20feature.\n\x20+optional\
    \n\n\x0e\n\x06\x04\xba\x01\x02\x0e\x04\x12\x04\xf6&\x02\n\n\x0e\n\x06\
    \x04\xba\x01\x02\x0e\x05\x12\x04\xf6&\x0b\x11\n\x0e\n\x06\x04\xba\x01\
    \x02\x0e\x01\x12\x04\xf6&\x12\x1e\n\x0e\n\x06\x04\xba\x01\x02\x0e\x03\
    \x12\x04\xf6&!#\n\xdd\x08\n\x05\x04\xba\x01\x02\x0f\x12\x04\x8b'\x02\"\
    \x1a\xcd\x08\x20IPFamilies\x20is\x20a\x20list\x20of\x20IP\x20families\
    \x20(e.g.\x20IPv4,\x20IPv6)\x20assigned\x20to\x20this\n\x20service,\x20a\
    nd\x20is\x20gated\x20by\x20the\x20\"IPv6DualStack\"\x20feature\x20gate.\
    \x20\x20This\x20field\n\x20is\x20usually\x20assigned\x20automatically\
    \x20based\x20on\x20cluster\x20configuration\x20and\x20the\n\x20ipFamilyP\
    olicy\x20field.\x20If\x20this\x20field\x20is\x20specified\x20manually,\
    \x20the\x20requested\n\x20family\x20is\x20available\x20in\x20the\x20clus\
    ter,\x20and\x20ipFamilyPolicy\x20allows\x20it,\x20it\n\x20will\x20be\x20\
    used;\x20otherwise\x20creation\x20of\x20the\x20service\x20will\x20fail.\
    \x20\x20This\x20field\n\x20is\x20conditionally\x20mutable:\x20it\x20allo\
    ws\x20for\x20adding\x20or\x20removing\x20a\x20secondary\n\x20IP\x20famil\
    y,\x20but\x20it\x20does\x20not\x20allow\x20changing\x20the\x20primary\
    \x20IP\x20family\x20of\x20the\n\x20Service.\x20\x20Valid\x20values\x20ar\
    e\x20\"IPv4\"\x20and\x20\"IPv6\".\x20\x20This\x20field\x20only\x20applie\
    s\n\x20to\x20Services\x20of\x20types\x20ClusterIP,\x20NodePort,\x20and\
    \x20LoadBalancer,\x20and\x20does\n\x20apply\x20to\x20\"headless\"\x20ser\
    vices.\x20\x20This\x20field\x20will\x20be\x20wiped\x20when\x20updating\
    \x20a\n\x20Service\x20to\x20type\x20ExternalName.\n\n\x20This\x20field\
    \x20may\x20hold\x20a\x20maximum\x20of\x20two\x20entries\x20(dual-stack\
    \x20families,\x20in\n\x20either\x20order).\x20\x20These\x20families\x20m\
    ust\x20correspond\x20to\x20the\x20values\x20of\x20the\n\x20clusterIPs\
    \x20field,\x20if\x20specified.\x20Both\x20clusterIPs\x20and\x20ipFamilie\
    s\x20are\n\x20governed\x20by\x20the\x20ipFamilyPolicy\x20field.\n\x20+li\
    stType=atomic\n\x20+optional\n\n\x0e\n\x06\x04\xba\x01\x02\x0f\x04\x12\
    \x04\x8b'\x02\n\n\x0e\n\x06\x04\xba\x01\x02\x0f\x05\x12\x04\x8b'\x0b\x11\
    \n\x0e\n\x06\x04\xba\x01\x02\x0f\x01\x12\x04\x8b'\x12\x1c\n\x0e\n\x06\
    \x04\xba\x01\x02\x0f\x03\x12\x04\x8b'\x1f!\n\x8c\x05\n\x05\x04\xba\x01\
    \x02\x10\x12\x04\x97'\x02&\x1a\xfc\x04\x20IPFamilyPolicy\x20represents\
    \x20the\x20dual-stack-ness\x20requested\x20or\x20required\x20by\n\x20thi\
    s\x20Service,\x20and\x20is\x20gated\x20by\x20the\x20\"IPv6DualStack\"\
    \x20feature\x20gate.\x20\x20If\n\x20there\x20is\x20no\x20value\x20provid\
    ed,\x20then\x20this\x20field\x20will\x20be\x20set\x20to\x20SingleStack.\
    \n\x20Services\x20can\x20be\x20\"SingleStack\"\x20(a\x20single\x20IP\x20\
    family),\x20\"PreferDualStack\"\n\x20(two\x20IP\x20families\x20on\x20dua\
    l-stack\x20configured\x20clusters\x20or\x20a\x20single\x20IP\x20family\n\
    \x20on\x20single-stack\x20clusters),\x20or\x20\"RequireDualStack\"\x20(t\
    wo\x20IP\x20families\x20on\n\x20dual-stack\x20configured\x20clusters,\
    \x20otherwise\x20fail).\x20The\x20ipFamilies\x20and\n\x20clusterIPs\x20f\
    ields\x20depend\x20on\x20the\x20value\x20of\x20this\x20field.\x20\x20Thi\
    s\x20field\x20will\x20be\n\x20wiped\x20when\x20updating\x20a\x20service\
    \x20to\x20type\x20ExternalName.\n\x20+optional\n\n\x0e\n\x06\x04\xba\x01\
    \x02\x10\x04\x12\x04\x97'\x02\n\n\x0e\n\x06\x04\xba\x01\x02\x10\x05\x12\
    \x04\x97'\x0b\x11\n\x0e\n\x06\x04\xba\x01\x02\x10\x01\x12\x04\x97'\x12\
    \x20\n\x0e\n\x06\x04\xba\x01\x02\x10\x03\x12\x04\x97'#%\n\xfa\x03\n\x05\
    \x04\xba\x01\x02\x11\x12\x04\xa0'\x023\x1a\xea\x03\x20allocateLoadBalanc\
    erNodePorts\x20defines\x20if\x20NodePorts\x20will\x20be\x20automatically\
    \n\x20allocated\x20for\x20services\x20with\x20type\x20LoadBalancer.\x20\
    \x20Default\x20is\x20\"true\".\x20It\x20may\x20be\n\x20set\x20to\x20\"fa\
    lse\"\x20if\x20the\x20cluster\x20load-balancer\x20does\x20not\x20rely\
    \x20on\x20NodePorts.\n\x20allocateLoadBalancerNodePorts\x20may\x20only\
    \x20be\x20set\x20for\x20services\x20with\x20type\x20LoadBalancer\n\x20an\
    d\x20will\x20be\x20cleared\x20if\x20the\x20type\x20is\x20changed\x20to\
    \x20any\x20other\x20type.\n\x20This\x20field\x20is\x20alpha-level\x20and\
    \x20is\x20only\x20honored\x20by\x20servers\x20that\x20enable\x20the\x20S\
    erviceLBNodePortControl\x20feature.\n\x20+optional\n\n\x0e\n\x06\x04\xba\
    \x01\x02\x11\x04\x12\x04\xa0'\x02\n\n\x0e\n\x06\x04\xba\x01\x02\x11\x05\
    \x12\x04\xa0'\x0b\x0f\n\x0e\n\x06\x04\xba\x01\x02\x11\x01\x12\x04\xa0'\
    \x10-\n\x0e\n\x06\x04\xba\x01\x02\x11\x03\x12\x04\xa0'02\nJ\n\x03\x04\
    \xbb\x01\x12\x06\xa4'\0\xb1'\x01\x1a;\x20ServiceStatus\x20represents\x20\
    the\x20current\x20status\x20of\x20a\x20service.\n\n\x0c\n\x04\x04\xbb\
    \x01\x01\x12\x04\xa4'\x08\x15\nn\n\x05\x04\xbb\x01\x02\0\x12\x04\xa8'\
    \x02/\x1a_\x20LoadBalancer\x20contains\x20the\x20current\x20status\x20of\
    \x20the\x20load-balancer,\n\x20if\x20one\x20is\x20present.\n\x20+optiona\
    l\n\n\x0e\n\x06\x04\xbb\x01\x02\0\x04\x12\x04\xa8'\x02\n\n\x0e\n\x06\x04\
    \xbb\x01\x02\0\x06\x12\x04\xa8'\x0b\x1d\n\x0e\n\x06\x04\xbb\x01\x02\0\
    \x01\x12\x04\xa8'\x1e*\n\x0e\n\x06\x04\xbb\x01\x02\0\x03\x12\x04\xa8'-.\
    \n}\n\x05\x04\xbb\x01\x02\x01\x12\x04\xb0'\x02I\x1an\x20Current\x20servi\
    ce\x20state\n\x20+optional\n\x20+patchMergeKey=type\n\x20+patchStrategy=\
    merge\n\x20+listType=map\n\x20+listMapKey=type\n\n\x0e\n\x06\x04\xbb\x01\
    \x02\x01\x04\x12\x04\xb0'\x02\n\n\x0e\n\x06\x04\xbb\x01\x02\x01\x06\x12\
    \x04\xb0'\x0b9\n\x0e\n\x06\x04\xbb\x01\x02\x01\x01\x12\x04\xb0':D\n\x0e\
    \n\x06\x04\xbb\x01\x02\x01\x03\x12\x04\xb0'GH\nY\n\x03\x04\xbc\x01\x12\
    \x06\xb4'\0\xb8'\x01\x1aJ\x20SessionAffinityConfig\x20represents\x20the\
    \x20configurations\x20of\x20session\x20affinity.\n\n\x0c\n\x04\x04\xbc\
    \x01\x01\x12\x04\xb4'\x08\x1d\ne\n\x05\x04\xbc\x01\x02\0\x12\x04\xb7'\
    \x02'\x1aV\x20clientIP\x20contains\x20the\x20configurations\x20of\x20Cli\
    ent\x20IP\x20based\x20session\x20affinity.\n\x20+optional\n\n\x0e\n\x06\
    \x04\xbc\x01\x02\0\x04\x12\x04\xb7'\x02\n\n\x0e\n\x06\x04\xbc\x01\x02\0\
    \x06\x12\x04\xb7'\x0b\x19\n\x0e\n\x06\x04\xbc\x01\x02\0\x01\x12\x04\xb7'\
    \x1a\"\n\x0e\n\x06\x04\xbc\x01\x02\0\x03\x12\x04\xb7'%&\nC\n\x03\x04\xbd\
    \x01\x12\x06\xbb'\0\xd8'\x01\x1a4\x20Represents\x20a\x20StorageOS\x20per\
    sistent\x20volume\x20resource.\n\n\x0c\n\x04\x04\xbd\x01\x01\x12\x04\xbb\
    '\x08'\n\x82\x01\n\x05\x04\xbd\x01\x02\0\x12\x04\xbe'\x02!\x1as\x20Volum\
    eName\x20is\x20the\x20human-readable\x20name\x20of\x20the\x20StorageOS\
    \x20volume.\x20\x20Volume\n\x20names\x20are\x20only\x20unique\x20within\
    \x20a\x20namespace.\n\n\x0e\n\x06\x04\xbd\x01\x02\0\x04\x12\x04\xbe'\x02\
    \n\n\x0e\n\x06\x04\xbd\x01\x02\0\x05\x12\x04\xbe'\x0b\x11\n\x0e\n\x06\
    \x04\xbd\x01\x02\0\x01\x12\x04\xbe'\x12\x1c\n\x0e\n\x06\x04\xbd\x01\x02\
    \0\x03\x12\x04\xbe'\x1f\x20\n\xd0\x03\n\x05\x04\xbd\x01\x02\x01\x12\x04\
    \xc7'\x02&\x1a\xc0\x03\x20VolumeNamespace\x20specifies\x20the\x20scope\
    \x20of\x20the\x20volume\x20within\x20StorageOS.\x20\x20If\x20no\n\x20nam\
    espace\x20is\x20specified\x20then\x20the\x20Pod's\x20namespace\x20will\
    \x20be\x20used.\x20\x20This\x20allows\x20the\n\x20Kubernetes\x20name\x20\
    scoping\x20to\x20be\x20mirrored\x20within\x20StorageOS\x20for\x20tighter\
    \x20integration.\n\x20Set\x20VolumeName\x20to\x20any\x20name\x20to\x20ov\
    erride\x20the\x20default\x20behaviour.\n\x20Set\x20to\x20\"default\"\x20\
    if\x20you\x20are\x20not\x20using\x20namespaces\x20within\x20StorageOS.\n\
    \x20Namespaces\x20that\x20do\x20not\x20pre-exist\x20within\x20StorageOS\
    \x20will\x20be\x20created.\n\x20+optional\n\n\x0e\n\x06\x04\xbd\x01\x02\
    \x01\x04\x12\x04\xc7'\x02\n\n\x0e\n\x06\x04\xbd\x01\x02\x01\x05\x12\x04\
    \xc7'\x0b\x11\n\x0e\n\x06\x04\xbd\x01\x02\x01\x01\x12\x04\xc7'\x12!\n\
    \x0e\n\x06\x04\xbd\x01\x02\x01\x03\x12\x04\xc7'$%\n\xc6\x01\n\x05\x04\
    \xbd\x01\x02\x02\x12\x04\xcd'\x02\x1d\x1a\xb6\x01\x20Filesystem\x20type\
    \x20to\x20mount.\n\x20Must\x20be\x20a\x20filesystem\x20type\x20supported\
    \x20by\x20the\x20host\x20operating\x20system.\n\x20Ex.\x20\"ext4\",\x20\
    \"xfs\",\x20\"ntfs\".\x20Implicitly\x20inferred\x20to\x20be\x20\"ext4\"\
    \x20if\x20unspecified.\n\x20+optional\n\n\x0e\n\x06\x04\xbd\x01\x02\x02\
    \x04\x12\x04\xcd'\x02\n\n\x0e\n\x06\x04\xbd\x01\x02\x02\x05\x12\x04\xcd'\
    \x0b\x11\n\x0e\n\x06\x04\xbd\x01\x02\x02\x01\x12\x04\xcd'\x12\x18\n\x0e\
    \n\x06\x04\xbd\x01\x02\x02\x03\x12\x04\xcd'\x1b\x1c\n{\n\x05\x04\xbd\x01\
    \x02\x03\x12\x04\xd2'\x02\x1d\x1al\x20Defaults\x20to\x20false\x20(read/w\
    rite).\x20ReadOnly\x20here\x20will\x20force\n\x20the\x20ReadOnly\x20sett\
    ing\x20in\x20VolumeMounts.\n\x20+optional\n\n\x0e\n\x06\x04\xbd\x01\x02\
    \x03\x04\x12\x04\xd2'\x02\n\n\x0e\n\x06\x04\xbd\x01\x02\x03\x05\x12\x04\
    \xd2'\x0b\x0f\n\x0e\n\x06\x04\xbd\x01\x02\x03\x01\x12\x04\xd2'\x10\x18\n\
    \x0e\n\x06\x04\xbd\x01\x02\x03\x03\x12\x04\xd2'\x1b\x1c\n\xa5\x01\n\x05\
    \x04\xbd\x01\x02\x04\x12\x04\xd7'\x02)\x1a\x95\x01\x20SecretRef\x20speci\
    fies\x20the\x20secret\x20to\x20use\x20for\x20obtaining\x20the\x20Storage\
    OS\x20API\n\x20credentials.\x20\x20If\x20not\x20specified,\x20default\
    \x20values\x20will\x20be\x20attempted.\n\x20+optional\n\n\x0e\n\x06\x04\
    \xbd\x01\x02\x04\x04\x12\x04\xd7'\x02\n\n\x0e\n\x06\x04\xbd\x01\x02\x04\
    \x06\x12\x04\xd7'\x0b\x1a\n\x0e\n\x06\x04\xbd\x01\x02\x04\x01\x12\x04\
    \xd7'\x1b$\n\x0e\n\x06\x04\xbd\x01\x02\x04\x03\x12\x04\xd7''(\nC\n\x03\
    \x04\xbe\x01\x12\x06\xdb'\0\xf8'\x01\x1a4\x20Represents\x20a\x20StorageO\
    S\x20persistent\x20volume\x20resource.\n\n\x0c\n\x04\x04\xbe\x01\x01\x12\
    \x04\xdb'\x08\x1d\n\x82\x01\n\x05\x04\xbe\x01\x02\0\x12\x04\xde'\x02!\
    \x1as\x20VolumeName\x20is\x20the\x20human-readable\x20name\x20of\x20the\
    \x20StorageOS\x20volume.\x20\x20Volume\n\x20names\x20are\x20only\x20uniq\
    ue\x20within\x20a\x20namespace.\n\n\x0e\n\x06\x04\xbe\x01\x02\0\x04\x12\
    \x04\xde'\x02\n\n\x0e\n\x06\x04\xbe\x01\x02\0\x05\x12\x04\xde'\x0b\x11\n\
    \x0e\n\x06\x04\xbe\x01\x02\0\x01\x12\x04\xde'\x12\x1c\n\x0e\n\x06\x04\
    \xbe\x01\x02\0\x03\x12\x04\xde'\x1f\x20\n\xd0\x03\n\x05\x04\xbe\x01\x02\
    \x01\x12\x04\xe7'\x02&\x1a\xc0\x03\x20VolumeNamespace\x20specifies\x20th\
    e\x20scope\x20of\x20the\x20volume\x20within\x20StorageOS.\x20\x20If\x20n\
    o\n\x20namespace\x20is\x20specified\x20then\x20the\x20Pod's\x20namespace\
    \x20will\x20be\x20used.\x20\x20This\x20allows\x20the\n\x20Kubernetes\x20\
    name\x20scoping\x20to\x20be\x20mirrored\x20within\x20StorageOS\x20for\
    \x20tighter\x20integration.\n\x20Set\x20VolumeName\x20to\x20any\x20name\
    \x20to\x20override\x20the\x20default\x20behaviour.\n\x20Set\x20to\x20\"d\
    efault\"\x20if\x20you\x20are\x20not\x20using\x20namespaces\x20within\x20\
    StorageOS.\n\x20Namespaces\x20that\x20do\x20not\x20pre-exist\x20within\
    \x20StorageOS\x20will\x20be\x20created.\n\x20+optional\n\n\x0e\n\x06\x04\
    \xbe\x01\x02\x01\x04\x12\x04\xe7'\x02\n\n\x0e\n\x06\x04\xbe\x01\x02\x01\
    \x05\x12\x04\xe7'\x0b\x11\n\x0e\n\x06\x04\xbe\x01\x02\x01\x01\x12\x04\
    \xe7'\x12!\n\x0e\n\x06\x04\xbe\x01\x02\x01\x03\x12\x04\xe7'$%\n\xc6\x01\
    \n\x05\x04\xbe\x01\x02\x02\x12\x04\xed'\x02\x1d\x1a\xb6\x01\x20Filesyste\
    m\x20type\x20to\x20mount.\n\x20Must\x20be\x20a\x20filesystem\x20type\x20\
    supported\x20by\x20the\x20host\x20operating\x20system.\n\x20Ex.\x20\"ext\
    4\",\x20\"xfs\",\x20\"ntfs\".\x20Implicitly\x20inferred\x20to\x20be\x20\
    \"ext4\"\x20if\x20unspecified.\n\x20+optional\n\n\x0e\n\x06\x04\xbe\x01\
    \x02\x02\x04\x12\x04\xed'\x02\n\n\x0e\n\x06\x04\xbe\x01\x02\x02\x05\x12\
    \x04\xed'\x0b\x11\n\x0e\n\x06\x04\xbe\x01\x02\x02\x01\x12\x04\xed'\x12\
    \x18\n\x0e\n\x06\x04\xbe\x01\x02\x02\x03\x12\x04\xed'\x1b\x1c\n{\n\x05\
    \x04\xbe\x01\x02\x03\x12\x04\xf2'\x02\x1d\x1al\x20Defaults\x20to\x20fals\
    e\x20(read/write).\x20ReadOnly\x20here\x20will\x20force\n\x20the\x20Read\
    Only\x20setting\x20in\x20VolumeMounts.\n\x20+optional\n\n\x0e\n\x06\x04\
    \xbe\x01\x02\x03\x04\x12\x04\xf2'\x02\n\n\x0e\n\x06\x04\xbe\x01\x02\x03\
    \x05\x12\x04\xf2'\x0b\x0f\n\x0e\n\x06\x04\xbe\x01\x02\x03\x01\x12\x04\
    \xf2'\x10\x18\n\x0e\n\x06\x04\xbe\x01\x02\x03\x03\x12\x04\xf2'\x1b\x1c\n\
    \xa5\x01\n\x05\x04\xbe\x01\x02\x04\x12\x04\xf7'\x02.\x1a\x95\x01\x20Secr\
    etRef\x20specifies\x20the\x20secret\x20to\x20use\x20for\x20obtaining\x20\
    the\x20StorageOS\x20API\n\x20credentials.\x20\x20If\x20not\x20specified,\
    \x20default\x20values\x20will\x20be\x20attempted.\n\x20+optional\n\n\x0e\
    \n\x06\x04\xbe\x01\x02\x04\x04\x12\x04\xf7'\x02\n\n\x0e\n\x06\x04\xbe\
    \x01\x02\x04\x06\x12\x04\xf7'\x0b\x1f\n\x0e\n\x06\x04\xbe\x01\x02\x04\
    \x01\x12\x04\xf7'\x20)\n\x0e\n\x06\x04\xbe\x01\x02\x04\x03\x12\x04\xf7',\
    -\n<\n\x03\x04\xbf\x01\x12\x06\xfb'\0\x81(\x01\x1a-\x20Sysctl\x20defines\
    \x20a\x20kernel\x20parameter\x20to\x20be\x20set\n\n\x0c\n\x04\x04\xbf\
    \x01\x01\x12\x04\xfb'\x08\x0e\n*\n\x05\x04\xbf\x01\x02\0\x12\x04\xfd'\
    \x02\x1b\x1a\x1b\x20Name\x20of\x20a\x20property\x20to\x20set\n\n\x0e\n\
    \x06\x04\xbf\x01\x02\0\x04\x12\x04\xfd'\x02\n\n\x0e\n\x06\x04\xbf\x01\
    \x02\0\x05\x12\x04\xfd'\x0b\x11\n\x0e\n\x06\x04\xbf\x01\x02\0\x01\x12\
    \x04\xfd'\x12\x16\n\x0e\n\x06\x04\xbf\x01\x02\0\x03\x12\x04\xfd'\x19\x1a\
    \n+\n\x05\x04\xbf\x01\x02\x01\x12\x04\x80(\x02\x1c\x1a\x1c\x20Value\x20o\
    f\x20a\x20property\x20to\x20set\n\n\x0e\n\x06\x04\xbf\x01\x02\x01\x04\
    \x12\x04\x80(\x02\n\n\x0e\n\x06\x04\xbf\x01\x02\x01\x05\x12\x04\x80(\x0b\
    \x11\n\x0e\n\x06\x04\xbf\x01\x02\x01\x01\x12\x04\x80(\x12\x17\n\x0e\n\
    \x06\x04\xbf\x01\x02\x01\x03\x12\x04\x80(\x1a\x1b\nN\n\x03\x04\xc0\x01\
    \x12\x06\x84(\0\x8d(\x01\x1a?\x20TCPSocketAction\x20describes\x20an\x20a\
    ction\x20based\x20on\x20opening\x20a\x20socket\n\n\x0c\n\x04\x04\xc0\x01\
    \x01\x12\x04\x84(\x08\x17\n\x91\x01\n\x05\x04\xc0\x01\x02\0\x12\x04\x88(\
    \x02D\x1a\x81\x01\x20Number\x20or\x20name\x20of\x20the\x20port\x20to\x20\
    access\x20on\x20the\x20container.\n\x20Number\x20must\x20be\x20in\x20the\
    \x20range\x201\x20to\x2065535.\n\x20Name\x20must\x20be\x20an\x20IANA_SVC\
    _NAME.\n\n\x0e\n\x06\x04\xc0\x01\x02\0\x04\x12\x04\x88(\x02\n\n\x0e\n\
    \x06\x04\xc0\x01\x02\0\x06\x12\x04\x88(\x0b:\n\x0e\n\x06\x04\xc0\x01\x02\
    \0\x01\x12\x04\x88(;?\n\x0e\n\x06\x04\xc0\x01\x02\0\x03\x12\x04\x88(BC\n\
    V\n\x05\x04\xc0\x01\x02\x01\x12\x04\x8c(\x02\x1b\x1aG\x20Optional:\x20Ho\
    st\x20name\x20to\x20connect\x20to,\x20defaults\x20to\x20the\x20pod\x20IP\
    .\n\x20+optional\n\n\x0e\n\x06\x04\xc0\x01\x02\x01\x04\x12\x04\x8c(\x02\
    \n\n\x0e\n\x06\x04\xc0\x01\x02\x01\x05\x12\x04\x8c(\x0b\x11\n\x0e\n\x06\
    \x04\xc0\x01\x02\x01\x01\x12\x04\x8c(\x12\x16\n\x0e\n\x06\x04\xc0\x01\
    \x02\x01\x03\x12\x04\x8c(\x19\x1a\nr\n\x03\x04\xc1\x01\x12\x06\x91(\0\
    \xa2(\x01\x1ac\x20The\x20node\x20this\x20Taint\x20is\x20attached\x20to\
    \x20has\x20the\x20\"effect\"\x20on\n\x20any\x20pod\x20that\x20does\x20no\
    t\x20tolerate\x20the\x20Taint.\n\n\x0c\n\x04\x04\xc1\x01\x01\x12\x04\x91\
    (\x08\r\nA\n\x05\x04\xc1\x01\x02\0\x12\x04\x93(\x02\x1a\x1a2\x20Required\
    .\x20The\x20taint\x20key\x20to\x20be\x20applied\x20to\x20a\x20node.\n\n\
    \x0e\n\x06\x04\xc1\x01\x02\0\x04\x12\x04\x93(\x02\n\n\x0e\n\x06\x04\xc1\
    \x01\x02\0\x05\x12\x04\x93(\x0b\x11\n\x0e\n\x06\x04\xc1\x01\x02\0\x01\
    \x12\x04\x93(\x12\x15\n\x0e\n\x06\x04\xc1\x01\x02\0\x03\x12\x04\x93(\x18\
    \x19\nK\n\x05\x04\xc1\x01\x02\x01\x12\x04\x97(\x02\x1c\x1a<\x20The\x20ta\
    int\x20value\x20corresponding\x20to\x20the\x20taint\x20key.\n\x20+option\
    al\n\n\x0e\n\x06\x04\xc1\x01\x02\x01\x04\x12\x04\x97(\x02\n\n\x0e\n\x06\
    \x04\xc1\x01\x02\x01\x05\x12\x04\x97(\x0b\x11\n\x0e\n\x06\x04\xc1\x01\
    \x02\x01\x01\x12\x04\x97(\x12\x17\n\x0e\n\x06\x04\xc1\x01\x02\x01\x03\
    \x12\x04\x97(\x1a\x1b\n\x9b\x01\n\x05\x04\xc1\x01\x02\x02\x12\x04\x9c(\
    \x02\x1d\x1a\x8b\x01\x20Required.\x20The\x20effect\x20of\x20the\x20taint\
    \x20on\x20pods\n\x20that\x20do\x20not\x20tolerate\x20the\x20taint.\n\x20\
    Valid\x20effects\x20are\x20NoSchedule,\x20PreferNoSchedule\x20and\x20NoE\
    xecute.\n\n\x0e\n\x06\x04\xc1\x01\x02\x02\x04\x12\x04\x9c(\x02\n\n\x0e\n\
    \x06\x04\xc1\x01\x02\x02\x05\x12\x04\x9c(\x0b\x11\n\x0e\n\x06\x04\xc1\
    \x01\x02\x02\x01\x12\x04\x9c(\x12\x18\n\x0e\n\x06\x04\xc1\x01\x02\x02\
    \x03\x12\x04\x9c(\x1b\x1c\n\x81\x01\n\x05\x04\xc1\x01\x02\x03\x12\x04\
    \xa1(\x02C\x1ar\x20TimeAdded\x20represents\x20the\x20time\x20at\x20which\
    \x20the\x20taint\x20was\x20added.\n\x20It\x20is\x20only\x20written\x20fo\
    r\x20NoExecute\x20taints.\n\x20+optional\n\n\x0e\n\x06\x04\xc1\x01\x02\
    \x03\x04\x12\x04\xa1(\x02\n\n\x0e\n\x06\x04\xc1\x01\x02\x03\x06\x12\x04\
    \xa1(\x0b4\n\x0e\n\x06\x04\xc1\x01\x02\x03\x01\x12\x04\xa1(5>\n\x0e\n\
    \x06\x04\xc1\x01\x02\x03\x03\x12\x04\xa1(AB\n\xa0\x01\n\x03\x04\xc2\x01\
    \x12\x06\xa6(\0\xc3(\x01\x1a\x90\x01\x20The\x20pod\x20this\x20Toleration\
    \x20is\x20attached\x20to\x20tolerates\x20any\x20taint\x20that\x20matches\
    \n\x20the\x20triple\x20<key,value,effect>\x20using\x20the\x20matching\
    \x20operator\x20<operator>.\n\n\x0c\n\x04\x04\xc2\x01\x01\x12\x04\xa6(\
    \x08\x12\n\xdb\x01\n\x05\x04\xc2\x01\x02\0\x12\x04\xaa(\x02\x1a\x1a\xcb\
    \x01\x20Key\x20is\x20the\x20taint\x20key\x20that\x20the\x20toleration\
    \x20applies\x20to.\x20Empty\x20means\x20match\x20all\x20taint\x20keys.\n\
    \x20If\x20the\x20key\x20is\x20empty,\x20operator\x20must\x20be\x20Exists\
    ;\x20this\x20combination\x20means\x20to\x20match\x20all\x20values\x20and\
    \x20all\x20keys.\n\x20+optional\n\n\x0e\n\x06\x04\xc2\x01\x02\0\x04\x12\
    \x04\xaa(\x02\n\n\x0e\n\x06\x04\xc2\x01\x02\0\x05\x12\x04\xaa(\x0b\x11\n\
    \x0e\n\x06\x04\xc2\x01\x02\0\x01\x12\x04\xaa(\x12\x15\n\x0e\n\x06\x04\
    \xc2\x01\x02\0\x03\x12\x04\xaa(\x18\x19\n\xfb\x01\n\x05\x04\xc2\x01\x02\
    \x01\x12\x04\xb1(\x02\x1f\x1a\xeb\x01\x20Operator\x20represents\x20a\x20\
    key's\x20relationship\x20to\x20the\x20value.\n\x20Valid\x20operators\x20\
    are\x20Exists\x20and\x20Equal.\x20Defaults\x20to\x20Equal.\n\x20Exists\
    \x20is\x20equivalent\x20to\x20wildcard\x20for\x20value,\x20so\x20that\
    \x20a\x20pod\x20can\n\x20tolerate\x20all\x20taints\x20of\x20a\x20particu\
    lar\x20category.\n\x20+optional\n\n\x0e\n\x06\x04\xc2\x01\x02\x01\x04\
    \x12\x04\xb1(\x02\n\n\x0e\n\x06\x04\xc2\x01\x02\x01\x05\x12\x04\xb1(\x0b\
    \x11\n\x0e\n\x06\x04\xc2\x01\x02\x01\x01\x12\x04\xb1(\x12\x1a\n\x0e\n\
    \x06\x04\xc2\x01\x02\x01\x03\x12\x04\xb1(\x1d\x1e\n\xa8\x01\n\x05\x04\
    \xc2\x01\x02\x02\x12\x04\xb6(\x02\x1c\x1a\x98\x01\x20Value\x20is\x20the\
    \x20taint\x20value\x20the\x20toleration\x20matches\x20to.\n\x20If\x20the\
    \x20operator\x20is\x20Exists,\x20the\x20value\x20should\x20be\x20empty,\
    \x20otherwise\x20just\x20a\x20regular\x20string.\n\x20+optional\n\n\x0e\
    \n\x06\x04\xc2\x01\x02\x02\x04\x12\x04\xb6(\x02\n\n\x0e\n\x06\x04\xc2\
    \x01\x02\x02\x05\x12\x04\xb6(\x0b\x11\n\x0e\n\x06\x04\xc2\x01\x02\x02\
    \x01\x12\x04\xb6(\x12\x17\n\x0e\n\x06\x04\xc2\x01\x02\x02\x03\x12\x04\
    \xb6(\x1a\x1b\n\xbd\x01\n\x05\x04\xc2\x01\x02\x03\x12\x04\xbb(\x02\x1d\
    \x1a\xad\x01\x20Effect\x20indicates\x20the\x20taint\x20effect\x20to\x20m\
    atch.\x20Empty\x20means\x20match\x20all\x20taint\x20effects.\n\x20When\
    \x20specified,\x20allowed\x20values\x20are\x20NoSchedule,\x20PreferNoSch\
    edule\x20and\x20NoExecute.\n\x20+optional\n\n\x0e\n\x06\x04\xc2\x01\x02\
    \x03\x04\x12\x04\xbb(\x02\n\n\x0e\n\x06\x04\xc2\x01\x02\x03\x05\x12\x04\
    \xbb(\x0b\x11\n\x0e\n\x06\x04\xc2\x01\x02\x03\x01\x12\x04\xbb(\x12\x18\n\
    \x0e\n\x06\x04\xc2\x01\x02\x03\x03\x12\x04\xbb(\x1b\x1c\n\xdb\x02\n\x05\
    \x04\xc2\x01\x02\x04\x12\x04\xc2(\x02'\x1a\xcb\x02\x20TolerationSeconds\
    \x20represents\x20the\x20period\x20of\x20time\x20the\x20toleration\x20(w\
    hich\x20must\x20be\n\x20of\x20effect\x20NoExecute,\x20otherwise\x20this\
    \x20field\x20is\x20ignored)\x20tolerates\x20the\x20taint.\x20By\x20defau\
    lt,\n\x20it\x20is\x20not\x20set,\x20which\x20means\x20tolerate\x20the\
    \x20taint\x20forever\x20(do\x20not\x20evict).\x20Zero\x20and\n\x20negati\
    ve\x20values\x20will\x20be\x20treated\x20as\x200\x20(evict\x20immediatel\
    y)\x20by\x20the\x20system.\n\x20+optional\n\n\x0e\n\x06\x04\xc2\x01\x02\
    \x04\x04\x12\x04\xc2(\x02\n\n\x0e\n\x06\x04\xc2\x01\x02\x04\x05\x12\x04\
    \xc2(\x0b\x10\n\x0e\n\x06\x04\xc2\x01\x02\x04\x01\x12\x04\xc2(\x11\"\n\
    \x0e\n\x06\x04\xc2\x01\x02\x04\x03\x12\x04\xc2(%&\n\x91\x01\n\x03\x04\
    \xc3\x01\x12\x06\xc7(\0\xce(\x01\x1a\x81\x01\x20A\x20topology\x20selecto\
    r\x20requirement\x20is\x20a\x20selector\x20that\x20matches\x20given\x20l\
    abel.\n\x20This\x20is\x20an\x20alpha\x20feature\x20and\x20may\x20change\
    \x20in\x20the\x20future.\n\n\x0c\n\x04\x04\xc3\x01\x01\x12\x04\xc7(\x08(\
    \n<\n\x05\x04\xc3\x01\x02\0\x12\x04\xc9(\x02\x1a\x1a-\x20The\x20label\
    \x20key\x20that\x20the\x20selector\x20applies\x20to.\n\n\x0e\n\x06\x04\
    \xc3\x01\x02\0\x04\x12\x04\xc9(\x02\n\n\x0e\n\x06\x04\xc3\x01\x02\0\x05\
    \x12\x04\xc9(\x0b\x11\n\x0e\n\x06\x04\xc3\x01\x02\0\x01\x12\x04\xc9(\x12\
    \x15\n\x0e\n\x06\x04\xc3\x01\x02\0\x03\x12\x04\xc9(\x18\x19\ny\n\x05\x04\
    \xc3\x01\x02\x01\x12\x04\xcd(\x02\x1d\x1aj\x20An\x20array\x20of\x20strin\
    g\x20values.\x20One\x20value\x20must\x20match\x20the\x20label\x20to\x20b\
    e\x20selected.\n\x20Each\x20entry\x20in\x20Values\x20is\x20ORed.\n\n\x0e\
    \n\x06\x04\xc3\x01\x02\x01\x04\x12\x04\xcd(\x02\n\n\x0e\n\x06\x04\xc3\
    \x01\x02\x01\x05\x12\x04\xcd(\x0b\x11\n\x0e\n\x06\x04\xc3\x01\x02\x01\
    \x01\x12\x04\xcd(\x12\x18\n\x0e\n\x06\x04\xc3\x01\x02\x01\x03\x12\x04\
    \xcd(\x1b\x1c\n\xa7\x02\n\x03\x04\xc4\x01\x12\x06\xd5(\0\xd9(\x01\x1a\
    \x97\x02\x20A\x20topology\x20selector\x20term\x20represents\x20the\x20re\
    sult\x20of\x20label\x20queries.\n\x20A\x20null\x20or\x20empty\x20topolog\
    y\x20selector\x20term\x20matches\x20no\x20objects.\n\x20The\x20requireme\
    nts\x20of\x20them\x20are\x20ANDed.\n\x20It\x20provides\x20a\x20subset\
    \x20of\x20functionality\x20as\x20NodeSelectorTerm.\n\x20This\x20is\x20an\
    \x20alpha\x20feature\x20and\x20may\x20change\x20in\x20the\x20future.\n\n\
    \x0c\n\x04\x04\xc4\x01\x01\x12\x04\xd5(\x08\x1c\nO\n\x05\x04\xc4\x01\x02\
    \0\x12\x04\xd8(\x02F\x1a@\x20A\x20list\x20of\x20topology\x20selector\x20\
    requirements\x20by\x20labels.\n\x20+optional\n\n\x0e\n\x06\x04\xc4\x01\
    \x02\0\x04\x12\x04\xd8(\x02\n\n\x0e\n\x06\x04\xc4\x01\x02\0\x06\x12\x04\
    \xd8(\x0b+\n\x0e\n\x06\x04\xc4\x01\x02\0\x01\x12\x04\xd8(,A\n\x0e\n\x06\
    \x04\xc4\x01\x02\0\x03\x12\x04\xd8(DE\ni\n\x03\x04\xc5\x01\x12\x06\xdc(\
    \0\x93)\x01\x1aZ\x20TopologySpreadConstraint\x20specifies\x20how\x20to\
    \x20spread\x20matching\x20pods\x20among\x20the\x20given\x20topology.\n\n\
    \x0c\n\x04\x04\xc5\x01\x01\x12\x04\xdc(\x08\x20\n\x9a\x07\n\x05\x04\xc5\
    \x01\x02\0\x12\x04\xee(\x02\x1d\x1a\x8a\x07\x20MaxSkew\x20describes\x20t\
    he\x20degree\x20to\x20which\x20pods\x20may\x20be\x20unevenly\x20distribu\
    ted.\n\x20When\x20`whenUnsatisfiable=DoNotSchedule`,\x20it\x20is\x20the\
    \x20maximum\x20permitted\x20difference\n\x20between\x20the\x20number\x20\
    of\x20matching\x20pods\x20in\x20the\x20target\x20topology\x20and\x20the\
    \x20global\x20minimum.\n\x20For\x20example,\x20in\x20a\x203-zone\x20clus\
    ter,\x20MaxSkew\x20is\x20set\x20to\x201,\x20and\x20pods\x20with\x20the\
    \x20same\n\x20labelSelector\x20spread\x20as\x201/1/0:\n\x20+-------+----\
    ---+-------+\n\x20|\x20zone1\x20|\x20zone2\x20|\x20zone3\x20|\n\x20+----\
    ---+-------+-------+\n\x20|\x20\x20\x20P\x20\x20\x20|\x20\x20\x20P\x20\
    \x20\x20|\x20\x20\x20\x20\x20\x20\x20|\n\x20+-------+-------+-------+\n\
    \x20-\x20if\x20MaxSkew\x20is\x201,\x20incoming\x20pod\x20can\x20only\x20\
    be\x20scheduled\x20to\x20zone3\x20to\x20become\x201/1/1;\n\x20scheduling\
    \x20it\x20onto\x20zone1(zone2)\x20would\x20make\x20the\x20ActualSkew(2-0\
    )\x20on\x20zone1(zone2)\n\x20violate\x20MaxSkew(1).\n\x20-\x20if\x20MaxS\
    kew\x20is\x202,\x20incoming\x20pod\x20can\x20be\x20scheduled\x20onto\x20\
    any\x20zone.\n\x20When\x20`whenUnsatisfiable=ScheduleAnyway`,\x20it\x20i\
    s\x20used\x20to\x20give\x20higher\x20precedence\n\x20to\x20topologies\
    \x20that\x20satisfy\x20it.\n\x20It's\x20a\x20required\x20field.\x20Defau\
    lt\x20value\x20is\x201\x20and\x200\x20is\x20not\x20allowed.\n\n\x0e\n\
    \x06\x04\xc5\x01\x02\0\x04\x12\x04\xee(\x02\n\n\x0e\n\x06\x04\xc5\x01\
    \x02\0\x05\x12\x04\xee(\x0b\x10\n\x0e\n\x06\x04\xc5\x01\x02\0\x01\x12\
    \x04\xee(\x11\x18\n\x0e\n\x06\x04\xc5\x01\x02\0\x03\x12\x04\xee(\x1b\x1c\
    \n\x9f\x02\n\x05\x04\xc5\x01\x02\x01\x12\x04\xf5(\x02\"\x1a\x8f\x02\x20T\
    opologyKey\x20is\x20the\x20key\x20of\x20node\x20labels.\x20Nodes\x20that\
    \x20have\x20a\x20label\x20with\x20this\x20key\n\x20and\x20identical\x20v\
    alues\x20are\x20considered\x20to\x20be\x20in\x20the\x20same\x20topology.\
    \n\x20We\x20consider\x20each\x20<key,\x20value>\x20as\x20a\x20\"bucket\"\
    ,\x20and\x20try\x20to\x20put\x20balanced\x20number\n\x20of\x20pods\x20in\
    to\x20each\x20bucket.\n\x20It's\x20a\x20required\x20field.\n\n\x0e\n\x06\
    \x04\xc5\x01\x02\x01\x04\x12\x04\xf5(\x02\n\n\x0e\n\x06\x04\xc5\x01\x02\
    \x01\x05\x12\x04\xf5(\x0b\x11\n\x0e\n\x06\x04\xc5\x01\x02\x01\x01\x12\
    \x04\xf5(\x12\x1d\n\x0e\n\x06\x04\xc5\x01\x02\x01\x03\x12\x04\xf5(\x20!\
    \n\x9f\x08\n\x05\x04\xc5\x01\x02\x02\x12\x04\x8c)\x02(\x1a\x8f\x08\x20Wh\
    enUnsatisfiable\x20indicates\x20how\x20to\x20deal\x20with\x20a\x20pod\
    \x20if\x20it\x20doesn't\x20satisfy\n\x20the\x20spread\x20constraint.\n\
    \x20-\x20DoNotSchedule\x20(default)\x20tells\x20the\x20scheduler\x20not\
    \x20to\x20schedule\x20it.\n\x20-\x20ScheduleAnyway\x20tells\x20the\x20sc\
    heduler\x20to\x20schedule\x20the\x20pod\x20in\x20any\x20location,\n\x20\
    \x20\x20but\x20giving\x20higher\x20precedence\x20to\x20topologies\x20tha\
    t\x20would\x20help\x20reduce\x20the\n\x20\x20\x20skew.\n\x20A\x20constra\
    int\x20is\x20considered\x20\"Unsatisfiable\"\x20for\x20an\x20incoming\
    \x20pod\n\x20if\x20and\x20only\x20if\x20every\x20possible\x20node\x20ass\
    igment\x20for\x20that\x20pod\x20would\x20violate\n\x20\"MaxSkew\"\x20on\
    \x20some\x20topology.\n\x20For\x20example,\x20in\x20a\x203-zone\x20clust\
    er,\x20MaxSkew\x20is\x20set\x20to\x201,\x20and\x20pods\x20with\x20the\
    \x20same\n\x20labelSelector\x20spread\x20as\x203/1/1:\n\x20+-------+----\
    ---+-------+\n\x20|\x20zone1\x20|\x20zone2\x20|\x20zone3\x20|\n\x20+----\
    ---+-------+-------+\n\x20|\x20P\x20P\x20P\x20|\x20\x20\x20P\x20\x20\x20\
    |\x20\x20\x20P\x20\x20\x20|\n\x20+-------+-------+-------+\n\x20If\x20Wh\
    enUnsatisfiable\x20is\x20set\x20to\x20DoNotSchedule,\x20incoming\x20pod\
    \x20can\x20only\x20be\x20scheduled\n\x20to\x20zone2(zone3)\x20to\x20beco\
    me\x203/2/1(3/1/2)\x20as\x20ActualSkew(2-1)\x20on\x20zone2(zone3)\x20sat\
    isfies\n\x20MaxSkew(1).\x20In\x20other\x20words,\x20the\x20cluster\x20ca\
    n\x20still\x20be\x20imbalanced,\x20but\x20scheduler\n\x20won't\x20make\
    \x20it\x20*more*\x20imbalanced.\n\x20It's\x20a\x20required\x20field.\n\n\
    \x0e\n\x06\x04\xc5\x01\x02\x02\x04\x12\x04\x8c)\x02\n\n\x0e\n\x06\x04\
    \xc5\x01\x02\x02\x05\x12\x04\x8c)\x0b\x11\n\x0e\n\x06\x04\xc5\x01\x02\
    \x02\x01\x12\x04\x8c)\x12#\n\x0e\n\x06\x04\xc5\x01\x02\x02\x03\x12\x04\
    \x8c)&'\n\xc3\x01\n\x05\x04\xc5\x01\x02\x03\x12\x04\x92)\x02P\x1a\xb3\
    \x01\x20LabelSelector\x20is\x20used\x20to\x20find\x20matching\x20pods.\n\
    \x20Pods\x20that\x20match\x20this\x20label\x20selector\x20are\x20counted\
    \x20to\x20determine\x20the\x20number\x20of\x20pods\n\x20in\x20their\x20c\
    orresponding\x20topology\x20domain.\n\x20+optional\n\n\x0e\n\x06\x04\xc5\
    \x01\x02\x03\x04\x12\x04\x92)\x02\n\n\x0e\n\x06\x04\xc5\x01\x02\x03\x06\
    \x12\x04\x92)\x0b=\n\x0e\n\x06\x04\xc5\x01\x02\x03\x01\x12\x04\x92)>K\n\
    \x0e\n\x06\x04\xc5\x01\x02\x03\x03\x12\x04\x92)NO\n\x91\x01\n\x03\x04\
    \xc6\x01\x12\x06\x97)\0\xa3)\x01\x1a\x81\x01\x20TypedLocalObjectReferenc\
    e\x20contains\x20enough\x20information\x20to\x20let\x20you\x20locate\x20\
    the\n\x20typed\x20referenced\x20object\x20inside\x20the\x20same\x20names\
    pace.\n\n\x0c\n\x04\x04\xc6\x01\x01\x12\x04\x97)\x08!\n\xde\x01\n\x05\
    \x04\xc6\x01\x02\0\x12\x04\x9c)\x02\x1f\x1a\xce\x01\x20APIGroup\x20is\
    \x20the\x20group\x20for\x20the\x20resource\x20being\x20referenced.\n\x20\
    If\x20APIGroup\x20is\x20not\x20specified,\x20the\x20specified\x20Kind\
    \x20must\x20be\x20in\x20the\x20core\x20API\x20group.\n\x20For\x20any\x20\
    other\x20third-party\x20types,\x20APIGroup\x20is\x20required.\n\x20+opti\
    onal\n\n\x0e\n\x06\x04\xc6\x01\x02\0\x04\x12\x04\x9c)\x02\n\n\x0e\n\x06\
    \x04\xc6\x01\x02\0\x05\x12\x04\x9c)\x0b\x11\n\x0e\n\x06\x04\xc6\x01\x02\
    \0\x01\x12\x04\x9c)\x12\x1a\n\x0e\n\x06\x04\xc6\x01\x02\0\x03\x12\x04\
    \x9c)\x1d\x1e\n>\n\x05\x04\xc6\x01\x02\x01\x12\x04\x9f)\x02\x1b\x1a/\x20\
    Kind\x20is\x20the\x20type\x20of\x20resource\x20being\x20referenced\n\n\
    \x0e\n\x06\x04\xc6\x01\x02\x01\x04\x12\x04\x9f)\x02\n\n\x0e\n\x06\x04\
    \xc6\x01\x02\x01\x05\x12\x04\x9f)\x0b\x11\n\x0e\n\x06\x04\xc6\x01\x02\
    \x01\x01\x12\x04\x9f)\x12\x16\n\x0e\n\x06\x04\xc6\x01\x02\x01\x03\x12\
    \x04\x9f)\x19\x1a\n>\n\x05\x04\xc6\x01\x02\x02\x12\x04\xa2)\x02\x1b\x1a/\
    \x20Name\x20is\x20the\x20name\x20of\x20resource\x20being\x20referenced\n\
    \n\x0e\n\x06\x04\xc6\x01\x02\x02\x04\x12\x04\xa2)\x02\n\n\x0e\n\x06\x04\
    \xc6\x01\x02\x02\x05\x12\x04\xa2)\x0b\x11\n\x0e\n\x06\x04\xc6\x01\x02\
    \x02\x01\x12\x04\xa2)\x12\x16\n\x0e\n\x06\x04\xc6\x01\x02\x02\x03\x12\
    \x04\xa2)\x19\x1a\nl\n\x03\x04\xc7\x01\x12\x06\xa6)\0\xb0)\x01\x1a]\x20V\
    olume\x20represents\x20a\x20named\x20volume\x20in\x20a\x20pod\x20that\
    \x20may\x20be\x20accessed\x20by\x20any\x20container\x20in\x20the\x20pod.\
    \n\n\x0c\n\x04\x04\xc7\x01\x01\x12\x04\xa6)\x08\x0e\n\xab\x01\n\x05\x04\
    \xc7\x01\x02\0\x12\x04\xaa)\x02\x1b\x1a\x9b\x01\x20Volume's\x20name.\n\
    \x20Must\x20be\x20a\x20DNS_LABEL\x20and\x20unique\x20within\x20the\x20po\
    d.\n\x20More\x20info:\x20https://kubernetes.io/docs/concepts/overview/wo\
    rking-with-objects/names/#names\n\n\x0e\n\x06\x04\xc7\x01\x02\0\x04\x12\
    \x04\xaa)\x02\n\n\x0e\n\x06\x04\xc7\x01\x02\0\x05\x12\x04\xaa)\x0b\x11\n\
    \x0e\n\x06\x04\xc7\x01\x02\0\x01\x12\x04\xaa)\x12\x16\n\x0e\n\x06\x04\
    \xc7\x01\x02\0\x03\x12\x04\xaa)\x19\x1a\n\xe0\x01\n\x05\x04\xc7\x01\x02\
    \x01\x12\x04\xaf)\x02)\x1a\xd0\x01\x20VolumeSource\x20represents\x20the\
    \x20location\x20and\x20type\x20of\x20the\x20mounted\x20volume.\n\x20If\
    \x20not\x20specified,\x20the\x20Volume\x20is\x20implied\x20to\x20be\x20a\
    n\x20EmptyDir.\n\x20This\x20implied\x20behavior\x20is\x20deprecated\x20a\
    nd\x20will\x20be\x20removed\x20in\x20a\x20future\x20version.\n\n\x0e\n\
    \x06\x04\xc7\x01\x02\x01\x04\x12\x04\xaf)\x02\n\n\x0e\n\x06\x04\xc7\x01\
    \x02\x01\x06\x12\x04\xaf)\x0b\x17\n\x0e\n\x06\x04\xc7\x01\x02\x01\x01\
    \x12\x04\xaf)\x18$\n\x0e\n\x06\x04\xc7\x01\x02\x01\x03\x12\x04\xaf)'(\n[\
    \n\x03\x04\xc8\x01\x12\x06\xb3)\0\xb9)\x01\x1aL\x20volumeDevice\x20descr\
    ibes\x20a\x20mapping\x20of\x20a\x20raw\x20block\x20device\x20within\x20a\
    \x20container.\n\n\x0c\n\x04\x04\xc8\x01\x01\x12\x04\xb3)\x08\x14\nO\n\
    \x05\x04\xc8\x01\x02\0\x12\x04\xb5)\x02\x1b\x1a@\x20name\x20must\x20matc\
    h\x20the\x20name\x20of\x20a\x20persistentVolumeClaim\x20in\x20the\x20pod\
    \n\n\x0e\n\x06\x04\xc8\x01\x02\0\x04\x12\x04\xb5)\x02\n\n\x0e\n\x06\x04\
    \xc8\x01\x02\0\x05\x12\x04\xb5)\x0b\x11\n\x0e\n\x06\x04\xc8\x01\x02\0\
    \x01\x12\x04\xb5)\x12\x16\n\x0e\n\x06\x04\xc8\x01\x02\0\x03\x12\x04\xb5)\
    \x19\x1a\nb\n\x05\x04\xc8\x01\x02\x01\x12\x04\xb8)\x02!\x1aS\x20devicePa\
    th\x20is\x20the\x20path\x20inside\x20of\x20the\x20container\x20that\x20t\
    he\x20device\x20will\x20be\x20mapped\x20to.\n\n\x0e\n\x06\x04\xc8\x01\
    \x02\x01\x04\x12\x04\xb8)\x02\n\n\x0e\n\x06\x04\xc8\x01\x02\x01\x05\x12\
    \x04\xb8)\x0b\x11\n\x0e\n\x06\x04\xc8\x01\x02\x01\x01\x12\x04\xb8)\x12\
    \x1c\n\x0e\n\x06\x04\xc8\x01\x02\x01\x03\x12\x04\xb8)\x1f\x20\nQ\n\x03\
    \x04\xc9\x01\x12\x06\xbc)\0\xdb)\x01\x1aB\x20VolumeMount\x20describes\
    \x20a\x20mounting\x20of\x20a\x20Volume\x20within\x20a\x20container.\n\n\
    \x0c\n\x04\x04\xc9\x01\x01\x12\x04\xbc)\x08\x13\n6\n\x05\x04\xc9\x01\x02\
    \0\x12\x04\xbe)\x02\x1b\x1a'\x20This\x20must\x20match\x20the\x20Name\x20\
    of\x20a\x20Volume.\n\n\x0e\n\x06\x04\xc9\x01\x02\0\x04\x12\x04\xbe)\x02\
    \n\n\x0e\n\x06\x04\xc9\x01\x02\0\x05\x12\x04\xbe)\x0b\x11\n\x0e\n\x06\
    \x04\xc9\x01\x02\0\x01\x12\x04\xbe)\x12\x16\n\x0e\n\x06\x04\xc9\x01\x02\
    \0\x03\x12\x04\xbe)\x19\x1a\nw\n\x05\x04\xc9\x01\x02\x01\x12\x04\xc3)\
    \x02\x1d\x1ah\x20Mounted\x20read-only\x20if\x20true,\x20read-write\x20ot\
    herwise\x20(false\x20or\x20unspecified).\n\x20Defaults\x20to\x20false.\n\
    \x20+optional\n\n\x0e\n\x06\x04\xc9\x01\x02\x01\x04\x12\x04\xc3)\x02\n\n\
    \x0e\n\x06\x04\xc9\x01\x02\x01\x05\x12\x04\xc3)\x0b\x0f\n\x0e\n\x06\x04\
    \xc9\x01\x02\x01\x01\x12\x04\xc3)\x10\x18\n\x0e\n\x06\x04\xc9\x01\x02\
    \x01\x03\x12\x04\xc3)\x1b\x1c\ni\n\x05\x04\xc9\x01\x02\x02\x12\x04\xc7)\
    \x02\x20\x1aZ\x20Path\x20within\x20the\x20container\x20at\x20which\x20th\
    e\x20volume\x20should\x20be\x20mounted.\x20\x20Must\n\x20not\x20contain\
    \x20':'.\n\n\x0e\n\x06\x04\xc9\x01\x02\x02\x04\x12\x04\xc7)\x02\n\n\x0e\
    \n\x06\x04\xc9\x01\x02\x02\x05\x12\x04\xc7)\x0b\x11\n\x0e\n\x06\x04\xc9\
    \x01\x02\x02\x01\x12\x04\xc7)\x12\x1b\n\x0e\n\x06\x04\xc9\x01\x02\x02\
    \x03\x12\x04\xc7)\x1e\x1f\n\x88\x01\n\x05\x04\xc9\x01\x02\x03\x12\x04\
    \xcc)\x02\x1e\x1ay\x20Path\x20within\x20the\x20volume\x20from\x20which\
    \x20the\x20container's\x20volume\x20should\x20be\x20mounted.\n\x20Defaul\
    ts\x20to\x20\"\"\x20(volume's\x20root).\n\x20+optional\n\n\x0e\n\x06\x04\
    \xc9\x01\x02\x03\x04\x12\x04\xcc)\x02\n\n\x0e\n\x06\x04\xc9\x01\x02\x03\
    \x05\x12\x04\xcc)\x0b\x11\n\x0e\n\x06\x04\xc9\x01\x02\x03\x01\x12\x04\
    \xcc)\x12\x19\n\x0e\n\x06\x04\xc9\x01\x02\x03\x03\x12\x04\xcc)\x1c\x1d\n\
    \xd2\x01\n\x05\x04\xc9\x01\x02\x04\x12\x04\xd3)\x02'\x1a\xc2\x01\x20moun\
    tPropagation\x20determines\x20how\x20mounts\x20are\x20propagated\x20from\
    \x20the\x20host\n\x20to\x20container\x20and\x20the\x20other\x20way\x20ar\
    ound.\n\x20When\x20not\x20set,\x20MountPropagationNone\x20is\x20used.\n\
    \x20This\x20field\x20is\x20beta\x20in\x201.10.\n\x20+optional\n\n\x0e\n\
    \x06\x04\xc9\x01\x02\x04\x04\x12\x04\xd3)\x02\n\n\x0e\n\x06\x04\xc9\x01\
    \x02\x04\x05\x12\x04\xd3)\x0b\x11\n\x0e\n\x06\x04\xc9\x01\x02\x04\x01\
    \x12\x04\xd3)\x12\"\n\x0e\n\x06\x04\xc9\x01\x02\x04\x03\x12\x04\xd3)%&\n\
    \xc1\x02\n\x05\x04\xc9\x01\x02\x05\x12\x04\xda)\x02\"\x1a\xb1\x02\x20Exp\
    anded\x20path\x20within\x20the\x20volume\x20from\x20which\x20the\x20cont\
    ainer's\x20volume\x20should\x20be\x20mounted.\n\x20Behaves\x20similarly\
    \x20to\x20SubPath\x20but\x20environment\x20variable\x20references\x20$(V\
    AR_NAME)\x20are\x20expanded\x20using\x20the\x20container's\x20environmen\
    t.\n\x20Defaults\x20to\x20\"\"\x20(volume's\x20root).\n\x20SubPathExpr\
    \x20and\x20SubPath\x20are\x20mutually\x20exclusive.\n\x20+optional\n\n\
    \x0e\n\x06\x04\xc9\x01\x02\x05\x04\x12\x04\xda)\x02\n\n\x0e\n\x06\x04\
    \xc9\x01\x02\x05\x05\x12\x04\xda)\x0b\x11\n\x0e\n\x06\x04\xc9\x01\x02\
    \x05\x01\x12\x04\xda)\x12\x1d\n\x0e\n\x06\x04\xc9\x01\x02\x05\x03\x12\
    \x04\xda)\x20!\no\n\x03\x04\xca\x01\x12\x06\xde)\0\xe1)\x01\x1a`\x20Volu\
    meNodeAffinity\x20defines\x20constraints\x20that\x20limit\x20what\x20nod\
    es\x20this\x20volume\x20can\x20be\x20accessed\x20from.\n\n\x0c\n\x04\x04\
    \xca\x01\x01\x12\x04\xde)\x08\x1a\nK\n\x05\x04\xca\x01\x02\0\x12\x04\xe0\
    )\x02%\x1a<\x20Required\x20specifies\x20hard\x20node\x20constraints\x20t\
    hat\x20must\x20be\x20met.\n\n\x0e\n\x06\x04\xca\x01\x02\0\x04\x12\x04\
    \xe0)\x02\n\n\x0e\n\x06\x04\xca\x01\x02\0\x06\x12\x04\xe0)\x0b\x17\n\x0e\
    \n\x06\x04\xca\x01\x02\0\x01\x12\x04\xe0)\x18\x20\n\x0e\n\x06\x04\xca\
    \x01\x02\0\x03\x12\x04\xe0)#$\nY\n\x03\x04\xcb\x01\x12\x06\xe4)\0\xf4)\
    \x01\x1aJ\x20Projection\x20that\x20may\x20be\x20projected\x20along\x20wi\
    th\x20other\x20supported\x20volume\x20types\n\n\x0c\n\x04\x04\xcb\x01\
    \x01\x12\x04\xe4)\x08\x18\nH\n\x05\x04\xcb\x01\x02\0\x12\x04\xe7)\x02'\
    \x1a9\x20information\x20about\x20the\x20secret\x20data\x20to\x20project\
    \n\x20+optional\n\n\x0e\n\x06\x04\xcb\x01\x02\0\x04\x12\x04\xe7)\x02\n\n\
    \x0e\n\x06\x04\xcb\x01\x02\0\x06\x12\x04\xe7)\x0b\x1b\n\x0e\n\x06\x04\
    \xcb\x01\x02\0\x01\x12\x04\xe7)\x1c\"\n\x0e\n\x06\x04\xcb\x01\x02\0\x03\
    \x12\x04\xe7)%&\nM\n\x05\x04\xcb\x01\x02\x01\x12\x04\xeb)\x021\x1a>\x20i\
    nformation\x20about\x20the\x20downwardAPI\x20data\x20to\x20project\n\x20\
    +optional\n\n\x0e\n\x06\x04\xcb\x01\x02\x01\x04\x12\x04\xeb)\x02\n\n\x0e\
    \n\x06\x04\xcb\x01\x02\x01\x06\x12\x04\xeb)\x0b\x20\n\x0e\n\x06\x04\xcb\
    \x01\x02\x01\x01\x12\x04\xeb)!,\n\x0e\n\x06\x04\xcb\x01\x02\x01\x03\x12\
    \x04\xeb)/0\nK\n\x05\x04\xcb\x01\x02\x02\x12\x04\xef)\x02-\x1a<\x20infor\
    mation\x20about\x20the\x20configMap\x20data\x20to\x20project\n\x20+optio\
    nal\n\n\x0e\n\x06\x04\xcb\x01\x02\x02\x04\x12\x04\xef)\x02\n\n\x0e\n\x06\
    \x04\xcb\x01\x02\x02\x06\x12\x04\xef)\x0b\x1e\n\x0e\n\x06\x04\xcb\x01\
    \x02\x02\x01\x12\x04\xef)\x1f(\n\x0e\n\x06\x04\xcb\x01\x02\x02\x03\x12\
    \x04\xef)+,\nU\n\x05\x04\xcb\x01\x02\x03\x12\x04\xf3)\x02A\x1aF\x20infor\
    mation\x20about\x20the\x20serviceAccountToken\x20data\x20to\x20project\n\
    \x20+optional\n\n\x0e\n\x06\x04\xcb\x01\x02\x03\x04\x12\x04\xf3)\x02\n\n\
    \x0e\n\x06\x04\xcb\x01\x02\x03\x06\x12\x04\xf3)\x0b(\n\x0e\n\x06\x04\xcb\
    \x01\x02\x03\x01\x12\x04\xf3))<\n\x0e\n\x06\x04\xcb\x01\x02\x03\x03\x12\
    \x04\xf3)?@\ng\n\x03\x04\xcc\x01\x12\x06\xf8)\0\x9b+\x01\x1aX\x20Represe\
    nts\x20the\x20source\x20of\x20a\x20volume\x20to\x20mount.\n\x20Only\x20o\
    ne\x20of\x20its\x20members\x20may\x20be\x20specified.\n\n\x0c\n\x04\x04\
    \xcc\x01\x01\x12\x04\xf8)\x08\x14\n\xf3\x03\n\x05\x04\xcc\x01\x02\0\x12\
    \x04\x82*\x02-\x1a\xe3\x03\x20HostPath\x20represents\x20a\x20pre-existin\
    g\x20file\x20or\x20directory\x20on\x20the\x20host\n\x20machine\x20that\
    \x20is\x20directly\x20exposed\x20to\x20the\x20container.\x20This\x20is\
    \x20generally\n\x20used\x20for\x20system\x20agents\x20or\x20other\x20pri\
    vileged\x20things\x20that\x20are\x20allowed\n\x20to\x20see\x20the\x20hos\
    t\x20machine.\x20Most\x20containers\x20will\x20NOT\x20need\x20this.\n\
    \x20More\x20info:\x20https://kubernetes.io/docs/concepts/storage/volumes\
    #hostpath\n\x20---\n\x20TODO(jonesdl)\x20We\x20need\x20to\x20restrict\
    \x20who\x20can\x20use\x20host\x20directory\x20mounts\x20and\x20who\x20ca\
    n/can\x20not\n\x20mount\x20host\x20directories\x20as\x20read/write.\n\
    \x20+optional\n\n\x0e\n\x06\x04\xcc\x01\x02\0\x04\x12\x04\x82*\x02\n\n\
    \x0e\n\x06\x04\xcc\x01\x02\0\x06\x12\x04\x82*\x0b\x1f\n\x0e\n\x06\x04\
    \xcc\x01\x02\0\x01\x12\x04\x82*\x20(\n\x0e\n\x06\x04\xcc\x01\x02\0\x03\
    \x12\x04\x82*+,\n\xad\x01\n\x05\x04\xcc\x01\x02\x01\x12\x04\x87*\x02-\
    \x1a\x9d\x01\x20EmptyDir\x20represents\x20a\x20temporary\x20directory\
    \x20that\x20shares\x20a\x20pod's\x20lifetime.\n\x20More\x20info:\x20http\
    s://kubernetes.io/docs/concepts/storage/volumes#emptydir\n\x20+optional\
    \n\n\x0e\n\x06\x04\xcc\x01\x02\x01\x04\x12\x04\x87*\x02\n\n\x0e\n\x06\
    \x04\xcc\x01\x02\x01\x06\x12\x04\x87*\x0b\x1f\n\x0e\n\x06\x04\xcc\x01\
    \x02\x01\x01\x12\x04\x87*\x20(\n\x0e\n\x06\x04\xcc\x01\x02\x01\x03\x12\
    \x04\x87*+,\n\xea\x01\n\x05\x04\xcc\x01\x02\x02\x12\x04\x8d*\x02?\x1a\
    \xda\x01\x20GCEPersistentDisk\x20represents\x20a\x20GCE\x20Disk\x20resou\
    rce\x20that\x20is\x20attached\x20to\x20a\n\x20kubelet's\x20host\x20machi\
    ne\x20and\x20then\x20exposed\x20to\x20the\x20pod.\n\x20More\x20info:\x20\
    https://kubernetes.io/docs/concepts/storage/volumes#gcepersistentdisk\n\
    \x20+optional\n\n\x0e\n\x06\x04\xcc\x01\x02\x02\x04\x12\x04\x8d*\x02\n\n\
    \x0e\n\x06\x04\xcc\x01\x02\x02\x06\x12\x04\x8d*\x0b(\n\x0e\n\x06\x04\xcc\
    \x01\x02\x02\x01\x12\x04\x8d*):\n\x0e\n\x06\x04\xcc\x01\x02\x02\x03\x12\
    \x04\x8d*=>\n\xf1\x01\n\x05\x04\xcc\x01\x02\x03\x12\x04\x93*\x02E\x1a\
    \xe1\x01\x20AWSElasticBlockStore\x20represents\x20an\x20AWS\x20Disk\x20r\
    esource\x20that\x20is\x20attached\x20to\x20a\n\x20kubelet's\x20host\x20m\
    achine\x20and\x20then\x20exposed\x20to\x20the\x20pod.\n\x20More\x20info:\
    \x20https://kubernetes.io/docs/concepts/storage/volumes#awselasticblocks\
    tore\n\x20+optional\n\n\x0e\n\x06\x04\xcc\x01\x02\x03\x04\x12\x04\x93*\
    \x02\n\n\x0e\n\x06\x04\xcc\x01\x02\x03\x06\x12\x04\x93*\x0b+\n\x0e\n\x06\
    \x04\xcc\x01\x02\x03\x01\x12\x04\x93*,@\n\x0e\n\x06\x04\xcc\x01\x02\x03\
    \x03\x12\x04\x93*CD\n\xa4\x02\n\x05\x04\xcc\x01\x02\x04\x12\x04\x9a*\x02\
    +\x1a\x94\x02\x20GitRepo\x20represents\x20a\x20git\x20repository\x20at\
    \x20a\x20particular\x20revision.\n\x20DEPRECATED:\x20GitRepo\x20is\x20de\
    precated.\x20To\x20provision\x20a\x20container\x20with\x20a\x20git\x20re\
    po,\x20mount\x20an\n\x20EmptyDir\x20into\x20an\x20InitContainer\x20that\
    \x20clones\x20the\x20repo\x20using\x20git,\x20then\x20mount\x20the\x20Em\
    ptyDir\n\x20into\x20the\x20Pod's\x20container.\n\x20+optional\n\n\x0e\n\
    \x06\x04\xcc\x01\x02\x04\x04\x12\x04\x9a*\x02\n\n\x0e\n\x06\x04\xcc\x01\
    \x02\x04\x06\x12\x04\x9a*\x0b\x1e\n\x0e\n\x06\x04\xcc\x01\x02\x04\x01\
    \x12\x04\x9a*\x1f&\n\x0e\n\x06\x04\xcc\x01\x02\x04\x03\x12\x04\x9a*)*\n\
    \xa0\x01\n\x05\x04\xcc\x01\x02\x05\x12\x04\x9f*\x02)\x1a\x90\x01\x20Secr\
    et\x20represents\x20a\x20secret\x20that\x20should\x20populate\x20this\
    \x20volume.\n\x20More\x20info:\x20https://kubernetes.io/docs/concepts/st\
    orage/volumes#secret\n\x20+optional\n\n\x0e\n\x06\x04\xcc\x01\x02\x05\
    \x04\x12\x04\x9f*\x02\n\n\x0e\n\x06\x04\xcc\x01\x02\x05\x06\x12\x04\x9f*\
    \x0b\x1d\n\x0e\n\x06\x04\xcc\x01\x02\x05\x01\x12\x04\x9f*\x1e$\n\x0e\n\
    \x06\x04\xcc\x01\x02\x05\x03\x12\x04\x9f*'(\n\xa5\x01\n\x05\x04\xcc\x01\
    \x02\x06\x12\x04\xa4*\x02#\x1a\x95\x01\x20NFS\x20represents\x20an\x20NFS\
    \x20mount\x20on\x20the\x20host\x20that\x20shares\x20a\x20pod's\x20lifeti\
    me\n\x20More\x20info:\x20https://kubernetes.io/docs/concepts/storage/vol\
    umes#nfs\n\x20+optional\n\n\x0e\n\x06\x04\xcc\x01\x02\x06\x04\x12\x04\
    \xa4*\x02\n\n\x0e\n\x06\x04\xcc\x01\x02\x06\x06\x12\x04\xa4*\x0b\x1a\n\
    \x0e\n\x06\x04\xcc\x01\x02\x06\x01\x12\x04\xa4*\x1b\x1e\n\x0e\n\x06\x04\
    \xcc\x01\x02\x06\x03\x12\x04\xa4*!\"\n\xcb\x01\n\x05\x04\xcc\x01\x02\x07\
    \x12\x04\xaa*\x02'\x1a\xbb\x01\x20ISCSI\x20represents\x20an\x20ISCSI\x20\
    Disk\x20resource\x20that\x20is\x20attached\x20to\x20a\n\x20kubelet's\x20\
    host\x20machine\x20and\x20then\x20exposed\x20to\x20the\x20pod.\n\x20More\
    \x20info:\x20https://examples.k8s.io/volumes/iscsi/README.md\n\x20+optio\
    nal\n\n\x0e\n\x06\x04\xcc\x01\x02\x07\x04\x12\x04\xaa*\x02\n\n\x0e\n\x06\
    \x04\xcc\x01\x02\x07\x06\x12\x04\xaa*\x0b\x1c\n\x0e\n\x06\x04\xcc\x01\
    \x02\x07\x01\x12\x04\xaa*\x1d\"\n\x0e\n\x06\x04\xcc\x01\x02\x07\x03\x12\
    \x04\xaa*%&\n\xad\x01\n\x05\x04\xcc\x01\x02\x08\x12\x04\xaf*\x02/\x1a\
    \x9d\x01\x20Glusterfs\x20represents\x20a\x20Glusterfs\x20mount\x20on\x20\
    the\x20host\x20that\x20shares\x20a\x20pod's\x20lifetime.\n\x20More\x20in\
    fo:\x20https://examples.k8s.io/volumes/glusterfs/README.md\n\x20+optiona\
    l\n\n\x0e\n\x06\x04\xcc\x01\x02\x08\x04\x12\x04\xaf*\x02\n\n\x0e\n\x06\
    \x04\xcc\x01\x02\x08\x06\x12\x04\xaf*\x0b\x20\n\x0e\n\x06\x04\xcc\x01\
    \x02\x08\x01\x12\x04\xaf*!*\n\x0e\n\x06\x04\xcc\x01\x02\x08\x03\x12\x04\
    \xaf*-.\n\xea\x01\n\x05\x04\xcc\x01\x02\t\x12\x04\xb5*\x02H\x1a\xda\x01\
    \x20PersistentVolumeClaimVolumeSource\x20represents\x20a\x20reference\
    \x20to\x20a\n\x20PersistentVolumeClaim\x20in\x20the\x20same\x20namespace\
    .\n\x20More\x20info:\x20https://kubernetes.io/docs/concepts/storage/pers\
    istent-volumes#persistentvolumeclaims\n\x20+optional\n\n\x0e\n\x06\x04\
    \xcc\x01\x02\t\x04\x12\x04\xb5*\x02\n\n\x0e\n\x06\x04\xcc\x01\x02\t\x06\
    \x12\x04\xb5*\x0b,\n\x0e\n\x06\x04\xcc\x01\x02\t\x01\x12\x04\xb5*-B\n\
    \x0e\n\x06\x04\xcc\x01\x02\t\x03\x12\x04\xb5*EG\n\xaa\x01\n\x05\x04\xcc\
    \x01\x02\n\x12\x04\xba*\x02$\x1a\x9a\x01\x20RBD\x20represents\x20a\x20Ra\
    dos\x20Block\x20Device\x20mount\x20on\x20the\x20host\x20that\x20shares\
    \x20a\x20pod's\x20lifetime.\n\x20More\x20info:\x20https://examples.k8s.i\
    o/volumes/rbd/README.md\n\x20+optional\n\n\x0e\n\x06\x04\xcc\x01\x02\n\
    \x04\x12\x04\xba*\x02\n\n\x0e\n\x06\x04\xcc\x01\x02\n\x06\x12\x04\xba*\
    \x0b\x1a\n\x0e\n\x06\x04\xcc\x01\x02\n\x01\x12\x04\xba*\x1b\x1e\n\x0e\n\
    \x06\x04\xcc\x01\x02\n\x03\x12\x04\xba*!#\n\x85\x01\n\x05\x04\xcc\x01\
    \x02\x0b\x12\x04\xbf*\x02,\x1av\x20FlexVolume\x20represents\x20a\x20gene\
    ric\x20volume\x20resource\x20that\x20is\n\x20provisioned/attached\x20usi\
    ng\x20an\x20exec\x20based\x20plugin.\n\x20+optional\n\n\x0e\n\x06\x04\
    \xcc\x01\x02\x0b\x04\x12\x04\xbf*\x02\n\n\x0e\n\x06\x04\xcc\x01\x02\x0b\
    \x06\x12\x04\xbf*\x0b\x1b\n\x0e\n\x06\x04\xcc\x01\x02\x0b\x01\x12\x04\
    \xbf*\x1c&\n\x0e\n\x06\x04\xcc\x01\x02\x0b\x03\x12\x04\xbf*)+\n\xab\x01\
    \n\x05\x04\xcc\x01\x02\x0c\x12\x04\xc4*\x02*\x1a\x9b\x01\x20Cinder\x20re\
    presents\x20a\x20cinder\x20volume\x20attached\x20and\x20mounted\x20on\
    \x20kubelets\x20host\x20machine.\n\x20More\x20info:\x20https://examples.\
    k8s.io/mysql-cinder-pd/README.md\n\x20+optional\n\n\x0e\n\x06\x04\xcc\
    \x01\x02\x0c\x04\x12\x04\xc4*\x02\n\n\x0e\n\x06\x04\xcc\x01\x02\x0c\x06\
    \x12\x04\xc4*\x0b\x1d\n\x0e\n\x06\x04\xcc\x01\x02\x0c\x01\x12\x04\xc4*\
    \x1e$\n\x0e\n\x06\x04\xcc\x01\x02\x0c\x03\x12\x04\xc4*')\nf\n\x05\x04\
    \xcc\x01\x02\r\x12\x04\xc8*\x02*\x1aW\x20CephFS\x20represents\x20a\x20Ce\
    ph\x20FS\x20mount\x20on\x20the\x20host\x20that\x20shares\x20a\x20pod's\
    \x20lifetime\n\x20+optional\n\n\x0e\n\x06\x04\xcc\x01\x02\r\x04\x12\x04\
    \xc8*\x02\n\n\x0e\n\x06\x04\xcc\x01\x02\r\x06\x12\x04\xc8*\x0b\x1d\n\x0e\
    \n\x06\x04\xcc\x01\x02\r\x01\x12\x04\xc8*\x1e$\n\x0e\n\x06\x04\xcc\x01\
    \x02\r\x03\x12\x04\xc8*')\n\xa0\x01\n\x05\x04\xcc\x01\x02\x0e\x12\x04\
    \xcc*\x02,\x1a\x90\x01\x20Flocker\x20represents\x20a\x20Flocker\x20volum\
    e\x20attached\x20to\x20a\x20kubelet's\x20host\x20machine.\x20This\x20dep\
    ends\x20on\x20the\x20Flocker\x20control\x20service\x20being\x20running\n\
    \x20+optional\n\n\x0e\n\x06\x04\xcc\x01\x02\x0e\x04\x12\x04\xcc*\x02\n\n\
    \x0e\n\x06\x04\xcc\x01\x02\x0e\x06\x12\x04\xcc*\x0b\x1e\n\x0e\n\x06\x04\
    \xcc\x01\x02\x0e\x01\x12\x04\xcc*\x1f&\n\x0e\n\x06\x04\xcc\x01\x02\x0e\
    \x03\x12\x04\xcc*)+\nn\n\x05\x04\xcc\x01\x02\x0f\x12\x04\xd0*\x024\x1a_\
    \x20DownwardAPI\x20represents\x20downward\x20API\x20about\x20the\x20pod\
    \x20that\x20should\x20populate\x20this\x20volume\n\x20+optional\n\n\x0e\
    \n\x06\x04\xcc\x01\x02\x0f\x04\x12\x04\xd0*\x02\n\n\x0e\n\x06\x04\xcc\
    \x01\x02\x0f\x06\x12\x04\xd0*\x0b\"\n\x0e\n\x06\x04\xcc\x01\x02\x0f\x01\
    \x12\x04\xd0*#.\n\x0e\n\x06\x04\xcc\x01\x02\x0f\x03\x12\x04\xd0*13\n\x8c\
    \x01\n\x05\x04\xcc\x01\x02\x10\x12\x04\xd4*\x02\"\x1a}\x20FC\x20represen\
    ts\x20a\x20Fibre\x20Channel\x20resource\x20that\x20is\x20attached\x20to\
    \x20a\x20kubelet's\x20host\x20machine\x20and\x20then\x20exposed\x20to\
    \x20the\x20pod.\n\x20+optional\n\n\x0e\n\x06\x04\xcc\x01\x02\x10\x04\x12\
    \x04\xd4*\x02\n\n\x0e\n\x06\x04\xcc\x01\x02\x10\x06\x12\x04\xd4*\x0b\x19\
    \n\x0e\n\x06\x04\xcc\x01\x02\x10\x01\x12\x04\xd4*\x1a\x1c\n\x0e\n\x06\
    \x04\xcc\x01\x02\x10\x03\x12\x04\xd4*\x1f!\ns\n\x05\x04\xcc\x01\x02\x11\
    \x12\x04\xd8*\x020\x1ad\x20AzureFile\x20represents\x20an\x20Azure\x20Fil\
    e\x20Service\x20mount\x20on\x20the\x20host\x20and\x20bind\x20mount\x20to\
    \x20the\x20pod.\n\x20+optional\n\n\x0e\n\x06\x04\xcc\x01\x02\x11\x04\x12\
    \x04\xd8*\x02\n\n\x0e\n\x06\x04\xcc\x01\x02\x11\x06\x12\x04\xd8*\x0b\x20\
    \n\x0e\n\x06\x04\xcc\x01\x02\x11\x01\x12\x04\xd8*!*\n\x0e\n\x06\x04\xcc\
    \x01\x02\x11\x03\x12\x04\xd8*-/\n]\n\x05\x04\xcc\x01\x02\x12\x12\x04\xdc\
    *\x020\x1aN\x20ConfigMap\x20represents\x20a\x20configMap\x20that\x20shou\
    ld\x20populate\x20this\x20volume\n\x20+optional\n\n\x0e\n\x06\x04\xcc\
    \x01\x02\x12\x04\x12\x04\xdc*\x02\n\n\x0e\n\x06\x04\xcc\x01\x02\x12\x06\
    \x12\x04\xdc*\x0b\x20\n\x0e\n\x06\x04\xcc\x01\x02\x12\x01\x12\x04\xdc*!*\
    \n\x0e\n\x06\x04\xcc\x01\x02\x12\x03\x12\x04\xdc*-/\ns\n\x05\x04\xcc\x01\
    \x02\x13\x12\x04\xe0*\x02=\x1ad\x20VsphereVolume\x20represents\x20a\x20v\
    Sphere\x20volume\x20attached\x20and\x20mounted\x20on\x20kubelets\x20host\
    \x20machine\n\x20+optional\n\n\x0e\n\x06\x04\xcc\x01\x02\x13\x04\x12\x04\
    \xe0*\x02\n\n\x0e\n\x06\x04\xcc\x01\x02\x13\x06\x12\x04\xe0*\x0b)\n\x0e\
    \n\x06\x04\xcc\x01\x02\x13\x01\x12\x04\xe0**7\n\x0e\n\x06\x04\xcc\x01\
    \x02\x13\x03\x12\x04\xe0*:<\ng\n\x05\x04\xcc\x01\x02\x14\x12\x04\xe4*\
    \x02,\x1aX\x20Quobyte\x20represents\x20a\x20Quobyte\x20mount\x20on\x20th\
    e\x20host\x20that\x20shares\x20a\x20pod's\x20lifetime\n\x20+optional\n\n\
    \x0e\n\x06\x04\xcc\x01\x02\x14\x04\x12\x04\xe4*\x02\n\n\x0e\n\x06\x04\
    \xcc\x01\x02\x14\x06\x12\x04\xe4*\x0b\x1e\n\x0e\n\x06\x04\xcc\x01\x02\
    \x14\x01\x12\x04\xe4*\x1f&\n\x0e\n\x06\x04\xcc\x01\x02\x14\x03\x12\x04\
    \xe4*)+\np\n\x05\x04\xcc\x01\x02\x15\x12\x04\xe8*\x020\x1aa\x20AzureDisk\
    \x20represents\x20an\x20Azure\x20Data\x20Disk\x20mount\x20on\x20the\x20h\
    ost\x20and\x20bind\x20mount\x20to\x20the\x20pod.\n\x20+optional\n\n\x0e\
    \n\x06\x04\xcc\x01\x02\x15\x04\x12\x04\xe8*\x02\n\n\x0e\n\x06\x04\xcc\
    \x01\x02\x15\x06\x12\x04\xe8*\x0b\x20\n\x0e\n\x06\x04\xcc\x01\x02\x15\
    \x01\x12\x04\xe8*!*\n\x0e\n\x06\x04\xcc\x01\x02\x15\x03\x12\x04\xe8*-/\n\
    \x81\x01\n\x05\x04\xcc\x01\x02\x16\x12\x04\xeb*\x02F\x1ar\x20PhotonPersi\
    stentDisk\x20represents\x20a\x20PhotonController\x20persistent\x20disk\
    \x20attached\x20and\x20mounted\x20on\x20kubelets\x20host\x20machine\n\n\
    \x0e\n\x06\x04\xcc\x01\x02\x16\x04\x12\x04\xeb*\x02\n\n\x0e\n\x06\x04\
    \xcc\x01\x02\x16\x06\x12\x04\xeb*\x0b+\n\x0e\n\x06\x04\xcc\x01\x02\x16\
    \x01\x12\x04\xeb*,@\n\x0e\n\x06\x04\xcc\x01\x02\x16\x03\x12\x04\xeb*CE\n\
    U\n\x05\x04\xcc\x01\x02\x17\x12\x04\xee*\x020\x1aF\x20Items\x20for\x20al\
    l\x20in\x20one\x20resources\x20secrets,\x20configmaps,\x20and\x20downwar\
    d\x20API\n\n\x0e\n\x06\x04\xcc\x01\x02\x17\x04\x12\x04\xee*\x02\n\n\x0e\
    \n\x06\x04\xcc\x01\x02\x17\x06\x12\x04\xee*\x0b\x20\n\x0e\n\x06\x04\xcc\
    \x01\x02\x17\x01\x12\x04\xee*!*\n\x0e\n\x06\x04\xcc\x01\x02\x17\x03\x12\
    \x04\xee*-/\nu\n\x05\x04\xcc\x01\x02\x18\x12\x04\xf2*\x024\x1af\x20Portw\
    orxVolume\x20represents\x20a\x20portworx\x20volume\x20attached\x20and\
    \x20mounted\x20on\x20kubelets\x20host\x20machine\n\x20+optional\n\n\x0e\
    \n\x06\x04\xcc\x01\x02\x18\x04\x12\x04\xf2*\x02\n\n\x0e\n\x06\x04\xcc\
    \x01\x02\x18\x06\x12\x04\xf2*\x0b\x1f\n\x0e\n\x06\x04\xcc\x01\x02\x18\
    \x01\x12\x04\xf2*\x20.\n\x0e\n\x06\x04\xcc\x01\x02\x18\x03\x12\x04\xf2*1\
    3\nt\n\x05\x04\xcc\x01\x02\x19\x12\x04\xf6*\x02,\x1ae\x20ScaleIO\x20repr\
    esents\x20a\x20ScaleIO\x20persistent\x20volume\x20attached\x20and\x20mou\
    nted\x20on\x20Kubernetes\x20nodes.\n\x20+optional\n\n\x0e\n\x06\x04\xcc\
    \x01\x02\x19\x04\x12\x04\xf6*\x02\n\n\x0e\n\x06\x04\xcc\x01\x02\x19\x06\
    \x12\x04\xf6*\x0b\x1e\n\x0e\n\x06\x04\xcc\x01\x02\x19\x01\x12\x04\xf6*\
    \x1f&\n\x0e\n\x06\x04\xcc\x01\x02\x19\x03\x12\x04\xf6*)+\nm\n\x05\x04\
    \xcc\x01\x02\x1a\x12\x04\xfa*\x020\x1a^\x20StorageOS\x20represents\x20a\
    \x20StorageOS\x20volume\x20attached\x20and\x20mounted\x20on\x20Kubernete\
    s\x20nodes.\n\x20+optional\n\n\x0e\n\x06\x04\xcc\x01\x02\x1a\x04\x12\x04\
    \xfa*\x02\n\n\x0e\n\x06\x04\xcc\x01\x02\x1a\x06\x12\x04\xfa*\x0b\x20\n\
    \x0e\n\x06\x04\xcc\x01\x02\x1a\x01\x12\x04\xfa*!*\n\x0e\n\x06\x04\xcc\
    \x01\x02\x1a\x03\x12\x04\xfa*-/\n\x9b\x01\n\x05\x04\xcc\x01\x02\x1b\x12\
    \x04\xfe*\x02$\x1a\x8b\x01\x20CSI\x20(Container\x20Storage\x20Interface)\
    \x20represents\x20ephemeral\x20storage\x20that\x20is\x20handled\x20by\
    \x20certain\x20external\x20CSI\x20drivers\x20(Beta\x20feature).\n\x20+op\
    tional\n\n\x0e\n\x06\x04\xcc\x01\x02\x1b\x04\x12\x04\xfe*\x02\n\n\x0e\n\
    \x06\x04\xcc\x01\x02\x1b\x06\x12\x04\xfe*\x0b\x1a\n\x0e\n\x06\x04\xcc\
    \x01\x02\x1b\x01\x12\x04\xfe*\x1b\x1e\n\x0e\n\x06\x04\xcc\x01\x02\x1b\
    \x03\x12\x04\xfe*!#\n\xcf\x08\n\x05\x04\xcc\x01\x02\x1c\x12\x04\x9a+\x02\
    0\x1a\xbf\x08\x20Ephemeral\x20represents\x20a\x20volume\x20that\x20is\
    \x20handled\x20by\x20a\x20cluster\x20storage\x20driver\x20(Alpha\x20feat\
    ure).\n\x20The\x20volume's\x20lifecycle\x20is\x20tied\x20to\x20the\x20po\
    d\x20that\x20defines\x20it\x20-\x20it\x20will\x20be\x20created\x20before\
    \x20the\x20pod\x20starts,\n\x20and\x20deleted\x20when\x20the\x20pod\x20i\
    s\x20removed.\n\n\x20Use\x20this\x20if:\n\x20a)\x20the\x20volume\x20is\
    \x20only\x20needed\x20while\x20the\x20pod\x20runs,\n\x20b)\x20features\
    \x20of\x20normal\x20volumes\x20like\x20restoring\x20from\x20snapshot\x20\
    or\x20capacity\n\x20\x20\x20\x20tracking\x20are\x20needed,\n\x20c)\x20th\
    e\x20storage\x20driver\x20is\x20specified\x20through\x20a\x20storage\x20\
    class,\x20and\n\x20d)\x20the\x20storage\x20driver\x20supports\x20dynamic\
    \x20volume\x20provisioning\x20through\n\x20\x20\x20\x20a\x20PersistentVo\
    lumeClaim\x20(see\x20EphemeralVolumeSource\x20for\x20more\n\x20\x20\x20\
    \x20information\x20on\x20the\x20connection\x20between\x20this\x20volume\
    \x20type\n\x20\x20\x20\x20and\x20PersistentVolumeClaim).\n\n\x20Use\x20P\
    ersistentVolumeClaim\x20or\x20one\x20of\x20the\x20vendor-specific\n\x20A\
    PIs\x20for\x20volumes\x20that\x20persist\x20for\x20longer\x20than\x20the\
    \x20lifecycle\n\x20of\x20an\x20individual\x20pod.\n\n\x20Use\x20CSI\x20f\
    or\x20light-weight\x20local\x20ephemeral\x20volumes\x20if\x20the\x20CSI\
    \x20driver\x20is\x20meant\x20to\n\x20be\x20used\x20that\x20way\x20-\x20s\
    ee\x20the\x20documentation\x20of\x20the\x20driver\x20for\n\x20more\x20in\
    formation.\n\n\x20A\x20pod\x20can\x20use\x20both\x20types\x20of\x20ephem\
    eral\x20volumes\x20and\n\x20persistent\x20volumes\x20at\x20the\x20same\
    \x20time.\n\n\x20+optional\n\n\x0e\n\x06\x04\xcc\x01\x02\x1c\x04\x12\x04\
    \x9a+\x02\n\n\x0e\n\x06\x04\xcc\x01\x02\x1c\x06\x12\x04\x9a+\x0b\x20\n\
    \x0e\n\x06\x04\xcc\x01\x02\x1c\x01\x12\x04\x9a+!*\n\x0e\n\x06\x04\xcc\
    \x01\x02\x1c\x03\x12\x04\x9a+-/\n6\n\x03\x04\xcd\x01\x12\x06\x9e+\0\xaf+\
    \x01\x1a'\x20Represents\x20a\x20vSphere\x20volume\x20resource.\n\n\x0c\n\
    \x04\x04\xcd\x01\x01\x12\x04\x9e+\x08&\n9\n\x05\x04\xcd\x01\x02\0\x12\
    \x04\xa0+\x02!\x1a*\x20Path\x20that\x20identifies\x20vSphere\x20volume\
    \x20vmdk\n\n\x0e\n\x06\x04\xcd\x01\x02\0\x04\x12\x04\xa0+\x02\n\n\x0e\n\
    \x06\x04\xcd\x01\x02\0\x05\x12\x04\xa0+\x0b\x11\n\x0e\n\x06\x04\xcd\x01\
    \x02\0\x01\x12\x04\xa0+\x12\x1c\n\x0e\n\x06\x04\xcd\x01\x02\0\x03\x12\
    \x04\xa0+\x1f\x20\n\xc6\x01\n\x05\x04\xcd\x01\x02\x01\x12\x04\xa6+\x02\
    \x1d\x1a\xb6\x01\x20Filesystem\x20type\x20to\x20mount.\n\x20Must\x20be\
    \x20a\x20filesystem\x20type\x20supported\x20by\x20the\x20host\x20operati\
    ng\x20system.\n\x20Ex.\x20\"ext4\",\x20\"xfs\",\x20\"ntfs\".\x20Implicit\
    ly\x20inferred\x20to\x20be\x20\"ext4\"\x20if\x20unspecified.\n\x20+optio\
    nal\n\n\x0e\n\x06\x04\xcd\x01\x02\x01\x04\x12\x04\xa6+\x02\n\n\x0e\n\x06\
    \x04\xcd\x01\x02\x01\x05\x12\x04\xa6+\x0b\x11\n\x0e\n\x06\x04\xcd\x01\
    \x02\x01\x01\x12\x04\xa6+\x12\x18\n\x0e\n\x06\x04\xcd\x01\x02\x01\x03\
    \x12\x04\xa6+\x1b\x1c\nP\n\x05\x04\xcd\x01\x02\x02\x12\x04\xaa+\x02(\x1a\
    A\x20Storage\x20Policy\x20Based\x20Management\x20(SPBM)\x20profile\x20na\
    me.\n\x20+optional\n\n\x0e\n\x06\x04\xcd\x01\x02\x02\x04\x12\x04\xaa+\
    \x02\n\n\x0e\n\x06\x04\xcd\x01\x02\x02\x05\x12\x04\xaa+\x0b\x11\n\x0e\n\
    \x06\x04\xcd\x01\x02\x02\x01\x12\x04\xaa+\x12#\n\x0e\n\x06\x04\xcd\x01\
    \x02\x02\x03\x12\x04\xaa+&'\nt\n\x05\x04\xcd\x01\x02\x03\x12\x04\xae+\
    \x02&\x1ae\x20Storage\x20Policy\x20Based\x20Management\x20(SPBM)\x20prof\
    ile\x20ID\x20associated\x20with\x20the\x20StoragePolicyName.\n\x20+optio\
    nal\n\n\x0e\n\x06\x04\xcd\x01\x02\x03\x04\x12\x04\xae+\x02\n\n\x0e\n\x06\
    \x04\xcd\x01\x02\x03\x05\x12\x04\xae+\x0b\x11\n\x0e\n\x06\x04\xcd\x01\
    \x02\x03\x01\x12\x04\xae+\x12!\n\x0e\n\x06\x04\xcd\x01\x02\x03\x03\x12\
    \x04\xae+$%\n\x87\x01\n\x03\x04\xce\x01\x12\x06\xb2+\0\xb9+\x01\x1ax\x20\
    The\x20weights\x20of\x20all\x20of\x20the\x20matched\x20WeightedPodAffini\
    tyTerm\x20fields\x20are\x20added\x20per-node\x20to\x20find\x20the\x20mos\
    t\x20preferred\x20node(s)\n\n\x0c\n\x04\x04\xce\x01\x01\x12\x04\xb2+\x08\
    \x1f\nh\n\x05\x04\xce\x01\x02\0\x12\x04\xb5+\x02\x1c\x1aY\x20weight\x20a\
    ssociated\x20with\x20matching\x20the\x20corresponding\x20podAffinityTerm\
    ,\n\x20in\x20the\x20range\x201-100.\n\n\x0e\n\x06\x04\xce\x01\x02\0\x04\
    \x12\x04\xb5+\x02\n\n\x0e\n\x06\x04\xce\x01\x02\0\x05\x12\x04\xb5+\x0b\
    \x10\n\x0e\n\x06\x04\xce\x01\x02\0\x01\x12\x04\xb5+\x11\x17\n\x0e\n\x06\
    \x04\xce\x01\x02\0\x03\x12\x04\xb5+\x1a\x1b\nY\n\x05\x04\xce\x01\x02\x01\
    \x12\x04\xb8+\x02/\x1aJ\x20Required.\x20A\x20pod\x20affinity\x20term,\
    \x20associated\x20with\x20the\x20corresponding\x20weight.\n\n\x0e\n\x06\
    \x04\xce\x01\x02\x01\x04\x12\x04\xb8+\x02\n\n\x0e\n\x06\x04\xce\x01\x02\
    \x01\x06\x12\x04\xb8+\x0b\x1a\n\x0e\n\x06\x04\xce\x01\x02\x01\x01\x12\
    \x04\xb8+\x1b*\n\x0e\n\x06\x04\xce\x01\x02\x01\x03\x12\x04\xb8+-.\n`\n\
    \x03\x04\xcf\x01\x12\x06\xbc+\0\xcd+\x01\x1aQ\x20WindowsSecurityContextO\
    ptions\x20contain\x20Windows-specific\x20options\x20and\x20credentials.\
    \n\n\x0c\n\x04\x04\xcf\x01\x01\x12\x04\xbc+\x08%\nb\n\x05\x04\xcf\x01\
    \x02\0\x12\x04\xbf+\x02-\x1aS\x20GMSACredentialSpecName\x20is\x20the\x20\
    name\x20of\x20the\x20GMSA\x20credential\x20spec\x20to\x20use.\n\x20+opti\
    onal\n\n\x0e\n\x06\x04\xcf\x01\x02\0\x04\x12\x04\xbf+\x02\n\n\x0e\n\x06\
    \x04\xcf\x01\x02\0\x05\x12\x04\xbf+\x0b\x11\n\x0e\n\x06\x04\xcf\x01\x02\
    \0\x01\x12\x04\xbf+\x12(\n\x0e\n\x06\x04\xcf\x01\x02\0\x03\x12\x04\xbf++\
    ,\n\xe3\x01\n\x05\x04\xcf\x01\x02\x01\x12\x04\xc5+\x02)\x1a\xd3\x01\x20G\
    MSACredentialSpec\x20is\x20where\x20the\x20GMSA\x20admission\x20webhook\
    \n\x20(https://github.com/kubernetes-sigs/windows-gmsa)\x20inlines\x20th\
    e\x20contents\x20of\x20the\n\x20GMSA\x20credential\x20spec\x20named\x20b\
    y\x20the\x20GMSACredentialSpecName\x20field.\n\x20+optional\n\n\x0e\n\
    \x06\x04\xcf\x01\x02\x01\x04\x12\x04\xc5+\x02\n\n\x0e\n\x06\x04\xcf\x01\
    \x02\x01\x05\x12\x04\xc5+\x0b\x11\n\x0e\n\x06\x04\xcf\x01\x02\x01\x01\
    \x12\x04\xc5+\x12$\n\x0e\n\x06\x04\xcf\x01\x02\x01\x03\x12\x04\xc5+'(\n\
    \xbf\x02\n\x05\x04\xcf\x01\x02\x02\x12\x04\xcc+\x02$\x1a\xaf\x02\x20The\
    \x20UserName\x20in\x20Windows\x20to\x20run\x20the\x20entrypoint\x20of\
    \x20the\x20container\x20process.\n\x20Defaults\x20to\x20the\x20user\x20s\
    pecified\x20in\x20image\x20metadata\x20if\x20unspecified.\n\x20May\x20al\
    so\x20be\x20set\x20in\x20PodSecurityContext.\x20If\x20set\x20in\x20both\
    \x20SecurityContext\x20and\n\x20PodSecurityContext,\x20the\x20value\x20s\
    pecified\x20in\x20SecurityContext\x20takes\x20precedence.\n\x20+optional\
    \n\n\x0e\n\x06\x04\xcf\x01\x02\x02\x04\x12\x04\xcc+\x02\n\n\x0e\n\x06\
    \x04\xcf\x01\x02\x02\x05\x12\x04\xcc+\x0b\x11\n\x0e\n\x06\x04\xcf\x01\
    \x02\x02\x01\x12\x04\xcc+\x12\x1f\n\x0e\n\x06\x04\xcf\x01\x02\x02\x03\
    \x12\x04\xcc+\"#\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
