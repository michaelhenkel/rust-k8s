// This file is generated by rust-protobuf 2.27.1. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `ssd-git.juniper.net/contrail/cn2/contrail/pkg/apis/core/v1alpha1/contrail.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_27_1;

#[derive(PartialEq,Clone,Default)]
pub struct APSAttribute {
    // message fields
    sequence: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a APSAttribute {
    fn default() -> &'a APSAttribute {
        <APSAttribute as ::protobuf::Message>::default_instance()
    }
}

impl APSAttribute {
    pub fn new() -> APSAttribute {
        ::std::default::Default::default()
    }

    // optional string sequence = 1;


    pub fn get_sequence(&self) -> &str {
        match self.sequence.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_sequence(&mut self) {
        self.sequence.clear();
    }

    pub fn has_sequence(&self) -> bool {
        self.sequence.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sequence(&mut self, v: ::std::string::String) {
        self.sequence = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sequence(&mut self) -> &mut ::std::string::String {
        if self.sequence.is_none() {
            self.sequence.set_default();
        }
        self.sequence.as_mut().unwrap()
    }

    // Take field
    pub fn take_sequence(&mut self) -> ::std::string::String {
        self.sequence.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for APSAttribute {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.sequence)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.sequence.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.sequence.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> APSAttribute {
        APSAttribute::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "sequence",
                |m: &APSAttribute| { &m.sequence },
                |m: &mut APSAttribute| { &mut m.sequence },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<APSAttribute>(
                "APSAttribute",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static APSAttribute {
        static instance: ::protobuf::rt::LazyV2<APSAttribute> = ::protobuf::rt::LazyV2::INIT;
        instance.get(APSAttribute::new)
    }
}

impl ::protobuf::Clear for APSAttribute {
    fn clear(&mut self) {
        self.sequence.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for APSAttribute {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for APSAttribute {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AddressFamilies {
    // message fields
    pub family: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AddressFamilies {
    fn default() -> &'a AddressFamilies {
        <AddressFamilies as ::protobuf::Message>::default_instance()
    }
}

impl AddressFamilies {
    pub fn new() -> AddressFamilies {
        ::std::default::Default::default()
    }

    // repeated string family = 1;


    pub fn get_family(&self) -> &[::std::string::String] {
        &self.family
    }
    pub fn clear_family(&mut self) {
        self.family.clear();
    }

    // Param is passed by value, moved
    pub fn set_family(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.family = v;
    }

    // Mutable pointer to the field.
    pub fn mut_family(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.family
    }

    // Take field
    pub fn take_family(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.family, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for AddressFamilies {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.family)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.family {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.family {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AddressFamilies {
        AddressFamilies::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "family",
                |m: &AddressFamilies| { &m.family },
                |m: &mut AddressFamilies| { &mut m.family },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AddressFamilies>(
                "AddressFamilies",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AddressFamilies {
        static instance: ::protobuf::rt::LazyV2<AddressFamilies> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AddressFamilies::new)
    }
}

impl ::protobuf::Clear for AddressFamilies {
    fn clear(&mut self) {
        self.family.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AddressFamilies {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddressFamilies {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AddressGroup {
    // message fields
    pub metadata: ::protobuf::SingularPtrField<super::meta::ObjectMeta>,
    pub spec: ::protobuf::SingularPtrField<AddressGroupSpec>,
    pub status: ::protobuf::SingularPtrField<AddressGroupStatus>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AddressGroup {
    fn default() -> &'a AddressGroup {
        <AddressGroup as ::protobuf::Message>::default_instance()
    }
}

impl AddressGroup {
    pub fn new() -> AddressGroup {
        ::std::default::Default::default()
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;


    pub fn get_metadata(&self) -> &super::meta::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <super::meta::ObjectMeta as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::meta::ObjectMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::meta::ObjectMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::meta::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| super::meta::ObjectMeta::new())
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AddressGroupSpec spec = 2;


    pub fn get_spec(&self) -> &AddressGroupSpec {
        self.spec.as_ref().unwrap_or_else(|| <AddressGroupSpec as ::protobuf::Message>::default_instance())
    }
    pub fn clear_spec(&mut self) {
        self.spec.clear();
    }

    pub fn has_spec(&self) -> bool {
        self.spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spec(&mut self, v: AddressGroupSpec) {
        self.spec = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spec(&mut self) -> &mut AddressGroupSpec {
        if self.spec.is_none() {
            self.spec.set_default();
        }
        self.spec.as_mut().unwrap()
    }

    // Take field
    pub fn take_spec(&mut self) -> AddressGroupSpec {
        self.spec.take().unwrap_or_else(|| AddressGroupSpec::new())
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AddressGroupStatus status = 3;


    pub fn get_status(&self) -> &AddressGroupStatus {
        self.status.as_ref().unwrap_or_else(|| <AddressGroupStatus as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: AddressGroupStatus) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut AddressGroupStatus {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> AddressGroupStatus {
        self.status.take().unwrap_or_else(|| AddressGroupStatus::new())
    }
}

impl ::protobuf::Message for AddressGroup {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.spec {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.spec)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.spec.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AddressGroup {
        AddressGroup::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::meta::ObjectMeta>>(
                "metadata",
                |m: &AddressGroup| { &m.metadata },
                |m: &mut AddressGroup| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AddressGroupSpec>>(
                "spec",
                |m: &AddressGroup| { &m.spec },
                |m: &mut AddressGroup| { &mut m.spec },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AddressGroupStatus>>(
                "status",
                |m: &AddressGroup| { &m.status },
                |m: &mut AddressGroup| { &mut m.status },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AddressGroup>(
                "AddressGroup",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AddressGroup {
        static instance: ::protobuf::rt::LazyV2<AddressGroup> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AddressGroup::new)
    }
}

impl ::protobuf::Clear for AddressGroup {
    fn clear(&mut self) {
        self.metadata.clear();
        self.spec.clear();
        self.status.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AddressGroup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddressGroup {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AddressGroupList {
    // message fields
    pub metadata: ::protobuf::SingularPtrField<super::meta::ListMeta>,
    pub items: ::protobuf::RepeatedField<AddressGroup>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AddressGroupList {
    fn default() -> &'a AddressGroupList {
        <AddressGroupList as ::protobuf::Message>::default_instance()
    }
}

impl AddressGroupList {
    pub fn new() -> AddressGroupList {
        ::std::default::Default::default()
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;


    pub fn get_metadata(&self) -> &super::meta::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <super::meta::ListMeta as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::meta::ListMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::meta::ListMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::meta::ListMeta {
        self.metadata.take().unwrap_or_else(|| super::meta::ListMeta::new())
    }

    // repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AddressGroup items = 2;


    pub fn get_items(&self) -> &[AddressGroup] {
        &self.items
    }
    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::protobuf::RepeatedField<AddressGroup>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::protobuf::RepeatedField<AddressGroup> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::protobuf::RepeatedField<AddressGroup> {
        ::std::mem::replace(&mut self.items, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for AddressGroupList {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.items {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.items)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.items {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AddressGroupList {
        AddressGroupList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::meta::ListMeta>>(
                "metadata",
                |m: &AddressGroupList| { &m.metadata },
                |m: &mut AddressGroupList| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AddressGroup>>(
                "items",
                |m: &AddressGroupList| { &m.items },
                |m: &mut AddressGroupList| { &mut m.items },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AddressGroupList>(
                "AddressGroupList",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AddressGroupList {
        static instance: ::protobuf::rt::LazyV2<AddressGroupList> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AddressGroupList::new)
    }
}

impl ::protobuf::Clear for AddressGroupList {
    fn clear(&mut self) {
        self.metadata.clear();
        self.items.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AddressGroupList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddressGroupList {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AddressGroupPrefix {
    // message fields
    pub subnet: ::protobuf::RepeatedField<FirewallSubnet>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AddressGroupPrefix {
    fn default() -> &'a AddressGroupPrefix {
        <AddressGroupPrefix as ::protobuf::Message>::default_instance()
    }
}

impl AddressGroupPrefix {
    pub fn new() -> AddressGroupPrefix {
        ::std::default::Default::default()
    }

    // repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallSubnet subnet = 1;


    pub fn get_subnet(&self) -> &[FirewallSubnet] {
        &self.subnet
    }
    pub fn clear_subnet(&mut self) {
        self.subnet.clear();
    }

    // Param is passed by value, moved
    pub fn set_subnet(&mut self, v: ::protobuf::RepeatedField<FirewallSubnet>) {
        self.subnet = v;
    }

    // Mutable pointer to the field.
    pub fn mut_subnet(&mut self) -> &mut ::protobuf::RepeatedField<FirewallSubnet> {
        &mut self.subnet
    }

    // Take field
    pub fn take_subnet(&mut self) -> ::protobuf::RepeatedField<FirewallSubnet> {
        ::std::mem::replace(&mut self.subnet, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for AddressGroupPrefix {
    fn is_initialized(&self) -> bool {
        for v in &self.subnet {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.subnet)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.subnet {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.subnet {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AddressGroupPrefix {
        AddressGroupPrefix::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FirewallSubnet>>(
                "subnet",
                |m: &AddressGroupPrefix| { &m.subnet },
                |m: &mut AddressGroupPrefix| { &mut m.subnet },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AddressGroupPrefix>(
                "AddressGroupPrefix",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AddressGroupPrefix {
        static instance: ::protobuf::rt::LazyV2<AddressGroupPrefix> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AddressGroupPrefix::new)
    }
}

impl ::protobuf::Clear for AddressGroupPrefix {
    fn clear(&mut self) {
        self.subnet.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AddressGroupPrefix {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddressGroupPrefix {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AddressGroupSpec {
    // message fields
    pub commonSpec: ::protobuf::SingularPtrField<CommonSpec>,
    pub addressGroupPrefixes: ::protobuf::SingularPtrField<AddressGroupPrefix>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AddressGroupSpec {
    fn default() -> &'a AddressGroupSpec {
        <AddressGroupSpec as ::protobuf::Message>::default_instance()
    }
}

impl AddressGroupSpec {
    pub fn new() -> AddressGroupSpec {
        ::std::default::Default::default()
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonSpec commonSpec = 1;


    pub fn get_commonSpec(&self) -> &CommonSpec {
        self.commonSpec.as_ref().unwrap_or_else(|| <CommonSpec as ::protobuf::Message>::default_instance())
    }
    pub fn clear_commonSpec(&mut self) {
        self.commonSpec.clear();
    }

    pub fn has_commonSpec(&self) -> bool {
        self.commonSpec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_commonSpec(&mut self, v: CommonSpec) {
        self.commonSpec = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_commonSpec(&mut self) -> &mut CommonSpec {
        if self.commonSpec.is_none() {
            self.commonSpec.set_default();
        }
        self.commonSpec.as_mut().unwrap()
    }

    // Take field
    pub fn take_commonSpec(&mut self) -> CommonSpec {
        self.commonSpec.take().unwrap_or_else(|| CommonSpec::new())
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AddressGroupPrefix addressGroupPrefixes = 2;


    pub fn get_addressGroupPrefixes(&self) -> &AddressGroupPrefix {
        self.addressGroupPrefixes.as_ref().unwrap_or_else(|| <AddressGroupPrefix as ::protobuf::Message>::default_instance())
    }
    pub fn clear_addressGroupPrefixes(&mut self) {
        self.addressGroupPrefixes.clear();
    }

    pub fn has_addressGroupPrefixes(&self) -> bool {
        self.addressGroupPrefixes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_addressGroupPrefixes(&mut self, v: AddressGroupPrefix) {
        self.addressGroupPrefixes = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_addressGroupPrefixes(&mut self) -> &mut AddressGroupPrefix {
        if self.addressGroupPrefixes.is_none() {
            self.addressGroupPrefixes.set_default();
        }
        self.addressGroupPrefixes.as_mut().unwrap()
    }

    // Take field
    pub fn take_addressGroupPrefixes(&mut self) -> AddressGroupPrefix {
        self.addressGroupPrefixes.take().unwrap_or_else(|| AddressGroupPrefix::new())
    }
}

impl ::protobuf::Message for AddressGroupSpec {
    fn is_initialized(&self) -> bool {
        for v in &self.commonSpec {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.addressGroupPrefixes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.commonSpec)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.addressGroupPrefixes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.commonSpec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.addressGroupPrefixes.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.commonSpec.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.addressGroupPrefixes.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AddressGroupSpec {
        AddressGroupSpec::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommonSpec>>(
                "commonSpec",
                |m: &AddressGroupSpec| { &m.commonSpec },
                |m: &mut AddressGroupSpec| { &mut m.commonSpec },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AddressGroupPrefix>>(
                "addressGroupPrefixes",
                |m: &AddressGroupSpec| { &m.addressGroupPrefixes },
                |m: &mut AddressGroupSpec| { &mut m.addressGroupPrefixes },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AddressGroupSpec>(
                "AddressGroupSpec",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AddressGroupSpec {
        static instance: ::protobuf::rt::LazyV2<AddressGroupSpec> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AddressGroupSpec::new)
    }
}

impl ::protobuf::Clear for AddressGroupSpec {
    fn clear(&mut self) {
        self.commonSpec.clear();
        self.addressGroupPrefixes.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AddressGroupSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddressGroupSpec {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AddressGroupStatus {
    // message fields
    pub commonStatus: ::protobuf::SingularPtrField<CommonStatus>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AddressGroupStatus {
    fn default() -> &'a AddressGroupStatus {
        <AddressGroupStatus as ::protobuf::Message>::default_instance()
    }
}

impl AddressGroupStatus {
    pub fn new() -> AddressGroupStatus {
        ::std::default::Default::default()
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonStatus commonStatus = 1;


    pub fn get_commonStatus(&self) -> &CommonStatus {
        self.commonStatus.as_ref().unwrap_or_else(|| <CommonStatus as ::protobuf::Message>::default_instance())
    }
    pub fn clear_commonStatus(&mut self) {
        self.commonStatus.clear();
    }

    pub fn has_commonStatus(&self) -> bool {
        self.commonStatus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_commonStatus(&mut self, v: CommonStatus) {
        self.commonStatus = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_commonStatus(&mut self) -> &mut CommonStatus {
        if self.commonStatus.is_none() {
            self.commonStatus.set_default();
        }
        self.commonStatus.as_mut().unwrap()
    }

    // Take field
    pub fn take_commonStatus(&mut self) -> CommonStatus {
        self.commonStatus.take().unwrap_or_else(|| CommonStatus::new())
    }
}

impl ::protobuf::Message for AddressGroupStatus {
    fn is_initialized(&self) -> bool {
        for v in &self.commonStatus {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.commonStatus)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.commonStatus.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.commonStatus.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AddressGroupStatus {
        AddressGroupStatus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommonStatus>>(
                "commonStatus",
                |m: &AddressGroupStatus| { &m.commonStatus },
                |m: &mut AddressGroupStatus| { &mut m.commonStatus },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AddressGroupStatus>(
                "AddressGroupStatus",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AddressGroupStatus {
        static instance: ::protobuf::rt::LazyV2<AddressGroupStatus> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AddressGroupStatus::new)
    }
}

impl ::protobuf::Clear for AddressGroupStatus {
    fn clear(&mut self) {
        self.commonStatus.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AddressGroupStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddressGroupStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AllowedAddressPair {
    // message fields
    pub ip: ::protobuf::SingularPtrField<AllowedAddressPairSubnet>,
    mac: ::protobuf::SingularField<::std::string::String>,
    addressMode: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AllowedAddressPair {
    fn default() -> &'a AllowedAddressPair {
        <AllowedAddressPair as ::protobuf::Message>::default_instance()
    }
}

impl AllowedAddressPair {
    pub fn new() -> AllowedAddressPair {
        ::std::default::Default::default()
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AllowedAddressPairSubnet ip = 1;


    pub fn get_ip(&self) -> &AllowedAddressPairSubnet {
        self.ip.as_ref().unwrap_or_else(|| <AllowedAddressPairSubnet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_ip(&mut self) {
        self.ip.clear();
    }

    pub fn has_ip(&self) -> bool {
        self.ip.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ip(&mut self, v: AllowedAddressPairSubnet) {
        self.ip = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ip(&mut self) -> &mut AllowedAddressPairSubnet {
        if self.ip.is_none() {
            self.ip.set_default();
        }
        self.ip.as_mut().unwrap()
    }

    // Take field
    pub fn take_ip(&mut self) -> AllowedAddressPairSubnet {
        self.ip.take().unwrap_or_else(|| AllowedAddressPairSubnet::new())
    }

    // optional string mac = 2;


    pub fn get_mac(&self) -> &str {
        match self.mac.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_mac(&mut self) {
        self.mac.clear();
    }

    pub fn has_mac(&self) -> bool {
        self.mac.is_some()
    }

    // Param is passed by value, moved
    pub fn set_mac(&mut self, v: ::std::string::String) {
        self.mac = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_mac(&mut self) -> &mut ::std::string::String {
        if self.mac.is_none() {
            self.mac.set_default();
        }
        self.mac.as_mut().unwrap()
    }

    // Take field
    pub fn take_mac(&mut self) -> ::std::string::String {
        self.mac.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string addressMode = 3;


    pub fn get_addressMode(&self) -> &str {
        match self.addressMode.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_addressMode(&mut self) {
        self.addressMode.clear();
    }

    pub fn has_addressMode(&self) -> bool {
        self.addressMode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_addressMode(&mut self, v: ::std::string::String) {
        self.addressMode = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_addressMode(&mut self) -> &mut ::std::string::String {
        if self.addressMode.is_none() {
            self.addressMode.set_default();
        }
        self.addressMode.as_mut().unwrap()
    }

    // Take field
    pub fn take_addressMode(&mut self) -> ::std::string::String {
        self.addressMode.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for AllowedAddressPair {
    fn is_initialized(&self) -> bool {
        for v in &self.ip {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ip)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.mac)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.addressMode)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.ip.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.mac.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.addressMode.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.ip.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.mac.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.addressMode.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AllowedAddressPair {
        AllowedAddressPair::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AllowedAddressPairSubnet>>(
                "ip",
                |m: &AllowedAddressPair| { &m.ip },
                |m: &mut AllowedAddressPair| { &mut m.ip },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "mac",
                |m: &AllowedAddressPair| { &m.mac },
                |m: &mut AllowedAddressPair| { &mut m.mac },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "addressMode",
                |m: &AllowedAddressPair| { &m.addressMode },
                |m: &mut AllowedAddressPair| { &mut m.addressMode },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AllowedAddressPair>(
                "AllowedAddressPair",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AllowedAddressPair {
        static instance: ::protobuf::rt::LazyV2<AllowedAddressPair> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AllowedAddressPair::new)
    }
}

impl ::protobuf::Clear for AllowedAddressPair {
    fn clear(&mut self) {
        self.ip.clear();
        self.mac.clear();
        self.addressMode.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AllowedAddressPair {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AllowedAddressPair {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AllowedAddressPairSubnet {
    // message fields
    ipPrefix: ::protobuf::SingularField<::std::string::String>,
    pub ipPrefixLen: ::protobuf::SingularPtrField<super::generated::IntOrString>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AllowedAddressPairSubnet {
    fn default() -> &'a AllowedAddressPairSubnet {
        <AllowedAddressPairSubnet as ::protobuf::Message>::default_instance()
    }
}

impl AllowedAddressPairSubnet {
    pub fn new() -> AllowedAddressPairSubnet {
        ::std::default::Default::default()
    }

    // optional string ipPrefix = 1;


    pub fn get_ipPrefix(&self) -> &str {
        match self.ipPrefix.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_ipPrefix(&mut self) {
        self.ipPrefix.clear();
    }

    pub fn has_ipPrefix(&self) -> bool {
        self.ipPrefix.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ipPrefix(&mut self, v: ::std::string::String) {
        self.ipPrefix = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ipPrefix(&mut self) -> &mut ::std::string::String {
        if self.ipPrefix.is_none() {
            self.ipPrefix.set_default();
        }
        self.ipPrefix.as_mut().unwrap()
    }

    // Take field
    pub fn take_ipPrefix(&mut self) -> ::std::string::String {
        self.ipPrefix.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString ipPrefixLen = 2;


    pub fn get_ipPrefixLen(&self) -> &super::generated::IntOrString {
        self.ipPrefixLen.as_ref().unwrap_or_else(|| <super::generated::IntOrString as ::protobuf::Message>::default_instance())
    }
    pub fn clear_ipPrefixLen(&mut self) {
        self.ipPrefixLen.clear();
    }

    pub fn has_ipPrefixLen(&self) -> bool {
        self.ipPrefixLen.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ipPrefixLen(&mut self, v: super::generated::IntOrString) {
        self.ipPrefixLen = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ipPrefixLen(&mut self) -> &mut super::generated::IntOrString {
        if self.ipPrefixLen.is_none() {
            self.ipPrefixLen.set_default();
        }
        self.ipPrefixLen.as_mut().unwrap()
    }

    // Take field
    pub fn take_ipPrefixLen(&mut self) -> super::generated::IntOrString {
        self.ipPrefixLen.take().unwrap_or_else(|| super::generated::IntOrString::new())
    }
}

impl ::protobuf::Message for AllowedAddressPairSubnet {
    fn is_initialized(&self) -> bool {
        for v in &self.ipPrefixLen {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.ipPrefix)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ipPrefixLen)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.ipPrefix.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.ipPrefixLen.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.ipPrefix.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.ipPrefixLen.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AllowedAddressPairSubnet {
        AllowedAddressPairSubnet::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "ipPrefix",
                |m: &AllowedAddressPairSubnet| { &m.ipPrefix },
                |m: &mut AllowedAddressPairSubnet| { &mut m.ipPrefix },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::generated::IntOrString>>(
                "ipPrefixLen",
                |m: &AllowedAddressPairSubnet| { &m.ipPrefixLen },
                |m: &mut AllowedAddressPairSubnet| { &mut m.ipPrefixLen },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AllowedAddressPairSubnet>(
                "AllowedAddressPairSubnet",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AllowedAddressPairSubnet {
        static instance: ::protobuf::rt::LazyV2<AllowedAddressPairSubnet> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AllowedAddressPairSubnet::new)
    }
}

impl ::protobuf::Clear for AllowedAddressPairSubnet {
    fn clear(&mut self) {
        self.ipPrefix.clear();
        self.ipPrefixLen.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AllowedAddressPairSubnet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AllowedAddressPairSubnet {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AllowedAddressPairs {
    // message fields
    pub allowedAddressPair: ::protobuf::RepeatedField<AllowedAddressPair>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AllowedAddressPairs {
    fn default() -> &'a AllowedAddressPairs {
        <AllowedAddressPairs as ::protobuf::Message>::default_instance()
    }
}

impl AllowedAddressPairs {
    pub fn new() -> AllowedAddressPairs {
        ::std::default::Default::default()
    }

    // repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AllowedAddressPair allowedAddressPair = 1;


    pub fn get_allowedAddressPair(&self) -> &[AllowedAddressPair] {
        &self.allowedAddressPair
    }
    pub fn clear_allowedAddressPair(&mut self) {
        self.allowedAddressPair.clear();
    }

    // Param is passed by value, moved
    pub fn set_allowedAddressPair(&mut self, v: ::protobuf::RepeatedField<AllowedAddressPair>) {
        self.allowedAddressPair = v;
    }

    // Mutable pointer to the field.
    pub fn mut_allowedAddressPair(&mut self) -> &mut ::protobuf::RepeatedField<AllowedAddressPair> {
        &mut self.allowedAddressPair
    }

    // Take field
    pub fn take_allowedAddressPair(&mut self) -> ::protobuf::RepeatedField<AllowedAddressPair> {
        ::std::mem::replace(&mut self.allowedAddressPair, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for AllowedAddressPairs {
    fn is_initialized(&self) -> bool {
        for v in &self.allowedAddressPair {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.allowedAddressPair)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.allowedAddressPair {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.allowedAddressPair {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AllowedAddressPairs {
        AllowedAddressPairs::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AllowedAddressPair>>(
                "allowedAddressPair",
                |m: &AllowedAddressPairs| { &m.allowedAddressPair },
                |m: &mut AllowedAddressPairs| { &mut m.allowedAddressPair },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AllowedAddressPairs>(
                "AllowedAddressPairs",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AllowedAddressPairs {
        static instance: ::protobuf::rt::LazyV2<AllowedAddressPairs> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AllowedAddressPairs::new)
    }
}

impl ::protobuf::Clear for AllowedAddressPairs {
    fn clear(&mut self) {
        self.allowedAddressPair.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AllowedAddressPairs {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AllowedAddressPairs {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ApplicationPolicySet {
    // message fields
    pub metadata: ::protobuf::SingularPtrField<super::meta::ObjectMeta>,
    pub spec: ::protobuf::SingularPtrField<ApplicationPolicySetSpec>,
    pub status: ::protobuf::SingularPtrField<ApplicationPolicySetStatus>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ApplicationPolicySet {
    fn default() -> &'a ApplicationPolicySet {
        <ApplicationPolicySet as ::protobuf::Message>::default_instance()
    }
}

impl ApplicationPolicySet {
    pub fn new() -> ApplicationPolicySet {
        ::std::default::Default::default()
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;


    pub fn get_metadata(&self) -> &super::meta::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <super::meta::ObjectMeta as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::meta::ObjectMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::meta::ObjectMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::meta::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| super::meta::ObjectMeta::new())
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ApplicationPolicySetSpec spec = 2;


    pub fn get_spec(&self) -> &ApplicationPolicySetSpec {
        self.spec.as_ref().unwrap_or_else(|| <ApplicationPolicySetSpec as ::protobuf::Message>::default_instance())
    }
    pub fn clear_spec(&mut self) {
        self.spec.clear();
    }

    pub fn has_spec(&self) -> bool {
        self.spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spec(&mut self, v: ApplicationPolicySetSpec) {
        self.spec = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spec(&mut self) -> &mut ApplicationPolicySetSpec {
        if self.spec.is_none() {
            self.spec.set_default();
        }
        self.spec.as_mut().unwrap()
    }

    // Take field
    pub fn take_spec(&mut self) -> ApplicationPolicySetSpec {
        self.spec.take().unwrap_or_else(|| ApplicationPolicySetSpec::new())
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ApplicationPolicySetStatus status = 3;


    pub fn get_status(&self) -> &ApplicationPolicySetStatus {
        self.status.as_ref().unwrap_or_else(|| <ApplicationPolicySetStatus as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: ApplicationPolicySetStatus) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut ApplicationPolicySetStatus {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> ApplicationPolicySetStatus {
        self.status.take().unwrap_or_else(|| ApplicationPolicySetStatus::new())
    }
}

impl ::protobuf::Message for ApplicationPolicySet {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.spec {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.spec)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.spec.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ApplicationPolicySet {
        ApplicationPolicySet::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::meta::ObjectMeta>>(
                "metadata",
                |m: &ApplicationPolicySet| { &m.metadata },
                |m: &mut ApplicationPolicySet| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ApplicationPolicySetSpec>>(
                "spec",
                |m: &ApplicationPolicySet| { &m.spec },
                |m: &mut ApplicationPolicySet| { &mut m.spec },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ApplicationPolicySetStatus>>(
                "status",
                |m: &ApplicationPolicySet| { &m.status },
                |m: &mut ApplicationPolicySet| { &mut m.status },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ApplicationPolicySet>(
                "ApplicationPolicySet",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ApplicationPolicySet {
        static instance: ::protobuf::rt::LazyV2<ApplicationPolicySet> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ApplicationPolicySet::new)
    }
}

impl ::protobuf::Clear for ApplicationPolicySet {
    fn clear(&mut self) {
        self.metadata.clear();
        self.spec.clear();
        self.status.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ApplicationPolicySet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ApplicationPolicySet {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ApplicationPolicySetList {
    // message fields
    pub metadata: ::protobuf::SingularPtrField<super::meta::ListMeta>,
    pub items: ::protobuf::RepeatedField<ApplicationPolicySet>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ApplicationPolicySetList {
    fn default() -> &'a ApplicationPolicySetList {
        <ApplicationPolicySetList as ::protobuf::Message>::default_instance()
    }
}

impl ApplicationPolicySetList {
    pub fn new() -> ApplicationPolicySetList {
        ::std::default::Default::default()
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;


    pub fn get_metadata(&self) -> &super::meta::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <super::meta::ListMeta as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::meta::ListMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::meta::ListMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::meta::ListMeta {
        self.metadata.take().unwrap_or_else(|| super::meta::ListMeta::new())
    }

    // repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ApplicationPolicySet items = 2;


    pub fn get_items(&self) -> &[ApplicationPolicySet] {
        &self.items
    }
    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::protobuf::RepeatedField<ApplicationPolicySet>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::protobuf::RepeatedField<ApplicationPolicySet> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::protobuf::RepeatedField<ApplicationPolicySet> {
        ::std::mem::replace(&mut self.items, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ApplicationPolicySetList {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.items {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.items)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.items {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ApplicationPolicySetList {
        ApplicationPolicySetList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::meta::ListMeta>>(
                "metadata",
                |m: &ApplicationPolicySetList| { &m.metadata },
                |m: &mut ApplicationPolicySetList| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ApplicationPolicySet>>(
                "items",
                |m: &ApplicationPolicySetList| { &m.items },
                |m: &mut ApplicationPolicySetList| { &mut m.items },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ApplicationPolicySetList>(
                "ApplicationPolicySetList",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ApplicationPolicySetList {
        static instance: ::protobuf::rt::LazyV2<ApplicationPolicySetList> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ApplicationPolicySetList::new)
    }
}

impl ::protobuf::Clear for ApplicationPolicySetList {
    fn clear(&mut self) {
        self.metadata.clear();
        self.items.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ApplicationPolicySetList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ApplicationPolicySetList {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ApplicationPolicySetSpec {
    // message fields
    pub commonSpec: ::protobuf::SingularPtrField<CommonSpec>,
    pub firewallPolicyReferences: ::protobuf::RepeatedField<FirewallPolicyReference>,
    pub tagReferences: ::protobuf::RepeatedField<ResourceReference>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ApplicationPolicySetSpec {
    fn default() -> &'a ApplicationPolicySetSpec {
        <ApplicationPolicySetSpec as ::protobuf::Message>::default_instance()
    }
}

impl ApplicationPolicySetSpec {
    pub fn new() -> ApplicationPolicySetSpec {
        ::std::default::Default::default()
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonSpec commonSpec = 1;


    pub fn get_commonSpec(&self) -> &CommonSpec {
        self.commonSpec.as_ref().unwrap_or_else(|| <CommonSpec as ::protobuf::Message>::default_instance())
    }
    pub fn clear_commonSpec(&mut self) {
        self.commonSpec.clear();
    }

    pub fn has_commonSpec(&self) -> bool {
        self.commonSpec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_commonSpec(&mut self, v: CommonSpec) {
        self.commonSpec = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_commonSpec(&mut self) -> &mut CommonSpec {
        if self.commonSpec.is_none() {
            self.commonSpec.set_default();
        }
        self.commonSpec.as_mut().unwrap()
    }

    // Take field
    pub fn take_commonSpec(&mut self) -> CommonSpec {
        self.commonSpec.take().unwrap_or_else(|| CommonSpec::new())
    }

    // repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallPolicyReference firewallPolicyReferences = 2;


    pub fn get_firewallPolicyReferences(&self) -> &[FirewallPolicyReference] {
        &self.firewallPolicyReferences
    }
    pub fn clear_firewallPolicyReferences(&mut self) {
        self.firewallPolicyReferences.clear();
    }

    // Param is passed by value, moved
    pub fn set_firewallPolicyReferences(&mut self, v: ::protobuf::RepeatedField<FirewallPolicyReference>) {
        self.firewallPolicyReferences = v;
    }

    // Mutable pointer to the field.
    pub fn mut_firewallPolicyReferences(&mut self) -> &mut ::protobuf::RepeatedField<FirewallPolicyReference> {
        &mut self.firewallPolicyReferences
    }

    // Take field
    pub fn take_firewallPolicyReferences(&mut self) -> ::protobuf::RepeatedField<FirewallPolicyReference> {
        ::std::mem::replace(&mut self.firewallPolicyReferences, ::protobuf::RepeatedField::new())
    }

    // repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ResourceReference tagReferences = 3;


    pub fn get_tagReferences(&self) -> &[ResourceReference] {
        &self.tagReferences
    }
    pub fn clear_tagReferences(&mut self) {
        self.tagReferences.clear();
    }

    // Param is passed by value, moved
    pub fn set_tagReferences(&mut self, v: ::protobuf::RepeatedField<ResourceReference>) {
        self.tagReferences = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tagReferences(&mut self) -> &mut ::protobuf::RepeatedField<ResourceReference> {
        &mut self.tagReferences
    }

    // Take field
    pub fn take_tagReferences(&mut self) -> ::protobuf::RepeatedField<ResourceReference> {
        ::std::mem::replace(&mut self.tagReferences, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ApplicationPolicySetSpec {
    fn is_initialized(&self) -> bool {
        for v in &self.commonSpec {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.firewallPolicyReferences {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tagReferences {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.commonSpec)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.firewallPolicyReferences)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.tagReferences)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.commonSpec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.firewallPolicyReferences {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.tagReferences {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.commonSpec.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.firewallPolicyReferences {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.tagReferences {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ApplicationPolicySetSpec {
        ApplicationPolicySetSpec::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommonSpec>>(
                "commonSpec",
                |m: &ApplicationPolicySetSpec| { &m.commonSpec },
                |m: &mut ApplicationPolicySetSpec| { &mut m.commonSpec },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FirewallPolicyReference>>(
                "firewallPolicyReferences",
                |m: &ApplicationPolicySetSpec| { &m.firewallPolicyReferences },
                |m: &mut ApplicationPolicySetSpec| { &mut m.firewallPolicyReferences },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResourceReference>>(
                "tagReferences",
                |m: &ApplicationPolicySetSpec| { &m.tagReferences },
                |m: &mut ApplicationPolicySetSpec| { &mut m.tagReferences },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ApplicationPolicySetSpec>(
                "ApplicationPolicySetSpec",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ApplicationPolicySetSpec {
        static instance: ::protobuf::rt::LazyV2<ApplicationPolicySetSpec> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ApplicationPolicySetSpec::new)
    }
}

impl ::protobuf::Clear for ApplicationPolicySetSpec {
    fn clear(&mut self) {
        self.commonSpec.clear();
        self.firewallPolicyReferences.clear();
        self.tagReferences.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ApplicationPolicySetSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ApplicationPolicySetSpec {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ApplicationPolicySetStatus {
    // message fields
    pub commonStatus: ::protobuf::SingularPtrField<CommonStatus>,
    allApplications: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ApplicationPolicySetStatus {
    fn default() -> &'a ApplicationPolicySetStatus {
        <ApplicationPolicySetStatus as ::protobuf::Message>::default_instance()
    }
}

impl ApplicationPolicySetStatus {
    pub fn new() -> ApplicationPolicySetStatus {
        ::std::default::Default::default()
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonStatus commonStatus = 1;


    pub fn get_commonStatus(&self) -> &CommonStatus {
        self.commonStatus.as_ref().unwrap_or_else(|| <CommonStatus as ::protobuf::Message>::default_instance())
    }
    pub fn clear_commonStatus(&mut self) {
        self.commonStatus.clear();
    }

    pub fn has_commonStatus(&self) -> bool {
        self.commonStatus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_commonStatus(&mut self, v: CommonStatus) {
        self.commonStatus = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_commonStatus(&mut self) -> &mut CommonStatus {
        if self.commonStatus.is_none() {
            self.commonStatus.set_default();
        }
        self.commonStatus.as_mut().unwrap()
    }

    // Take field
    pub fn take_commonStatus(&mut self) -> CommonStatus {
        self.commonStatus.take().unwrap_or_else(|| CommonStatus::new())
    }

    // optional bool allApplications = 3;


    pub fn get_allApplications(&self) -> bool {
        self.allApplications.unwrap_or(false)
    }
    pub fn clear_allApplications(&mut self) {
        self.allApplications = ::std::option::Option::None;
    }

    pub fn has_allApplications(&self) -> bool {
        self.allApplications.is_some()
    }

    // Param is passed by value, moved
    pub fn set_allApplications(&mut self, v: bool) {
        self.allApplications = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ApplicationPolicySetStatus {
    fn is_initialized(&self) -> bool {
        for v in &self.commonStatus {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.commonStatus)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.allApplications = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.commonStatus.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.allApplications {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.commonStatus.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.allApplications {
            os.write_bool(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ApplicationPolicySetStatus {
        ApplicationPolicySetStatus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommonStatus>>(
                "commonStatus",
                |m: &ApplicationPolicySetStatus| { &m.commonStatus },
                |m: &mut ApplicationPolicySetStatus| { &mut m.commonStatus },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "allApplications",
                |m: &ApplicationPolicySetStatus| { &m.allApplications },
                |m: &mut ApplicationPolicySetStatus| { &mut m.allApplications },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ApplicationPolicySetStatus>(
                "ApplicationPolicySetStatus",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ApplicationPolicySetStatus {
        static instance: ::protobuf::rt::LazyV2<ApplicationPolicySetStatus> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ApplicationPolicySetStatus::new)
    }
}

impl ::protobuf::Clear for ApplicationPolicySetStatus {
    fn clear(&mut self) {
        self.commonStatus.clear();
        self.allApplications = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ApplicationPolicySetStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ApplicationPolicySetStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AuthenticationData {
    // message fields
    keyType: ::protobuf::SingularField<::std::string::String>,
    pub keyItems: ::protobuf::RepeatedField<AuthenticationKeyItem>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AuthenticationData {
    fn default() -> &'a AuthenticationData {
        <AuthenticationData as ::protobuf::Message>::default_instance()
    }
}

impl AuthenticationData {
    pub fn new() -> AuthenticationData {
        ::std::default::Default::default()
    }

    // optional string keyType = 1;


    pub fn get_keyType(&self) -> &str {
        match self.keyType.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_keyType(&mut self) {
        self.keyType.clear();
    }

    pub fn has_keyType(&self) -> bool {
        self.keyType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_keyType(&mut self, v: ::std::string::String) {
        self.keyType = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_keyType(&mut self) -> &mut ::std::string::String {
        if self.keyType.is_none() {
            self.keyType.set_default();
        }
        self.keyType.as_mut().unwrap()
    }

    // Take field
    pub fn take_keyType(&mut self) -> ::std::string::String {
        self.keyType.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AuthenticationKeyItem keyItems = 2;


    pub fn get_keyItems(&self) -> &[AuthenticationKeyItem] {
        &self.keyItems
    }
    pub fn clear_keyItems(&mut self) {
        self.keyItems.clear();
    }

    // Param is passed by value, moved
    pub fn set_keyItems(&mut self, v: ::protobuf::RepeatedField<AuthenticationKeyItem>) {
        self.keyItems = v;
    }

    // Mutable pointer to the field.
    pub fn mut_keyItems(&mut self) -> &mut ::protobuf::RepeatedField<AuthenticationKeyItem> {
        &mut self.keyItems
    }

    // Take field
    pub fn take_keyItems(&mut self) -> ::protobuf::RepeatedField<AuthenticationKeyItem> {
        ::std::mem::replace(&mut self.keyItems, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for AuthenticationData {
    fn is_initialized(&self) -> bool {
        for v in &self.keyItems {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.keyType)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.keyItems)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.keyType.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.keyItems {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.keyType.as_ref() {
            os.write_string(1, &v)?;
        }
        for v in &self.keyItems {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuthenticationData {
        AuthenticationData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "keyType",
                |m: &AuthenticationData| { &m.keyType },
                |m: &mut AuthenticationData| { &mut m.keyType },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AuthenticationKeyItem>>(
                "keyItems",
                |m: &AuthenticationData| { &m.keyItems },
                |m: &mut AuthenticationData| { &mut m.keyItems },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AuthenticationData>(
                "AuthenticationData",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AuthenticationData {
        static instance: ::protobuf::rt::LazyV2<AuthenticationData> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AuthenticationData::new)
    }
}

impl ::protobuf::Clear for AuthenticationData {
    fn clear(&mut self) {
        self.keyType.clear();
        self.keyItems.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AuthenticationData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthenticationData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct AuthenticationKeyItem {
    // message fields
    keyId: ::std::option::Option<i32>,
    key: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AuthenticationKeyItem {
    fn default() -> &'a AuthenticationKeyItem {
        <AuthenticationKeyItem as ::protobuf::Message>::default_instance()
    }
}

impl AuthenticationKeyItem {
    pub fn new() -> AuthenticationKeyItem {
        ::std::default::Default::default()
    }

    // optional int32 keyId = 1;


    pub fn get_keyId(&self) -> i32 {
        self.keyId.unwrap_or(0)
    }
    pub fn clear_keyId(&mut self) {
        self.keyId = ::std::option::Option::None;
    }

    pub fn has_keyId(&self) -> bool {
        self.keyId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_keyId(&mut self, v: i32) {
        self.keyId = ::std::option::Option::Some(v);
    }

    // optional string key = 2;


    pub fn get_key(&self) -> &str {
        match self.key.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        if self.key.is_none() {
            self.key.set_default();
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        self.key.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for AuthenticationKeyItem {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.keyId = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.key)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.keyId {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.key.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.keyId {
            os.write_int32(1, v)?;
        }
        if let Some(ref v) = self.key.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AuthenticationKeyItem {
        AuthenticationKeyItem::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "keyId",
                |m: &AuthenticationKeyItem| { &m.keyId },
                |m: &mut AuthenticationKeyItem| { &mut m.keyId },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "key",
                |m: &AuthenticationKeyItem| { &m.key },
                |m: &mut AuthenticationKeyItem| { &mut m.key },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<AuthenticationKeyItem>(
                "AuthenticationKeyItem",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static AuthenticationKeyItem {
        static instance: ::protobuf::rt::LazyV2<AuthenticationKeyItem> = ::protobuf::rt::LazyV2::INIT;
        instance.get(AuthenticationKeyItem::new)
    }
}

impl ::protobuf::Clear for AuthenticationKeyItem {
    fn clear(&mut self) {
        self.keyId = ::std::option::Option::None;
        self.key.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AuthenticationKeyItem {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AuthenticationKeyItem {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BGPAsAService {
    // message fields
    pub metadata: ::protobuf::SingularPtrField<super::meta::ObjectMeta>,
    pub spec: ::protobuf::SingularPtrField<BGPAsAServiceSpec>,
    pub status: ::protobuf::SingularPtrField<BGPAsAServiceStatus>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BGPAsAService {
    fn default() -> &'a BGPAsAService {
        <BGPAsAService as ::protobuf::Message>::default_instance()
    }
}

impl BGPAsAService {
    pub fn new() -> BGPAsAService {
        ::std::default::Default::default()
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;


    pub fn get_metadata(&self) -> &super::meta::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <super::meta::ObjectMeta as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::meta::ObjectMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::meta::ObjectMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::meta::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| super::meta::ObjectMeta::new())
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPAsAServiceSpec spec = 2;


    pub fn get_spec(&self) -> &BGPAsAServiceSpec {
        self.spec.as_ref().unwrap_or_else(|| <BGPAsAServiceSpec as ::protobuf::Message>::default_instance())
    }
    pub fn clear_spec(&mut self) {
        self.spec.clear();
    }

    pub fn has_spec(&self) -> bool {
        self.spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spec(&mut self, v: BGPAsAServiceSpec) {
        self.spec = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spec(&mut self) -> &mut BGPAsAServiceSpec {
        if self.spec.is_none() {
            self.spec.set_default();
        }
        self.spec.as_mut().unwrap()
    }

    // Take field
    pub fn take_spec(&mut self) -> BGPAsAServiceSpec {
        self.spec.take().unwrap_or_else(|| BGPAsAServiceSpec::new())
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPAsAServiceStatus status = 3;


    pub fn get_status(&self) -> &BGPAsAServiceStatus {
        self.status.as_ref().unwrap_or_else(|| <BGPAsAServiceStatus as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: BGPAsAServiceStatus) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut BGPAsAServiceStatus {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> BGPAsAServiceStatus {
        self.status.take().unwrap_or_else(|| BGPAsAServiceStatus::new())
    }
}

impl ::protobuf::Message for BGPAsAService {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.spec {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.spec)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.spec.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BGPAsAService {
        BGPAsAService::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::meta::ObjectMeta>>(
                "metadata",
                |m: &BGPAsAService| { &m.metadata },
                |m: &mut BGPAsAService| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BGPAsAServiceSpec>>(
                "spec",
                |m: &BGPAsAService| { &m.spec },
                |m: &mut BGPAsAService| { &mut m.spec },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BGPAsAServiceStatus>>(
                "status",
                |m: &BGPAsAService| { &m.status },
                |m: &mut BGPAsAService| { &mut m.status },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BGPAsAService>(
                "BGPAsAService",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BGPAsAService {
        static instance: ::protobuf::rt::LazyV2<BGPAsAService> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BGPAsAService::new)
    }
}

impl ::protobuf::Clear for BGPAsAService {
    fn clear(&mut self) {
        self.metadata.clear();
        self.spec.clear();
        self.status.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BGPAsAService {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BGPAsAService {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BGPAsAServiceList {
    // message fields
    pub metadata: ::protobuf::SingularPtrField<super::meta::ListMeta>,
    pub items: ::protobuf::RepeatedField<BGPAsAService>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BGPAsAServiceList {
    fn default() -> &'a BGPAsAServiceList {
        <BGPAsAServiceList as ::protobuf::Message>::default_instance()
    }
}

impl BGPAsAServiceList {
    pub fn new() -> BGPAsAServiceList {
        ::std::default::Default::default()
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;


    pub fn get_metadata(&self) -> &super::meta::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <super::meta::ListMeta as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::meta::ListMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::meta::ListMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::meta::ListMeta {
        self.metadata.take().unwrap_or_else(|| super::meta::ListMeta::new())
    }

    // repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPAsAService items = 2;


    pub fn get_items(&self) -> &[BGPAsAService] {
        &self.items
    }
    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::protobuf::RepeatedField<BGPAsAService>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::protobuf::RepeatedField<BGPAsAService> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::protobuf::RepeatedField<BGPAsAService> {
        ::std::mem::replace(&mut self.items, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for BGPAsAServiceList {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.items {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.items)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.items {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BGPAsAServiceList {
        BGPAsAServiceList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::meta::ListMeta>>(
                "metadata",
                |m: &BGPAsAServiceList| { &m.metadata },
                |m: &mut BGPAsAServiceList| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BGPAsAService>>(
                "items",
                |m: &BGPAsAServiceList| { &m.items },
                |m: &mut BGPAsAServiceList| { &mut m.items },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BGPAsAServiceList>(
                "BGPAsAServiceList",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BGPAsAServiceList {
        static instance: ::protobuf::rt::LazyV2<BGPAsAServiceList> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BGPAsAServiceList::new)
    }
}

impl ::protobuf::Clear for BGPAsAServiceList {
    fn clear(&mut self) {
        self.metadata.clear();
        self.items.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BGPAsAServiceList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BGPAsAServiceList {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BGPAsAServiceSpec {
    // message fields
    pub commonSpec: ::protobuf::SingularPtrField<CommonSpec>,
    shared: ::std::option::Option<bool>,
    ipAddress: ::protobuf::SingularField<::std::string::String>,
    autonomousSystem: ::std::option::Option<i32>,
    suppressRouteAdvertisement: ::std::option::Option<bool>,
    ipv4MappedIPv6NextHop: ::std::option::Option<bool>,
    pub bgpAsAServiceSessionAttributes: ::protobuf::SingularPtrField<BGPSessionAttributes>,
    pub virtualMachineInterfaceReferences: ::protobuf::RepeatedField<ResourceReference>,
    pub virtualMachineInterfacesSelector: ::protobuf::RepeatedField<super::meta::LabelSelector>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BGPAsAServiceSpec {
    fn default() -> &'a BGPAsAServiceSpec {
        <BGPAsAServiceSpec as ::protobuf::Message>::default_instance()
    }
}

impl BGPAsAServiceSpec {
    pub fn new() -> BGPAsAServiceSpec {
        ::std::default::Default::default()
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonSpec commonSpec = 1;


    pub fn get_commonSpec(&self) -> &CommonSpec {
        self.commonSpec.as_ref().unwrap_or_else(|| <CommonSpec as ::protobuf::Message>::default_instance())
    }
    pub fn clear_commonSpec(&mut self) {
        self.commonSpec.clear();
    }

    pub fn has_commonSpec(&self) -> bool {
        self.commonSpec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_commonSpec(&mut self, v: CommonSpec) {
        self.commonSpec = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_commonSpec(&mut self) -> &mut CommonSpec {
        if self.commonSpec.is_none() {
            self.commonSpec.set_default();
        }
        self.commonSpec.as_mut().unwrap()
    }

    // Take field
    pub fn take_commonSpec(&mut self) -> CommonSpec {
        self.commonSpec.take().unwrap_or_else(|| CommonSpec::new())
    }

    // optional bool shared = 2;


    pub fn get_shared(&self) -> bool {
        self.shared.unwrap_or(false)
    }
    pub fn clear_shared(&mut self) {
        self.shared = ::std::option::Option::None;
    }

    pub fn has_shared(&self) -> bool {
        self.shared.is_some()
    }

    // Param is passed by value, moved
    pub fn set_shared(&mut self, v: bool) {
        self.shared = ::std::option::Option::Some(v);
    }

    // optional string ipAddress = 3;


    pub fn get_ipAddress(&self) -> &str {
        match self.ipAddress.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_ipAddress(&mut self) {
        self.ipAddress.clear();
    }

    pub fn has_ipAddress(&self) -> bool {
        self.ipAddress.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ipAddress(&mut self, v: ::std::string::String) {
        self.ipAddress = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ipAddress(&mut self) -> &mut ::std::string::String {
        if self.ipAddress.is_none() {
            self.ipAddress.set_default();
        }
        self.ipAddress.as_mut().unwrap()
    }

    // Take field
    pub fn take_ipAddress(&mut self) -> ::std::string::String {
        self.ipAddress.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 autonomousSystem = 4;


    pub fn get_autonomousSystem(&self) -> i32 {
        self.autonomousSystem.unwrap_or(0)
    }
    pub fn clear_autonomousSystem(&mut self) {
        self.autonomousSystem = ::std::option::Option::None;
    }

    pub fn has_autonomousSystem(&self) -> bool {
        self.autonomousSystem.is_some()
    }

    // Param is passed by value, moved
    pub fn set_autonomousSystem(&mut self, v: i32) {
        self.autonomousSystem = ::std::option::Option::Some(v);
    }

    // optional bool suppressRouteAdvertisement = 5;


    pub fn get_suppressRouteAdvertisement(&self) -> bool {
        self.suppressRouteAdvertisement.unwrap_or(false)
    }
    pub fn clear_suppressRouteAdvertisement(&mut self) {
        self.suppressRouteAdvertisement = ::std::option::Option::None;
    }

    pub fn has_suppressRouteAdvertisement(&self) -> bool {
        self.suppressRouteAdvertisement.is_some()
    }

    // Param is passed by value, moved
    pub fn set_suppressRouteAdvertisement(&mut self, v: bool) {
        self.suppressRouteAdvertisement = ::std::option::Option::Some(v);
    }

    // optional bool ipv4MappedIPv6NextHop = 6;


    pub fn get_ipv4MappedIPv6NextHop(&self) -> bool {
        self.ipv4MappedIPv6NextHop.unwrap_or(false)
    }
    pub fn clear_ipv4MappedIPv6NextHop(&mut self) {
        self.ipv4MappedIPv6NextHop = ::std::option::Option::None;
    }

    pub fn has_ipv4MappedIPv6NextHop(&self) -> bool {
        self.ipv4MappedIPv6NextHop.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ipv4MappedIPv6NextHop(&mut self, v: bool) {
        self.ipv4MappedIPv6NextHop = ::std::option::Option::Some(v);
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPSessionAttributes bgpAsAServiceSessionAttributes = 7;


    pub fn get_bgpAsAServiceSessionAttributes(&self) -> &BGPSessionAttributes {
        self.bgpAsAServiceSessionAttributes.as_ref().unwrap_or_else(|| <BGPSessionAttributes as ::protobuf::Message>::default_instance())
    }
    pub fn clear_bgpAsAServiceSessionAttributes(&mut self) {
        self.bgpAsAServiceSessionAttributes.clear();
    }

    pub fn has_bgpAsAServiceSessionAttributes(&self) -> bool {
        self.bgpAsAServiceSessionAttributes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bgpAsAServiceSessionAttributes(&mut self, v: BGPSessionAttributes) {
        self.bgpAsAServiceSessionAttributes = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bgpAsAServiceSessionAttributes(&mut self) -> &mut BGPSessionAttributes {
        if self.bgpAsAServiceSessionAttributes.is_none() {
            self.bgpAsAServiceSessionAttributes.set_default();
        }
        self.bgpAsAServiceSessionAttributes.as_mut().unwrap()
    }

    // Take field
    pub fn take_bgpAsAServiceSessionAttributes(&mut self) -> BGPSessionAttributes {
        self.bgpAsAServiceSessionAttributes.take().unwrap_or_else(|| BGPSessionAttributes::new())
    }

    // repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ResourceReference virtualMachineInterfaceReferences = 8;


    pub fn get_virtualMachineInterfaceReferences(&self) -> &[ResourceReference] {
        &self.virtualMachineInterfaceReferences
    }
    pub fn clear_virtualMachineInterfaceReferences(&mut self) {
        self.virtualMachineInterfaceReferences.clear();
    }

    // Param is passed by value, moved
    pub fn set_virtualMachineInterfaceReferences(&mut self, v: ::protobuf::RepeatedField<ResourceReference>) {
        self.virtualMachineInterfaceReferences = v;
    }

    // Mutable pointer to the field.
    pub fn mut_virtualMachineInterfaceReferences(&mut self) -> &mut ::protobuf::RepeatedField<ResourceReference> {
        &mut self.virtualMachineInterfaceReferences
    }

    // Take field
    pub fn take_virtualMachineInterfaceReferences(&mut self) -> ::protobuf::RepeatedField<ResourceReference> {
        ::std::mem::replace(&mut self.virtualMachineInterfaceReferences, ::protobuf::RepeatedField::new())
    }

    // repeated .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector virtualMachineInterfacesSelector = 9;


    pub fn get_virtualMachineInterfacesSelector(&self) -> &[super::meta::LabelSelector] {
        &self.virtualMachineInterfacesSelector
    }
    pub fn clear_virtualMachineInterfacesSelector(&mut self) {
        self.virtualMachineInterfacesSelector.clear();
    }

    // Param is passed by value, moved
    pub fn set_virtualMachineInterfacesSelector(&mut self, v: ::protobuf::RepeatedField<super::meta::LabelSelector>) {
        self.virtualMachineInterfacesSelector = v;
    }

    // Mutable pointer to the field.
    pub fn mut_virtualMachineInterfacesSelector(&mut self) -> &mut ::protobuf::RepeatedField<super::meta::LabelSelector> {
        &mut self.virtualMachineInterfacesSelector
    }

    // Take field
    pub fn take_virtualMachineInterfacesSelector(&mut self) -> ::protobuf::RepeatedField<super::meta::LabelSelector> {
        ::std::mem::replace(&mut self.virtualMachineInterfacesSelector, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for BGPAsAServiceSpec {
    fn is_initialized(&self) -> bool {
        for v in &self.commonSpec {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.bgpAsAServiceSessionAttributes {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.virtualMachineInterfaceReferences {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.virtualMachineInterfacesSelector {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.commonSpec)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.shared = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.ipAddress)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.autonomousSystem = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.suppressRouteAdvertisement = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.ipv4MappedIPv6NextHop = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.bgpAsAServiceSessionAttributes)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.virtualMachineInterfaceReferences)?;
                },
                9 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.virtualMachineInterfacesSelector)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.commonSpec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.shared {
            my_size += 2;
        }
        if let Some(ref v) = self.ipAddress.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.autonomousSystem {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.suppressRouteAdvertisement {
            my_size += 2;
        }
        if let Some(v) = self.ipv4MappedIPv6NextHop {
            my_size += 2;
        }
        if let Some(ref v) = self.bgpAsAServiceSessionAttributes.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.virtualMachineInterfaceReferences {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.virtualMachineInterfacesSelector {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.commonSpec.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.shared {
            os.write_bool(2, v)?;
        }
        if let Some(ref v) = self.ipAddress.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.autonomousSystem {
            os.write_int32(4, v)?;
        }
        if let Some(v) = self.suppressRouteAdvertisement {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.ipv4MappedIPv6NextHop {
            os.write_bool(6, v)?;
        }
        if let Some(ref v) = self.bgpAsAServiceSessionAttributes.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.virtualMachineInterfaceReferences {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.virtualMachineInterfacesSelector {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BGPAsAServiceSpec {
        BGPAsAServiceSpec::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommonSpec>>(
                "commonSpec",
                |m: &BGPAsAServiceSpec| { &m.commonSpec },
                |m: &mut BGPAsAServiceSpec| { &mut m.commonSpec },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "shared",
                |m: &BGPAsAServiceSpec| { &m.shared },
                |m: &mut BGPAsAServiceSpec| { &mut m.shared },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "ipAddress",
                |m: &BGPAsAServiceSpec| { &m.ipAddress },
                |m: &mut BGPAsAServiceSpec| { &mut m.ipAddress },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "autonomousSystem",
                |m: &BGPAsAServiceSpec| { &m.autonomousSystem },
                |m: &mut BGPAsAServiceSpec| { &mut m.autonomousSystem },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "suppressRouteAdvertisement",
                |m: &BGPAsAServiceSpec| { &m.suppressRouteAdvertisement },
                |m: &mut BGPAsAServiceSpec| { &mut m.suppressRouteAdvertisement },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "ipv4MappedIPv6NextHop",
                |m: &BGPAsAServiceSpec| { &m.ipv4MappedIPv6NextHop },
                |m: &mut BGPAsAServiceSpec| { &mut m.ipv4MappedIPv6NextHop },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BGPSessionAttributes>>(
                "bgpAsAServiceSessionAttributes",
                |m: &BGPAsAServiceSpec| { &m.bgpAsAServiceSessionAttributes },
                |m: &mut BGPAsAServiceSpec| { &mut m.bgpAsAServiceSessionAttributes },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResourceReference>>(
                "virtualMachineInterfaceReferences",
                |m: &BGPAsAServiceSpec| { &m.virtualMachineInterfaceReferences },
                |m: &mut BGPAsAServiceSpec| { &mut m.virtualMachineInterfaceReferences },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::meta::LabelSelector>>(
                "virtualMachineInterfacesSelector",
                |m: &BGPAsAServiceSpec| { &m.virtualMachineInterfacesSelector },
                |m: &mut BGPAsAServiceSpec| { &mut m.virtualMachineInterfacesSelector },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BGPAsAServiceSpec>(
                "BGPAsAServiceSpec",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BGPAsAServiceSpec {
        static instance: ::protobuf::rt::LazyV2<BGPAsAServiceSpec> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BGPAsAServiceSpec::new)
    }
}

impl ::protobuf::Clear for BGPAsAServiceSpec {
    fn clear(&mut self) {
        self.commonSpec.clear();
        self.shared = ::std::option::Option::None;
        self.ipAddress.clear();
        self.autonomousSystem = ::std::option::Option::None;
        self.suppressRouteAdvertisement = ::std::option::Option::None;
        self.ipv4MappedIPv6NextHop = ::std::option::Option::None;
        self.bgpAsAServiceSessionAttributes.clear();
        self.virtualMachineInterfaceReferences.clear();
        self.virtualMachineInterfacesSelector.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BGPAsAServiceSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BGPAsAServiceSpec {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BGPAsAServiceStatus {
    // message fields
    pub commonStatus: ::protobuf::SingularPtrField<CommonStatus>,
    pub bgpRouterReferences: ::protobuf::RepeatedField<BGPRouterReference>,
    pub subnetReferences: ::protobuf::RepeatedField<SubnetReference>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BGPAsAServiceStatus {
    fn default() -> &'a BGPAsAServiceStatus {
        <BGPAsAServiceStatus as ::protobuf::Message>::default_instance()
    }
}

impl BGPAsAServiceStatus {
    pub fn new() -> BGPAsAServiceStatus {
        ::std::default::Default::default()
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonStatus commonStatus = 1;


    pub fn get_commonStatus(&self) -> &CommonStatus {
        self.commonStatus.as_ref().unwrap_or_else(|| <CommonStatus as ::protobuf::Message>::default_instance())
    }
    pub fn clear_commonStatus(&mut self) {
        self.commonStatus.clear();
    }

    pub fn has_commonStatus(&self) -> bool {
        self.commonStatus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_commonStatus(&mut self, v: CommonStatus) {
        self.commonStatus = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_commonStatus(&mut self) -> &mut CommonStatus {
        if self.commonStatus.is_none() {
            self.commonStatus.set_default();
        }
        self.commonStatus.as_mut().unwrap()
    }

    // Take field
    pub fn take_commonStatus(&mut self) -> CommonStatus {
        self.commonStatus.take().unwrap_or_else(|| CommonStatus::new())
    }

    // repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterReference bgpRouterReferences = 2;


    pub fn get_bgpRouterReferences(&self) -> &[BGPRouterReference] {
        &self.bgpRouterReferences
    }
    pub fn clear_bgpRouterReferences(&mut self) {
        self.bgpRouterReferences.clear();
    }

    // Param is passed by value, moved
    pub fn set_bgpRouterReferences(&mut self, v: ::protobuf::RepeatedField<BGPRouterReference>) {
        self.bgpRouterReferences = v;
    }

    // Mutable pointer to the field.
    pub fn mut_bgpRouterReferences(&mut self) -> &mut ::protobuf::RepeatedField<BGPRouterReference> {
        &mut self.bgpRouterReferences
    }

    // Take field
    pub fn take_bgpRouterReferences(&mut self) -> ::protobuf::RepeatedField<BGPRouterReference> {
        ::std::mem::replace(&mut self.bgpRouterReferences, ::protobuf::RepeatedField::new())
    }

    // repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.SubnetReference subnetReferences = 3;


    pub fn get_subnetReferences(&self) -> &[SubnetReference] {
        &self.subnetReferences
    }
    pub fn clear_subnetReferences(&mut self) {
        self.subnetReferences.clear();
    }

    // Param is passed by value, moved
    pub fn set_subnetReferences(&mut self, v: ::protobuf::RepeatedField<SubnetReference>) {
        self.subnetReferences = v;
    }

    // Mutable pointer to the field.
    pub fn mut_subnetReferences(&mut self) -> &mut ::protobuf::RepeatedField<SubnetReference> {
        &mut self.subnetReferences
    }

    // Take field
    pub fn take_subnetReferences(&mut self) -> ::protobuf::RepeatedField<SubnetReference> {
        ::std::mem::replace(&mut self.subnetReferences, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for BGPAsAServiceStatus {
    fn is_initialized(&self) -> bool {
        for v in &self.commonStatus {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.bgpRouterReferences {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.subnetReferences {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.commonStatus)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.bgpRouterReferences)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.subnetReferences)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.commonStatus.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.bgpRouterReferences {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.subnetReferences {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.commonStatus.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.bgpRouterReferences {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.subnetReferences {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BGPAsAServiceStatus {
        BGPAsAServiceStatus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommonStatus>>(
                "commonStatus",
                |m: &BGPAsAServiceStatus| { &m.commonStatus },
                |m: &mut BGPAsAServiceStatus| { &mut m.commonStatus },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BGPRouterReference>>(
                "bgpRouterReferences",
                |m: &BGPAsAServiceStatus| { &m.bgpRouterReferences },
                |m: &mut BGPAsAServiceStatus| { &mut m.bgpRouterReferences },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SubnetReference>>(
                "subnetReferences",
                |m: &BGPAsAServiceStatus| { &m.subnetReferences },
                |m: &mut BGPAsAServiceStatus| { &mut m.subnetReferences },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BGPAsAServiceStatus>(
                "BGPAsAServiceStatus",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BGPAsAServiceStatus {
        static instance: ::protobuf::rt::LazyV2<BGPAsAServiceStatus> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BGPAsAServiceStatus::new)
    }
}

impl ::protobuf::Clear for BGPAsAServiceStatus {
    fn clear(&mut self) {
        self.commonStatus.clear();
        self.bgpRouterReferences.clear();
        self.subnetReferences.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BGPAsAServiceStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BGPAsAServiceStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BGPFamilyAttributes {
    // message fields
    addressFamily: ::protobuf::SingularField<::std::string::String>,
    loopCount: ::std::option::Option<i32>,
    pub prefixLimit: ::protobuf::SingularPtrField<BGPPrefixLimit>,
    pub defaultTunnelEncap: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BGPFamilyAttributes {
    fn default() -> &'a BGPFamilyAttributes {
        <BGPFamilyAttributes as ::protobuf::Message>::default_instance()
    }
}

impl BGPFamilyAttributes {
    pub fn new() -> BGPFamilyAttributes {
        ::std::default::Default::default()
    }

    // optional string addressFamily = 1;


    pub fn get_addressFamily(&self) -> &str {
        match self.addressFamily.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_addressFamily(&mut self) {
        self.addressFamily.clear();
    }

    pub fn has_addressFamily(&self) -> bool {
        self.addressFamily.is_some()
    }

    // Param is passed by value, moved
    pub fn set_addressFamily(&mut self, v: ::std::string::String) {
        self.addressFamily = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_addressFamily(&mut self) -> &mut ::std::string::String {
        if self.addressFamily.is_none() {
            self.addressFamily.set_default();
        }
        self.addressFamily.as_mut().unwrap()
    }

    // Take field
    pub fn take_addressFamily(&mut self) -> ::std::string::String {
        self.addressFamily.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 loopCount = 2;


    pub fn get_loopCount(&self) -> i32 {
        self.loopCount.unwrap_or(0)
    }
    pub fn clear_loopCount(&mut self) {
        self.loopCount = ::std::option::Option::None;
    }

    pub fn has_loopCount(&self) -> bool {
        self.loopCount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_loopCount(&mut self, v: i32) {
        self.loopCount = ::std::option::Option::Some(v);
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPPrefixLimit prefixLimit = 3;


    pub fn get_prefixLimit(&self) -> &BGPPrefixLimit {
        self.prefixLimit.as_ref().unwrap_or_else(|| <BGPPrefixLimit as ::protobuf::Message>::default_instance())
    }
    pub fn clear_prefixLimit(&mut self) {
        self.prefixLimit.clear();
    }

    pub fn has_prefixLimit(&self) -> bool {
        self.prefixLimit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_prefixLimit(&mut self, v: BGPPrefixLimit) {
        self.prefixLimit = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_prefixLimit(&mut self) -> &mut BGPPrefixLimit {
        if self.prefixLimit.is_none() {
            self.prefixLimit.set_default();
        }
        self.prefixLimit.as_mut().unwrap()
    }

    // Take field
    pub fn take_prefixLimit(&mut self) -> BGPPrefixLimit {
        self.prefixLimit.take().unwrap_or_else(|| BGPPrefixLimit::new())
    }

    // repeated string defaultTunnelEncap = 4;


    pub fn get_defaultTunnelEncap(&self) -> &[::std::string::String] {
        &self.defaultTunnelEncap
    }
    pub fn clear_defaultTunnelEncap(&mut self) {
        self.defaultTunnelEncap.clear();
    }

    // Param is passed by value, moved
    pub fn set_defaultTunnelEncap(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.defaultTunnelEncap = v;
    }

    // Mutable pointer to the field.
    pub fn mut_defaultTunnelEncap(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.defaultTunnelEncap
    }

    // Take field
    pub fn take_defaultTunnelEncap(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.defaultTunnelEncap, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for BGPFamilyAttributes {
    fn is_initialized(&self) -> bool {
        for v in &self.prefixLimit {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.addressFamily)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.loopCount = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.prefixLimit)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.defaultTunnelEncap)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.addressFamily.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.loopCount {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.prefixLimit.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.defaultTunnelEncap {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.addressFamily.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.loopCount {
            os.write_int32(2, v)?;
        }
        if let Some(ref v) = self.prefixLimit.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.defaultTunnelEncap {
            os.write_string(4, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BGPFamilyAttributes {
        BGPFamilyAttributes::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "addressFamily",
                |m: &BGPFamilyAttributes| { &m.addressFamily },
                |m: &mut BGPFamilyAttributes| { &mut m.addressFamily },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "loopCount",
                |m: &BGPFamilyAttributes| { &m.loopCount },
                |m: &mut BGPFamilyAttributes| { &mut m.loopCount },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BGPPrefixLimit>>(
                "prefixLimit",
                |m: &BGPFamilyAttributes| { &m.prefixLimit },
                |m: &mut BGPFamilyAttributes| { &mut m.prefixLimit },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "defaultTunnelEncap",
                |m: &BGPFamilyAttributes| { &m.defaultTunnelEncap },
                |m: &mut BGPFamilyAttributes| { &mut m.defaultTunnelEncap },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BGPFamilyAttributes>(
                "BGPFamilyAttributes",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BGPFamilyAttributes {
        static instance: ::protobuf::rt::LazyV2<BGPFamilyAttributes> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BGPFamilyAttributes::new)
    }
}

impl ::protobuf::Clear for BGPFamilyAttributes {
    fn clear(&mut self) {
        self.addressFamily.clear();
        self.loopCount = ::std::option::Option::None;
        self.prefixLimit.clear();
        self.defaultTunnelEncap.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BGPFamilyAttributes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BGPFamilyAttributes {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BGPPrefixLimit {
    // message fields
    idleTimeout: ::std::option::Option<i32>,
    maximum: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BGPPrefixLimit {
    fn default() -> &'a BGPPrefixLimit {
        <BGPPrefixLimit as ::protobuf::Message>::default_instance()
    }
}

impl BGPPrefixLimit {
    pub fn new() -> BGPPrefixLimit {
        ::std::default::Default::default()
    }

    // optional int32 idleTimeout = 1;


    pub fn get_idleTimeout(&self) -> i32 {
        self.idleTimeout.unwrap_or(0)
    }
    pub fn clear_idleTimeout(&mut self) {
        self.idleTimeout = ::std::option::Option::None;
    }

    pub fn has_idleTimeout(&self) -> bool {
        self.idleTimeout.is_some()
    }

    // Param is passed by value, moved
    pub fn set_idleTimeout(&mut self, v: i32) {
        self.idleTimeout = ::std::option::Option::Some(v);
    }

    // optional int32 maximum = 2;


    pub fn get_maximum(&self) -> i32 {
        self.maximum.unwrap_or(0)
    }
    pub fn clear_maximum(&mut self) {
        self.maximum = ::std::option::Option::None;
    }

    pub fn has_maximum(&self) -> bool {
        self.maximum.is_some()
    }

    // Param is passed by value, moved
    pub fn set_maximum(&mut self, v: i32) {
        self.maximum = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for BGPPrefixLimit {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.idleTimeout = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.maximum = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.idleTimeout {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.maximum {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.idleTimeout {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.maximum {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BGPPrefixLimit {
        BGPPrefixLimit::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "idleTimeout",
                |m: &BGPPrefixLimit| { &m.idleTimeout },
                |m: &mut BGPPrefixLimit| { &mut m.idleTimeout },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "maximum",
                |m: &BGPPrefixLimit| { &m.maximum },
                |m: &mut BGPPrefixLimit| { &mut m.maximum },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BGPPrefixLimit>(
                "BGPPrefixLimit",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BGPPrefixLimit {
        static instance: ::protobuf::rt::LazyV2<BGPPrefixLimit> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BGPPrefixLimit::new)
    }
}

impl ::protobuf::Clear for BGPPrefixLimit {
    fn clear(&mut self) {
        self.idleTimeout = ::std::option::Option::None;
        self.maximum = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BGPPrefixLimit {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BGPPrefixLimit {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BGPRouter {
    // message fields
    pub metadata: ::protobuf::SingularPtrField<super::meta::ObjectMeta>,
    pub spec: ::protobuf::SingularPtrField<BGPRouterSpec>,
    pub status: ::protobuf::SingularPtrField<BGPRouterStatus>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BGPRouter {
    fn default() -> &'a BGPRouter {
        <BGPRouter as ::protobuf::Message>::default_instance()
    }
}

impl BGPRouter {
    pub fn new() -> BGPRouter {
        ::std::default::Default::default()
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;


    pub fn get_metadata(&self) -> &super::meta::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <super::meta::ObjectMeta as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::meta::ObjectMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::meta::ObjectMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::meta::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| super::meta::ObjectMeta::new())
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterSpec spec = 2;


    pub fn get_spec(&self) -> &BGPRouterSpec {
        self.spec.as_ref().unwrap_or_else(|| <BGPRouterSpec as ::protobuf::Message>::default_instance())
    }
    pub fn clear_spec(&mut self) {
        self.spec.clear();
    }

    pub fn has_spec(&self) -> bool {
        self.spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spec(&mut self, v: BGPRouterSpec) {
        self.spec = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spec(&mut self) -> &mut BGPRouterSpec {
        if self.spec.is_none() {
            self.spec.set_default();
        }
        self.spec.as_mut().unwrap()
    }

    // Take field
    pub fn take_spec(&mut self) -> BGPRouterSpec {
        self.spec.take().unwrap_or_else(|| BGPRouterSpec::new())
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterStatus status = 3;


    pub fn get_status(&self) -> &BGPRouterStatus {
        self.status.as_ref().unwrap_or_else(|| <BGPRouterStatus as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: BGPRouterStatus) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut BGPRouterStatus {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> BGPRouterStatus {
        self.status.take().unwrap_or_else(|| BGPRouterStatus::new())
    }
}

impl ::protobuf::Message for BGPRouter {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.spec {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.spec)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.spec.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BGPRouter {
        BGPRouter::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::meta::ObjectMeta>>(
                "metadata",
                |m: &BGPRouter| { &m.metadata },
                |m: &mut BGPRouter| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BGPRouterSpec>>(
                "spec",
                |m: &BGPRouter| { &m.spec },
                |m: &mut BGPRouter| { &mut m.spec },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BGPRouterStatus>>(
                "status",
                |m: &BGPRouter| { &m.status },
                |m: &mut BGPRouter| { &mut m.status },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BGPRouter>(
                "BGPRouter",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BGPRouter {
        static instance: ::protobuf::rt::LazyV2<BGPRouter> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BGPRouter::new)
    }
}

impl ::protobuf::Clear for BGPRouter {
    fn clear(&mut self) {
        self.metadata.clear();
        self.spec.clear();
        self.status.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BGPRouter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BGPRouter {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BGPRouterList {
    // message fields
    pub metadata: ::protobuf::SingularPtrField<super::meta::ListMeta>,
    pub items: ::protobuf::RepeatedField<BGPRouter>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BGPRouterList {
    fn default() -> &'a BGPRouterList {
        <BGPRouterList as ::protobuf::Message>::default_instance()
    }
}

impl BGPRouterList {
    pub fn new() -> BGPRouterList {
        ::std::default::Default::default()
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;


    pub fn get_metadata(&self) -> &super::meta::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <super::meta::ListMeta as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::meta::ListMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::meta::ListMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::meta::ListMeta {
        self.metadata.take().unwrap_or_else(|| super::meta::ListMeta::new())
    }

    // repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouter items = 2;


    pub fn get_items(&self) -> &[BGPRouter] {
        &self.items
    }
    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::protobuf::RepeatedField<BGPRouter>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::protobuf::RepeatedField<BGPRouter> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::protobuf::RepeatedField<BGPRouter> {
        ::std::mem::replace(&mut self.items, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for BGPRouterList {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.items {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.items)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.items {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BGPRouterList {
        BGPRouterList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::meta::ListMeta>>(
                "metadata",
                |m: &BGPRouterList| { &m.metadata },
                |m: &mut BGPRouterList| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BGPRouter>>(
                "items",
                |m: &BGPRouterList| { &m.items },
                |m: &mut BGPRouterList| { &mut m.items },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BGPRouterList>(
                "BGPRouterList",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BGPRouterList {
        static instance: ::protobuf::rt::LazyV2<BGPRouterList> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BGPRouterList::new)
    }
}

impl ::protobuf::Clear for BGPRouterList {
    fn clear(&mut self) {
        self.metadata.clear();
        self.items.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BGPRouterList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BGPRouterList {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BGPRouterParameters {
    // message fields
    adminDown: ::std::option::Option<bool>,
    vendor: ::protobuf::SingularField<::std::string::String>,
    clusterID: ::std::option::Option<i64>,
    autonomousSystem: ::std::option::Option<i32>,
    identifier: ::protobuf::SingularField<::std::string::String>,
    address: ::protobuf::SingularField<::std::string::String>,
    port: ::std::option::Option<i32>,
    sourcePort: ::std::option::Option<i32>,
    holdTime: ::std::option::Option<i32>,
    pub addressFamilies: ::protobuf::SingularPtrField<AddressFamilies>,
    pub authData: ::protobuf::SingularPtrField<AuthenticationData>,
    localAutonomousSystem: ::std::option::Option<i32>,
    routerType: ::protobuf::SingularField<::std::string::String>,
    gatewayAddress: ::protobuf::SingularField<::std::string::String>,
    ipv6GatewayAddress: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BGPRouterParameters {
    fn default() -> &'a BGPRouterParameters {
        <BGPRouterParameters as ::protobuf::Message>::default_instance()
    }
}

impl BGPRouterParameters {
    pub fn new() -> BGPRouterParameters {
        ::std::default::Default::default()
    }

    // optional bool adminDown = 1;


    pub fn get_adminDown(&self) -> bool {
        self.adminDown.unwrap_or(false)
    }
    pub fn clear_adminDown(&mut self) {
        self.adminDown = ::std::option::Option::None;
    }

    pub fn has_adminDown(&self) -> bool {
        self.adminDown.is_some()
    }

    // Param is passed by value, moved
    pub fn set_adminDown(&mut self, v: bool) {
        self.adminDown = ::std::option::Option::Some(v);
    }

    // optional string vendor = 2;


    pub fn get_vendor(&self) -> &str {
        match self.vendor.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_vendor(&mut self) {
        self.vendor.clear();
    }

    pub fn has_vendor(&self) -> bool {
        self.vendor.is_some()
    }

    // Param is passed by value, moved
    pub fn set_vendor(&mut self, v: ::std::string::String) {
        self.vendor = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vendor(&mut self) -> &mut ::std::string::String {
        if self.vendor.is_none() {
            self.vendor.set_default();
        }
        self.vendor.as_mut().unwrap()
    }

    // Take field
    pub fn take_vendor(&mut self) -> ::std::string::String {
        self.vendor.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int64 clusterID = 3;


    pub fn get_clusterID(&self) -> i64 {
        self.clusterID.unwrap_or(0)
    }
    pub fn clear_clusterID(&mut self) {
        self.clusterID = ::std::option::Option::None;
    }

    pub fn has_clusterID(&self) -> bool {
        self.clusterID.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clusterID(&mut self, v: i64) {
        self.clusterID = ::std::option::Option::Some(v);
    }

    // optional int32 autonomousSystem = 4;


    pub fn get_autonomousSystem(&self) -> i32 {
        self.autonomousSystem.unwrap_or(0)
    }
    pub fn clear_autonomousSystem(&mut self) {
        self.autonomousSystem = ::std::option::Option::None;
    }

    pub fn has_autonomousSystem(&self) -> bool {
        self.autonomousSystem.is_some()
    }

    // Param is passed by value, moved
    pub fn set_autonomousSystem(&mut self, v: i32) {
        self.autonomousSystem = ::std::option::Option::Some(v);
    }

    // optional string identifier = 5;


    pub fn get_identifier(&self) -> &str {
        match self.identifier.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_identifier(&mut self) {
        self.identifier.clear();
    }

    pub fn has_identifier(&self) -> bool {
        self.identifier.is_some()
    }

    // Param is passed by value, moved
    pub fn set_identifier(&mut self, v: ::std::string::String) {
        self.identifier = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_identifier(&mut self) -> &mut ::std::string::String {
        if self.identifier.is_none() {
            self.identifier.set_default();
        }
        self.identifier.as_mut().unwrap()
    }

    // Take field
    pub fn take_identifier(&mut self) -> ::std::string::String {
        self.identifier.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string address = 6;


    pub fn get_address(&self) -> &str {
        match self.address.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    pub fn has_address(&self) -> bool {
        self.address.is_some()
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::string::String) {
        self.address = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::string::String {
        if self.address.is_none() {
            self.address.set_default();
        }
        self.address.as_mut().unwrap()
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::string::String {
        self.address.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 port = 7;


    pub fn get_port(&self) -> i32 {
        self.port.unwrap_or(0)
    }
    pub fn clear_port(&mut self) {
        self.port = ::std::option::Option::None;
    }

    pub fn has_port(&self) -> bool {
        self.port.is_some()
    }

    // Param is passed by value, moved
    pub fn set_port(&mut self, v: i32) {
        self.port = ::std::option::Option::Some(v);
    }

    // optional int32 sourcePort = 8;


    pub fn get_sourcePort(&self) -> i32 {
        self.sourcePort.unwrap_or(0)
    }
    pub fn clear_sourcePort(&mut self) {
        self.sourcePort = ::std::option::Option::None;
    }

    pub fn has_sourcePort(&self) -> bool {
        self.sourcePort.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sourcePort(&mut self, v: i32) {
        self.sourcePort = ::std::option::Option::Some(v);
    }

    // optional int32 holdTime = 9;


    pub fn get_holdTime(&self) -> i32 {
        self.holdTime.unwrap_or(0)
    }
    pub fn clear_holdTime(&mut self) {
        self.holdTime = ::std::option::Option::None;
    }

    pub fn has_holdTime(&self) -> bool {
        self.holdTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_holdTime(&mut self, v: i32) {
        self.holdTime = ::std::option::Option::Some(v);
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AddressFamilies addressFamilies = 10;


    pub fn get_addressFamilies(&self) -> &AddressFamilies {
        self.addressFamilies.as_ref().unwrap_or_else(|| <AddressFamilies as ::protobuf::Message>::default_instance())
    }
    pub fn clear_addressFamilies(&mut self) {
        self.addressFamilies.clear();
    }

    pub fn has_addressFamilies(&self) -> bool {
        self.addressFamilies.is_some()
    }

    // Param is passed by value, moved
    pub fn set_addressFamilies(&mut self, v: AddressFamilies) {
        self.addressFamilies = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_addressFamilies(&mut self) -> &mut AddressFamilies {
        if self.addressFamilies.is_none() {
            self.addressFamilies.set_default();
        }
        self.addressFamilies.as_mut().unwrap()
    }

    // Take field
    pub fn take_addressFamilies(&mut self) -> AddressFamilies {
        self.addressFamilies.take().unwrap_or_else(|| AddressFamilies::new())
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AuthenticationData authData = 11;


    pub fn get_authData(&self) -> &AuthenticationData {
        self.authData.as_ref().unwrap_or_else(|| <AuthenticationData as ::protobuf::Message>::default_instance())
    }
    pub fn clear_authData(&mut self) {
        self.authData.clear();
    }

    pub fn has_authData(&self) -> bool {
        self.authData.is_some()
    }

    // Param is passed by value, moved
    pub fn set_authData(&mut self, v: AuthenticationData) {
        self.authData = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_authData(&mut self) -> &mut AuthenticationData {
        if self.authData.is_none() {
            self.authData.set_default();
        }
        self.authData.as_mut().unwrap()
    }

    // Take field
    pub fn take_authData(&mut self) -> AuthenticationData {
        self.authData.take().unwrap_or_else(|| AuthenticationData::new())
    }

    // optional int32 localAutonomousSystem = 12;


    pub fn get_localAutonomousSystem(&self) -> i32 {
        self.localAutonomousSystem.unwrap_or(0)
    }
    pub fn clear_localAutonomousSystem(&mut self) {
        self.localAutonomousSystem = ::std::option::Option::None;
    }

    pub fn has_localAutonomousSystem(&self) -> bool {
        self.localAutonomousSystem.is_some()
    }

    // Param is passed by value, moved
    pub fn set_localAutonomousSystem(&mut self, v: i32) {
        self.localAutonomousSystem = ::std::option::Option::Some(v);
    }

    // optional string routerType = 13;


    pub fn get_routerType(&self) -> &str {
        match self.routerType.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_routerType(&mut self) {
        self.routerType.clear();
    }

    pub fn has_routerType(&self) -> bool {
        self.routerType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_routerType(&mut self, v: ::std::string::String) {
        self.routerType = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_routerType(&mut self) -> &mut ::std::string::String {
        if self.routerType.is_none() {
            self.routerType.set_default();
        }
        self.routerType.as_mut().unwrap()
    }

    // Take field
    pub fn take_routerType(&mut self) -> ::std::string::String {
        self.routerType.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string gatewayAddress = 14;


    pub fn get_gatewayAddress(&self) -> &str {
        match self.gatewayAddress.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_gatewayAddress(&mut self) {
        self.gatewayAddress.clear();
    }

    pub fn has_gatewayAddress(&self) -> bool {
        self.gatewayAddress.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gatewayAddress(&mut self, v: ::std::string::String) {
        self.gatewayAddress = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gatewayAddress(&mut self) -> &mut ::std::string::String {
        if self.gatewayAddress.is_none() {
            self.gatewayAddress.set_default();
        }
        self.gatewayAddress.as_mut().unwrap()
    }

    // Take field
    pub fn take_gatewayAddress(&mut self) -> ::std::string::String {
        self.gatewayAddress.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string ipv6GatewayAddress = 15;


    pub fn get_ipv6GatewayAddress(&self) -> &str {
        match self.ipv6GatewayAddress.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_ipv6GatewayAddress(&mut self) {
        self.ipv6GatewayAddress.clear();
    }

    pub fn has_ipv6GatewayAddress(&self) -> bool {
        self.ipv6GatewayAddress.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ipv6GatewayAddress(&mut self, v: ::std::string::String) {
        self.ipv6GatewayAddress = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ipv6GatewayAddress(&mut self) -> &mut ::std::string::String {
        if self.ipv6GatewayAddress.is_none() {
            self.ipv6GatewayAddress.set_default();
        }
        self.ipv6GatewayAddress.as_mut().unwrap()
    }

    // Take field
    pub fn take_ipv6GatewayAddress(&mut self) -> ::std::string::String {
        self.ipv6GatewayAddress.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for BGPRouterParameters {
    fn is_initialized(&self) -> bool {
        for v in &self.addressFamilies {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.authData {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.adminDown = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.vendor)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.clusterID = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.autonomousSystem = ::std::option::Option::Some(tmp);
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.identifier)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.address)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.port = ::std::option::Option::Some(tmp);
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.sourcePort = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.holdTime = ::std::option::Option::Some(tmp);
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.addressFamilies)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.authData)?;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.localAutonomousSystem = ::std::option::Option::Some(tmp);
                },
                13 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.routerType)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.gatewayAddress)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.ipv6GatewayAddress)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.adminDown {
            my_size += 2;
        }
        if let Some(ref v) = self.vendor.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.clusterID {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.autonomousSystem {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.identifier.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.address.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.port {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.sourcePort {
            my_size += ::protobuf::rt::value_size(8, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.holdTime {
            my_size += ::protobuf::rt::value_size(9, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.addressFamilies.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.authData.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.localAutonomousSystem {
            my_size += ::protobuf::rt::value_size(12, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.routerType.as_ref() {
            my_size += ::protobuf::rt::string_size(13, &v);
        }
        if let Some(ref v) = self.gatewayAddress.as_ref() {
            my_size += ::protobuf::rt::string_size(14, &v);
        }
        if let Some(ref v) = self.ipv6GatewayAddress.as_ref() {
            my_size += ::protobuf::rt::string_size(15, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.adminDown {
            os.write_bool(1, v)?;
        }
        if let Some(ref v) = self.vendor.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.clusterID {
            os.write_int64(3, v)?;
        }
        if let Some(v) = self.autonomousSystem {
            os.write_int32(4, v)?;
        }
        if let Some(ref v) = self.identifier.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.address.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(v) = self.port {
            os.write_int32(7, v)?;
        }
        if let Some(v) = self.sourcePort {
            os.write_int32(8, v)?;
        }
        if let Some(v) = self.holdTime {
            os.write_int32(9, v)?;
        }
        if let Some(ref v) = self.addressFamilies.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.authData.as_ref() {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.localAutonomousSystem {
            os.write_int32(12, v)?;
        }
        if let Some(ref v) = self.routerType.as_ref() {
            os.write_string(13, &v)?;
        }
        if let Some(ref v) = self.gatewayAddress.as_ref() {
            os.write_string(14, &v)?;
        }
        if let Some(ref v) = self.ipv6GatewayAddress.as_ref() {
            os.write_string(15, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BGPRouterParameters {
        BGPRouterParameters::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "adminDown",
                |m: &BGPRouterParameters| { &m.adminDown },
                |m: &mut BGPRouterParameters| { &mut m.adminDown },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "vendor",
                |m: &BGPRouterParameters| { &m.vendor },
                |m: &mut BGPRouterParameters| { &mut m.vendor },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "clusterID",
                |m: &BGPRouterParameters| { &m.clusterID },
                |m: &mut BGPRouterParameters| { &mut m.clusterID },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "autonomousSystem",
                |m: &BGPRouterParameters| { &m.autonomousSystem },
                |m: &mut BGPRouterParameters| { &mut m.autonomousSystem },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "identifier",
                |m: &BGPRouterParameters| { &m.identifier },
                |m: &mut BGPRouterParameters| { &mut m.identifier },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "address",
                |m: &BGPRouterParameters| { &m.address },
                |m: &mut BGPRouterParameters| { &mut m.address },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "port",
                |m: &BGPRouterParameters| { &m.port },
                |m: &mut BGPRouterParameters| { &mut m.port },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "sourcePort",
                |m: &BGPRouterParameters| { &m.sourcePort },
                |m: &mut BGPRouterParameters| { &mut m.sourcePort },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "holdTime",
                |m: &BGPRouterParameters| { &m.holdTime },
                |m: &mut BGPRouterParameters| { &mut m.holdTime },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AddressFamilies>>(
                "addressFamilies",
                |m: &BGPRouterParameters| { &m.addressFamilies },
                |m: &mut BGPRouterParameters| { &mut m.addressFamilies },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AuthenticationData>>(
                "authData",
                |m: &BGPRouterParameters| { &m.authData },
                |m: &mut BGPRouterParameters| { &mut m.authData },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "localAutonomousSystem",
                |m: &BGPRouterParameters| { &m.localAutonomousSystem },
                |m: &mut BGPRouterParameters| { &mut m.localAutonomousSystem },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "routerType",
                |m: &BGPRouterParameters| { &m.routerType },
                |m: &mut BGPRouterParameters| { &mut m.routerType },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "gatewayAddress",
                |m: &BGPRouterParameters| { &m.gatewayAddress },
                |m: &mut BGPRouterParameters| { &mut m.gatewayAddress },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "ipv6GatewayAddress",
                |m: &BGPRouterParameters| { &m.ipv6GatewayAddress },
                |m: &mut BGPRouterParameters| { &mut m.ipv6GatewayAddress },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BGPRouterParameters>(
                "BGPRouterParameters",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BGPRouterParameters {
        static instance: ::protobuf::rt::LazyV2<BGPRouterParameters> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BGPRouterParameters::new)
    }
}

impl ::protobuf::Clear for BGPRouterParameters {
    fn clear(&mut self) {
        self.adminDown = ::std::option::Option::None;
        self.vendor.clear();
        self.clusterID = ::std::option::Option::None;
        self.autonomousSystem = ::std::option::Option::None;
        self.identifier.clear();
        self.address.clear();
        self.port = ::std::option::Option::None;
        self.sourcePort = ::std::option::Option::None;
        self.holdTime = ::std::option::Option::None;
        self.addressFamilies.clear();
        self.authData.clear();
        self.localAutonomousSystem = ::std::option::Option::None;
        self.routerType.clear();
        self.gatewayAddress.clear();
        self.ipv6GatewayAddress.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BGPRouterParameters {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BGPRouterParameters {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BGPRouterReference {
    // message fields
    pub resourceReference: ::protobuf::SingularPtrField<ResourceReference>,
    pub attributes: ::protobuf::SingularPtrField<BGPRouterReferenceAttributes>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BGPRouterReference {
    fn default() -> &'a BGPRouterReference {
        <BGPRouterReference as ::protobuf::Message>::default_instance()
    }
}

impl BGPRouterReference {
    pub fn new() -> BGPRouterReference {
        ::std::default::Default::default()
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ResourceReference resourceReference = 1;


    pub fn get_resourceReference(&self) -> &ResourceReference {
        self.resourceReference.as_ref().unwrap_or_else(|| <ResourceReference as ::protobuf::Message>::default_instance())
    }
    pub fn clear_resourceReference(&mut self) {
        self.resourceReference.clear();
    }

    pub fn has_resourceReference(&self) -> bool {
        self.resourceReference.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resourceReference(&mut self, v: ResourceReference) {
        self.resourceReference = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_resourceReference(&mut self) -> &mut ResourceReference {
        if self.resourceReference.is_none() {
            self.resourceReference.set_default();
        }
        self.resourceReference.as_mut().unwrap()
    }

    // Take field
    pub fn take_resourceReference(&mut self) -> ResourceReference {
        self.resourceReference.take().unwrap_or_else(|| ResourceReference::new())
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterReferenceAttributes attributes = 2;


    pub fn get_attributes(&self) -> &BGPRouterReferenceAttributes {
        self.attributes.as_ref().unwrap_or_else(|| <BGPRouterReferenceAttributes as ::protobuf::Message>::default_instance())
    }
    pub fn clear_attributes(&mut self) {
        self.attributes.clear();
    }

    pub fn has_attributes(&self) -> bool {
        self.attributes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attributes(&mut self, v: BGPRouterReferenceAttributes) {
        self.attributes = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_attributes(&mut self) -> &mut BGPRouterReferenceAttributes {
        if self.attributes.is_none() {
            self.attributes.set_default();
        }
        self.attributes.as_mut().unwrap()
    }

    // Take field
    pub fn take_attributes(&mut self) -> BGPRouterReferenceAttributes {
        self.attributes.take().unwrap_or_else(|| BGPRouterReferenceAttributes::new())
    }
}

impl ::protobuf::Message for BGPRouterReference {
    fn is_initialized(&self) -> bool {
        for v in &self.resourceReference {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.attributes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.resourceReference)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.attributes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.resourceReference.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.attributes.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.resourceReference.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.attributes.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BGPRouterReference {
        BGPRouterReference::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResourceReference>>(
                "resourceReference",
                |m: &BGPRouterReference| { &m.resourceReference },
                |m: &mut BGPRouterReference| { &mut m.resourceReference },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BGPRouterReferenceAttributes>>(
                "attributes",
                |m: &BGPRouterReference| { &m.attributes },
                |m: &mut BGPRouterReference| { &mut m.attributes },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BGPRouterReference>(
                "BGPRouterReference",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BGPRouterReference {
        static instance: ::protobuf::rt::LazyV2<BGPRouterReference> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BGPRouterReference::new)
    }
}

impl ::protobuf::Clear for BGPRouterReference {
    fn clear(&mut self) {
        self.resourceReference.clear();
        self.attributes.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BGPRouterReference {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BGPRouterReference {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BGPRouterReferenceAttributes {
    // message fields
    pub session: ::protobuf::RepeatedField<BGPSession>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BGPRouterReferenceAttributes {
    fn default() -> &'a BGPRouterReferenceAttributes {
        <BGPRouterReferenceAttributes as ::protobuf::Message>::default_instance()
    }
}

impl BGPRouterReferenceAttributes {
    pub fn new() -> BGPRouterReferenceAttributes {
        ::std::default::Default::default()
    }

    // repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPSession session = 1;


    pub fn get_session(&self) -> &[BGPSession] {
        &self.session
    }
    pub fn clear_session(&mut self) {
        self.session.clear();
    }

    // Param is passed by value, moved
    pub fn set_session(&mut self, v: ::protobuf::RepeatedField<BGPSession>) {
        self.session = v;
    }

    // Mutable pointer to the field.
    pub fn mut_session(&mut self) -> &mut ::protobuf::RepeatedField<BGPSession> {
        &mut self.session
    }

    // Take field
    pub fn take_session(&mut self) -> ::protobuf::RepeatedField<BGPSession> {
        ::std::mem::replace(&mut self.session, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for BGPRouterReferenceAttributes {
    fn is_initialized(&self) -> bool {
        for v in &self.session {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.session)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.session {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.session {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BGPRouterReferenceAttributes {
        BGPRouterReferenceAttributes::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BGPSession>>(
                "session",
                |m: &BGPRouterReferenceAttributes| { &m.session },
                |m: &mut BGPRouterReferenceAttributes| { &mut m.session },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BGPRouterReferenceAttributes>(
                "BGPRouterReferenceAttributes",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BGPRouterReferenceAttributes {
        static instance: ::protobuf::rt::LazyV2<BGPRouterReferenceAttributes> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BGPRouterReferenceAttributes::new)
    }
}

impl ::protobuf::Clear for BGPRouterReferenceAttributes {
    fn clear(&mut self) {
        self.session.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BGPRouterReferenceAttributes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BGPRouterReferenceAttributes {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BGPRouterSpec {
    // message fields
    pub commonSpec: ::protobuf::SingularPtrField<CommonSpec>,
    pub parent: ::protobuf::SingularPtrField<super::generated::ObjectReference>,
    pub bgpRouterReferences: ::protobuf::RepeatedField<BGPRouterReference>,
    pub bgpRouterParameters: ::protobuf::SingularPtrField<BGPRouterParameters>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BGPRouterSpec {
    fn default() -> &'a BGPRouterSpec {
        <BGPRouterSpec as ::protobuf::Message>::default_instance()
    }
}

impl BGPRouterSpec {
    pub fn new() -> BGPRouterSpec {
        ::std::default::Default::default()
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonSpec commonSpec = 1;


    pub fn get_commonSpec(&self) -> &CommonSpec {
        self.commonSpec.as_ref().unwrap_or_else(|| <CommonSpec as ::protobuf::Message>::default_instance())
    }
    pub fn clear_commonSpec(&mut self) {
        self.commonSpec.clear();
    }

    pub fn has_commonSpec(&self) -> bool {
        self.commonSpec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_commonSpec(&mut self, v: CommonSpec) {
        self.commonSpec = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_commonSpec(&mut self) -> &mut CommonSpec {
        if self.commonSpec.is_none() {
            self.commonSpec.set_default();
        }
        self.commonSpec.as_mut().unwrap()
    }

    // Take field
    pub fn take_commonSpec(&mut self) -> CommonSpec {
        self.commonSpec.take().unwrap_or_else(|| CommonSpec::new())
    }

    // optional .k8s.io.api.core.v1.ObjectReference parent = 2;


    pub fn get_parent(&self) -> &super::generated::ObjectReference {
        self.parent.as_ref().unwrap_or_else(|| <super::generated::ObjectReference as ::protobuf::Message>::default_instance())
    }
    pub fn clear_parent(&mut self) {
        self.parent.clear();
    }

    pub fn has_parent(&self) -> bool {
        self.parent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_parent(&mut self, v: super::generated::ObjectReference) {
        self.parent = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent(&mut self) -> &mut super::generated::ObjectReference {
        if self.parent.is_none() {
            self.parent.set_default();
        }
        self.parent.as_mut().unwrap()
    }

    // Take field
    pub fn take_parent(&mut self) -> super::generated::ObjectReference {
        self.parent.take().unwrap_or_else(|| super::generated::ObjectReference::new())
    }

    // repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterReference bgpRouterReferences = 4;


    pub fn get_bgpRouterReferences(&self) -> &[BGPRouterReference] {
        &self.bgpRouterReferences
    }
    pub fn clear_bgpRouterReferences(&mut self) {
        self.bgpRouterReferences.clear();
    }

    // Param is passed by value, moved
    pub fn set_bgpRouterReferences(&mut self, v: ::protobuf::RepeatedField<BGPRouterReference>) {
        self.bgpRouterReferences = v;
    }

    // Mutable pointer to the field.
    pub fn mut_bgpRouterReferences(&mut self) -> &mut ::protobuf::RepeatedField<BGPRouterReference> {
        &mut self.bgpRouterReferences
    }

    // Take field
    pub fn take_bgpRouterReferences(&mut self) -> ::protobuf::RepeatedField<BGPRouterReference> {
        ::std::mem::replace(&mut self.bgpRouterReferences, ::protobuf::RepeatedField::new())
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterParameters bgpRouterParameters = 3;


    pub fn get_bgpRouterParameters(&self) -> &BGPRouterParameters {
        self.bgpRouterParameters.as_ref().unwrap_or_else(|| <BGPRouterParameters as ::protobuf::Message>::default_instance())
    }
    pub fn clear_bgpRouterParameters(&mut self) {
        self.bgpRouterParameters.clear();
    }

    pub fn has_bgpRouterParameters(&self) -> bool {
        self.bgpRouterParameters.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bgpRouterParameters(&mut self, v: BGPRouterParameters) {
        self.bgpRouterParameters = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bgpRouterParameters(&mut self) -> &mut BGPRouterParameters {
        if self.bgpRouterParameters.is_none() {
            self.bgpRouterParameters.set_default();
        }
        self.bgpRouterParameters.as_mut().unwrap()
    }

    // Take field
    pub fn take_bgpRouterParameters(&mut self) -> BGPRouterParameters {
        self.bgpRouterParameters.take().unwrap_or_else(|| BGPRouterParameters::new())
    }
}

impl ::protobuf::Message for BGPRouterSpec {
    fn is_initialized(&self) -> bool {
        for v in &self.commonSpec {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.parent {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.bgpRouterReferences {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.bgpRouterParameters {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.commonSpec)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.parent)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.bgpRouterReferences)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.bgpRouterParameters)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.commonSpec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.parent.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.bgpRouterReferences {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.bgpRouterParameters.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.commonSpec.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.parent.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.bgpRouterReferences {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.bgpRouterParameters.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BGPRouterSpec {
        BGPRouterSpec::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommonSpec>>(
                "commonSpec",
                |m: &BGPRouterSpec| { &m.commonSpec },
                |m: &mut BGPRouterSpec| { &mut m.commonSpec },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::generated::ObjectReference>>(
                "parent",
                |m: &BGPRouterSpec| { &m.parent },
                |m: &mut BGPRouterSpec| { &mut m.parent },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BGPRouterReference>>(
                "bgpRouterReferences",
                |m: &BGPRouterSpec| { &m.bgpRouterReferences },
                |m: &mut BGPRouterSpec| { &mut m.bgpRouterReferences },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BGPRouterParameters>>(
                "bgpRouterParameters",
                |m: &BGPRouterSpec| { &m.bgpRouterParameters },
                |m: &mut BGPRouterSpec| { &mut m.bgpRouterParameters },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BGPRouterSpec>(
                "BGPRouterSpec",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BGPRouterSpec {
        static instance: ::protobuf::rt::LazyV2<BGPRouterSpec> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BGPRouterSpec::new)
    }
}

impl ::protobuf::Clear for BGPRouterSpec {
    fn clear(&mut self) {
        self.commonSpec.clear();
        self.parent.clear();
        self.bgpRouterReferences.clear();
        self.bgpRouterParameters.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BGPRouterSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BGPRouterSpec {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BGPRouterStatus {
    // message fields
    pub commonStatus: ::protobuf::SingularPtrField<CommonStatus>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BGPRouterStatus {
    fn default() -> &'a BGPRouterStatus {
        <BGPRouterStatus as ::protobuf::Message>::default_instance()
    }
}

impl BGPRouterStatus {
    pub fn new() -> BGPRouterStatus {
        ::std::default::Default::default()
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonStatus commonStatus = 1;


    pub fn get_commonStatus(&self) -> &CommonStatus {
        self.commonStatus.as_ref().unwrap_or_else(|| <CommonStatus as ::protobuf::Message>::default_instance())
    }
    pub fn clear_commonStatus(&mut self) {
        self.commonStatus.clear();
    }

    pub fn has_commonStatus(&self) -> bool {
        self.commonStatus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_commonStatus(&mut self, v: CommonStatus) {
        self.commonStatus = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_commonStatus(&mut self) -> &mut CommonStatus {
        if self.commonStatus.is_none() {
            self.commonStatus.set_default();
        }
        self.commonStatus.as_mut().unwrap()
    }

    // Take field
    pub fn take_commonStatus(&mut self) -> CommonStatus {
        self.commonStatus.take().unwrap_or_else(|| CommonStatus::new())
    }
}

impl ::protobuf::Message for BGPRouterStatus {
    fn is_initialized(&self) -> bool {
        for v in &self.commonStatus {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.commonStatus)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.commonStatus.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.commonStatus.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BGPRouterStatus {
        BGPRouterStatus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommonStatus>>(
                "commonStatus",
                |m: &BGPRouterStatus| { &m.commonStatus },
                |m: &mut BGPRouterStatus| { &mut m.commonStatus },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BGPRouterStatus>(
                "BGPRouterStatus",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BGPRouterStatus {
        static instance: ::protobuf::rt::LazyV2<BGPRouterStatus> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BGPRouterStatus::new)
    }
}

impl ::protobuf::Clear for BGPRouterStatus {
    fn clear(&mut self) {
        self.commonStatus.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BGPRouterStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BGPRouterStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BGPSession {
    // message fields
    pub sessionAttributes: ::protobuf::RepeatedField<BGPSessionAttributes>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BGPSession {
    fn default() -> &'a BGPSession {
        <BGPSession as ::protobuf::Message>::default_instance()
    }
}

impl BGPSession {
    pub fn new() -> BGPSession {
        ::std::default::Default::default()
    }

    // repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPSessionAttributes sessionAttributes = 1;


    pub fn get_sessionAttributes(&self) -> &[BGPSessionAttributes] {
        &self.sessionAttributes
    }
    pub fn clear_sessionAttributes(&mut self) {
        self.sessionAttributes.clear();
    }

    // Param is passed by value, moved
    pub fn set_sessionAttributes(&mut self, v: ::protobuf::RepeatedField<BGPSessionAttributes>) {
        self.sessionAttributes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_sessionAttributes(&mut self) -> &mut ::protobuf::RepeatedField<BGPSessionAttributes> {
        &mut self.sessionAttributes
    }

    // Take field
    pub fn take_sessionAttributes(&mut self) -> ::protobuf::RepeatedField<BGPSessionAttributes> {
        ::std::mem::replace(&mut self.sessionAttributes, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for BGPSession {
    fn is_initialized(&self) -> bool {
        for v in &self.sessionAttributes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.sessionAttributes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.sessionAttributes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.sessionAttributes {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BGPSession {
        BGPSession::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BGPSessionAttributes>>(
                "sessionAttributes",
                |m: &BGPSession| { &m.sessionAttributes },
                |m: &mut BGPSession| { &mut m.sessionAttributes },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BGPSession>(
                "BGPSession",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BGPSession {
        static instance: ::protobuf::rt::LazyV2<BGPSession> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BGPSession::new)
    }
}

impl ::protobuf::Clear for BGPSession {
    fn clear(&mut self) {
        self.sessionAttributes.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BGPSession {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BGPSession {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BGPSessionAttributes {
    // message fields
    bgpRouter: ::protobuf::SingularField<::std::string::String>,
    adminDown: ::std::option::Option<bool>,
    passive: ::std::option::Option<bool>,
    asOverride: ::std::option::Option<bool>,
    holdTime: ::std::option::Option<i32>,
    loopCount: ::std::option::Option<i32>,
    localAutonomousSystem: ::std::option::Option<i32>,
    pub addressFamilies: ::protobuf::SingularPtrField<AddressFamilies>,
    pub authData: ::protobuf::SingularPtrField<AuthenticationData>,
    pub familyAttributes: ::protobuf::RepeatedField<BGPFamilyAttributes>,
    privateAsAction: ::protobuf::SingularField<::std::string::String>,
    pub routeOriginOverride: ::protobuf::SingularPtrField<RouteOriginOverride>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BGPSessionAttributes {
    fn default() -> &'a BGPSessionAttributes {
        <BGPSessionAttributes as ::protobuf::Message>::default_instance()
    }
}

impl BGPSessionAttributes {
    pub fn new() -> BGPSessionAttributes {
        ::std::default::Default::default()
    }

    // optional string bgpRouter = 1;


    pub fn get_bgpRouter(&self) -> &str {
        match self.bgpRouter.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_bgpRouter(&mut self) {
        self.bgpRouter.clear();
    }

    pub fn has_bgpRouter(&self) -> bool {
        self.bgpRouter.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bgpRouter(&mut self, v: ::std::string::String) {
        self.bgpRouter = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bgpRouter(&mut self) -> &mut ::std::string::String {
        if self.bgpRouter.is_none() {
            self.bgpRouter.set_default();
        }
        self.bgpRouter.as_mut().unwrap()
    }

    // Take field
    pub fn take_bgpRouter(&mut self) -> ::std::string::String {
        self.bgpRouter.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool adminDown = 2;


    pub fn get_adminDown(&self) -> bool {
        self.adminDown.unwrap_or(false)
    }
    pub fn clear_adminDown(&mut self) {
        self.adminDown = ::std::option::Option::None;
    }

    pub fn has_adminDown(&self) -> bool {
        self.adminDown.is_some()
    }

    // Param is passed by value, moved
    pub fn set_adminDown(&mut self, v: bool) {
        self.adminDown = ::std::option::Option::Some(v);
    }

    // optional bool passive = 3;


    pub fn get_passive(&self) -> bool {
        self.passive.unwrap_or(false)
    }
    pub fn clear_passive(&mut self) {
        self.passive = ::std::option::Option::None;
    }

    pub fn has_passive(&self) -> bool {
        self.passive.is_some()
    }

    // Param is passed by value, moved
    pub fn set_passive(&mut self, v: bool) {
        self.passive = ::std::option::Option::Some(v);
    }

    // optional bool asOverride = 4;


    pub fn get_asOverride(&self) -> bool {
        self.asOverride.unwrap_or(false)
    }
    pub fn clear_asOverride(&mut self) {
        self.asOverride = ::std::option::Option::None;
    }

    pub fn has_asOverride(&self) -> bool {
        self.asOverride.is_some()
    }

    // Param is passed by value, moved
    pub fn set_asOverride(&mut self, v: bool) {
        self.asOverride = ::std::option::Option::Some(v);
    }

    // optional int32 holdTime = 5;


    pub fn get_holdTime(&self) -> i32 {
        self.holdTime.unwrap_or(0)
    }
    pub fn clear_holdTime(&mut self) {
        self.holdTime = ::std::option::Option::None;
    }

    pub fn has_holdTime(&self) -> bool {
        self.holdTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_holdTime(&mut self, v: i32) {
        self.holdTime = ::std::option::Option::Some(v);
    }

    // optional int32 loopCount = 6;


    pub fn get_loopCount(&self) -> i32 {
        self.loopCount.unwrap_or(0)
    }
    pub fn clear_loopCount(&mut self) {
        self.loopCount = ::std::option::Option::None;
    }

    pub fn has_loopCount(&self) -> bool {
        self.loopCount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_loopCount(&mut self, v: i32) {
        self.loopCount = ::std::option::Option::Some(v);
    }

    // optional int32 localAutonomousSystem = 7;


    pub fn get_localAutonomousSystem(&self) -> i32 {
        self.localAutonomousSystem.unwrap_or(0)
    }
    pub fn clear_localAutonomousSystem(&mut self) {
        self.localAutonomousSystem = ::std::option::Option::None;
    }

    pub fn has_localAutonomousSystem(&self) -> bool {
        self.localAutonomousSystem.is_some()
    }

    // Param is passed by value, moved
    pub fn set_localAutonomousSystem(&mut self, v: i32) {
        self.localAutonomousSystem = ::std::option::Option::Some(v);
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AddressFamilies addressFamilies = 8;


    pub fn get_addressFamilies(&self) -> &AddressFamilies {
        self.addressFamilies.as_ref().unwrap_or_else(|| <AddressFamilies as ::protobuf::Message>::default_instance())
    }
    pub fn clear_addressFamilies(&mut self) {
        self.addressFamilies.clear();
    }

    pub fn has_addressFamilies(&self) -> bool {
        self.addressFamilies.is_some()
    }

    // Param is passed by value, moved
    pub fn set_addressFamilies(&mut self, v: AddressFamilies) {
        self.addressFamilies = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_addressFamilies(&mut self) -> &mut AddressFamilies {
        if self.addressFamilies.is_none() {
            self.addressFamilies.set_default();
        }
        self.addressFamilies.as_mut().unwrap()
    }

    // Take field
    pub fn take_addressFamilies(&mut self) -> AddressFamilies {
        self.addressFamilies.take().unwrap_or_else(|| AddressFamilies::new())
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AuthenticationData authData = 9;


    pub fn get_authData(&self) -> &AuthenticationData {
        self.authData.as_ref().unwrap_or_else(|| <AuthenticationData as ::protobuf::Message>::default_instance())
    }
    pub fn clear_authData(&mut self) {
        self.authData.clear();
    }

    pub fn has_authData(&self) -> bool {
        self.authData.is_some()
    }

    // Param is passed by value, moved
    pub fn set_authData(&mut self, v: AuthenticationData) {
        self.authData = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_authData(&mut self) -> &mut AuthenticationData {
        if self.authData.is_none() {
            self.authData.set_default();
        }
        self.authData.as_mut().unwrap()
    }

    // Take field
    pub fn take_authData(&mut self) -> AuthenticationData {
        self.authData.take().unwrap_or_else(|| AuthenticationData::new())
    }

    // repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPFamilyAttributes familyAttributes = 10;


    pub fn get_familyAttributes(&self) -> &[BGPFamilyAttributes] {
        &self.familyAttributes
    }
    pub fn clear_familyAttributes(&mut self) {
        self.familyAttributes.clear();
    }

    // Param is passed by value, moved
    pub fn set_familyAttributes(&mut self, v: ::protobuf::RepeatedField<BGPFamilyAttributes>) {
        self.familyAttributes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_familyAttributes(&mut self) -> &mut ::protobuf::RepeatedField<BGPFamilyAttributes> {
        &mut self.familyAttributes
    }

    // Take field
    pub fn take_familyAttributes(&mut self) -> ::protobuf::RepeatedField<BGPFamilyAttributes> {
        ::std::mem::replace(&mut self.familyAttributes, ::protobuf::RepeatedField::new())
    }

    // optional string privateAsAction = 11;


    pub fn get_privateAsAction(&self) -> &str {
        match self.privateAsAction.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_privateAsAction(&mut self) {
        self.privateAsAction.clear();
    }

    pub fn has_privateAsAction(&self) -> bool {
        self.privateAsAction.is_some()
    }

    // Param is passed by value, moved
    pub fn set_privateAsAction(&mut self, v: ::std::string::String) {
        self.privateAsAction = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_privateAsAction(&mut self) -> &mut ::std::string::String {
        if self.privateAsAction.is_none() {
            self.privateAsAction.set_default();
        }
        self.privateAsAction.as_mut().unwrap()
    }

    // Take field
    pub fn take_privateAsAction(&mut self) -> ::std::string::String {
        self.privateAsAction.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RouteOriginOverride routeOriginOverride = 12;


    pub fn get_routeOriginOverride(&self) -> &RouteOriginOverride {
        self.routeOriginOverride.as_ref().unwrap_or_else(|| <RouteOriginOverride as ::protobuf::Message>::default_instance())
    }
    pub fn clear_routeOriginOverride(&mut self) {
        self.routeOriginOverride.clear();
    }

    pub fn has_routeOriginOverride(&self) -> bool {
        self.routeOriginOverride.is_some()
    }

    // Param is passed by value, moved
    pub fn set_routeOriginOverride(&mut self, v: RouteOriginOverride) {
        self.routeOriginOverride = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_routeOriginOverride(&mut self) -> &mut RouteOriginOverride {
        if self.routeOriginOverride.is_none() {
            self.routeOriginOverride.set_default();
        }
        self.routeOriginOverride.as_mut().unwrap()
    }

    // Take field
    pub fn take_routeOriginOverride(&mut self) -> RouteOriginOverride {
        self.routeOriginOverride.take().unwrap_or_else(|| RouteOriginOverride::new())
    }
}

impl ::protobuf::Message for BGPSessionAttributes {
    fn is_initialized(&self) -> bool {
        for v in &self.addressFamilies {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.authData {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.familyAttributes {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.routeOriginOverride {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.bgpRouter)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.adminDown = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.passive = ::std::option::Option::Some(tmp);
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.asOverride = ::std::option::Option::Some(tmp);
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.holdTime = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.loopCount = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.localAutonomousSystem = ::std::option::Option::Some(tmp);
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.addressFamilies)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.authData)?;
                },
                10 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.familyAttributes)?;
                },
                11 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.privateAsAction)?;
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.routeOriginOverride)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.bgpRouter.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.adminDown {
            my_size += 2;
        }
        if let Some(v) = self.passive {
            my_size += 2;
        }
        if let Some(v) = self.asOverride {
            my_size += 2;
        }
        if let Some(v) = self.holdTime {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.loopCount {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.localAutonomousSystem {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.addressFamilies.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.authData.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.familyAttributes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.privateAsAction.as_ref() {
            my_size += ::protobuf::rt::string_size(11, &v);
        }
        if let Some(ref v) = self.routeOriginOverride.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.bgpRouter.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.adminDown {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.passive {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.asOverride {
            os.write_bool(4, v)?;
        }
        if let Some(v) = self.holdTime {
            os.write_int32(5, v)?;
        }
        if let Some(v) = self.loopCount {
            os.write_int32(6, v)?;
        }
        if let Some(v) = self.localAutonomousSystem {
            os.write_int32(7, v)?;
        }
        if let Some(ref v) = self.addressFamilies.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.authData.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.familyAttributes {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.privateAsAction.as_ref() {
            os.write_string(11, &v)?;
        }
        if let Some(ref v) = self.routeOriginOverride.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BGPSessionAttributes {
        BGPSessionAttributes::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "bgpRouter",
                |m: &BGPSessionAttributes| { &m.bgpRouter },
                |m: &mut BGPSessionAttributes| { &mut m.bgpRouter },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "adminDown",
                |m: &BGPSessionAttributes| { &m.adminDown },
                |m: &mut BGPSessionAttributes| { &mut m.adminDown },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "passive",
                |m: &BGPSessionAttributes| { &m.passive },
                |m: &mut BGPSessionAttributes| { &mut m.passive },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "asOverride",
                |m: &BGPSessionAttributes| { &m.asOverride },
                |m: &mut BGPSessionAttributes| { &mut m.asOverride },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "holdTime",
                |m: &BGPSessionAttributes| { &m.holdTime },
                |m: &mut BGPSessionAttributes| { &mut m.holdTime },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "loopCount",
                |m: &BGPSessionAttributes| { &m.loopCount },
                |m: &mut BGPSessionAttributes| { &mut m.loopCount },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "localAutonomousSystem",
                |m: &BGPSessionAttributes| { &m.localAutonomousSystem },
                |m: &mut BGPSessionAttributes| { &mut m.localAutonomousSystem },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AddressFamilies>>(
                "addressFamilies",
                |m: &BGPSessionAttributes| { &m.addressFamilies },
                |m: &mut BGPSessionAttributes| { &mut m.addressFamilies },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AuthenticationData>>(
                "authData",
                |m: &BGPSessionAttributes| { &m.authData },
                |m: &mut BGPSessionAttributes| { &mut m.authData },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BGPFamilyAttributes>>(
                "familyAttributes",
                |m: &BGPSessionAttributes| { &m.familyAttributes },
                |m: &mut BGPSessionAttributes| { &mut m.familyAttributes },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "privateAsAction",
                |m: &BGPSessionAttributes| { &m.privateAsAction },
                |m: &mut BGPSessionAttributes| { &mut m.privateAsAction },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RouteOriginOverride>>(
                "routeOriginOverride",
                |m: &BGPSessionAttributes| { &m.routeOriginOverride },
                |m: &mut BGPSessionAttributes| { &mut m.routeOriginOverride },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BGPSessionAttributes>(
                "BGPSessionAttributes",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BGPSessionAttributes {
        static instance: ::protobuf::rt::LazyV2<BGPSessionAttributes> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BGPSessionAttributes::new)
    }
}

impl ::protobuf::Clear for BGPSessionAttributes {
    fn clear(&mut self) {
        self.bgpRouter.clear();
        self.adminDown = ::std::option::Option::None;
        self.passive = ::std::option::Option::None;
        self.asOverride = ::std::option::Option::None;
        self.holdTime = ::std::option::Option::None;
        self.loopCount = ::std::option::Option::None;
        self.localAutonomousSystem = ::std::option::Option::None;
        self.addressFamilies.clear();
        self.authData.clear();
        self.familyAttributes.clear();
        self.privateAsAction.clear();
        self.routeOriginOverride.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BGPSessionAttributes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BGPSessionAttributes {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct BGPSessionIPAttributes {
    // message fields
    bgpaasPrimaryIP: ::protobuf::SingularField<::std::string::String>,
    bgpaasSecondaryIP: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BGPSessionIPAttributes {
    fn default() -> &'a BGPSessionIPAttributes {
        <BGPSessionIPAttributes as ::protobuf::Message>::default_instance()
    }
}

impl BGPSessionIPAttributes {
    pub fn new() -> BGPSessionIPAttributes {
        ::std::default::Default::default()
    }

    // optional string bgpaasPrimaryIP = 1;


    pub fn get_bgpaasPrimaryIP(&self) -> &str {
        match self.bgpaasPrimaryIP.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_bgpaasPrimaryIP(&mut self) {
        self.bgpaasPrimaryIP.clear();
    }

    pub fn has_bgpaasPrimaryIP(&self) -> bool {
        self.bgpaasPrimaryIP.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bgpaasPrimaryIP(&mut self, v: ::std::string::String) {
        self.bgpaasPrimaryIP = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bgpaasPrimaryIP(&mut self) -> &mut ::std::string::String {
        if self.bgpaasPrimaryIP.is_none() {
            self.bgpaasPrimaryIP.set_default();
        }
        self.bgpaasPrimaryIP.as_mut().unwrap()
    }

    // Take field
    pub fn take_bgpaasPrimaryIP(&mut self) -> ::std::string::String {
        self.bgpaasPrimaryIP.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string bgpaasSecondaryIP = 2;


    pub fn get_bgpaasSecondaryIP(&self) -> &str {
        match self.bgpaasSecondaryIP.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_bgpaasSecondaryIP(&mut self) {
        self.bgpaasSecondaryIP.clear();
    }

    pub fn has_bgpaasSecondaryIP(&self) -> bool {
        self.bgpaasSecondaryIP.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bgpaasSecondaryIP(&mut self, v: ::std::string::String) {
        self.bgpaasSecondaryIP = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bgpaasSecondaryIP(&mut self) -> &mut ::std::string::String {
        if self.bgpaasSecondaryIP.is_none() {
            self.bgpaasSecondaryIP.set_default();
        }
        self.bgpaasSecondaryIP.as_mut().unwrap()
    }

    // Take field
    pub fn take_bgpaasSecondaryIP(&mut self) -> ::std::string::String {
        self.bgpaasSecondaryIP.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for BGPSessionIPAttributes {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.bgpaasPrimaryIP)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.bgpaasSecondaryIP)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.bgpaasPrimaryIP.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.bgpaasSecondaryIP.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.bgpaasPrimaryIP.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.bgpaasSecondaryIP.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BGPSessionIPAttributes {
        BGPSessionIPAttributes::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "bgpaasPrimaryIP",
                |m: &BGPSessionIPAttributes| { &m.bgpaasPrimaryIP },
                |m: &mut BGPSessionIPAttributes| { &mut m.bgpaasPrimaryIP },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "bgpaasSecondaryIP",
                |m: &BGPSessionIPAttributes| { &m.bgpaasSecondaryIP },
                |m: &mut BGPSessionIPAttributes| { &mut m.bgpaasSecondaryIP },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<BGPSessionIPAttributes>(
                "BGPSessionIPAttributes",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static BGPSessionIPAttributes {
        static instance: ::protobuf::rt::LazyV2<BGPSessionIPAttributes> = ::protobuf::rt::LazyV2::INIT;
        instance.get(BGPSessionIPAttributes::new)
    }
}

impl ::protobuf::Clear for BGPSessionIPAttributes {
    fn clear(&mut self) {
        self.bgpaasPrimaryIP.clear();
        self.bgpaasSecondaryIP.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BGPSessionIPAttributes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BGPSessionIPAttributes {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CommonSpec {
    // message fields
    pub contrailFqName: ::protobuf::SingularPtrField<ContrailFqName>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CommonSpec {
    fn default() -> &'a CommonSpec {
        <CommonSpec as ::protobuf::Message>::default_instance()
    }
}

impl CommonSpec {
    pub fn new() -> CommonSpec {
        ::std::default::Default::default()
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ContrailFqName contrailFqName = 1;


    pub fn get_contrailFqName(&self) -> &ContrailFqName {
        self.contrailFqName.as_ref().unwrap_or_else(|| <ContrailFqName as ::protobuf::Message>::default_instance())
    }
    pub fn clear_contrailFqName(&mut self) {
        self.contrailFqName.clear();
    }

    pub fn has_contrailFqName(&self) -> bool {
        self.contrailFqName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_contrailFqName(&mut self, v: ContrailFqName) {
        self.contrailFqName = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_contrailFqName(&mut self) -> &mut ContrailFqName {
        if self.contrailFqName.is_none() {
            self.contrailFqName.set_default();
        }
        self.contrailFqName.as_mut().unwrap()
    }

    // Take field
    pub fn take_contrailFqName(&mut self) -> ContrailFqName {
        self.contrailFqName.take().unwrap_or_else(|| ContrailFqName::new())
    }
}

impl ::protobuf::Message for CommonSpec {
    fn is_initialized(&self) -> bool {
        for v in &self.contrailFqName {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.contrailFqName)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.contrailFqName.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.contrailFqName.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommonSpec {
        CommonSpec::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ContrailFqName>>(
                "contrailFqName",
                |m: &CommonSpec| { &m.contrailFqName },
                |m: &mut CommonSpec| { &mut m.contrailFqName },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CommonSpec>(
                "CommonSpec",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CommonSpec {
        static instance: ::protobuf::rt::LazyV2<CommonSpec> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CommonSpec::new)
    }
}

impl ::protobuf::Clear for CommonSpec {
    fn clear(&mut self) {
        self.contrailFqName.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CommonSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CommonSpec {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CommonStatus {
    // message fields
    pub reconcilerState: ::protobuf::SingularPtrField<ReconcilerState>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CommonStatus {
    fn default() -> &'a CommonStatus {
        <CommonStatus as ::protobuf::Message>::default_instance()
    }
}

impl CommonStatus {
    pub fn new() -> CommonStatus {
        ::std::default::Default::default()
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ReconcilerState reconcilerState = 1;


    pub fn get_reconcilerState(&self) -> &ReconcilerState {
        self.reconcilerState.as_ref().unwrap_or_else(|| <ReconcilerState as ::protobuf::Message>::default_instance())
    }
    pub fn clear_reconcilerState(&mut self) {
        self.reconcilerState.clear();
    }

    pub fn has_reconcilerState(&self) -> bool {
        self.reconcilerState.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reconcilerState(&mut self, v: ReconcilerState) {
        self.reconcilerState = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reconcilerState(&mut self) -> &mut ReconcilerState {
        if self.reconcilerState.is_none() {
            self.reconcilerState.set_default();
        }
        self.reconcilerState.as_mut().unwrap()
    }

    // Take field
    pub fn take_reconcilerState(&mut self) -> ReconcilerState {
        self.reconcilerState.take().unwrap_or_else(|| ReconcilerState::new())
    }
}

impl ::protobuf::Message for CommonStatus {
    fn is_initialized(&self) -> bool {
        for v in &self.reconcilerState {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.reconcilerState)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.reconcilerState.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.reconcilerState.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommonStatus {
        CommonStatus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ReconcilerState>>(
                "reconcilerState",
                |m: &CommonStatus| { &m.reconcilerState },
                |m: &mut CommonStatus| { &mut m.reconcilerState },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CommonStatus>(
                "CommonStatus",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CommonStatus {
        static instance: ::protobuf::rt::LazyV2<CommonStatus> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CommonStatus::new)
    }
}

impl ::protobuf::Clear for CommonStatus {
    fn clear(&mut self) {
        self.reconcilerState.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CommonStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CommonStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ContrailFqName {
    // message fields
    pub fqName: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ContrailFqName {
    fn default() -> &'a ContrailFqName {
        <ContrailFqName as ::protobuf::Message>::default_instance()
    }
}

impl ContrailFqName {
    pub fn new() -> ContrailFqName {
        ::std::default::Default::default()
    }

    // repeated string fqName = 1;


    pub fn get_fqName(&self) -> &[::std::string::String] {
        &self.fqName
    }
    pub fn clear_fqName(&mut self) {
        self.fqName.clear();
    }

    // Param is passed by value, moved
    pub fn set_fqName(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.fqName = v;
    }

    // Mutable pointer to the field.
    pub fn mut_fqName(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.fqName
    }

    // Take field
    pub fn take_fqName(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.fqName, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ContrailFqName {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.fqName)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.fqName {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.fqName {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ContrailFqName {
        ContrailFqName::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "fqName",
                |m: &ContrailFqName| { &m.fqName },
                |m: &mut ContrailFqName| { &mut m.fqName },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ContrailFqName>(
                "ContrailFqName",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ContrailFqName {
        static instance: ::protobuf::rt::LazyV2<ContrailFqName> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ContrailFqName::new)
    }
}

impl ::protobuf::Clear for ContrailFqName {
    fn clear(&mut self) {
        self.fqName.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ContrailFqName {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContrailFqName {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct EncapsulationPriorities {
    // message fields
    pub encapsulation: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a EncapsulationPriorities {
    fn default() -> &'a EncapsulationPriorities {
        <EncapsulationPriorities as ::protobuf::Message>::default_instance()
    }
}

impl EncapsulationPriorities {
    pub fn new() -> EncapsulationPriorities {
        ::std::default::Default::default()
    }

    // repeated string encapsulation = 1;


    pub fn get_encapsulation(&self) -> &[::std::string::String] {
        &self.encapsulation
    }
    pub fn clear_encapsulation(&mut self) {
        self.encapsulation.clear();
    }

    // Param is passed by value, moved
    pub fn set_encapsulation(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.encapsulation = v;
    }

    // Mutable pointer to the field.
    pub fn mut_encapsulation(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.encapsulation
    }

    // Take field
    pub fn take_encapsulation(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.encapsulation, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for EncapsulationPriorities {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.encapsulation)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.encapsulation {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.encapsulation {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> EncapsulationPriorities {
        EncapsulationPriorities::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "encapsulation",
                |m: &EncapsulationPriorities| { &m.encapsulation },
                |m: &mut EncapsulationPriorities| { &mut m.encapsulation },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<EncapsulationPriorities>(
                "EncapsulationPriorities",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static EncapsulationPriorities {
        static instance: ::protobuf::rt::LazyV2<EncapsulationPriorities> = ::protobuf::rt::LazyV2::INIT;
        instance.get(EncapsulationPriorities::new)
    }
}

impl ::protobuf::Clear for EncapsulationPriorities {
    fn clear(&mut self) {
        self.encapsulation.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for EncapsulationPriorities {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EncapsulationPriorities {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FirewallActionListType {
    // message fields
    simpleAction: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FirewallActionListType {
    fn default() -> &'a FirewallActionListType {
        <FirewallActionListType as ::protobuf::Message>::default_instance()
    }
}

impl FirewallActionListType {
    pub fn new() -> FirewallActionListType {
        ::std::default::Default::default()
    }

    // optional string simpleAction = 1;


    pub fn get_simpleAction(&self) -> &str {
        match self.simpleAction.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_simpleAction(&mut self) {
        self.simpleAction.clear();
    }

    pub fn has_simpleAction(&self) -> bool {
        self.simpleAction.is_some()
    }

    // Param is passed by value, moved
    pub fn set_simpleAction(&mut self, v: ::std::string::String) {
        self.simpleAction = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_simpleAction(&mut self) -> &mut ::std::string::String {
        if self.simpleAction.is_none() {
            self.simpleAction.set_default();
        }
        self.simpleAction.as_mut().unwrap()
    }

    // Take field
    pub fn take_simpleAction(&mut self) -> ::std::string::String {
        self.simpleAction.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for FirewallActionListType {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.simpleAction)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.simpleAction.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.simpleAction.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FirewallActionListType {
        FirewallActionListType::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "simpleAction",
                |m: &FirewallActionListType| { &m.simpleAction },
                |m: &mut FirewallActionListType| { &mut m.simpleAction },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FirewallActionListType>(
                "FirewallActionListType",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FirewallActionListType {
        static instance: ::protobuf::rt::LazyV2<FirewallActionListType> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FirewallActionListType::new)
    }
}

impl ::protobuf::Clear for FirewallActionListType {
    fn clear(&mut self) {
        self.simpleAction.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FirewallActionListType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FirewallActionListType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FirewallPolicy {
    // message fields
    pub metadata: ::protobuf::SingularPtrField<super::meta::ObjectMeta>,
    pub spec: ::protobuf::SingularPtrField<FirewallPolicySpec>,
    pub status: ::protobuf::SingularPtrField<FirewallPolicyStatus>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FirewallPolicy {
    fn default() -> &'a FirewallPolicy {
        <FirewallPolicy as ::protobuf::Message>::default_instance()
    }
}

impl FirewallPolicy {
    pub fn new() -> FirewallPolicy {
        ::std::default::Default::default()
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;


    pub fn get_metadata(&self) -> &super::meta::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <super::meta::ObjectMeta as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::meta::ObjectMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::meta::ObjectMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::meta::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| super::meta::ObjectMeta::new())
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallPolicySpec spec = 2;


    pub fn get_spec(&self) -> &FirewallPolicySpec {
        self.spec.as_ref().unwrap_or_else(|| <FirewallPolicySpec as ::protobuf::Message>::default_instance())
    }
    pub fn clear_spec(&mut self) {
        self.spec.clear();
    }

    pub fn has_spec(&self) -> bool {
        self.spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spec(&mut self, v: FirewallPolicySpec) {
        self.spec = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spec(&mut self) -> &mut FirewallPolicySpec {
        if self.spec.is_none() {
            self.spec.set_default();
        }
        self.spec.as_mut().unwrap()
    }

    // Take field
    pub fn take_spec(&mut self) -> FirewallPolicySpec {
        self.spec.take().unwrap_or_else(|| FirewallPolicySpec::new())
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallPolicyStatus status = 3;


    pub fn get_status(&self) -> &FirewallPolicyStatus {
        self.status.as_ref().unwrap_or_else(|| <FirewallPolicyStatus as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: FirewallPolicyStatus) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut FirewallPolicyStatus {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> FirewallPolicyStatus {
        self.status.take().unwrap_or_else(|| FirewallPolicyStatus::new())
    }
}

impl ::protobuf::Message for FirewallPolicy {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.spec {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.spec)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.spec.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FirewallPolicy {
        FirewallPolicy::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::meta::ObjectMeta>>(
                "metadata",
                |m: &FirewallPolicy| { &m.metadata },
                |m: &mut FirewallPolicy| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FirewallPolicySpec>>(
                "spec",
                |m: &FirewallPolicy| { &m.spec },
                |m: &mut FirewallPolicy| { &mut m.spec },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FirewallPolicyStatus>>(
                "status",
                |m: &FirewallPolicy| { &m.status },
                |m: &mut FirewallPolicy| { &mut m.status },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FirewallPolicy>(
                "FirewallPolicy",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FirewallPolicy {
        static instance: ::protobuf::rt::LazyV2<FirewallPolicy> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FirewallPolicy::new)
    }
}

impl ::protobuf::Clear for FirewallPolicy {
    fn clear(&mut self) {
        self.metadata.clear();
        self.spec.clear();
        self.status.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FirewallPolicy {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FirewallPolicy {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FirewallPolicyAttribute {
    // message fields
    sequence: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FirewallPolicyAttribute {
    fn default() -> &'a FirewallPolicyAttribute {
        <FirewallPolicyAttribute as ::protobuf::Message>::default_instance()
    }
}

impl FirewallPolicyAttribute {
    pub fn new() -> FirewallPolicyAttribute {
        ::std::default::Default::default()
    }

    // optional string sequence = 1;


    pub fn get_sequence(&self) -> &str {
        match self.sequence.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_sequence(&mut self) {
        self.sequence.clear();
    }

    pub fn has_sequence(&self) -> bool {
        self.sequence.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sequence(&mut self, v: ::std::string::String) {
        self.sequence = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sequence(&mut self) -> &mut ::std::string::String {
        if self.sequence.is_none() {
            self.sequence.set_default();
        }
        self.sequence.as_mut().unwrap()
    }

    // Take field
    pub fn take_sequence(&mut self) -> ::std::string::String {
        self.sequence.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for FirewallPolicyAttribute {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.sequence)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.sequence.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.sequence.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FirewallPolicyAttribute {
        FirewallPolicyAttribute::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "sequence",
                |m: &FirewallPolicyAttribute| { &m.sequence },
                |m: &mut FirewallPolicyAttribute| { &mut m.sequence },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FirewallPolicyAttribute>(
                "FirewallPolicyAttribute",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FirewallPolicyAttribute {
        static instance: ::protobuf::rt::LazyV2<FirewallPolicyAttribute> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FirewallPolicyAttribute::new)
    }
}

impl ::protobuf::Clear for FirewallPolicyAttribute {
    fn clear(&mut self) {
        self.sequence.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FirewallPolicyAttribute {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FirewallPolicyAttribute {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FirewallPolicyList {
    // message fields
    pub metadata: ::protobuf::SingularPtrField<super::meta::ListMeta>,
    pub items: ::protobuf::RepeatedField<FirewallPolicy>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FirewallPolicyList {
    fn default() -> &'a FirewallPolicyList {
        <FirewallPolicyList as ::protobuf::Message>::default_instance()
    }
}

impl FirewallPolicyList {
    pub fn new() -> FirewallPolicyList {
        ::std::default::Default::default()
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;


    pub fn get_metadata(&self) -> &super::meta::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <super::meta::ListMeta as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::meta::ListMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::meta::ListMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::meta::ListMeta {
        self.metadata.take().unwrap_or_else(|| super::meta::ListMeta::new())
    }

    // repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallPolicy items = 2;


    pub fn get_items(&self) -> &[FirewallPolicy] {
        &self.items
    }
    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::protobuf::RepeatedField<FirewallPolicy>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::protobuf::RepeatedField<FirewallPolicy> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::protobuf::RepeatedField<FirewallPolicy> {
        ::std::mem::replace(&mut self.items, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for FirewallPolicyList {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.items {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.items)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.items {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FirewallPolicyList {
        FirewallPolicyList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::meta::ListMeta>>(
                "metadata",
                |m: &FirewallPolicyList| { &m.metadata },
                |m: &mut FirewallPolicyList| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FirewallPolicy>>(
                "items",
                |m: &FirewallPolicyList| { &m.items },
                |m: &mut FirewallPolicyList| { &mut m.items },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FirewallPolicyList>(
                "FirewallPolicyList",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FirewallPolicyList {
        static instance: ::protobuf::rt::LazyV2<FirewallPolicyList> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FirewallPolicyList::new)
    }
}

impl ::protobuf::Clear for FirewallPolicyList {
    fn clear(&mut self) {
        self.metadata.clear();
        self.items.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FirewallPolicyList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FirewallPolicyList {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FirewallPolicyReference {
    // message fields
    pub resourceReference: ::protobuf::SingularPtrField<ResourceReference>,
    pub attributes: ::protobuf::SingularPtrField<APSAttribute>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FirewallPolicyReference {
    fn default() -> &'a FirewallPolicyReference {
        <FirewallPolicyReference as ::protobuf::Message>::default_instance()
    }
}

impl FirewallPolicyReference {
    pub fn new() -> FirewallPolicyReference {
        ::std::default::Default::default()
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ResourceReference resourceReference = 1;


    pub fn get_resourceReference(&self) -> &ResourceReference {
        self.resourceReference.as_ref().unwrap_or_else(|| <ResourceReference as ::protobuf::Message>::default_instance())
    }
    pub fn clear_resourceReference(&mut self) {
        self.resourceReference.clear();
    }

    pub fn has_resourceReference(&self) -> bool {
        self.resourceReference.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resourceReference(&mut self, v: ResourceReference) {
        self.resourceReference = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_resourceReference(&mut self) -> &mut ResourceReference {
        if self.resourceReference.is_none() {
            self.resourceReference.set_default();
        }
        self.resourceReference.as_mut().unwrap()
    }

    // Take field
    pub fn take_resourceReference(&mut self) -> ResourceReference {
        self.resourceReference.take().unwrap_or_else(|| ResourceReference::new())
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.APSAttribute attributes = 2;


    pub fn get_attributes(&self) -> &APSAttribute {
        self.attributes.as_ref().unwrap_or_else(|| <APSAttribute as ::protobuf::Message>::default_instance())
    }
    pub fn clear_attributes(&mut self) {
        self.attributes.clear();
    }

    pub fn has_attributes(&self) -> bool {
        self.attributes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attributes(&mut self, v: APSAttribute) {
        self.attributes = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_attributes(&mut self) -> &mut APSAttribute {
        if self.attributes.is_none() {
            self.attributes.set_default();
        }
        self.attributes.as_mut().unwrap()
    }

    // Take field
    pub fn take_attributes(&mut self) -> APSAttribute {
        self.attributes.take().unwrap_or_else(|| APSAttribute::new())
    }
}

impl ::protobuf::Message for FirewallPolicyReference {
    fn is_initialized(&self) -> bool {
        for v in &self.resourceReference {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.attributes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.resourceReference)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.attributes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.resourceReference.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.attributes.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.resourceReference.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.attributes.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FirewallPolicyReference {
        FirewallPolicyReference::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResourceReference>>(
                "resourceReference",
                |m: &FirewallPolicyReference| { &m.resourceReference },
                |m: &mut FirewallPolicyReference| { &mut m.resourceReference },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<APSAttribute>>(
                "attributes",
                |m: &FirewallPolicyReference| { &m.attributes },
                |m: &mut FirewallPolicyReference| { &mut m.attributes },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FirewallPolicyReference>(
                "FirewallPolicyReference",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FirewallPolicyReference {
        static instance: ::protobuf::rt::LazyV2<FirewallPolicyReference> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FirewallPolicyReference::new)
    }
}

impl ::protobuf::Clear for FirewallPolicyReference {
    fn clear(&mut self) {
        self.resourceReference.clear();
        self.attributes.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FirewallPolicyReference {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FirewallPolicyReference {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FirewallPolicySpec {
    // message fields
    pub commonSpec: ::protobuf::SingularPtrField<CommonSpec>,
    pub firewallRule: ::protobuf::RepeatedField<FirewallRuleReference>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FirewallPolicySpec {
    fn default() -> &'a FirewallPolicySpec {
        <FirewallPolicySpec as ::protobuf::Message>::default_instance()
    }
}

impl FirewallPolicySpec {
    pub fn new() -> FirewallPolicySpec {
        ::std::default::Default::default()
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonSpec commonSpec = 1;


    pub fn get_commonSpec(&self) -> &CommonSpec {
        self.commonSpec.as_ref().unwrap_or_else(|| <CommonSpec as ::protobuf::Message>::default_instance())
    }
    pub fn clear_commonSpec(&mut self) {
        self.commonSpec.clear();
    }

    pub fn has_commonSpec(&self) -> bool {
        self.commonSpec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_commonSpec(&mut self, v: CommonSpec) {
        self.commonSpec = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_commonSpec(&mut self) -> &mut CommonSpec {
        if self.commonSpec.is_none() {
            self.commonSpec.set_default();
        }
        self.commonSpec.as_mut().unwrap()
    }

    // Take field
    pub fn take_commonSpec(&mut self) -> CommonSpec {
        self.commonSpec.take().unwrap_or_else(|| CommonSpec::new())
    }

    // repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleReference firewallRule = 3;


    pub fn get_firewallRule(&self) -> &[FirewallRuleReference] {
        &self.firewallRule
    }
    pub fn clear_firewallRule(&mut self) {
        self.firewallRule.clear();
    }

    // Param is passed by value, moved
    pub fn set_firewallRule(&mut self, v: ::protobuf::RepeatedField<FirewallRuleReference>) {
        self.firewallRule = v;
    }

    // Mutable pointer to the field.
    pub fn mut_firewallRule(&mut self) -> &mut ::protobuf::RepeatedField<FirewallRuleReference> {
        &mut self.firewallRule
    }

    // Take field
    pub fn take_firewallRule(&mut self) -> ::protobuf::RepeatedField<FirewallRuleReference> {
        ::std::mem::replace(&mut self.firewallRule, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for FirewallPolicySpec {
    fn is_initialized(&self) -> bool {
        for v in &self.commonSpec {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.firewallRule {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.commonSpec)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.firewallRule)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.commonSpec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.firewallRule {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.commonSpec.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.firewallRule {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FirewallPolicySpec {
        FirewallPolicySpec::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommonSpec>>(
                "commonSpec",
                |m: &FirewallPolicySpec| { &m.commonSpec },
                |m: &mut FirewallPolicySpec| { &mut m.commonSpec },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FirewallRuleReference>>(
                "firewallRule",
                |m: &FirewallPolicySpec| { &m.firewallRule },
                |m: &mut FirewallPolicySpec| { &mut m.firewallRule },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FirewallPolicySpec>(
                "FirewallPolicySpec",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FirewallPolicySpec {
        static instance: ::protobuf::rt::LazyV2<FirewallPolicySpec> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FirewallPolicySpec::new)
    }
}

impl ::protobuf::Clear for FirewallPolicySpec {
    fn clear(&mut self) {
        self.commonSpec.clear();
        self.firewallRule.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FirewallPolicySpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FirewallPolicySpec {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FirewallPolicyStatus {
    // message fields
    pub commonStatus: ::protobuf::SingularPtrField<CommonStatus>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FirewallPolicyStatus {
    fn default() -> &'a FirewallPolicyStatus {
        <FirewallPolicyStatus as ::protobuf::Message>::default_instance()
    }
}

impl FirewallPolicyStatus {
    pub fn new() -> FirewallPolicyStatus {
        ::std::default::Default::default()
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonStatus commonStatus = 1;


    pub fn get_commonStatus(&self) -> &CommonStatus {
        self.commonStatus.as_ref().unwrap_or_else(|| <CommonStatus as ::protobuf::Message>::default_instance())
    }
    pub fn clear_commonStatus(&mut self) {
        self.commonStatus.clear();
    }

    pub fn has_commonStatus(&self) -> bool {
        self.commonStatus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_commonStatus(&mut self, v: CommonStatus) {
        self.commonStatus = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_commonStatus(&mut self) -> &mut CommonStatus {
        if self.commonStatus.is_none() {
            self.commonStatus.set_default();
        }
        self.commonStatus.as_mut().unwrap()
    }

    // Take field
    pub fn take_commonStatus(&mut self) -> CommonStatus {
        self.commonStatus.take().unwrap_or_else(|| CommonStatus::new())
    }
}

impl ::protobuf::Message for FirewallPolicyStatus {
    fn is_initialized(&self) -> bool {
        for v in &self.commonStatus {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.commonStatus)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.commonStatus.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.commonStatus.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FirewallPolicyStatus {
        FirewallPolicyStatus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommonStatus>>(
                "commonStatus",
                |m: &FirewallPolicyStatus| { &m.commonStatus },
                |m: &mut FirewallPolicyStatus| { &mut m.commonStatus },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FirewallPolicyStatus>(
                "FirewallPolicyStatus",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FirewallPolicyStatus {
        static instance: ::protobuf::rt::LazyV2<FirewallPolicyStatus> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FirewallPolicyStatus::new)
    }
}

impl ::protobuf::Clear for FirewallPolicyStatus {
    fn clear(&mut self) {
        self.commonStatus.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FirewallPolicyStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FirewallPolicyStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FirewallRule {
    // message fields
    pub metadata: ::protobuf::SingularPtrField<super::meta::ObjectMeta>,
    pub spec: ::protobuf::SingularPtrField<FirewallRuleSpec>,
    pub status: ::protobuf::SingularPtrField<FirewallRuleStatus>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FirewallRule {
    fn default() -> &'a FirewallRule {
        <FirewallRule as ::protobuf::Message>::default_instance()
    }
}

impl FirewallRule {
    pub fn new() -> FirewallRule {
        ::std::default::Default::default()
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;


    pub fn get_metadata(&self) -> &super::meta::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <super::meta::ObjectMeta as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::meta::ObjectMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::meta::ObjectMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::meta::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| super::meta::ObjectMeta::new())
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleSpec spec = 2;


    pub fn get_spec(&self) -> &FirewallRuleSpec {
        self.spec.as_ref().unwrap_or_else(|| <FirewallRuleSpec as ::protobuf::Message>::default_instance())
    }
    pub fn clear_spec(&mut self) {
        self.spec.clear();
    }

    pub fn has_spec(&self) -> bool {
        self.spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spec(&mut self, v: FirewallRuleSpec) {
        self.spec = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spec(&mut self) -> &mut FirewallRuleSpec {
        if self.spec.is_none() {
            self.spec.set_default();
        }
        self.spec.as_mut().unwrap()
    }

    // Take field
    pub fn take_spec(&mut self) -> FirewallRuleSpec {
        self.spec.take().unwrap_or_else(|| FirewallRuleSpec::new())
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleStatus status = 3;


    pub fn get_status(&self) -> &FirewallRuleStatus {
        self.status.as_ref().unwrap_or_else(|| <FirewallRuleStatus as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: FirewallRuleStatus) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut FirewallRuleStatus {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> FirewallRuleStatus {
        self.status.take().unwrap_or_else(|| FirewallRuleStatus::new())
    }
}

impl ::protobuf::Message for FirewallRule {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.spec {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.spec)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.spec.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FirewallRule {
        FirewallRule::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::meta::ObjectMeta>>(
                "metadata",
                |m: &FirewallRule| { &m.metadata },
                |m: &mut FirewallRule| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FirewallRuleSpec>>(
                "spec",
                |m: &FirewallRule| { &m.spec },
                |m: &mut FirewallRule| { &mut m.spec },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FirewallRuleStatus>>(
                "status",
                |m: &FirewallRule| { &m.status },
                |m: &mut FirewallRule| { &mut m.status },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FirewallRule>(
                "FirewallRule",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FirewallRule {
        static instance: ::protobuf::rt::LazyV2<FirewallRule> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FirewallRule::new)
    }
}

impl ::protobuf::Clear for FirewallRule {
    fn clear(&mut self) {
        self.metadata.clear();
        self.spec.clear();
        self.status.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FirewallRule {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FirewallRule {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FirewallRuleEndpointType {
    // message fields
    pub subnet: ::protobuf::SingularPtrField<FirewallSubnet>,
    addressGroup: ::protobuf::SingularField<::std::string::String>,
    pub tags: ::protobuf::RepeatedField<::std::string::String>,
    pub tagIds: ::std::vec::Vec<i64>,
    any: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FirewallRuleEndpointType {
    fn default() -> &'a FirewallRuleEndpointType {
        <FirewallRuleEndpointType as ::protobuf::Message>::default_instance()
    }
}

impl FirewallRuleEndpointType {
    pub fn new() -> FirewallRuleEndpointType {
        ::std::default::Default::default()
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallSubnet subnet = 1;


    pub fn get_subnet(&self) -> &FirewallSubnet {
        self.subnet.as_ref().unwrap_or_else(|| <FirewallSubnet as ::protobuf::Message>::default_instance())
    }
    pub fn clear_subnet(&mut self) {
        self.subnet.clear();
    }

    pub fn has_subnet(&self) -> bool {
        self.subnet.is_some()
    }

    // Param is passed by value, moved
    pub fn set_subnet(&mut self, v: FirewallSubnet) {
        self.subnet = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subnet(&mut self) -> &mut FirewallSubnet {
        if self.subnet.is_none() {
            self.subnet.set_default();
        }
        self.subnet.as_mut().unwrap()
    }

    // Take field
    pub fn take_subnet(&mut self) -> FirewallSubnet {
        self.subnet.take().unwrap_or_else(|| FirewallSubnet::new())
    }

    // optional string addressGroup = 3;


    pub fn get_addressGroup(&self) -> &str {
        match self.addressGroup.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_addressGroup(&mut self) {
        self.addressGroup.clear();
    }

    pub fn has_addressGroup(&self) -> bool {
        self.addressGroup.is_some()
    }

    // Param is passed by value, moved
    pub fn set_addressGroup(&mut self, v: ::std::string::String) {
        self.addressGroup = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_addressGroup(&mut self) -> &mut ::std::string::String {
        if self.addressGroup.is_none() {
            self.addressGroup.set_default();
        }
        self.addressGroup.as_mut().unwrap()
    }

    // Take field
    pub fn take_addressGroup(&mut self) -> ::std::string::String {
        self.addressGroup.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated string tags = 4;


    pub fn get_tags(&self) -> &[::std::string::String] {
        &self.tags
    }
    pub fn clear_tags(&mut self) {
        self.tags.clear();
    }

    // Param is passed by value, moved
    pub fn set_tags(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.tags = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tags(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.tags
    }

    // Take field
    pub fn take_tags(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.tags, ::protobuf::RepeatedField::new())
    }

    // repeated int64 tagIds = 5;


    pub fn get_tagIds(&self) -> &[i64] {
        &self.tagIds
    }
    pub fn clear_tagIds(&mut self) {
        self.tagIds.clear();
    }

    // Param is passed by value, moved
    pub fn set_tagIds(&mut self, v: ::std::vec::Vec<i64>) {
        self.tagIds = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tagIds(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.tagIds
    }

    // Take field
    pub fn take_tagIds(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.tagIds, ::std::vec::Vec::new())
    }

    // optional bool any = 6;


    pub fn get_any(&self) -> bool {
        self.any.unwrap_or(false)
    }
    pub fn clear_any(&mut self) {
        self.any = ::std::option::Option::None;
    }

    pub fn has_any(&self) -> bool {
        self.any.is_some()
    }

    // Param is passed by value, moved
    pub fn set_any(&mut self, v: bool) {
        self.any = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for FirewallRuleEndpointType {
    fn is_initialized(&self) -> bool {
        for v in &self.subnet {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.subnet)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.addressGroup)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.tags)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_int64_into(wire_type, is, &mut self.tagIds)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.any = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.subnet.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.addressGroup.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        for value in &self.tags {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        for value in &self.tagIds {
            my_size += ::protobuf::rt::value_size(5, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(v) = self.any {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.subnet.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.addressGroup.as_ref() {
            os.write_string(3, &v)?;
        }
        for v in &self.tags {
            os.write_string(4, &v)?;
        };
        for v in &self.tagIds {
            os.write_int64(5, *v)?;
        };
        if let Some(v) = self.any {
            os.write_bool(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FirewallRuleEndpointType {
        FirewallRuleEndpointType::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FirewallSubnet>>(
                "subnet",
                |m: &FirewallRuleEndpointType| { &m.subnet },
                |m: &mut FirewallRuleEndpointType| { &mut m.subnet },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "addressGroup",
                |m: &FirewallRuleEndpointType| { &m.addressGroup },
                |m: &mut FirewallRuleEndpointType| { &mut m.addressGroup },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "tags",
                |m: &FirewallRuleEndpointType| { &m.tags },
                |m: &mut FirewallRuleEndpointType| { &mut m.tags },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "tagIds",
                |m: &FirewallRuleEndpointType| { &m.tagIds },
                |m: &mut FirewallRuleEndpointType| { &mut m.tagIds },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "any",
                |m: &FirewallRuleEndpointType| { &m.any },
                |m: &mut FirewallRuleEndpointType| { &mut m.any },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FirewallRuleEndpointType>(
                "FirewallRuleEndpointType",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FirewallRuleEndpointType {
        static instance: ::protobuf::rt::LazyV2<FirewallRuleEndpointType> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FirewallRuleEndpointType::new)
    }
}

impl ::protobuf::Clear for FirewallRuleEndpointType {
    fn clear(&mut self) {
        self.subnet.clear();
        self.addressGroup.clear();
        self.tags.clear();
        self.tagIds.clear();
        self.any = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FirewallRuleEndpointType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FirewallRuleEndpointType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FirewallRuleList {
    // message fields
    pub metadata: ::protobuf::SingularPtrField<super::meta::ListMeta>,
    pub items: ::protobuf::RepeatedField<FirewallRule>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FirewallRuleList {
    fn default() -> &'a FirewallRuleList {
        <FirewallRuleList as ::protobuf::Message>::default_instance()
    }
}

impl FirewallRuleList {
    pub fn new() -> FirewallRuleList {
        ::std::default::Default::default()
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;


    pub fn get_metadata(&self) -> &super::meta::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <super::meta::ListMeta as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::meta::ListMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::meta::ListMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::meta::ListMeta {
        self.metadata.take().unwrap_or_else(|| super::meta::ListMeta::new())
    }

    // repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRule items = 2;


    pub fn get_items(&self) -> &[FirewallRule] {
        &self.items
    }
    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::protobuf::RepeatedField<FirewallRule>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::protobuf::RepeatedField<FirewallRule> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::protobuf::RepeatedField<FirewallRule> {
        ::std::mem::replace(&mut self.items, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for FirewallRuleList {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.items {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.items)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.items {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FirewallRuleList {
        FirewallRuleList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::meta::ListMeta>>(
                "metadata",
                |m: &FirewallRuleList| { &m.metadata },
                |m: &mut FirewallRuleList| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FirewallRule>>(
                "items",
                |m: &FirewallRuleList| { &m.items },
                |m: &mut FirewallRuleList| { &mut m.items },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FirewallRuleList>(
                "FirewallRuleList",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FirewallRuleList {
        static instance: ::protobuf::rt::LazyV2<FirewallRuleList> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FirewallRuleList::new)
    }
}

impl ::protobuf::Clear for FirewallRuleList {
    fn clear(&mut self) {
        self.metadata.clear();
        self.items.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FirewallRuleList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FirewallRuleList {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FirewallRuleReference {
    // message fields
    pub resourceReference: ::protobuf::SingularPtrField<ResourceReference>,
    pub attributes: ::protobuf::SingularPtrField<FirewallPolicyAttribute>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FirewallRuleReference {
    fn default() -> &'a FirewallRuleReference {
        <FirewallRuleReference as ::protobuf::Message>::default_instance()
    }
}

impl FirewallRuleReference {
    pub fn new() -> FirewallRuleReference {
        ::std::default::Default::default()
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ResourceReference resourceReference = 1;


    pub fn get_resourceReference(&self) -> &ResourceReference {
        self.resourceReference.as_ref().unwrap_or_else(|| <ResourceReference as ::protobuf::Message>::default_instance())
    }
    pub fn clear_resourceReference(&mut self) {
        self.resourceReference.clear();
    }

    pub fn has_resourceReference(&self) -> bool {
        self.resourceReference.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resourceReference(&mut self, v: ResourceReference) {
        self.resourceReference = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_resourceReference(&mut self) -> &mut ResourceReference {
        if self.resourceReference.is_none() {
            self.resourceReference.set_default();
        }
        self.resourceReference.as_mut().unwrap()
    }

    // Take field
    pub fn take_resourceReference(&mut self) -> ResourceReference {
        self.resourceReference.take().unwrap_or_else(|| ResourceReference::new())
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallPolicyAttribute attributes = 2;


    pub fn get_attributes(&self) -> &FirewallPolicyAttribute {
        self.attributes.as_ref().unwrap_or_else(|| <FirewallPolicyAttribute as ::protobuf::Message>::default_instance())
    }
    pub fn clear_attributes(&mut self) {
        self.attributes.clear();
    }

    pub fn has_attributes(&self) -> bool {
        self.attributes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attributes(&mut self, v: FirewallPolicyAttribute) {
        self.attributes = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_attributes(&mut self) -> &mut FirewallPolicyAttribute {
        if self.attributes.is_none() {
            self.attributes.set_default();
        }
        self.attributes.as_mut().unwrap()
    }

    // Take field
    pub fn take_attributes(&mut self) -> FirewallPolicyAttribute {
        self.attributes.take().unwrap_or_else(|| FirewallPolicyAttribute::new())
    }
}

impl ::protobuf::Message for FirewallRuleReference {
    fn is_initialized(&self) -> bool {
        for v in &self.resourceReference {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.attributes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.resourceReference)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.attributes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.resourceReference.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.attributes.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.resourceReference.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.attributes.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FirewallRuleReference {
        FirewallRuleReference::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResourceReference>>(
                "resourceReference",
                |m: &FirewallRuleReference| { &m.resourceReference },
                |m: &mut FirewallRuleReference| { &mut m.resourceReference },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FirewallPolicyAttribute>>(
                "attributes",
                |m: &FirewallRuleReference| { &m.attributes },
                |m: &mut FirewallRuleReference| { &mut m.attributes },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FirewallRuleReference>(
                "FirewallRuleReference",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FirewallRuleReference {
        static instance: ::protobuf::rt::LazyV2<FirewallRuleReference> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FirewallRuleReference::new)
    }
}

impl ::protobuf::Clear for FirewallRuleReference {
    fn clear(&mut self) {
        self.resourceReference.clear();
        self.attributes.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FirewallRuleReference {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FirewallRuleReference {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FirewallRuleSpec {
    // message fields
    pub commonSpec: ::protobuf::SingularPtrField<CommonSpec>,
    pub addressGroupReference: ::protobuf::SingularPtrField<ResourceReference>,
    pub actionList: ::protobuf::SingularPtrField<FirewallActionListType>,
    pub service: ::protobuf::SingularPtrField<FirewallServiceType>,
    pub Endpoint1: ::protobuf::SingularPtrField<FirewallRuleEndpointType>,
    pub Endpoint2: ::protobuf::SingularPtrField<FirewallRuleEndpointType>,
    pub matchTags: ::protobuf::RepeatedField<::std::string::String>,
    pub matchTagsTypes: ::std::vec::Vec<i64>,
    direction: ::protobuf::SingularField<::std::string::String>,
    pub tagReferences: ::protobuf::RepeatedField<ResourceReference>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FirewallRuleSpec {
    fn default() -> &'a FirewallRuleSpec {
        <FirewallRuleSpec as ::protobuf::Message>::default_instance()
    }
}

impl FirewallRuleSpec {
    pub fn new() -> FirewallRuleSpec {
        ::std::default::Default::default()
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonSpec commonSpec = 1;


    pub fn get_commonSpec(&self) -> &CommonSpec {
        self.commonSpec.as_ref().unwrap_or_else(|| <CommonSpec as ::protobuf::Message>::default_instance())
    }
    pub fn clear_commonSpec(&mut self) {
        self.commonSpec.clear();
    }

    pub fn has_commonSpec(&self) -> bool {
        self.commonSpec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_commonSpec(&mut self, v: CommonSpec) {
        self.commonSpec = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_commonSpec(&mut self) -> &mut CommonSpec {
        if self.commonSpec.is_none() {
            self.commonSpec.set_default();
        }
        self.commonSpec.as_mut().unwrap()
    }

    // Take field
    pub fn take_commonSpec(&mut self) -> CommonSpec {
        self.commonSpec.take().unwrap_or_else(|| CommonSpec::new())
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ResourceReference addressGroupReference = 2;


    pub fn get_addressGroupReference(&self) -> &ResourceReference {
        self.addressGroupReference.as_ref().unwrap_or_else(|| <ResourceReference as ::protobuf::Message>::default_instance())
    }
    pub fn clear_addressGroupReference(&mut self) {
        self.addressGroupReference.clear();
    }

    pub fn has_addressGroupReference(&self) -> bool {
        self.addressGroupReference.is_some()
    }

    // Param is passed by value, moved
    pub fn set_addressGroupReference(&mut self, v: ResourceReference) {
        self.addressGroupReference = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_addressGroupReference(&mut self) -> &mut ResourceReference {
        if self.addressGroupReference.is_none() {
            self.addressGroupReference.set_default();
        }
        self.addressGroupReference.as_mut().unwrap()
    }

    // Take field
    pub fn take_addressGroupReference(&mut self) -> ResourceReference {
        self.addressGroupReference.take().unwrap_or_else(|| ResourceReference::new())
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallActionListType actionList = 3;


    pub fn get_actionList(&self) -> &FirewallActionListType {
        self.actionList.as_ref().unwrap_or_else(|| <FirewallActionListType as ::protobuf::Message>::default_instance())
    }
    pub fn clear_actionList(&mut self) {
        self.actionList.clear();
    }

    pub fn has_actionList(&self) -> bool {
        self.actionList.is_some()
    }

    // Param is passed by value, moved
    pub fn set_actionList(&mut self, v: FirewallActionListType) {
        self.actionList = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_actionList(&mut self) -> &mut FirewallActionListType {
        if self.actionList.is_none() {
            self.actionList.set_default();
        }
        self.actionList.as_mut().unwrap()
    }

    // Take field
    pub fn take_actionList(&mut self) -> FirewallActionListType {
        self.actionList.take().unwrap_or_else(|| FirewallActionListType::new())
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallServiceType service = 4;


    pub fn get_service(&self) -> &FirewallServiceType {
        self.service.as_ref().unwrap_or_else(|| <FirewallServiceType as ::protobuf::Message>::default_instance())
    }
    pub fn clear_service(&mut self) {
        self.service.clear();
    }

    pub fn has_service(&self) -> bool {
        self.service.is_some()
    }

    // Param is passed by value, moved
    pub fn set_service(&mut self, v: FirewallServiceType) {
        self.service = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_service(&mut self) -> &mut FirewallServiceType {
        if self.service.is_none() {
            self.service.set_default();
        }
        self.service.as_mut().unwrap()
    }

    // Take field
    pub fn take_service(&mut self) -> FirewallServiceType {
        self.service.take().unwrap_or_else(|| FirewallServiceType::new())
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleEndpointType Endpoint1 = 5;


    pub fn get_Endpoint1(&self) -> &FirewallRuleEndpointType {
        self.Endpoint1.as_ref().unwrap_or_else(|| <FirewallRuleEndpointType as ::protobuf::Message>::default_instance())
    }
    pub fn clear_Endpoint1(&mut self) {
        self.Endpoint1.clear();
    }

    pub fn has_Endpoint1(&self) -> bool {
        self.Endpoint1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Endpoint1(&mut self, v: FirewallRuleEndpointType) {
        self.Endpoint1 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Endpoint1(&mut self) -> &mut FirewallRuleEndpointType {
        if self.Endpoint1.is_none() {
            self.Endpoint1.set_default();
        }
        self.Endpoint1.as_mut().unwrap()
    }

    // Take field
    pub fn take_Endpoint1(&mut self) -> FirewallRuleEndpointType {
        self.Endpoint1.take().unwrap_or_else(|| FirewallRuleEndpointType::new())
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallRuleEndpointType Endpoint2 = 6;


    pub fn get_Endpoint2(&self) -> &FirewallRuleEndpointType {
        self.Endpoint2.as_ref().unwrap_or_else(|| <FirewallRuleEndpointType as ::protobuf::Message>::default_instance())
    }
    pub fn clear_Endpoint2(&mut self) {
        self.Endpoint2.clear();
    }

    pub fn has_Endpoint2(&self) -> bool {
        self.Endpoint2.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Endpoint2(&mut self, v: FirewallRuleEndpointType) {
        self.Endpoint2 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Endpoint2(&mut self) -> &mut FirewallRuleEndpointType {
        if self.Endpoint2.is_none() {
            self.Endpoint2.set_default();
        }
        self.Endpoint2.as_mut().unwrap()
    }

    // Take field
    pub fn take_Endpoint2(&mut self) -> FirewallRuleEndpointType {
        self.Endpoint2.take().unwrap_or_else(|| FirewallRuleEndpointType::new())
    }

    // repeated string matchTags = 7;


    pub fn get_matchTags(&self) -> &[::std::string::String] {
        &self.matchTags
    }
    pub fn clear_matchTags(&mut self) {
        self.matchTags.clear();
    }

    // Param is passed by value, moved
    pub fn set_matchTags(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.matchTags = v;
    }

    // Mutable pointer to the field.
    pub fn mut_matchTags(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.matchTags
    }

    // Take field
    pub fn take_matchTags(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.matchTags, ::protobuf::RepeatedField::new())
    }

    // repeated int64 matchTagsTypes = 8;


    pub fn get_matchTagsTypes(&self) -> &[i64] {
        &self.matchTagsTypes
    }
    pub fn clear_matchTagsTypes(&mut self) {
        self.matchTagsTypes.clear();
    }

    // Param is passed by value, moved
    pub fn set_matchTagsTypes(&mut self, v: ::std::vec::Vec<i64>) {
        self.matchTagsTypes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_matchTagsTypes(&mut self) -> &mut ::std::vec::Vec<i64> {
        &mut self.matchTagsTypes
    }

    // Take field
    pub fn take_matchTagsTypes(&mut self) -> ::std::vec::Vec<i64> {
        ::std::mem::replace(&mut self.matchTagsTypes, ::std::vec::Vec::new())
    }

    // optional string direction = 9;


    pub fn get_direction(&self) -> &str {
        match self.direction.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_direction(&mut self) {
        self.direction.clear();
    }

    pub fn has_direction(&self) -> bool {
        self.direction.is_some()
    }

    // Param is passed by value, moved
    pub fn set_direction(&mut self, v: ::std::string::String) {
        self.direction = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_direction(&mut self) -> &mut ::std::string::String {
        if self.direction.is_none() {
            self.direction.set_default();
        }
        self.direction.as_mut().unwrap()
    }

    // Take field
    pub fn take_direction(&mut self) -> ::std::string::String {
        self.direction.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ResourceReference tagReferences = 10;


    pub fn get_tagReferences(&self) -> &[ResourceReference] {
        &self.tagReferences
    }
    pub fn clear_tagReferences(&mut self) {
        self.tagReferences.clear();
    }

    // Param is passed by value, moved
    pub fn set_tagReferences(&mut self, v: ::protobuf::RepeatedField<ResourceReference>) {
        self.tagReferences = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tagReferences(&mut self) -> &mut ::protobuf::RepeatedField<ResourceReference> {
        &mut self.tagReferences
    }

    // Take field
    pub fn take_tagReferences(&mut self) -> ::protobuf::RepeatedField<ResourceReference> {
        ::std::mem::replace(&mut self.tagReferences, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for FirewallRuleSpec {
    fn is_initialized(&self) -> bool {
        for v in &self.commonSpec {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.addressGroupReference {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.actionList {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.service {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.Endpoint1 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.Endpoint2 {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tagReferences {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.commonSpec)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.addressGroupReference)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.actionList)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.service)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.Endpoint1)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.Endpoint2)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.matchTags)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_int64_into(wire_type, is, &mut self.matchTagsTypes)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.direction)?;
                },
                10 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.tagReferences)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.commonSpec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.addressGroupReference.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.actionList.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.service.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.Endpoint1.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.Endpoint2.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.matchTags {
            my_size += ::protobuf::rt::string_size(7, &value);
        };
        for value in &self.matchTagsTypes {
            my_size += ::protobuf::rt::value_size(8, *value, ::protobuf::wire_format::WireTypeVarint);
        };
        if let Some(ref v) = self.direction.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        for value in &self.tagReferences {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.commonSpec.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.addressGroupReference.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.actionList.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.service.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.Endpoint1.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.Endpoint2.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.matchTags {
            os.write_string(7, &v)?;
        };
        for v in &self.matchTagsTypes {
            os.write_int64(8, *v)?;
        };
        if let Some(ref v) = self.direction.as_ref() {
            os.write_string(9, &v)?;
        }
        for v in &self.tagReferences {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FirewallRuleSpec {
        FirewallRuleSpec::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommonSpec>>(
                "commonSpec",
                |m: &FirewallRuleSpec| { &m.commonSpec },
                |m: &mut FirewallRuleSpec| { &mut m.commonSpec },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResourceReference>>(
                "addressGroupReference",
                |m: &FirewallRuleSpec| { &m.addressGroupReference },
                |m: &mut FirewallRuleSpec| { &mut m.addressGroupReference },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FirewallActionListType>>(
                "actionList",
                |m: &FirewallRuleSpec| { &m.actionList },
                |m: &mut FirewallRuleSpec| { &mut m.actionList },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FirewallServiceType>>(
                "service",
                |m: &FirewallRuleSpec| { &m.service },
                |m: &mut FirewallRuleSpec| { &mut m.service },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FirewallRuleEndpointType>>(
                "Endpoint1",
                |m: &FirewallRuleSpec| { &m.Endpoint1 },
                |m: &mut FirewallRuleSpec| { &mut m.Endpoint1 },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FirewallRuleEndpointType>>(
                "Endpoint2",
                |m: &FirewallRuleSpec| { &m.Endpoint2 },
                |m: &mut FirewallRuleSpec| { &mut m.Endpoint2 },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "matchTags",
                |m: &FirewallRuleSpec| { &m.matchTags },
                |m: &mut FirewallRuleSpec| { &mut m.matchTags },
            ));
            fields.push(::protobuf::reflect::accessor::make_vec_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "matchTagsTypes",
                |m: &FirewallRuleSpec| { &m.matchTagsTypes },
                |m: &mut FirewallRuleSpec| { &mut m.matchTagsTypes },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "direction",
                |m: &FirewallRuleSpec| { &m.direction },
                |m: &mut FirewallRuleSpec| { &mut m.direction },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResourceReference>>(
                "tagReferences",
                |m: &FirewallRuleSpec| { &m.tagReferences },
                |m: &mut FirewallRuleSpec| { &mut m.tagReferences },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FirewallRuleSpec>(
                "FirewallRuleSpec",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FirewallRuleSpec {
        static instance: ::protobuf::rt::LazyV2<FirewallRuleSpec> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FirewallRuleSpec::new)
    }
}

impl ::protobuf::Clear for FirewallRuleSpec {
    fn clear(&mut self) {
        self.commonSpec.clear();
        self.addressGroupReference.clear();
        self.actionList.clear();
        self.service.clear();
        self.Endpoint1.clear();
        self.Endpoint2.clear();
        self.matchTags.clear();
        self.matchTagsTypes.clear();
        self.direction.clear();
        self.tagReferences.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FirewallRuleSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FirewallRuleSpec {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FirewallRuleStatus {
    // message fields
    pub commonStatus: ::protobuf::SingularPtrField<CommonStatus>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FirewallRuleStatus {
    fn default() -> &'a FirewallRuleStatus {
        <FirewallRuleStatus as ::protobuf::Message>::default_instance()
    }
}

impl FirewallRuleStatus {
    pub fn new() -> FirewallRuleStatus {
        ::std::default::Default::default()
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonStatus commonStatus = 1;


    pub fn get_commonStatus(&self) -> &CommonStatus {
        self.commonStatus.as_ref().unwrap_or_else(|| <CommonStatus as ::protobuf::Message>::default_instance())
    }
    pub fn clear_commonStatus(&mut self) {
        self.commonStatus.clear();
    }

    pub fn has_commonStatus(&self) -> bool {
        self.commonStatus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_commonStatus(&mut self, v: CommonStatus) {
        self.commonStatus = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_commonStatus(&mut self) -> &mut CommonStatus {
        if self.commonStatus.is_none() {
            self.commonStatus.set_default();
        }
        self.commonStatus.as_mut().unwrap()
    }

    // Take field
    pub fn take_commonStatus(&mut self) -> CommonStatus {
        self.commonStatus.take().unwrap_or_else(|| CommonStatus::new())
    }
}

impl ::protobuf::Message for FirewallRuleStatus {
    fn is_initialized(&self) -> bool {
        for v in &self.commonStatus {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.commonStatus)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.commonStatus.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.commonStatus.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FirewallRuleStatus {
        FirewallRuleStatus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommonStatus>>(
                "commonStatus",
                |m: &FirewallRuleStatus| { &m.commonStatus },
                |m: &mut FirewallRuleStatus| { &mut m.commonStatus },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FirewallRuleStatus>(
                "FirewallRuleStatus",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FirewallRuleStatus {
        static instance: ::protobuf::rt::LazyV2<FirewallRuleStatus> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FirewallRuleStatus::new)
    }
}

impl ::protobuf::Clear for FirewallRuleStatus {
    fn clear(&mut self) {
        self.commonStatus.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FirewallRuleStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FirewallRuleStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FirewallServiceType {
    // message fields
    protocol: ::protobuf::SingularField<::std::string::String>,
    protocolId: ::std::option::Option<i64>,
    pub sourcePorts: ::protobuf::SingularPtrField<PortType>,
    pub destinationPorts: ::protobuf::SingularPtrField<PortType>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FirewallServiceType {
    fn default() -> &'a FirewallServiceType {
        <FirewallServiceType as ::protobuf::Message>::default_instance()
    }
}

impl FirewallServiceType {
    pub fn new() -> FirewallServiceType {
        ::std::default::Default::default()
    }

    // optional string protocol = 1;


    pub fn get_protocol(&self) -> &str {
        match self.protocol.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_protocol(&mut self) {
        self.protocol.clear();
    }

    pub fn has_protocol(&self) -> bool {
        self.protocol.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protocol(&mut self, v: ::std::string::String) {
        self.protocol = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_protocol(&mut self) -> &mut ::std::string::String {
        if self.protocol.is_none() {
            self.protocol.set_default();
        }
        self.protocol.as_mut().unwrap()
    }

    // Take field
    pub fn take_protocol(&mut self) -> ::std::string::String {
        self.protocol.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int64 protocolId = 2;


    pub fn get_protocolId(&self) -> i64 {
        self.protocolId.unwrap_or(0)
    }
    pub fn clear_protocolId(&mut self) {
        self.protocolId = ::std::option::Option::None;
    }

    pub fn has_protocolId(&self) -> bool {
        self.protocolId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protocolId(&mut self, v: i64) {
        self.protocolId = ::std::option::Option::Some(v);
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.PortType sourcePorts = 3;


    pub fn get_sourcePorts(&self) -> &PortType {
        self.sourcePorts.as_ref().unwrap_or_else(|| <PortType as ::protobuf::Message>::default_instance())
    }
    pub fn clear_sourcePorts(&mut self) {
        self.sourcePorts.clear();
    }

    pub fn has_sourcePorts(&self) -> bool {
        self.sourcePorts.is_some()
    }

    // Param is passed by value, moved
    pub fn set_sourcePorts(&mut self, v: PortType) {
        self.sourcePorts = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sourcePorts(&mut self) -> &mut PortType {
        if self.sourcePorts.is_none() {
            self.sourcePorts.set_default();
        }
        self.sourcePorts.as_mut().unwrap()
    }

    // Take field
    pub fn take_sourcePorts(&mut self) -> PortType {
        self.sourcePorts.take().unwrap_or_else(|| PortType::new())
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.PortType destinationPorts = 4;


    pub fn get_destinationPorts(&self) -> &PortType {
        self.destinationPorts.as_ref().unwrap_or_else(|| <PortType as ::protobuf::Message>::default_instance())
    }
    pub fn clear_destinationPorts(&mut self) {
        self.destinationPorts.clear();
    }

    pub fn has_destinationPorts(&self) -> bool {
        self.destinationPorts.is_some()
    }

    // Param is passed by value, moved
    pub fn set_destinationPorts(&mut self, v: PortType) {
        self.destinationPorts = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_destinationPorts(&mut self) -> &mut PortType {
        if self.destinationPorts.is_none() {
            self.destinationPorts.set_default();
        }
        self.destinationPorts.as_mut().unwrap()
    }

    // Take field
    pub fn take_destinationPorts(&mut self) -> PortType {
        self.destinationPorts.take().unwrap_or_else(|| PortType::new())
    }
}

impl ::protobuf::Message for FirewallServiceType {
    fn is_initialized(&self) -> bool {
        for v in &self.sourcePorts {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.destinationPorts {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.protocol)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.protocolId = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.sourcePorts)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.destinationPorts)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.protocol.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(v) = self.protocolId {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.sourcePorts.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.destinationPorts.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.protocol.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(v) = self.protocolId {
            os.write_int64(2, v)?;
        }
        if let Some(ref v) = self.sourcePorts.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.destinationPorts.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FirewallServiceType {
        FirewallServiceType::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "protocol",
                |m: &FirewallServiceType| { &m.protocol },
                |m: &mut FirewallServiceType| { &mut m.protocol },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "protocolId",
                |m: &FirewallServiceType| { &m.protocolId },
                |m: &mut FirewallServiceType| { &mut m.protocolId },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PortType>>(
                "sourcePorts",
                |m: &FirewallServiceType| { &m.sourcePorts },
                |m: &mut FirewallServiceType| { &mut m.sourcePorts },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PortType>>(
                "destinationPorts",
                |m: &FirewallServiceType| { &m.destinationPorts },
                |m: &mut FirewallServiceType| { &mut m.destinationPorts },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FirewallServiceType>(
                "FirewallServiceType",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FirewallServiceType {
        static instance: ::protobuf::rt::LazyV2<FirewallServiceType> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FirewallServiceType::new)
    }
}

impl ::protobuf::Clear for FirewallServiceType {
    fn clear(&mut self) {
        self.protocol.clear();
        self.protocolId = ::std::option::Option::None;
        self.sourcePorts.clear();
        self.destinationPorts.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FirewallServiceType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FirewallServiceType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FirewallSubnet {
    // message fields
    ipPrefix: ::protobuf::SingularField<::std::string::String>,
    pub ipPrefixLen: ::protobuf::SingularPtrField<super::generated::IntOrString>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FirewallSubnet {
    fn default() -> &'a FirewallSubnet {
        <FirewallSubnet as ::protobuf::Message>::default_instance()
    }
}

impl FirewallSubnet {
    pub fn new() -> FirewallSubnet {
        ::std::default::Default::default()
    }

    // optional string ipPrefix = 1;


    pub fn get_ipPrefix(&self) -> &str {
        match self.ipPrefix.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_ipPrefix(&mut self) {
        self.ipPrefix.clear();
    }

    pub fn has_ipPrefix(&self) -> bool {
        self.ipPrefix.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ipPrefix(&mut self, v: ::std::string::String) {
        self.ipPrefix = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ipPrefix(&mut self) -> &mut ::std::string::String {
        if self.ipPrefix.is_none() {
            self.ipPrefix.set_default();
        }
        self.ipPrefix.as_mut().unwrap()
    }

    // Take field
    pub fn take_ipPrefix(&mut self) -> ::std::string::String {
        self.ipPrefix.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .k8s.io.apimachinery.pkg.util.intstr.IntOrString ipPrefixLen = 2;


    pub fn get_ipPrefixLen(&self) -> &super::generated::IntOrString {
        self.ipPrefixLen.as_ref().unwrap_or_else(|| <super::generated::IntOrString as ::protobuf::Message>::default_instance())
    }
    pub fn clear_ipPrefixLen(&mut self) {
        self.ipPrefixLen.clear();
    }

    pub fn has_ipPrefixLen(&self) -> bool {
        self.ipPrefixLen.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ipPrefixLen(&mut self, v: super::generated::IntOrString) {
        self.ipPrefixLen = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ipPrefixLen(&mut self) -> &mut super::generated::IntOrString {
        if self.ipPrefixLen.is_none() {
            self.ipPrefixLen.set_default();
        }
        self.ipPrefixLen.as_mut().unwrap()
    }

    // Take field
    pub fn take_ipPrefixLen(&mut self) -> super::generated::IntOrString {
        self.ipPrefixLen.take().unwrap_or_else(|| super::generated::IntOrString::new())
    }
}

impl ::protobuf::Message for FirewallSubnet {
    fn is_initialized(&self) -> bool {
        for v in &self.ipPrefixLen {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.ipPrefix)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.ipPrefixLen)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.ipPrefix.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.ipPrefixLen.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.ipPrefix.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.ipPrefixLen.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FirewallSubnet {
        FirewallSubnet::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "ipPrefix",
                |m: &FirewallSubnet| { &m.ipPrefix },
                |m: &mut FirewallSubnet| { &mut m.ipPrefix },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::generated::IntOrString>>(
                "ipPrefixLen",
                |m: &FirewallSubnet| { &m.ipPrefixLen },
                |m: &mut FirewallSubnet| { &mut m.ipPrefixLen },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FirewallSubnet>(
                "FirewallSubnet",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FirewallSubnet {
        static instance: ::protobuf::rt::LazyV2<FirewallSubnet> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FirewallSubnet::new)
    }
}

impl ::protobuf::Clear for FirewallSubnet {
    fn clear(&mut self) {
        self.ipPrefix.clear();
        self.ipPrefixLen.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FirewallSubnet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FirewallSubnet {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FloatingIP {
    // message fields
    pub metadata: ::protobuf::SingularPtrField<super::meta::ObjectMeta>,
    pub spec: ::protobuf::SingularPtrField<FloatingIPSpec>,
    pub status: ::protobuf::SingularPtrField<FloatingIPStatus>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FloatingIP {
    fn default() -> &'a FloatingIP {
        <FloatingIP as ::protobuf::Message>::default_instance()
    }
}

impl FloatingIP {
    pub fn new() -> FloatingIP {
        ::std::default::Default::default()
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;


    pub fn get_metadata(&self) -> &super::meta::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <super::meta::ObjectMeta as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::meta::ObjectMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::meta::ObjectMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::meta::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| super::meta::ObjectMeta::new())
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FloatingIPSpec spec = 2;


    pub fn get_spec(&self) -> &FloatingIPSpec {
        self.spec.as_ref().unwrap_or_else(|| <FloatingIPSpec as ::protobuf::Message>::default_instance())
    }
    pub fn clear_spec(&mut self) {
        self.spec.clear();
    }

    pub fn has_spec(&self) -> bool {
        self.spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spec(&mut self, v: FloatingIPSpec) {
        self.spec = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spec(&mut self) -> &mut FloatingIPSpec {
        if self.spec.is_none() {
            self.spec.set_default();
        }
        self.spec.as_mut().unwrap()
    }

    // Take field
    pub fn take_spec(&mut self) -> FloatingIPSpec {
        self.spec.take().unwrap_or_else(|| FloatingIPSpec::new())
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FloatingIPStatus status = 3;


    pub fn get_status(&self) -> &FloatingIPStatus {
        self.status.as_ref().unwrap_or_else(|| <FloatingIPStatus as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: FloatingIPStatus) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut FloatingIPStatus {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> FloatingIPStatus {
        self.status.take().unwrap_or_else(|| FloatingIPStatus::new())
    }
}

impl ::protobuf::Message for FloatingIP {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.spec {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.spec)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.spec.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FloatingIP {
        FloatingIP::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::meta::ObjectMeta>>(
                "metadata",
                |m: &FloatingIP| { &m.metadata },
                |m: &mut FloatingIP| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FloatingIPSpec>>(
                "spec",
                |m: &FloatingIP| { &m.spec },
                |m: &mut FloatingIP| { &mut m.spec },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FloatingIPStatus>>(
                "status",
                |m: &FloatingIP| { &m.status },
                |m: &mut FloatingIP| { &mut m.status },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FloatingIP>(
                "FloatingIP",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FloatingIP {
        static instance: ::protobuf::rt::LazyV2<FloatingIP> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FloatingIP::new)
    }
}

impl ::protobuf::Clear for FloatingIP {
    fn clear(&mut self) {
        self.metadata.clear();
        self.spec.clear();
        self.status.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FloatingIP {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FloatingIP {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FloatingIPList {
    // message fields
    pub metadata: ::protobuf::SingularPtrField<super::meta::ListMeta>,
    pub items: ::protobuf::RepeatedField<FloatingIP>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FloatingIPList {
    fn default() -> &'a FloatingIPList {
        <FloatingIPList as ::protobuf::Message>::default_instance()
    }
}

impl FloatingIPList {
    pub fn new() -> FloatingIPList {
        ::std::default::Default::default()
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;


    pub fn get_metadata(&self) -> &super::meta::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <super::meta::ListMeta as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::meta::ListMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::meta::ListMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::meta::ListMeta {
        self.metadata.take().unwrap_or_else(|| super::meta::ListMeta::new())
    }

    // repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FloatingIP items = 2;


    pub fn get_items(&self) -> &[FloatingIP] {
        &self.items
    }
    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::protobuf::RepeatedField<FloatingIP>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::protobuf::RepeatedField<FloatingIP> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::protobuf::RepeatedField<FloatingIP> {
        ::std::mem::replace(&mut self.items, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for FloatingIPList {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.items {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.items)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.items {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FloatingIPList {
        FloatingIPList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::meta::ListMeta>>(
                "metadata",
                |m: &FloatingIPList| { &m.metadata },
                |m: &mut FloatingIPList| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FloatingIP>>(
                "items",
                |m: &FloatingIPList| { &m.items },
                |m: &mut FloatingIPList| { &mut m.items },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FloatingIPList>(
                "FloatingIPList",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FloatingIPList {
        static instance: ::protobuf::rt::LazyV2<FloatingIPList> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FloatingIPList::new)
    }
}

impl ::protobuf::Clear for FloatingIPList {
    fn clear(&mut self) {
        self.metadata.clear();
        self.items.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FloatingIPList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FloatingIPList {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FloatingIPPortMappings {
    // message fields
    pub portMappings: ::protobuf::RepeatedField<FloatingIPPortPortMapping>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FloatingIPPortMappings {
    fn default() -> &'a FloatingIPPortMappings {
        <FloatingIPPortMappings as ::protobuf::Message>::default_instance()
    }
}

impl FloatingIPPortMappings {
    pub fn new() -> FloatingIPPortMappings {
        ::std::default::Default::default()
    }

    // repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FloatingIPPortPortMapping portMappings = 1;


    pub fn get_portMappings(&self) -> &[FloatingIPPortPortMapping] {
        &self.portMappings
    }
    pub fn clear_portMappings(&mut self) {
        self.portMappings.clear();
    }

    // Param is passed by value, moved
    pub fn set_portMappings(&mut self, v: ::protobuf::RepeatedField<FloatingIPPortPortMapping>) {
        self.portMappings = v;
    }

    // Mutable pointer to the field.
    pub fn mut_portMappings(&mut self) -> &mut ::protobuf::RepeatedField<FloatingIPPortPortMapping> {
        &mut self.portMappings
    }

    // Take field
    pub fn take_portMappings(&mut self) -> ::protobuf::RepeatedField<FloatingIPPortPortMapping> {
        ::std::mem::replace(&mut self.portMappings, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for FloatingIPPortMappings {
    fn is_initialized(&self) -> bool {
        for v in &self.portMappings {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.portMappings)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.portMappings {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.portMappings {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FloatingIPPortMappings {
        FloatingIPPortMappings::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FloatingIPPortPortMapping>>(
                "portMappings",
                |m: &FloatingIPPortMappings| { &m.portMappings },
                |m: &mut FloatingIPPortMappings| { &mut m.portMappings },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FloatingIPPortMappings>(
                "FloatingIPPortMappings",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FloatingIPPortMappings {
        static instance: ::protobuf::rt::LazyV2<FloatingIPPortMappings> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FloatingIPPortMappings::new)
    }
}

impl ::protobuf::Clear for FloatingIPPortMappings {
    fn clear(&mut self) {
        self.portMappings.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FloatingIPPortMappings {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FloatingIPPortMappings {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FloatingIPPortPortMapping {
    // message fields
    srcPort: ::std::option::Option<i32>,
    dstPort: ::std::option::Option<i32>,
    protocol: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FloatingIPPortPortMapping {
    fn default() -> &'a FloatingIPPortPortMapping {
        <FloatingIPPortPortMapping as ::protobuf::Message>::default_instance()
    }
}

impl FloatingIPPortPortMapping {
    pub fn new() -> FloatingIPPortPortMapping {
        ::std::default::Default::default()
    }

    // optional int32 srcPort = 1;


    pub fn get_srcPort(&self) -> i32 {
        self.srcPort.unwrap_or(0)
    }
    pub fn clear_srcPort(&mut self) {
        self.srcPort = ::std::option::Option::None;
    }

    pub fn has_srcPort(&self) -> bool {
        self.srcPort.is_some()
    }

    // Param is passed by value, moved
    pub fn set_srcPort(&mut self, v: i32) {
        self.srcPort = ::std::option::Option::Some(v);
    }

    // optional int32 dstPort = 2;


    pub fn get_dstPort(&self) -> i32 {
        self.dstPort.unwrap_or(0)
    }
    pub fn clear_dstPort(&mut self) {
        self.dstPort = ::std::option::Option::None;
    }

    pub fn has_dstPort(&self) -> bool {
        self.dstPort.is_some()
    }

    // Param is passed by value, moved
    pub fn set_dstPort(&mut self, v: i32) {
        self.dstPort = ::std::option::Option::Some(v);
    }

    // optional string protocol = 3;


    pub fn get_protocol(&self) -> &str {
        match self.protocol.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_protocol(&mut self) {
        self.protocol.clear();
    }

    pub fn has_protocol(&self) -> bool {
        self.protocol.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protocol(&mut self, v: ::std::string::String) {
        self.protocol = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_protocol(&mut self) -> &mut ::std::string::String {
        if self.protocol.is_none() {
            self.protocol.set_default();
        }
        self.protocol.as_mut().unwrap()
    }

    // Take field
    pub fn take_protocol(&mut self) -> ::std::string::String {
        self.protocol.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for FloatingIPPortPortMapping {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.srcPort = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.dstPort = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.protocol)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.srcPort {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.dstPort {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.protocol.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.srcPort {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.dstPort {
            os.write_int32(2, v)?;
        }
        if let Some(ref v) = self.protocol.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FloatingIPPortPortMapping {
        FloatingIPPortPortMapping::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "srcPort",
                |m: &FloatingIPPortPortMapping| { &m.srcPort },
                |m: &mut FloatingIPPortPortMapping| { &mut m.srcPort },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "dstPort",
                |m: &FloatingIPPortPortMapping| { &m.dstPort },
                |m: &mut FloatingIPPortPortMapping| { &mut m.dstPort },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "protocol",
                |m: &FloatingIPPortPortMapping| { &m.protocol },
                |m: &mut FloatingIPPortPortMapping| { &mut m.protocol },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FloatingIPPortPortMapping>(
                "FloatingIPPortPortMapping",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FloatingIPPortPortMapping {
        static instance: ::protobuf::rt::LazyV2<FloatingIPPortPortMapping> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FloatingIPPortPortMapping::new)
    }
}

impl ::protobuf::Clear for FloatingIPPortPortMapping {
    fn clear(&mut self) {
        self.srcPort = ::std::option::Option::None;
        self.dstPort = ::std::option::Option::None;
        self.protocol.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FloatingIPPortPortMapping {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FloatingIPPortPortMapping {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FloatingIPSpec {
    // message fields
    pub commonSpec: ::protobuf::SingularPtrField<CommonSpec>,
    floatingIPAddress: ::protobuf::SingularField<::std::string::String>,
    pub floatingIPPortMappings: ::protobuf::SingularPtrField<FloatingIPPortMappings>,
    floatingIPTrafficDirection: ::protobuf::SingularField<::std::string::String>,
    pub parent: ::protobuf::SingularPtrField<super::generated::ObjectReference>,
    pub virtualMachineInterfaceReferences: ::protobuf::RepeatedField<ResourceReference>,
    floatingIPPortMappingsEnable: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FloatingIPSpec {
    fn default() -> &'a FloatingIPSpec {
        <FloatingIPSpec as ::protobuf::Message>::default_instance()
    }
}

impl FloatingIPSpec {
    pub fn new() -> FloatingIPSpec {
        ::std::default::Default::default()
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonSpec commonSpec = 1;


    pub fn get_commonSpec(&self) -> &CommonSpec {
        self.commonSpec.as_ref().unwrap_or_else(|| <CommonSpec as ::protobuf::Message>::default_instance())
    }
    pub fn clear_commonSpec(&mut self) {
        self.commonSpec.clear();
    }

    pub fn has_commonSpec(&self) -> bool {
        self.commonSpec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_commonSpec(&mut self, v: CommonSpec) {
        self.commonSpec = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_commonSpec(&mut self) -> &mut CommonSpec {
        if self.commonSpec.is_none() {
            self.commonSpec.set_default();
        }
        self.commonSpec.as_mut().unwrap()
    }

    // Take field
    pub fn take_commonSpec(&mut self) -> CommonSpec {
        self.commonSpec.take().unwrap_or_else(|| CommonSpec::new())
    }

    // optional string floatingIPAddress = 2;


    pub fn get_floatingIPAddress(&self) -> &str {
        match self.floatingIPAddress.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_floatingIPAddress(&mut self) {
        self.floatingIPAddress.clear();
    }

    pub fn has_floatingIPAddress(&self) -> bool {
        self.floatingIPAddress.is_some()
    }

    // Param is passed by value, moved
    pub fn set_floatingIPAddress(&mut self, v: ::std::string::String) {
        self.floatingIPAddress = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_floatingIPAddress(&mut self) -> &mut ::std::string::String {
        if self.floatingIPAddress.is_none() {
            self.floatingIPAddress.set_default();
        }
        self.floatingIPAddress.as_mut().unwrap()
    }

    // Take field
    pub fn take_floatingIPAddress(&mut self) -> ::std::string::String {
        self.floatingIPAddress.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FloatingIPPortMappings floatingIPPortMappings = 3;


    pub fn get_floatingIPPortMappings(&self) -> &FloatingIPPortMappings {
        self.floatingIPPortMappings.as_ref().unwrap_or_else(|| <FloatingIPPortMappings as ::protobuf::Message>::default_instance())
    }
    pub fn clear_floatingIPPortMappings(&mut self) {
        self.floatingIPPortMappings.clear();
    }

    pub fn has_floatingIPPortMappings(&self) -> bool {
        self.floatingIPPortMappings.is_some()
    }

    // Param is passed by value, moved
    pub fn set_floatingIPPortMappings(&mut self, v: FloatingIPPortMappings) {
        self.floatingIPPortMappings = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_floatingIPPortMappings(&mut self) -> &mut FloatingIPPortMappings {
        if self.floatingIPPortMappings.is_none() {
            self.floatingIPPortMappings.set_default();
        }
        self.floatingIPPortMappings.as_mut().unwrap()
    }

    // Take field
    pub fn take_floatingIPPortMappings(&mut self) -> FloatingIPPortMappings {
        self.floatingIPPortMappings.take().unwrap_or_else(|| FloatingIPPortMappings::new())
    }

    // optional string floatingIPTrafficDirection = 4;


    pub fn get_floatingIPTrafficDirection(&self) -> &str {
        match self.floatingIPTrafficDirection.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_floatingIPTrafficDirection(&mut self) {
        self.floatingIPTrafficDirection.clear();
    }

    pub fn has_floatingIPTrafficDirection(&self) -> bool {
        self.floatingIPTrafficDirection.is_some()
    }

    // Param is passed by value, moved
    pub fn set_floatingIPTrafficDirection(&mut self, v: ::std::string::String) {
        self.floatingIPTrafficDirection = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_floatingIPTrafficDirection(&mut self) -> &mut ::std::string::String {
        if self.floatingIPTrafficDirection.is_none() {
            self.floatingIPTrafficDirection.set_default();
        }
        self.floatingIPTrafficDirection.as_mut().unwrap()
    }

    // Take field
    pub fn take_floatingIPTrafficDirection(&mut self) -> ::std::string::String {
        self.floatingIPTrafficDirection.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .k8s.io.api.core.v1.ObjectReference parent = 5;


    pub fn get_parent(&self) -> &super::generated::ObjectReference {
        self.parent.as_ref().unwrap_or_else(|| <super::generated::ObjectReference as ::protobuf::Message>::default_instance())
    }
    pub fn clear_parent(&mut self) {
        self.parent.clear();
    }

    pub fn has_parent(&self) -> bool {
        self.parent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_parent(&mut self, v: super::generated::ObjectReference) {
        self.parent = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent(&mut self) -> &mut super::generated::ObjectReference {
        if self.parent.is_none() {
            self.parent.set_default();
        }
        self.parent.as_mut().unwrap()
    }

    // Take field
    pub fn take_parent(&mut self) -> super::generated::ObjectReference {
        self.parent.take().unwrap_or_else(|| super::generated::ObjectReference::new())
    }

    // repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ResourceReference virtualMachineInterfaceReferences = 7;


    pub fn get_virtualMachineInterfaceReferences(&self) -> &[ResourceReference] {
        &self.virtualMachineInterfaceReferences
    }
    pub fn clear_virtualMachineInterfaceReferences(&mut self) {
        self.virtualMachineInterfaceReferences.clear();
    }

    // Param is passed by value, moved
    pub fn set_virtualMachineInterfaceReferences(&mut self, v: ::protobuf::RepeatedField<ResourceReference>) {
        self.virtualMachineInterfaceReferences = v;
    }

    // Mutable pointer to the field.
    pub fn mut_virtualMachineInterfaceReferences(&mut self) -> &mut ::protobuf::RepeatedField<ResourceReference> {
        &mut self.virtualMachineInterfaceReferences
    }

    // Take field
    pub fn take_virtualMachineInterfaceReferences(&mut self) -> ::protobuf::RepeatedField<ResourceReference> {
        ::std::mem::replace(&mut self.virtualMachineInterfaceReferences, ::protobuf::RepeatedField::new())
    }

    // optional bool floatingIPPortMappingsEnable = 8;


    pub fn get_floatingIPPortMappingsEnable(&self) -> bool {
        self.floatingIPPortMappingsEnable.unwrap_or(false)
    }
    pub fn clear_floatingIPPortMappingsEnable(&mut self) {
        self.floatingIPPortMappingsEnable = ::std::option::Option::None;
    }

    pub fn has_floatingIPPortMappingsEnable(&self) -> bool {
        self.floatingIPPortMappingsEnable.is_some()
    }

    // Param is passed by value, moved
    pub fn set_floatingIPPortMappingsEnable(&mut self, v: bool) {
        self.floatingIPPortMappingsEnable = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for FloatingIPSpec {
    fn is_initialized(&self) -> bool {
        for v in &self.commonSpec {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.floatingIPPortMappings {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.parent {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.virtualMachineInterfaceReferences {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.commonSpec)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.floatingIPAddress)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.floatingIPPortMappings)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.floatingIPTrafficDirection)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.parent)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.virtualMachineInterfaceReferences)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.floatingIPPortMappingsEnable = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.commonSpec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.floatingIPAddress.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.floatingIPPortMappings.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.floatingIPTrafficDirection.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.parent.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.virtualMachineInterfaceReferences {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.floatingIPPortMappingsEnable {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.commonSpec.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.floatingIPAddress.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.floatingIPPortMappings.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.floatingIPTrafficDirection.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.parent.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.virtualMachineInterfaceReferences {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.floatingIPPortMappingsEnable {
            os.write_bool(8, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FloatingIPSpec {
        FloatingIPSpec::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommonSpec>>(
                "commonSpec",
                |m: &FloatingIPSpec| { &m.commonSpec },
                |m: &mut FloatingIPSpec| { &mut m.commonSpec },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "floatingIPAddress",
                |m: &FloatingIPSpec| { &m.floatingIPAddress },
                |m: &mut FloatingIPSpec| { &mut m.floatingIPAddress },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FloatingIPPortMappings>>(
                "floatingIPPortMappings",
                |m: &FloatingIPSpec| { &m.floatingIPPortMappings },
                |m: &mut FloatingIPSpec| { &mut m.floatingIPPortMappings },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "floatingIPTrafficDirection",
                |m: &FloatingIPSpec| { &m.floatingIPTrafficDirection },
                |m: &mut FloatingIPSpec| { &mut m.floatingIPTrafficDirection },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::generated::ObjectReference>>(
                "parent",
                |m: &FloatingIPSpec| { &m.parent },
                |m: &mut FloatingIPSpec| { &mut m.parent },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResourceReference>>(
                "virtualMachineInterfaceReferences",
                |m: &FloatingIPSpec| { &m.virtualMachineInterfaceReferences },
                |m: &mut FloatingIPSpec| { &mut m.virtualMachineInterfaceReferences },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "floatingIPPortMappingsEnable",
                |m: &FloatingIPSpec| { &m.floatingIPPortMappingsEnable },
                |m: &mut FloatingIPSpec| { &mut m.floatingIPPortMappingsEnable },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FloatingIPSpec>(
                "FloatingIPSpec",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FloatingIPSpec {
        static instance: ::protobuf::rt::LazyV2<FloatingIPSpec> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FloatingIPSpec::new)
    }
}

impl ::protobuf::Clear for FloatingIPSpec {
    fn clear(&mut self) {
        self.commonSpec.clear();
        self.floatingIPAddress.clear();
        self.floatingIPPortMappings.clear();
        self.floatingIPTrafficDirection.clear();
        self.parent.clear();
        self.virtualMachineInterfaceReferences.clear();
        self.floatingIPPortMappingsEnable = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FloatingIPSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FloatingIPSpec {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FloatingIPStatus {
    // message fields
    pub commonStatus: ::protobuf::SingularPtrField<CommonStatus>,
    pub subnetReference: ::protobuf::SingularPtrField<ResourceReference>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FloatingIPStatus {
    fn default() -> &'a FloatingIPStatus {
        <FloatingIPStatus as ::protobuf::Message>::default_instance()
    }
}

impl FloatingIPStatus {
    pub fn new() -> FloatingIPStatus {
        ::std::default::Default::default()
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonStatus commonStatus = 1;


    pub fn get_commonStatus(&self) -> &CommonStatus {
        self.commonStatus.as_ref().unwrap_or_else(|| <CommonStatus as ::protobuf::Message>::default_instance())
    }
    pub fn clear_commonStatus(&mut self) {
        self.commonStatus.clear();
    }

    pub fn has_commonStatus(&self) -> bool {
        self.commonStatus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_commonStatus(&mut self, v: CommonStatus) {
        self.commonStatus = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_commonStatus(&mut self) -> &mut CommonStatus {
        if self.commonStatus.is_none() {
            self.commonStatus.set_default();
        }
        self.commonStatus.as_mut().unwrap()
    }

    // Take field
    pub fn take_commonStatus(&mut self) -> CommonStatus {
        self.commonStatus.take().unwrap_or_else(|| CommonStatus::new())
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ResourceReference subnetReference = 2;


    pub fn get_subnetReference(&self) -> &ResourceReference {
        self.subnetReference.as_ref().unwrap_or_else(|| <ResourceReference as ::protobuf::Message>::default_instance())
    }
    pub fn clear_subnetReference(&mut self) {
        self.subnetReference.clear();
    }

    pub fn has_subnetReference(&self) -> bool {
        self.subnetReference.is_some()
    }

    // Param is passed by value, moved
    pub fn set_subnetReference(&mut self, v: ResourceReference) {
        self.subnetReference = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subnetReference(&mut self) -> &mut ResourceReference {
        if self.subnetReference.is_none() {
            self.subnetReference.set_default();
        }
        self.subnetReference.as_mut().unwrap()
    }

    // Take field
    pub fn take_subnetReference(&mut self) -> ResourceReference {
        self.subnetReference.take().unwrap_or_else(|| ResourceReference::new())
    }
}

impl ::protobuf::Message for FloatingIPStatus {
    fn is_initialized(&self) -> bool {
        for v in &self.commonStatus {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.subnetReference {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.commonStatus)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.subnetReference)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.commonStatus.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.subnetReference.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.commonStatus.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.subnetReference.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FloatingIPStatus {
        FloatingIPStatus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommonStatus>>(
                "commonStatus",
                |m: &FloatingIPStatus| { &m.commonStatus },
                |m: &mut FloatingIPStatus| { &mut m.commonStatus },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResourceReference>>(
                "subnetReference",
                |m: &FloatingIPStatus| { &m.subnetReference },
                |m: &mut FloatingIPStatus| { &mut m.subnetReference },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FloatingIPStatus>(
                "FloatingIPStatus",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FloatingIPStatus {
        static instance: ::protobuf::rt::LazyV2<FloatingIPStatus> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FloatingIPStatus::new)
    }
}

impl ::protobuf::Clear for FloatingIPStatus {
    fn clear(&mut self) {
        self.commonStatus.clear();
        self.subnetReference.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FloatingIPStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FloatingIPStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GlobalSystemConfig {
    // message fields
    pub metadata: ::protobuf::SingularPtrField<super::meta::ObjectMeta>,
    pub spec: ::protobuf::SingularPtrField<GlobalSystemConfigSpec>,
    pub status: ::protobuf::SingularPtrField<GlobalSystemConfigStatus>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GlobalSystemConfig {
    fn default() -> &'a GlobalSystemConfig {
        <GlobalSystemConfig as ::protobuf::Message>::default_instance()
    }
}

impl GlobalSystemConfig {
    pub fn new() -> GlobalSystemConfig {
        ::std::default::Default::default()
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;


    pub fn get_metadata(&self) -> &super::meta::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <super::meta::ObjectMeta as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::meta::ObjectMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::meta::ObjectMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::meta::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| super::meta::ObjectMeta::new())
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalSystemConfigSpec spec = 2;


    pub fn get_spec(&self) -> &GlobalSystemConfigSpec {
        self.spec.as_ref().unwrap_or_else(|| <GlobalSystemConfigSpec as ::protobuf::Message>::default_instance())
    }
    pub fn clear_spec(&mut self) {
        self.spec.clear();
    }

    pub fn has_spec(&self) -> bool {
        self.spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spec(&mut self, v: GlobalSystemConfigSpec) {
        self.spec = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spec(&mut self) -> &mut GlobalSystemConfigSpec {
        if self.spec.is_none() {
            self.spec.set_default();
        }
        self.spec.as_mut().unwrap()
    }

    // Take field
    pub fn take_spec(&mut self) -> GlobalSystemConfigSpec {
        self.spec.take().unwrap_or_else(|| GlobalSystemConfigSpec::new())
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalSystemConfigStatus status = 3;


    pub fn get_status(&self) -> &GlobalSystemConfigStatus {
        self.status.as_ref().unwrap_or_else(|| <GlobalSystemConfigStatus as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: GlobalSystemConfigStatus) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut GlobalSystemConfigStatus {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> GlobalSystemConfigStatus {
        self.status.take().unwrap_or_else(|| GlobalSystemConfigStatus::new())
    }
}

impl ::protobuf::Message for GlobalSystemConfig {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.spec {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.spec)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.spec.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GlobalSystemConfig {
        GlobalSystemConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::meta::ObjectMeta>>(
                "metadata",
                |m: &GlobalSystemConfig| { &m.metadata },
                |m: &mut GlobalSystemConfig| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GlobalSystemConfigSpec>>(
                "spec",
                |m: &GlobalSystemConfig| { &m.spec },
                |m: &mut GlobalSystemConfig| { &mut m.spec },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GlobalSystemConfigStatus>>(
                "status",
                |m: &GlobalSystemConfig| { &m.status },
                |m: &mut GlobalSystemConfig| { &mut m.status },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GlobalSystemConfig>(
                "GlobalSystemConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GlobalSystemConfig {
        static instance: ::protobuf::rt::LazyV2<GlobalSystemConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GlobalSystemConfig::new)
    }
}

impl ::protobuf::Clear for GlobalSystemConfig {
    fn clear(&mut self) {
        self.metadata.clear();
        self.spec.clear();
        self.status.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GlobalSystemConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GlobalSystemConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GlobalSystemConfigList {
    // message fields
    pub metadata: ::protobuf::SingularPtrField<super::meta::ListMeta>,
    pub items: ::protobuf::RepeatedField<GlobalSystemConfig>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GlobalSystemConfigList {
    fn default() -> &'a GlobalSystemConfigList {
        <GlobalSystemConfigList as ::protobuf::Message>::default_instance()
    }
}

impl GlobalSystemConfigList {
    pub fn new() -> GlobalSystemConfigList {
        ::std::default::Default::default()
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;


    pub fn get_metadata(&self) -> &super::meta::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <super::meta::ListMeta as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::meta::ListMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::meta::ListMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::meta::ListMeta {
        self.metadata.take().unwrap_or_else(|| super::meta::ListMeta::new())
    }

    // repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalSystemConfig items = 2;


    pub fn get_items(&self) -> &[GlobalSystemConfig] {
        &self.items
    }
    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::protobuf::RepeatedField<GlobalSystemConfig>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::protobuf::RepeatedField<GlobalSystemConfig> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::protobuf::RepeatedField<GlobalSystemConfig> {
        ::std::mem::replace(&mut self.items, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for GlobalSystemConfigList {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.items {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.items)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.items {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GlobalSystemConfigList {
        GlobalSystemConfigList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::meta::ListMeta>>(
                "metadata",
                |m: &GlobalSystemConfigList| { &m.metadata },
                |m: &mut GlobalSystemConfigList| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GlobalSystemConfig>>(
                "items",
                |m: &GlobalSystemConfigList| { &m.items },
                |m: &mut GlobalSystemConfigList| { &mut m.items },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GlobalSystemConfigList>(
                "GlobalSystemConfigList",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GlobalSystemConfigList {
        static instance: ::protobuf::rt::LazyV2<GlobalSystemConfigList> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GlobalSystemConfigList::new)
    }
}

impl ::protobuf::Clear for GlobalSystemConfigList {
    fn clear(&mut self) {
        self.metadata.clear();
        self.items.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GlobalSystemConfigList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GlobalSystemConfigList {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GlobalSystemConfigSpec {
    // message fields
    pub commonSpec: ::protobuf::SingularPtrField<CommonSpec>,
    enable4bytesAS: ::std::option::Option<bool>,
    autonomousSystem: ::std::option::Option<i32>,
    pub bgpRouterReferences: ::protobuf::RepeatedField<ResourceReference>,
    ibgpAutoMesh: ::std::option::Option<bool>,
    defaultEnableSNAT: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GlobalSystemConfigSpec {
    fn default() -> &'a GlobalSystemConfigSpec {
        <GlobalSystemConfigSpec as ::protobuf::Message>::default_instance()
    }
}

impl GlobalSystemConfigSpec {
    pub fn new() -> GlobalSystemConfigSpec {
        ::std::default::Default::default()
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonSpec commonSpec = 1;


    pub fn get_commonSpec(&self) -> &CommonSpec {
        self.commonSpec.as_ref().unwrap_or_else(|| <CommonSpec as ::protobuf::Message>::default_instance())
    }
    pub fn clear_commonSpec(&mut self) {
        self.commonSpec.clear();
    }

    pub fn has_commonSpec(&self) -> bool {
        self.commonSpec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_commonSpec(&mut self, v: CommonSpec) {
        self.commonSpec = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_commonSpec(&mut self) -> &mut CommonSpec {
        if self.commonSpec.is_none() {
            self.commonSpec.set_default();
        }
        self.commonSpec.as_mut().unwrap()
    }

    // Take field
    pub fn take_commonSpec(&mut self) -> CommonSpec {
        self.commonSpec.take().unwrap_or_else(|| CommonSpec::new())
    }

    // optional bool enable4bytesAS = 2;


    pub fn get_enable4bytesAS(&self) -> bool {
        self.enable4bytesAS.unwrap_or(false)
    }
    pub fn clear_enable4bytesAS(&mut self) {
        self.enable4bytesAS = ::std::option::Option::None;
    }

    pub fn has_enable4bytesAS(&self) -> bool {
        self.enable4bytesAS.is_some()
    }

    // Param is passed by value, moved
    pub fn set_enable4bytesAS(&mut self, v: bool) {
        self.enable4bytesAS = ::std::option::Option::Some(v);
    }

    // optional int32 autonomousSystem = 3;


    pub fn get_autonomousSystem(&self) -> i32 {
        self.autonomousSystem.unwrap_or(0)
    }
    pub fn clear_autonomousSystem(&mut self) {
        self.autonomousSystem = ::std::option::Option::None;
    }

    pub fn has_autonomousSystem(&self) -> bool {
        self.autonomousSystem.is_some()
    }

    // Param is passed by value, moved
    pub fn set_autonomousSystem(&mut self, v: i32) {
        self.autonomousSystem = ::std::option::Option::Some(v);
    }

    // repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ResourceReference bgpRouterReferences = 4;


    pub fn get_bgpRouterReferences(&self) -> &[ResourceReference] {
        &self.bgpRouterReferences
    }
    pub fn clear_bgpRouterReferences(&mut self) {
        self.bgpRouterReferences.clear();
    }

    // Param is passed by value, moved
    pub fn set_bgpRouterReferences(&mut self, v: ::protobuf::RepeatedField<ResourceReference>) {
        self.bgpRouterReferences = v;
    }

    // Mutable pointer to the field.
    pub fn mut_bgpRouterReferences(&mut self) -> &mut ::protobuf::RepeatedField<ResourceReference> {
        &mut self.bgpRouterReferences
    }

    // Take field
    pub fn take_bgpRouterReferences(&mut self) -> ::protobuf::RepeatedField<ResourceReference> {
        ::std::mem::replace(&mut self.bgpRouterReferences, ::protobuf::RepeatedField::new())
    }

    // optional bool ibgpAutoMesh = 5;


    pub fn get_ibgpAutoMesh(&self) -> bool {
        self.ibgpAutoMesh.unwrap_or(false)
    }
    pub fn clear_ibgpAutoMesh(&mut self) {
        self.ibgpAutoMesh = ::std::option::Option::None;
    }

    pub fn has_ibgpAutoMesh(&self) -> bool {
        self.ibgpAutoMesh.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ibgpAutoMesh(&mut self, v: bool) {
        self.ibgpAutoMesh = ::std::option::Option::Some(v);
    }

    // optional bool defaultEnableSNAT = 6;


    pub fn get_defaultEnableSNAT(&self) -> bool {
        self.defaultEnableSNAT.unwrap_or(false)
    }
    pub fn clear_defaultEnableSNAT(&mut self) {
        self.defaultEnableSNAT = ::std::option::Option::None;
    }

    pub fn has_defaultEnableSNAT(&self) -> bool {
        self.defaultEnableSNAT.is_some()
    }

    // Param is passed by value, moved
    pub fn set_defaultEnableSNAT(&mut self, v: bool) {
        self.defaultEnableSNAT = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for GlobalSystemConfigSpec {
    fn is_initialized(&self) -> bool {
        for v in &self.commonSpec {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.bgpRouterReferences {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.commonSpec)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.enable4bytesAS = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.autonomousSystem = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.bgpRouterReferences)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.ibgpAutoMesh = ::std::option::Option::Some(tmp);
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.defaultEnableSNAT = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.commonSpec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.enable4bytesAS {
            my_size += 2;
        }
        if let Some(v) = self.autonomousSystem {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.bgpRouterReferences {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.ibgpAutoMesh {
            my_size += 2;
        }
        if let Some(v) = self.defaultEnableSNAT {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.commonSpec.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.enable4bytesAS {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.autonomousSystem {
            os.write_int32(3, v)?;
        }
        for v in &self.bgpRouterReferences {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.ibgpAutoMesh {
            os.write_bool(5, v)?;
        }
        if let Some(v) = self.defaultEnableSNAT {
            os.write_bool(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GlobalSystemConfigSpec {
        GlobalSystemConfigSpec::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommonSpec>>(
                "commonSpec",
                |m: &GlobalSystemConfigSpec| { &m.commonSpec },
                |m: &mut GlobalSystemConfigSpec| { &mut m.commonSpec },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "enable4bytesAS",
                |m: &GlobalSystemConfigSpec| { &m.enable4bytesAS },
                |m: &mut GlobalSystemConfigSpec| { &mut m.enable4bytesAS },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "autonomousSystem",
                |m: &GlobalSystemConfigSpec| { &m.autonomousSystem },
                |m: &mut GlobalSystemConfigSpec| { &mut m.autonomousSystem },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResourceReference>>(
                "bgpRouterReferences",
                |m: &GlobalSystemConfigSpec| { &m.bgpRouterReferences },
                |m: &mut GlobalSystemConfigSpec| { &mut m.bgpRouterReferences },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "ibgpAutoMesh",
                |m: &GlobalSystemConfigSpec| { &m.ibgpAutoMesh },
                |m: &mut GlobalSystemConfigSpec| { &mut m.ibgpAutoMesh },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "defaultEnableSNAT",
                |m: &GlobalSystemConfigSpec| { &m.defaultEnableSNAT },
                |m: &mut GlobalSystemConfigSpec| { &mut m.defaultEnableSNAT },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GlobalSystemConfigSpec>(
                "GlobalSystemConfigSpec",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GlobalSystemConfigSpec {
        static instance: ::protobuf::rt::LazyV2<GlobalSystemConfigSpec> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GlobalSystemConfigSpec::new)
    }
}

impl ::protobuf::Clear for GlobalSystemConfigSpec {
    fn clear(&mut self) {
        self.commonSpec.clear();
        self.enable4bytesAS = ::std::option::Option::None;
        self.autonomousSystem = ::std::option::Option::None;
        self.bgpRouterReferences.clear();
        self.ibgpAutoMesh = ::std::option::Option::None;
        self.defaultEnableSNAT = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GlobalSystemConfigSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GlobalSystemConfigSpec {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GlobalSystemConfigStatus {
    // message fields
    pub commonStatus: ::protobuf::SingularPtrField<CommonStatus>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GlobalSystemConfigStatus {
    fn default() -> &'a GlobalSystemConfigStatus {
        <GlobalSystemConfigStatus as ::protobuf::Message>::default_instance()
    }
}

impl GlobalSystemConfigStatus {
    pub fn new() -> GlobalSystemConfigStatus {
        ::std::default::Default::default()
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonStatus commonStatus = 1;


    pub fn get_commonStatus(&self) -> &CommonStatus {
        self.commonStatus.as_ref().unwrap_or_else(|| <CommonStatus as ::protobuf::Message>::default_instance())
    }
    pub fn clear_commonStatus(&mut self) {
        self.commonStatus.clear();
    }

    pub fn has_commonStatus(&self) -> bool {
        self.commonStatus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_commonStatus(&mut self, v: CommonStatus) {
        self.commonStatus = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_commonStatus(&mut self) -> &mut CommonStatus {
        if self.commonStatus.is_none() {
            self.commonStatus.set_default();
        }
        self.commonStatus.as_mut().unwrap()
    }

    // Take field
    pub fn take_commonStatus(&mut self) -> CommonStatus {
        self.commonStatus.take().unwrap_or_else(|| CommonStatus::new())
    }
}

impl ::protobuf::Message for GlobalSystemConfigStatus {
    fn is_initialized(&self) -> bool {
        for v in &self.commonStatus {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.commonStatus)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.commonStatus.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.commonStatus.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GlobalSystemConfigStatus {
        GlobalSystemConfigStatus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommonStatus>>(
                "commonStatus",
                |m: &GlobalSystemConfigStatus| { &m.commonStatus },
                |m: &mut GlobalSystemConfigStatus| { &mut m.commonStatus },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GlobalSystemConfigStatus>(
                "GlobalSystemConfigStatus",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GlobalSystemConfigStatus {
        static instance: ::protobuf::rt::LazyV2<GlobalSystemConfigStatus> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GlobalSystemConfigStatus::new)
    }
}

impl ::protobuf::Clear for GlobalSystemConfigStatus {
    fn clear(&mut self) {
        self.commonStatus.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GlobalSystemConfigStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GlobalSystemConfigStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GlobalVrouterConfig {
    // message fields
    pub metadata: ::protobuf::SingularPtrField<super::meta::ObjectMeta>,
    pub spec: ::protobuf::SingularPtrField<GlobalVrouterConfigSpec>,
    pub status: ::protobuf::SingularPtrField<GlobalVrouterConfigStatus>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GlobalVrouterConfig {
    fn default() -> &'a GlobalVrouterConfig {
        <GlobalVrouterConfig as ::protobuf::Message>::default_instance()
    }
}

impl GlobalVrouterConfig {
    pub fn new() -> GlobalVrouterConfig {
        ::std::default::Default::default()
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;


    pub fn get_metadata(&self) -> &super::meta::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <super::meta::ObjectMeta as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::meta::ObjectMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::meta::ObjectMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::meta::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| super::meta::ObjectMeta::new())
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalVrouterConfigSpec spec = 2;


    pub fn get_spec(&self) -> &GlobalVrouterConfigSpec {
        self.spec.as_ref().unwrap_or_else(|| <GlobalVrouterConfigSpec as ::protobuf::Message>::default_instance())
    }
    pub fn clear_spec(&mut self) {
        self.spec.clear();
    }

    pub fn has_spec(&self) -> bool {
        self.spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spec(&mut self, v: GlobalVrouterConfigSpec) {
        self.spec = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spec(&mut self) -> &mut GlobalVrouterConfigSpec {
        if self.spec.is_none() {
            self.spec.set_default();
        }
        self.spec.as_mut().unwrap()
    }

    // Take field
    pub fn take_spec(&mut self) -> GlobalVrouterConfigSpec {
        self.spec.take().unwrap_or_else(|| GlobalVrouterConfigSpec::new())
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalVrouterConfigStatus status = 3;


    pub fn get_status(&self) -> &GlobalVrouterConfigStatus {
        self.status.as_ref().unwrap_or_else(|| <GlobalVrouterConfigStatus as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: GlobalVrouterConfigStatus) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut GlobalVrouterConfigStatus {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> GlobalVrouterConfigStatus {
        self.status.take().unwrap_or_else(|| GlobalVrouterConfigStatus::new())
    }
}

impl ::protobuf::Message for GlobalVrouterConfig {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.spec {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.spec)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.spec.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GlobalVrouterConfig {
        GlobalVrouterConfig::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::meta::ObjectMeta>>(
                "metadata",
                |m: &GlobalVrouterConfig| { &m.metadata },
                |m: &mut GlobalVrouterConfig| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GlobalVrouterConfigSpec>>(
                "spec",
                |m: &GlobalVrouterConfig| { &m.spec },
                |m: &mut GlobalVrouterConfig| { &mut m.spec },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GlobalVrouterConfigStatus>>(
                "status",
                |m: &GlobalVrouterConfig| { &m.status },
                |m: &mut GlobalVrouterConfig| { &mut m.status },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GlobalVrouterConfig>(
                "GlobalVrouterConfig",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GlobalVrouterConfig {
        static instance: ::protobuf::rt::LazyV2<GlobalVrouterConfig> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GlobalVrouterConfig::new)
    }
}

impl ::protobuf::Clear for GlobalVrouterConfig {
    fn clear(&mut self) {
        self.metadata.clear();
        self.spec.clear();
        self.status.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GlobalVrouterConfig {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GlobalVrouterConfig {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GlobalVrouterConfigList {
    // message fields
    pub metadata: ::protobuf::SingularPtrField<super::meta::ListMeta>,
    pub items: ::protobuf::RepeatedField<GlobalVrouterConfig>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GlobalVrouterConfigList {
    fn default() -> &'a GlobalVrouterConfigList {
        <GlobalVrouterConfigList as ::protobuf::Message>::default_instance()
    }
}

impl GlobalVrouterConfigList {
    pub fn new() -> GlobalVrouterConfigList {
        ::std::default::Default::default()
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;


    pub fn get_metadata(&self) -> &super::meta::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <super::meta::ListMeta as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::meta::ListMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::meta::ListMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::meta::ListMeta {
        self.metadata.take().unwrap_or_else(|| super::meta::ListMeta::new())
    }

    // repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalVrouterConfig items = 2;


    pub fn get_items(&self) -> &[GlobalVrouterConfig] {
        &self.items
    }
    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::protobuf::RepeatedField<GlobalVrouterConfig>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::protobuf::RepeatedField<GlobalVrouterConfig> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::protobuf::RepeatedField<GlobalVrouterConfig> {
        ::std::mem::replace(&mut self.items, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for GlobalVrouterConfigList {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.items {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.items)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.items {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GlobalVrouterConfigList {
        GlobalVrouterConfigList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::meta::ListMeta>>(
                "metadata",
                |m: &GlobalVrouterConfigList| { &m.metadata },
                |m: &mut GlobalVrouterConfigList| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GlobalVrouterConfig>>(
                "items",
                |m: &GlobalVrouterConfigList| { &m.items },
                |m: &mut GlobalVrouterConfigList| { &mut m.items },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GlobalVrouterConfigList>(
                "GlobalVrouterConfigList",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GlobalVrouterConfigList {
        static instance: ::protobuf::rt::LazyV2<GlobalVrouterConfigList> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GlobalVrouterConfigList::new)
    }
}

impl ::protobuf::Clear for GlobalVrouterConfigList {
    fn clear(&mut self) {
        self.metadata.clear();
        self.items.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GlobalVrouterConfigList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GlobalVrouterConfigList {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GlobalVrouterConfigSpec {
    // message fields
    pub commonSpec: ::protobuf::SingularPtrField<CommonSpec>,
    pub parent: ::protobuf::SingularPtrField<super::generated::ObjectReference>,
    pub encapsulationPriorities: ::protobuf::SingularPtrField<EncapsulationPriorities>,
    pub linklocalServices: ::protobuf::SingularPtrField<LinklocalServices>,
    pub portTranslationPools: ::protobuf::SingularPtrField<PortTranslationPools>,
    flowExportRate: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GlobalVrouterConfigSpec {
    fn default() -> &'a GlobalVrouterConfigSpec {
        <GlobalVrouterConfigSpec as ::protobuf::Message>::default_instance()
    }
}

impl GlobalVrouterConfigSpec {
    pub fn new() -> GlobalVrouterConfigSpec {
        ::std::default::Default::default()
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonSpec commonSpec = 1;


    pub fn get_commonSpec(&self) -> &CommonSpec {
        self.commonSpec.as_ref().unwrap_or_else(|| <CommonSpec as ::protobuf::Message>::default_instance())
    }
    pub fn clear_commonSpec(&mut self) {
        self.commonSpec.clear();
    }

    pub fn has_commonSpec(&self) -> bool {
        self.commonSpec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_commonSpec(&mut self, v: CommonSpec) {
        self.commonSpec = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_commonSpec(&mut self) -> &mut CommonSpec {
        if self.commonSpec.is_none() {
            self.commonSpec.set_default();
        }
        self.commonSpec.as_mut().unwrap()
    }

    // Take field
    pub fn take_commonSpec(&mut self) -> CommonSpec {
        self.commonSpec.take().unwrap_or_else(|| CommonSpec::new())
    }

    // optional .k8s.io.api.core.v1.ObjectReference parent = 2;


    pub fn get_parent(&self) -> &super::generated::ObjectReference {
        self.parent.as_ref().unwrap_or_else(|| <super::generated::ObjectReference as ::protobuf::Message>::default_instance())
    }
    pub fn clear_parent(&mut self) {
        self.parent.clear();
    }

    pub fn has_parent(&self) -> bool {
        self.parent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_parent(&mut self, v: super::generated::ObjectReference) {
        self.parent = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent(&mut self) -> &mut super::generated::ObjectReference {
        if self.parent.is_none() {
            self.parent.set_default();
        }
        self.parent.as_mut().unwrap()
    }

    // Take field
    pub fn take_parent(&mut self) -> super::generated::ObjectReference {
        self.parent.take().unwrap_or_else(|| super::generated::ObjectReference::new())
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.EncapsulationPriorities encapsulationPriorities = 3;


    pub fn get_encapsulationPriorities(&self) -> &EncapsulationPriorities {
        self.encapsulationPriorities.as_ref().unwrap_or_else(|| <EncapsulationPriorities as ::protobuf::Message>::default_instance())
    }
    pub fn clear_encapsulationPriorities(&mut self) {
        self.encapsulationPriorities.clear();
    }

    pub fn has_encapsulationPriorities(&self) -> bool {
        self.encapsulationPriorities.is_some()
    }

    // Param is passed by value, moved
    pub fn set_encapsulationPriorities(&mut self, v: EncapsulationPriorities) {
        self.encapsulationPriorities = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_encapsulationPriorities(&mut self) -> &mut EncapsulationPriorities {
        if self.encapsulationPriorities.is_none() {
            self.encapsulationPriorities.set_default();
        }
        self.encapsulationPriorities.as_mut().unwrap()
    }

    // Take field
    pub fn take_encapsulationPriorities(&mut self) -> EncapsulationPriorities {
        self.encapsulationPriorities.take().unwrap_or_else(|| EncapsulationPriorities::new())
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.LinklocalServices linklocalServices = 4;


    pub fn get_linklocalServices(&self) -> &LinklocalServices {
        self.linklocalServices.as_ref().unwrap_or_else(|| <LinklocalServices as ::protobuf::Message>::default_instance())
    }
    pub fn clear_linklocalServices(&mut self) {
        self.linklocalServices.clear();
    }

    pub fn has_linklocalServices(&self) -> bool {
        self.linklocalServices.is_some()
    }

    // Param is passed by value, moved
    pub fn set_linklocalServices(&mut self, v: LinklocalServices) {
        self.linklocalServices = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_linklocalServices(&mut self) -> &mut LinklocalServices {
        if self.linklocalServices.is_none() {
            self.linklocalServices.set_default();
        }
        self.linklocalServices.as_mut().unwrap()
    }

    // Take field
    pub fn take_linklocalServices(&mut self) -> LinklocalServices {
        self.linklocalServices.take().unwrap_or_else(|| LinklocalServices::new())
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.PortTranslationPools portTranslationPools = 5;


    pub fn get_portTranslationPools(&self) -> &PortTranslationPools {
        self.portTranslationPools.as_ref().unwrap_or_else(|| <PortTranslationPools as ::protobuf::Message>::default_instance())
    }
    pub fn clear_portTranslationPools(&mut self) {
        self.portTranslationPools.clear();
    }

    pub fn has_portTranslationPools(&self) -> bool {
        self.portTranslationPools.is_some()
    }

    // Param is passed by value, moved
    pub fn set_portTranslationPools(&mut self, v: PortTranslationPools) {
        self.portTranslationPools = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_portTranslationPools(&mut self) -> &mut PortTranslationPools {
        if self.portTranslationPools.is_none() {
            self.portTranslationPools.set_default();
        }
        self.portTranslationPools.as_mut().unwrap()
    }

    // Take field
    pub fn take_portTranslationPools(&mut self) -> PortTranslationPools {
        self.portTranslationPools.take().unwrap_or_else(|| PortTranslationPools::new())
    }

    // optional int32 flowExportRate = 6;


    pub fn get_flowExportRate(&self) -> i32 {
        self.flowExportRate.unwrap_or(0)
    }
    pub fn clear_flowExportRate(&mut self) {
        self.flowExportRate = ::std::option::Option::None;
    }

    pub fn has_flowExportRate(&self) -> bool {
        self.flowExportRate.is_some()
    }

    // Param is passed by value, moved
    pub fn set_flowExportRate(&mut self, v: i32) {
        self.flowExportRate = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for GlobalVrouterConfigSpec {
    fn is_initialized(&self) -> bool {
        for v in &self.commonSpec {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.parent {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.encapsulationPriorities {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.linklocalServices {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.portTranslationPools {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.commonSpec)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.parent)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.encapsulationPriorities)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.linklocalServices)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.portTranslationPools)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.flowExportRate = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.commonSpec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.parent.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.encapsulationPriorities.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.linklocalServices.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.portTranslationPools.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.flowExportRate {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.commonSpec.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.parent.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.encapsulationPriorities.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.linklocalServices.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.portTranslationPools.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.flowExportRate {
            os.write_int32(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GlobalVrouterConfigSpec {
        GlobalVrouterConfigSpec::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommonSpec>>(
                "commonSpec",
                |m: &GlobalVrouterConfigSpec| { &m.commonSpec },
                |m: &mut GlobalVrouterConfigSpec| { &mut m.commonSpec },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::generated::ObjectReference>>(
                "parent",
                |m: &GlobalVrouterConfigSpec| { &m.parent },
                |m: &mut GlobalVrouterConfigSpec| { &mut m.parent },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<EncapsulationPriorities>>(
                "encapsulationPriorities",
                |m: &GlobalVrouterConfigSpec| { &m.encapsulationPriorities },
                |m: &mut GlobalVrouterConfigSpec| { &mut m.encapsulationPriorities },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LinklocalServices>>(
                "linklocalServices",
                |m: &GlobalVrouterConfigSpec| { &m.linklocalServices },
                |m: &mut GlobalVrouterConfigSpec| { &mut m.linklocalServices },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PortTranslationPools>>(
                "portTranslationPools",
                |m: &GlobalVrouterConfigSpec| { &m.portTranslationPools },
                |m: &mut GlobalVrouterConfigSpec| { &mut m.portTranslationPools },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "flowExportRate",
                |m: &GlobalVrouterConfigSpec| { &m.flowExportRate },
                |m: &mut GlobalVrouterConfigSpec| { &mut m.flowExportRate },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GlobalVrouterConfigSpec>(
                "GlobalVrouterConfigSpec",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GlobalVrouterConfigSpec {
        static instance: ::protobuf::rt::LazyV2<GlobalVrouterConfigSpec> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GlobalVrouterConfigSpec::new)
    }
}

impl ::protobuf::Clear for GlobalVrouterConfigSpec {
    fn clear(&mut self) {
        self.commonSpec.clear();
        self.parent.clear();
        self.encapsulationPriorities.clear();
        self.linklocalServices.clear();
        self.portTranslationPools.clear();
        self.flowExportRate = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GlobalVrouterConfigSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GlobalVrouterConfigSpec {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GlobalVrouterConfigStatus {
    // message fields
    pub commonStatus: ::protobuf::SingularPtrField<CommonStatus>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GlobalVrouterConfigStatus {
    fn default() -> &'a GlobalVrouterConfigStatus {
        <GlobalVrouterConfigStatus as ::protobuf::Message>::default_instance()
    }
}

impl GlobalVrouterConfigStatus {
    pub fn new() -> GlobalVrouterConfigStatus {
        ::std::default::Default::default()
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonStatus commonStatus = 1;


    pub fn get_commonStatus(&self) -> &CommonStatus {
        self.commonStatus.as_ref().unwrap_or_else(|| <CommonStatus as ::protobuf::Message>::default_instance())
    }
    pub fn clear_commonStatus(&mut self) {
        self.commonStatus.clear();
    }

    pub fn has_commonStatus(&self) -> bool {
        self.commonStatus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_commonStatus(&mut self, v: CommonStatus) {
        self.commonStatus = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_commonStatus(&mut self) -> &mut CommonStatus {
        if self.commonStatus.is_none() {
            self.commonStatus.set_default();
        }
        self.commonStatus.as_mut().unwrap()
    }

    // Take field
    pub fn take_commonStatus(&mut self) -> CommonStatus {
        self.commonStatus.take().unwrap_or_else(|| CommonStatus::new())
    }
}

impl ::protobuf::Message for GlobalVrouterConfigStatus {
    fn is_initialized(&self) -> bool {
        for v in &self.commonStatus {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.commonStatus)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.commonStatus.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.commonStatus.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GlobalVrouterConfigStatus {
        GlobalVrouterConfigStatus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommonStatus>>(
                "commonStatus",
                |m: &GlobalVrouterConfigStatus| { &m.commonStatus },
                |m: &mut GlobalVrouterConfigStatus| { &mut m.commonStatus },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GlobalVrouterConfigStatus>(
                "GlobalVrouterConfigStatus",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GlobalVrouterConfigStatus {
        static instance: ::protobuf::rt::LazyV2<GlobalVrouterConfigStatus> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GlobalVrouterConfigStatus::new)
    }
}

impl ::protobuf::Clear for GlobalVrouterConfigStatus {
    fn clear(&mut self) {
        self.commonStatus.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GlobalVrouterConfigStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GlobalVrouterConfigStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct IPRange {
    // message fields
    from: ::protobuf::SingularField<::std::string::String>,
    to: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IPRange {
    fn default() -> &'a IPRange {
        <IPRange as ::protobuf::Message>::default_instance()
    }
}

impl IPRange {
    pub fn new() -> IPRange {
        ::std::default::Default::default()
    }

    // optional string from = 1;


    pub fn get_from(&self) -> &str {
        match self.from.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_from(&mut self) {
        self.from.clear();
    }

    pub fn has_from(&self) -> bool {
        self.from.is_some()
    }

    // Param is passed by value, moved
    pub fn set_from(&mut self, v: ::std::string::String) {
        self.from = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_from(&mut self) -> &mut ::std::string::String {
        if self.from.is_none() {
            self.from.set_default();
        }
        self.from.as_mut().unwrap()
    }

    // Take field
    pub fn take_from(&mut self) -> ::std::string::String {
        self.from.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string to = 2;


    pub fn get_to(&self) -> &str {
        match self.to.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_to(&mut self) {
        self.to.clear();
    }

    pub fn has_to(&self) -> bool {
        self.to.is_some()
    }

    // Param is passed by value, moved
    pub fn set_to(&mut self, v: ::std::string::String) {
        self.to = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_to(&mut self) -> &mut ::std::string::String {
        if self.to.is_none() {
            self.to.set_default();
        }
        self.to.as_mut().unwrap()
    }

    // Take field
    pub fn take_to(&mut self) -> ::std::string::String {
        self.to.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for IPRange {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.from)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.to)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.from.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.to.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.from.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.to.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IPRange {
        IPRange::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "from",
                |m: &IPRange| { &m.from },
                |m: &mut IPRange| { &mut m.from },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "to",
                |m: &IPRange| { &m.to },
                |m: &mut IPRange| { &mut m.to },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<IPRange>(
                "IPRange",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static IPRange {
        static instance: ::protobuf::rt::LazyV2<IPRange> = ::protobuf::rt::LazyV2::INIT;
        instance.get(IPRange::new)
    }
}

impl ::protobuf::Clear for IPRange {
    fn clear(&mut self) {
        self.from.clear();
        self.to.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for IPRange {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IPRange {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ImportVirtualNetworkRouter {
    // message fields
    pub virtualNetworkRouters: ::protobuf::RepeatedField<VirtualNetworkRouterEntry>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ImportVirtualNetworkRouter {
    fn default() -> &'a ImportVirtualNetworkRouter {
        <ImportVirtualNetworkRouter as ::protobuf::Message>::default_instance()
    }
}

impl ImportVirtualNetworkRouter {
    pub fn new() -> ImportVirtualNetworkRouter {
        ::std::default::Default::default()
    }

    // repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkRouterEntry virtualNetworkRouters = 1;


    pub fn get_virtualNetworkRouters(&self) -> &[VirtualNetworkRouterEntry] {
        &self.virtualNetworkRouters
    }
    pub fn clear_virtualNetworkRouters(&mut self) {
        self.virtualNetworkRouters.clear();
    }

    // Param is passed by value, moved
    pub fn set_virtualNetworkRouters(&mut self, v: ::protobuf::RepeatedField<VirtualNetworkRouterEntry>) {
        self.virtualNetworkRouters = v;
    }

    // Mutable pointer to the field.
    pub fn mut_virtualNetworkRouters(&mut self) -> &mut ::protobuf::RepeatedField<VirtualNetworkRouterEntry> {
        &mut self.virtualNetworkRouters
    }

    // Take field
    pub fn take_virtualNetworkRouters(&mut self) -> ::protobuf::RepeatedField<VirtualNetworkRouterEntry> {
        ::std::mem::replace(&mut self.virtualNetworkRouters, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ImportVirtualNetworkRouter {
    fn is_initialized(&self) -> bool {
        for v in &self.virtualNetworkRouters {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.virtualNetworkRouters)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.virtualNetworkRouters {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.virtualNetworkRouters {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ImportVirtualNetworkRouter {
        ImportVirtualNetworkRouter::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<VirtualNetworkRouterEntry>>(
                "virtualNetworkRouters",
                |m: &ImportVirtualNetworkRouter| { &m.virtualNetworkRouters },
                |m: &mut ImportVirtualNetworkRouter| { &mut m.virtualNetworkRouters },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ImportVirtualNetworkRouter>(
                "ImportVirtualNetworkRouter",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ImportVirtualNetworkRouter {
        static instance: ::protobuf::rt::LazyV2<ImportVirtualNetworkRouter> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ImportVirtualNetworkRouter::new)
    }
}

impl ::protobuf::Clear for ImportVirtualNetworkRouter {
    fn clear(&mut self) {
        self.virtualNetworkRouters.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ImportVirtualNetworkRouter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ImportVirtualNetworkRouter {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct InstanceIP {
    // message fields
    pub metadata: ::protobuf::SingularPtrField<super::meta::ObjectMeta>,
    pub spec: ::protobuf::SingularPtrField<InstanceIPSpec>,
    pub status: ::protobuf::SingularPtrField<InstanceIPStatus>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a InstanceIP {
    fn default() -> &'a InstanceIP {
        <InstanceIP as ::protobuf::Message>::default_instance()
    }
}

impl InstanceIP {
    pub fn new() -> InstanceIP {
        ::std::default::Default::default()
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;


    pub fn get_metadata(&self) -> &super::meta::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <super::meta::ObjectMeta as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::meta::ObjectMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::meta::ObjectMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::meta::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| super::meta::ObjectMeta::new())
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.InstanceIPSpec spec = 2;


    pub fn get_spec(&self) -> &InstanceIPSpec {
        self.spec.as_ref().unwrap_or_else(|| <InstanceIPSpec as ::protobuf::Message>::default_instance())
    }
    pub fn clear_spec(&mut self) {
        self.spec.clear();
    }

    pub fn has_spec(&self) -> bool {
        self.spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spec(&mut self, v: InstanceIPSpec) {
        self.spec = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spec(&mut self) -> &mut InstanceIPSpec {
        if self.spec.is_none() {
            self.spec.set_default();
        }
        self.spec.as_mut().unwrap()
    }

    // Take field
    pub fn take_spec(&mut self) -> InstanceIPSpec {
        self.spec.take().unwrap_or_else(|| InstanceIPSpec::new())
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.InstanceIPStatus status = 3;


    pub fn get_status(&self) -> &InstanceIPStatus {
        self.status.as_ref().unwrap_or_else(|| <InstanceIPStatus as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: InstanceIPStatus) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut InstanceIPStatus {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> InstanceIPStatus {
        self.status.take().unwrap_or_else(|| InstanceIPStatus::new())
    }
}

impl ::protobuf::Message for InstanceIP {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.spec {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.spec)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.spec.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> InstanceIP {
        InstanceIP::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::meta::ObjectMeta>>(
                "metadata",
                |m: &InstanceIP| { &m.metadata },
                |m: &mut InstanceIP| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<InstanceIPSpec>>(
                "spec",
                |m: &InstanceIP| { &m.spec },
                |m: &mut InstanceIP| { &mut m.spec },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<InstanceIPStatus>>(
                "status",
                |m: &InstanceIP| { &m.status },
                |m: &mut InstanceIP| { &mut m.status },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<InstanceIP>(
                "InstanceIP",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static InstanceIP {
        static instance: ::protobuf::rt::LazyV2<InstanceIP> = ::protobuf::rt::LazyV2::INIT;
        instance.get(InstanceIP::new)
    }
}

impl ::protobuf::Clear for InstanceIP {
    fn clear(&mut self) {
        self.metadata.clear();
        self.spec.clear();
        self.status.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for InstanceIP {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InstanceIP {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct InstanceIPList {
    // message fields
    pub metadata: ::protobuf::SingularPtrField<super::meta::ListMeta>,
    pub items: ::protobuf::RepeatedField<InstanceIP>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a InstanceIPList {
    fn default() -> &'a InstanceIPList {
        <InstanceIPList as ::protobuf::Message>::default_instance()
    }
}

impl InstanceIPList {
    pub fn new() -> InstanceIPList {
        ::std::default::Default::default()
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;


    pub fn get_metadata(&self) -> &super::meta::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <super::meta::ListMeta as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::meta::ListMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::meta::ListMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::meta::ListMeta {
        self.metadata.take().unwrap_or_else(|| super::meta::ListMeta::new())
    }

    // repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.InstanceIP items = 2;


    pub fn get_items(&self) -> &[InstanceIP] {
        &self.items
    }
    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::protobuf::RepeatedField<InstanceIP>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::protobuf::RepeatedField<InstanceIP> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::protobuf::RepeatedField<InstanceIP> {
        ::std::mem::replace(&mut self.items, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for InstanceIPList {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.items {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.items)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.items {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> InstanceIPList {
        InstanceIPList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::meta::ListMeta>>(
                "metadata",
                |m: &InstanceIPList| { &m.metadata },
                |m: &mut InstanceIPList| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<InstanceIP>>(
                "items",
                |m: &InstanceIPList| { &m.items },
                |m: &mut InstanceIPList| { &mut m.items },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<InstanceIPList>(
                "InstanceIPList",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static InstanceIPList {
        static instance: ::protobuf::rt::LazyV2<InstanceIPList> = ::protobuf::rt::LazyV2::INIT;
        instance.get(InstanceIPList::new)
    }
}

impl ::protobuf::Clear for InstanceIPList {
    fn clear(&mut self) {
        self.metadata.clear();
        self.items.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for InstanceIPList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InstanceIPList {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct InstanceIPSpec {
    // message fields
    pub commonSpec: ::protobuf::SingularPtrField<CommonSpec>,
    instanceIPAddress: ::protobuf::SingularField<::std::string::String>,
    instanceIPFamily: ::protobuf::SingularField<::std::string::String>,
    cidr: ::protobuf::SingularField<::std::string::String>,
    pub virtualNetworkReference: ::protobuf::SingularPtrField<ResourceReference>,
    pub virtualMachineInterfaceReferences: ::protobuf::RepeatedField<ResourceReference>,
    pub ipRangeKeys: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a InstanceIPSpec {
    fn default() -> &'a InstanceIPSpec {
        <InstanceIPSpec as ::protobuf::Message>::default_instance()
    }
}

impl InstanceIPSpec {
    pub fn new() -> InstanceIPSpec {
        ::std::default::Default::default()
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonSpec commonSpec = 1;


    pub fn get_commonSpec(&self) -> &CommonSpec {
        self.commonSpec.as_ref().unwrap_or_else(|| <CommonSpec as ::protobuf::Message>::default_instance())
    }
    pub fn clear_commonSpec(&mut self) {
        self.commonSpec.clear();
    }

    pub fn has_commonSpec(&self) -> bool {
        self.commonSpec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_commonSpec(&mut self, v: CommonSpec) {
        self.commonSpec = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_commonSpec(&mut self) -> &mut CommonSpec {
        if self.commonSpec.is_none() {
            self.commonSpec.set_default();
        }
        self.commonSpec.as_mut().unwrap()
    }

    // Take field
    pub fn take_commonSpec(&mut self) -> CommonSpec {
        self.commonSpec.take().unwrap_or_else(|| CommonSpec::new())
    }

    // optional string instanceIPAddress = 2;


    pub fn get_instanceIPAddress(&self) -> &str {
        match self.instanceIPAddress.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_instanceIPAddress(&mut self) {
        self.instanceIPAddress.clear();
    }

    pub fn has_instanceIPAddress(&self) -> bool {
        self.instanceIPAddress.is_some()
    }

    // Param is passed by value, moved
    pub fn set_instanceIPAddress(&mut self, v: ::std::string::String) {
        self.instanceIPAddress = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_instanceIPAddress(&mut self) -> &mut ::std::string::String {
        if self.instanceIPAddress.is_none() {
            self.instanceIPAddress.set_default();
        }
        self.instanceIPAddress.as_mut().unwrap()
    }

    // Take field
    pub fn take_instanceIPAddress(&mut self) -> ::std::string::String {
        self.instanceIPAddress.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string instanceIPFamily = 3;


    pub fn get_instanceIPFamily(&self) -> &str {
        match self.instanceIPFamily.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_instanceIPFamily(&mut self) {
        self.instanceIPFamily.clear();
    }

    pub fn has_instanceIPFamily(&self) -> bool {
        self.instanceIPFamily.is_some()
    }

    // Param is passed by value, moved
    pub fn set_instanceIPFamily(&mut self, v: ::std::string::String) {
        self.instanceIPFamily = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_instanceIPFamily(&mut self) -> &mut ::std::string::String {
        if self.instanceIPFamily.is_none() {
            self.instanceIPFamily.set_default();
        }
        self.instanceIPFamily.as_mut().unwrap()
    }

    // Take field
    pub fn take_instanceIPFamily(&mut self) -> ::std::string::String {
        self.instanceIPFamily.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string cidr = 4;


    pub fn get_cidr(&self) -> &str {
        match self.cidr.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_cidr(&mut self) {
        self.cidr.clear();
    }

    pub fn has_cidr(&self) -> bool {
        self.cidr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cidr(&mut self, v: ::std::string::String) {
        self.cidr = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cidr(&mut self) -> &mut ::std::string::String {
        if self.cidr.is_none() {
            self.cidr.set_default();
        }
        self.cidr.as_mut().unwrap()
    }

    // Take field
    pub fn take_cidr(&mut self) -> ::std::string::String {
        self.cidr.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ResourceReference virtualNetworkReference = 5;


    pub fn get_virtualNetworkReference(&self) -> &ResourceReference {
        self.virtualNetworkReference.as_ref().unwrap_or_else(|| <ResourceReference as ::protobuf::Message>::default_instance())
    }
    pub fn clear_virtualNetworkReference(&mut self) {
        self.virtualNetworkReference.clear();
    }

    pub fn has_virtualNetworkReference(&self) -> bool {
        self.virtualNetworkReference.is_some()
    }

    // Param is passed by value, moved
    pub fn set_virtualNetworkReference(&mut self, v: ResourceReference) {
        self.virtualNetworkReference = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_virtualNetworkReference(&mut self) -> &mut ResourceReference {
        if self.virtualNetworkReference.is_none() {
            self.virtualNetworkReference.set_default();
        }
        self.virtualNetworkReference.as_mut().unwrap()
    }

    // Take field
    pub fn take_virtualNetworkReference(&mut self) -> ResourceReference {
        self.virtualNetworkReference.take().unwrap_or_else(|| ResourceReference::new())
    }

    // repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ResourceReference virtualMachineInterfaceReferences = 6;


    pub fn get_virtualMachineInterfaceReferences(&self) -> &[ResourceReference] {
        &self.virtualMachineInterfaceReferences
    }
    pub fn clear_virtualMachineInterfaceReferences(&mut self) {
        self.virtualMachineInterfaceReferences.clear();
    }

    // Param is passed by value, moved
    pub fn set_virtualMachineInterfaceReferences(&mut self, v: ::protobuf::RepeatedField<ResourceReference>) {
        self.virtualMachineInterfaceReferences = v;
    }

    // Mutable pointer to the field.
    pub fn mut_virtualMachineInterfaceReferences(&mut self) -> &mut ::protobuf::RepeatedField<ResourceReference> {
        &mut self.virtualMachineInterfaceReferences
    }

    // Take field
    pub fn take_virtualMachineInterfaceReferences(&mut self) -> ::protobuf::RepeatedField<ResourceReference> {
        ::std::mem::replace(&mut self.virtualMachineInterfaceReferences, ::protobuf::RepeatedField::new())
    }

    // repeated string ipRangeKeys = 7;


    pub fn get_ipRangeKeys(&self) -> &[::std::string::String] {
        &self.ipRangeKeys
    }
    pub fn clear_ipRangeKeys(&mut self) {
        self.ipRangeKeys.clear();
    }

    // Param is passed by value, moved
    pub fn set_ipRangeKeys(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.ipRangeKeys = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ipRangeKeys(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.ipRangeKeys
    }

    // Take field
    pub fn take_ipRangeKeys(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.ipRangeKeys, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for InstanceIPSpec {
    fn is_initialized(&self) -> bool {
        for v in &self.commonSpec {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.virtualNetworkReference {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.virtualMachineInterfaceReferences {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.commonSpec)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.instanceIPAddress)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.instanceIPFamily)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.cidr)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.virtualNetworkReference)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.virtualMachineInterfaceReferences)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.ipRangeKeys)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.commonSpec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.instanceIPAddress.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.instanceIPFamily.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.cidr.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.virtualNetworkReference.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.virtualMachineInterfaceReferences {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.ipRangeKeys {
            my_size += ::protobuf::rt::string_size(7, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.commonSpec.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.instanceIPAddress.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.instanceIPFamily.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.cidr.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.virtualNetworkReference.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.virtualMachineInterfaceReferences {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.ipRangeKeys {
            os.write_string(7, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> InstanceIPSpec {
        InstanceIPSpec::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommonSpec>>(
                "commonSpec",
                |m: &InstanceIPSpec| { &m.commonSpec },
                |m: &mut InstanceIPSpec| { &mut m.commonSpec },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "instanceIPAddress",
                |m: &InstanceIPSpec| { &m.instanceIPAddress },
                |m: &mut InstanceIPSpec| { &mut m.instanceIPAddress },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "instanceIPFamily",
                |m: &InstanceIPSpec| { &m.instanceIPFamily },
                |m: &mut InstanceIPSpec| { &mut m.instanceIPFamily },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "cidr",
                |m: &InstanceIPSpec| { &m.cidr },
                |m: &mut InstanceIPSpec| { &mut m.cidr },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResourceReference>>(
                "virtualNetworkReference",
                |m: &InstanceIPSpec| { &m.virtualNetworkReference },
                |m: &mut InstanceIPSpec| { &mut m.virtualNetworkReference },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResourceReference>>(
                "virtualMachineInterfaceReferences",
                |m: &InstanceIPSpec| { &m.virtualMachineInterfaceReferences },
                |m: &mut InstanceIPSpec| { &mut m.virtualMachineInterfaceReferences },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "ipRangeKeys",
                |m: &InstanceIPSpec| { &m.ipRangeKeys },
                |m: &mut InstanceIPSpec| { &mut m.ipRangeKeys },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<InstanceIPSpec>(
                "InstanceIPSpec",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static InstanceIPSpec {
        static instance: ::protobuf::rt::LazyV2<InstanceIPSpec> = ::protobuf::rt::LazyV2::INIT;
        instance.get(InstanceIPSpec::new)
    }
}

impl ::protobuf::Clear for InstanceIPSpec {
    fn clear(&mut self) {
        self.commonSpec.clear();
        self.instanceIPAddress.clear();
        self.instanceIPFamily.clear();
        self.cidr.clear();
        self.virtualNetworkReference.clear();
        self.virtualMachineInterfaceReferences.clear();
        self.ipRangeKeys.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for InstanceIPSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InstanceIPSpec {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct InstanceIPStatus {
    // message fields
    pub commonStatus: ::protobuf::SingularPtrField<CommonStatus>,
    pub subnetReference: ::protobuf::SingularPtrField<ResourceReference>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a InstanceIPStatus {
    fn default() -> &'a InstanceIPStatus {
        <InstanceIPStatus as ::protobuf::Message>::default_instance()
    }
}

impl InstanceIPStatus {
    pub fn new() -> InstanceIPStatus {
        ::std::default::Default::default()
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonStatus commonStatus = 1;


    pub fn get_commonStatus(&self) -> &CommonStatus {
        self.commonStatus.as_ref().unwrap_or_else(|| <CommonStatus as ::protobuf::Message>::default_instance())
    }
    pub fn clear_commonStatus(&mut self) {
        self.commonStatus.clear();
    }

    pub fn has_commonStatus(&self) -> bool {
        self.commonStatus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_commonStatus(&mut self, v: CommonStatus) {
        self.commonStatus = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_commonStatus(&mut self) -> &mut CommonStatus {
        if self.commonStatus.is_none() {
            self.commonStatus.set_default();
        }
        self.commonStatus.as_mut().unwrap()
    }

    // Take field
    pub fn take_commonStatus(&mut self) -> CommonStatus {
        self.commonStatus.take().unwrap_or_else(|| CommonStatus::new())
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ResourceReference subnetReference = 2;


    pub fn get_subnetReference(&self) -> &ResourceReference {
        self.subnetReference.as_ref().unwrap_or_else(|| <ResourceReference as ::protobuf::Message>::default_instance())
    }
    pub fn clear_subnetReference(&mut self) {
        self.subnetReference.clear();
    }

    pub fn has_subnetReference(&self) -> bool {
        self.subnetReference.is_some()
    }

    // Param is passed by value, moved
    pub fn set_subnetReference(&mut self, v: ResourceReference) {
        self.subnetReference = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_subnetReference(&mut self) -> &mut ResourceReference {
        if self.subnetReference.is_none() {
            self.subnetReference.set_default();
        }
        self.subnetReference.as_mut().unwrap()
    }

    // Take field
    pub fn take_subnetReference(&mut self) -> ResourceReference {
        self.subnetReference.take().unwrap_or_else(|| ResourceReference::new())
    }
}

impl ::protobuf::Message for InstanceIPStatus {
    fn is_initialized(&self) -> bool {
        for v in &self.commonStatus {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.subnetReference {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.commonStatus)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.subnetReference)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.commonStatus.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.subnetReference.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.commonStatus.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.subnetReference.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> InstanceIPStatus {
        InstanceIPStatus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommonStatus>>(
                "commonStatus",
                |m: &InstanceIPStatus| { &m.commonStatus },
                |m: &mut InstanceIPStatus| { &mut m.commonStatus },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResourceReference>>(
                "subnetReference",
                |m: &InstanceIPStatus| { &m.subnetReference },
                |m: &mut InstanceIPStatus| { &mut m.subnetReference },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<InstanceIPStatus>(
                "InstanceIPStatus",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static InstanceIPStatus {
        static instance: ::protobuf::rt::LazyV2<InstanceIPStatus> = ::protobuf::rt::LazyV2::INIT;
        instance.get(InstanceIPStatus::new)
    }
}

impl ::protobuf::Clear for InstanceIPStatus {
    fn clear(&mut self) {
        self.commonStatus.clear();
        self.subnetReference.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for InstanceIPStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InstanceIPStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LinklocalServiceEntryType {
    // message fields
    ipFabricDNSServiceName: ::protobuf::SingularField<::std::string::String>,
    pub ipFabricServiceIP: ::protobuf::RepeatedField<::std::string::String>,
    ipFabricServicePort: ::std::option::Option<i32>,
    linklocalServiceIP: ::protobuf::SingularField<::std::string::String>,
    linklocalServiceName: ::protobuf::SingularField<::std::string::String>,
    linklocalServicePort: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LinklocalServiceEntryType {
    fn default() -> &'a LinklocalServiceEntryType {
        <LinklocalServiceEntryType as ::protobuf::Message>::default_instance()
    }
}

impl LinklocalServiceEntryType {
    pub fn new() -> LinklocalServiceEntryType {
        ::std::default::Default::default()
    }

    // optional string ipFabricDNSServiceName = 1;


    pub fn get_ipFabricDNSServiceName(&self) -> &str {
        match self.ipFabricDNSServiceName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_ipFabricDNSServiceName(&mut self) {
        self.ipFabricDNSServiceName.clear();
    }

    pub fn has_ipFabricDNSServiceName(&self) -> bool {
        self.ipFabricDNSServiceName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ipFabricDNSServiceName(&mut self, v: ::std::string::String) {
        self.ipFabricDNSServiceName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ipFabricDNSServiceName(&mut self) -> &mut ::std::string::String {
        if self.ipFabricDNSServiceName.is_none() {
            self.ipFabricDNSServiceName.set_default();
        }
        self.ipFabricDNSServiceName.as_mut().unwrap()
    }

    // Take field
    pub fn take_ipFabricDNSServiceName(&mut self) -> ::std::string::String {
        self.ipFabricDNSServiceName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated string ipFabricServiceIP = 2;


    pub fn get_ipFabricServiceIP(&self) -> &[::std::string::String] {
        &self.ipFabricServiceIP
    }
    pub fn clear_ipFabricServiceIP(&mut self) {
        self.ipFabricServiceIP.clear();
    }

    // Param is passed by value, moved
    pub fn set_ipFabricServiceIP(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.ipFabricServiceIP = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ipFabricServiceIP(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.ipFabricServiceIP
    }

    // Take field
    pub fn take_ipFabricServiceIP(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.ipFabricServiceIP, ::protobuf::RepeatedField::new())
    }

    // optional int32 ipFabricServicePort = 3;


    pub fn get_ipFabricServicePort(&self) -> i32 {
        self.ipFabricServicePort.unwrap_or(0)
    }
    pub fn clear_ipFabricServicePort(&mut self) {
        self.ipFabricServicePort = ::std::option::Option::None;
    }

    pub fn has_ipFabricServicePort(&self) -> bool {
        self.ipFabricServicePort.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ipFabricServicePort(&mut self, v: i32) {
        self.ipFabricServicePort = ::std::option::Option::Some(v);
    }

    // optional string linklocalServiceIP = 4;


    pub fn get_linklocalServiceIP(&self) -> &str {
        match self.linklocalServiceIP.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_linklocalServiceIP(&mut self) {
        self.linklocalServiceIP.clear();
    }

    pub fn has_linklocalServiceIP(&self) -> bool {
        self.linklocalServiceIP.is_some()
    }

    // Param is passed by value, moved
    pub fn set_linklocalServiceIP(&mut self, v: ::std::string::String) {
        self.linklocalServiceIP = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_linklocalServiceIP(&mut self) -> &mut ::std::string::String {
        if self.linklocalServiceIP.is_none() {
            self.linklocalServiceIP.set_default();
        }
        self.linklocalServiceIP.as_mut().unwrap()
    }

    // Take field
    pub fn take_linklocalServiceIP(&mut self) -> ::std::string::String {
        self.linklocalServiceIP.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string linklocalServiceName = 5;


    pub fn get_linklocalServiceName(&self) -> &str {
        match self.linklocalServiceName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_linklocalServiceName(&mut self) {
        self.linklocalServiceName.clear();
    }

    pub fn has_linklocalServiceName(&self) -> bool {
        self.linklocalServiceName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_linklocalServiceName(&mut self, v: ::std::string::String) {
        self.linklocalServiceName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_linklocalServiceName(&mut self) -> &mut ::std::string::String {
        if self.linklocalServiceName.is_none() {
            self.linklocalServiceName.set_default();
        }
        self.linklocalServiceName.as_mut().unwrap()
    }

    // Take field
    pub fn take_linklocalServiceName(&mut self) -> ::std::string::String {
        self.linklocalServiceName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int32 linklocalServicePort = 6;


    pub fn get_linklocalServicePort(&self) -> i32 {
        self.linklocalServicePort.unwrap_or(0)
    }
    pub fn clear_linklocalServicePort(&mut self) {
        self.linklocalServicePort = ::std::option::Option::None;
    }

    pub fn has_linklocalServicePort(&self) -> bool {
        self.linklocalServicePort.is_some()
    }

    // Param is passed by value, moved
    pub fn set_linklocalServicePort(&mut self, v: i32) {
        self.linklocalServicePort = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for LinklocalServiceEntryType {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.ipFabricDNSServiceName)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.ipFabricServiceIP)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.ipFabricServicePort = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.linklocalServiceIP)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.linklocalServiceName)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.linklocalServicePort = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.ipFabricDNSServiceName.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.ipFabricServiceIP {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        if let Some(v) = self.ipFabricServicePort {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.linklocalServiceIP.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.linklocalServiceName.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(v) = self.linklocalServicePort {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.ipFabricDNSServiceName.as_ref() {
            os.write_string(1, &v)?;
        }
        for v in &self.ipFabricServiceIP {
            os.write_string(2, &v)?;
        };
        if let Some(v) = self.ipFabricServicePort {
            os.write_int32(3, v)?;
        }
        if let Some(ref v) = self.linklocalServiceIP.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.linklocalServiceName.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(v) = self.linklocalServicePort {
            os.write_int32(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LinklocalServiceEntryType {
        LinklocalServiceEntryType::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "ipFabricDNSServiceName",
                |m: &LinklocalServiceEntryType| { &m.ipFabricDNSServiceName },
                |m: &mut LinklocalServiceEntryType| { &mut m.ipFabricDNSServiceName },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "ipFabricServiceIP",
                |m: &LinklocalServiceEntryType| { &m.ipFabricServiceIP },
                |m: &mut LinklocalServiceEntryType| { &mut m.ipFabricServiceIP },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "ipFabricServicePort",
                |m: &LinklocalServiceEntryType| { &m.ipFabricServicePort },
                |m: &mut LinklocalServiceEntryType| { &mut m.ipFabricServicePort },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "linklocalServiceIP",
                |m: &LinklocalServiceEntryType| { &m.linklocalServiceIP },
                |m: &mut LinklocalServiceEntryType| { &mut m.linklocalServiceIP },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "linklocalServiceName",
                |m: &LinklocalServiceEntryType| { &m.linklocalServiceName },
                |m: &mut LinklocalServiceEntryType| { &mut m.linklocalServiceName },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "linklocalServicePort",
                |m: &LinklocalServiceEntryType| { &m.linklocalServicePort },
                |m: &mut LinklocalServiceEntryType| { &mut m.linklocalServicePort },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LinklocalServiceEntryType>(
                "LinklocalServiceEntryType",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LinklocalServiceEntryType {
        static instance: ::protobuf::rt::LazyV2<LinklocalServiceEntryType> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LinklocalServiceEntryType::new)
    }
}

impl ::protobuf::Clear for LinklocalServiceEntryType {
    fn clear(&mut self) {
        self.ipFabricDNSServiceName.clear();
        self.ipFabricServiceIP.clear();
        self.ipFabricServicePort = ::std::option::Option::None;
        self.linklocalServiceIP.clear();
        self.linklocalServiceName.clear();
        self.linklocalServicePort = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LinklocalServiceEntryType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LinklocalServiceEntryType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LinklocalServices {
    // message fields
    pub linklocalServiceEntry: ::protobuf::RepeatedField<LinklocalServiceEntryType>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LinklocalServices {
    fn default() -> &'a LinklocalServices {
        <LinklocalServices as ::protobuf::Message>::default_instance()
    }
}

impl LinklocalServices {
    pub fn new() -> LinklocalServices {
        ::std::default::Default::default()
    }

    // repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.LinklocalServiceEntryType linklocalServiceEntry = 1;


    pub fn get_linklocalServiceEntry(&self) -> &[LinklocalServiceEntryType] {
        &self.linklocalServiceEntry
    }
    pub fn clear_linklocalServiceEntry(&mut self) {
        self.linklocalServiceEntry.clear();
    }

    // Param is passed by value, moved
    pub fn set_linklocalServiceEntry(&mut self, v: ::protobuf::RepeatedField<LinklocalServiceEntryType>) {
        self.linklocalServiceEntry = v;
    }

    // Mutable pointer to the field.
    pub fn mut_linklocalServiceEntry(&mut self) -> &mut ::protobuf::RepeatedField<LinklocalServiceEntryType> {
        &mut self.linklocalServiceEntry
    }

    // Take field
    pub fn take_linklocalServiceEntry(&mut self) -> ::protobuf::RepeatedField<LinklocalServiceEntryType> {
        ::std::mem::replace(&mut self.linklocalServiceEntry, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for LinklocalServices {
    fn is_initialized(&self) -> bool {
        for v in &self.linklocalServiceEntry {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.linklocalServiceEntry)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.linklocalServiceEntry {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.linklocalServiceEntry {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LinklocalServices {
        LinklocalServices::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LinklocalServiceEntryType>>(
                "linklocalServiceEntry",
                |m: &LinklocalServices| { &m.linklocalServiceEntry },
                |m: &mut LinklocalServices| { &mut m.linklocalServiceEntry },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LinklocalServices>(
                "LinklocalServices",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LinklocalServices {
        static instance: ::protobuf::rt::LazyV2<LinklocalServices> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LinklocalServices::new)
    }
}

impl ::protobuf::Clear for LinklocalServices {
    fn clear(&mut self) {
        self.linklocalServiceEntry.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LinklocalServices {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LinklocalServices {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MACAddresses {
    // message fields
    pub macAddress: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MACAddresses {
    fn default() -> &'a MACAddresses {
        <MACAddresses as ::protobuf::Message>::default_instance()
    }
}

impl MACAddresses {
    pub fn new() -> MACAddresses {
        ::std::default::Default::default()
    }

    // repeated string macAddress = 1;


    pub fn get_macAddress(&self) -> &[::std::string::String] {
        &self.macAddress
    }
    pub fn clear_macAddress(&mut self) {
        self.macAddress.clear();
    }

    // Param is passed by value, moved
    pub fn set_macAddress(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.macAddress = v;
    }

    // Mutable pointer to the field.
    pub fn mut_macAddress(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.macAddress
    }

    // Take field
    pub fn take_macAddress(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.macAddress, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for MACAddresses {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.macAddress)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.macAddress {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.macAddress {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MACAddresses {
        MACAddresses::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "macAddress",
                |m: &MACAddresses| { &m.macAddress },
                |m: &mut MACAddresses| { &mut m.macAddress },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MACAddresses>(
                "MACAddresses",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MACAddresses {
        static instance: ::protobuf::rt::LazyV2<MACAddresses> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MACAddresses::new)
    }
}

impl ::protobuf::Clear for MACAddresses {
    fn clear(&mut self) {
        self.macAddress.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MACAddresses {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MACAddresses {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PolicyBasedForwardingRule {
    // message fields
    direction: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PolicyBasedForwardingRule {
    fn default() -> &'a PolicyBasedForwardingRule {
        <PolicyBasedForwardingRule as ::protobuf::Message>::default_instance()
    }
}

impl PolicyBasedForwardingRule {
    pub fn new() -> PolicyBasedForwardingRule {
        ::std::default::Default::default()
    }

    // optional string direction = 1;


    pub fn get_direction(&self) -> &str {
        match self.direction.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_direction(&mut self) {
        self.direction.clear();
    }

    pub fn has_direction(&self) -> bool {
        self.direction.is_some()
    }

    // Param is passed by value, moved
    pub fn set_direction(&mut self, v: ::std::string::String) {
        self.direction = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_direction(&mut self) -> &mut ::std::string::String {
        if self.direction.is_none() {
            self.direction.set_default();
        }
        self.direction.as_mut().unwrap()
    }

    // Take field
    pub fn take_direction(&mut self) -> ::std::string::String {
        self.direction.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for PolicyBasedForwardingRule {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.direction)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.direction.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.direction.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PolicyBasedForwardingRule {
        PolicyBasedForwardingRule::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "direction",
                |m: &PolicyBasedForwardingRule| { &m.direction },
                |m: &mut PolicyBasedForwardingRule| { &mut m.direction },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PolicyBasedForwardingRule>(
                "PolicyBasedForwardingRule",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PolicyBasedForwardingRule {
        static instance: ::protobuf::rt::LazyV2<PolicyBasedForwardingRule> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PolicyBasedForwardingRule::new)
    }
}

impl ::protobuf::Clear for PolicyBasedForwardingRule {
    fn clear(&mut self) {
        self.direction.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PolicyBasedForwardingRule {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PolicyBasedForwardingRule {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PortRange {
    // message fields
    startPort: ::std::option::Option<i32>,
    endPort: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PortRange {
    fn default() -> &'a PortRange {
        <PortRange as ::protobuf::Message>::default_instance()
    }
}

impl PortRange {
    pub fn new() -> PortRange {
        ::std::default::Default::default()
    }

    // optional int32 startPort = 1;


    pub fn get_startPort(&self) -> i32 {
        self.startPort.unwrap_or(0)
    }
    pub fn clear_startPort(&mut self) {
        self.startPort = ::std::option::Option::None;
    }

    pub fn has_startPort(&self) -> bool {
        self.startPort.is_some()
    }

    // Param is passed by value, moved
    pub fn set_startPort(&mut self, v: i32) {
        self.startPort = ::std::option::Option::Some(v);
    }

    // optional int32 endPort = 2;


    pub fn get_endPort(&self) -> i32 {
        self.endPort.unwrap_or(0)
    }
    pub fn clear_endPort(&mut self) {
        self.endPort = ::std::option::Option::None;
    }

    pub fn has_endPort(&self) -> bool {
        self.endPort.is_some()
    }

    // Param is passed by value, moved
    pub fn set_endPort(&mut self, v: i32) {
        self.endPort = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for PortRange {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.startPort = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.endPort = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.startPort {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.endPort {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.startPort {
            os.write_int32(1, v)?;
        }
        if let Some(v) = self.endPort {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PortRange {
        PortRange::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "startPort",
                |m: &PortRange| { &m.startPort },
                |m: &mut PortRange| { &mut m.startPort },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "endPort",
                |m: &PortRange| { &m.endPort },
                |m: &mut PortRange| { &mut m.endPort },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PortRange>(
                "PortRange",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PortRange {
        static instance: ::protobuf::rt::LazyV2<PortRange> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PortRange::new)
    }
}

impl ::protobuf::Clear for PortRange {
    fn clear(&mut self) {
        self.startPort = ::std::option::Option::None;
        self.endPort = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PortRange {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PortRange {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PortTranslationPool {
    // message fields
    protocol: ::protobuf::SingularField<::std::string::String>,
    pub portRange: ::protobuf::SingularPtrField<PortRange>,
    portCount: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PortTranslationPool {
    fn default() -> &'a PortTranslationPool {
        <PortTranslationPool as ::protobuf::Message>::default_instance()
    }
}

impl PortTranslationPool {
    pub fn new() -> PortTranslationPool {
        ::std::default::Default::default()
    }

    // optional string protocol = 1;


    pub fn get_protocol(&self) -> &str {
        match self.protocol.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_protocol(&mut self) {
        self.protocol.clear();
    }

    pub fn has_protocol(&self) -> bool {
        self.protocol.is_some()
    }

    // Param is passed by value, moved
    pub fn set_protocol(&mut self, v: ::std::string::String) {
        self.protocol = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_protocol(&mut self) -> &mut ::std::string::String {
        if self.protocol.is_none() {
            self.protocol.set_default();
        }
        self.protocol.as_mut().unwrap()
    }

    // Take field
    pub fn take_protocol(&mut self) -> ::std::string::String {
        self.protocol.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.PortRange portRange = 2;


    pub fn get_portRange(&self) -> &PortRange {
        self.portRange.as_ref().unwrap_or_else(|| <PortRange as ::protobuf::Message>::default_instance())
    }
    pub fn clear_portRange(&mut self) {
        self.portRange.clear();
    }

    pub fn has_portRange(&self) -> bool {
        self.portRange.is_some()
    }

    // Param is passed by value, moved
    pub fn set_portRange(&mut self, v: PortRange) {
        self.portRange = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_portRange(&mut self) -> &mut PortRange {
        if self.portRange.is_none() {
            self.portRange.set_default();
        }
        self.portRange.as_mut().unwrap()
    }

    // Take field
    pub fn take_portRange(&mut self) -> PortRange {
        self.portRange.take().unwrap_or_else(|| PortRange::new())
    }

    // optional int32 portCount = 3;


    pub fn get_portCount(&self) -> i32 {
        self.portCount.unwrap_or(0)
    }
    pub fn clear_portCount(&mut self) {
        self.portCount = ::std::option::Option::None;
    }

    pub fn has_portCount(&self) -> bool {
        self.portCount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_portCount(&mut self, v: i32) {
        self.portCount = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for PortTranslationPool {
    fn is_initialized(&self) -> bool {
        for v in &self.portRange {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.protocol)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.portRange)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.portCount = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.protocol.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.portRange.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.portCount {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.protocol.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.portRange.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.portCount {
            os.write_int32(3, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PortTranslationPool {
        PortTranslationPool::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "protocol",
                |m: &PortTranslationPool| { &m.protocol },
                |m: &mut PortTranslationPool| { &mut m.protocol },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PortRange>>(
                "portRange",
                |m: &PortTranslationPool| { &m.portRange },
                |m: &mut PortTranslationPool| { &mut m.portRange },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "portCount",
                |m: &PortTranslationPool| { &m.portCount },
                |m: &mut PortTranslationPool| { &mut m.portCount },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PortTranslationPool>(
                "PortTranslationPool",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PortTranslationPool {
        static instance: ::protobuf::rt::LazyV2<PortTranslationPool> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PortTranslationPool::new)
    }
}

impl ::protobuf::Clear for PortTranslationPool {
    fn clear(&mut self) {
        self.protocol.clear();
        self.portRange.clear();
        self.portCount = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PortTranslationPool {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PortTranslationPool {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PortTranslationPools {
    // message fields
    pub pools: ::protobuf::RepeatedField<PortTranslationPool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PortTranslationPools {
    fn default() -> &'a PortTranslationPools {
        <PortTranslationPools as ::protobuf::Message>::default_instance()
    }
}

impl PortTranslationPools {
    pub fn new() -> PortTranslationPools {
        ::std::default::Default::default()
    }

    // repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.PortTranslationPool pools = 1;


    pub fn get_pools(&self) -> &[PortTranslationPool] {
        &self.pools
    }
    pub fn clear_pools(&mut self) {
        self.pools.clear();
    }

    // Param is passed by value, moved
    pub fn set_pools(&mut self, v: ::protobuf::RepeatedField<PortTranslationPool>) {
        self.pools = v;
    }

    // Mutable pointer to the field.
    pub fn mut_pools(&mut self) -> &mut ::protobuf::RepeatedField<PortTranslationPool> {
        &mut self.pools
    }

    // Take field
    pub fn take_pools(&mut self) -> ::protobuf::RepeatedField<PortTranslationPool> {
        ::std::mem::replace(&mut self.pools, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PortTranslationPools {
    fn is_initialized(&self) -> bool {
        for v in &self.pools {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.pools)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.pools {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.pools {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PortTranslationPools {
        PortTranslationPools::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PortTranslationPool>>(
                "pools",
                |m: &PortTranslationPools| { &m.pools },
                |m: &mut PortTranslationPools| { &mut m.pools },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PortTranslationPools>(
                "PortTranslationPools",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PortTranslationPools {
        static instance: ::protobuf::rt::LazyV2<PortTranslationPools> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PortTranslationPools::new)
    }
}

impl ::protobuf::Clear for PortTranslationPools {
    fn clear(&mut self) {
        self.pools.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PortTranslationPools {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PortTranslationPools {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PortType {
    // message fields
    startPort: ::std::option::Option<i64>,
    endPort: ::std::option::Option<i64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PortType {
    fn default() -> &'a PortType {
        <PortType as ::protobuf::Message>::default_instance()
    }
}

impl PortType {
    pub fn new() -> PortType {
        ::std::default::Default::default()
    }

    // optional int64 startPort = 1;


    pub fn get_startPort(&self) -> i64 {
        self.startPort.unwrap_or(0)
    }
    pub fn clear_startPort(&mut self) {
        self.startPort = ::std::option::Option::None;
    }

    pub fn has_startPort(&self) -> bool {
        self.startPort.is_some()
    }

    // Param is passed by value, moved
    pub fn set_startPort(&mut self, v: i64) {
        self.startPort = ::std::option::Option::Some(v);
    }

    // optional int64 endPort = 2;


    pub fn get_endPort(&self) -> i64 {
        self.endPort.unwrap_or(0)
    }
    pub fn clear_endPort(&mut self) {
        self.endPort = ::std::option::Option::None;
    }

    pub fn has_endPort(&self) -> bool {
        self.endPort.is_some()
    }

    // Param is passed by value, moved
    pub fn set_endPort(&mut self, v: i64) {
        self.endPort = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for PortType {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.startPort = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.endPort = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.startPort {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.endPort {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.startPort {
            os.write_int64(1, v)?;
        }
        if let Some(v) = self.endPort {
            os.write_int64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PortType {
        PortType::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "startPort",
                |m: &PortType| { &m.startPort },
                |m: &mut PortType| { &mut m.startPort },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "endPort",
                |m: &PortType| { &m.endPort },
                |m: &mut PortType| { &mut m.endPort },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PortType>(
                "PortType",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PortType {
        static instance: ::protobuf::rt::LazyV2<PortType> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PortType::new)
    }
}

impl ::protobuf::Clear for PortType {
    fn clear(&mut self) {
        self.startPort = ::std::option::Option::None;
        self.endPort = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PortType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PortType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Range {
    // message fields
    key: ::protobuf::SingularField<::std::string::String>,
    pub ipRanges: ::protobuf::RepeatedField<IPRange>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Range {
    fn default() -> &'a Range {
        <Range as ::protobuf::Message>::default_instance()
    }
}

impl Range {
    pub fn new() -> Range {
        ::std::default::Default::default()
    }

    // optional string key = 1;


    pub fn get_key(&self) -> &str {
        match self.key.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        if self.key.is_none() {
            self.key.set_default();
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        self.key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.IPRange ipRanges = 2;


    pub fn get_ipRanges(&self) -> &[IPRange] {
        &self.ipRanges
    }
    pub fn clear_ipRanges(&mut self) {
        self.ipRanges.clear();
    }

    // Param is passed by value, moved
    pub fn set_ipRanges(&mut self, v: ::protobuf::RepeatedField<IPRange>) {
        self.ipRanges = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ipRanges(&mut self) -> &mut ::protobuf::RepeatedField<IPRange> {
        &mut self.ipRanges
    }

    // Take field
    pub fn take_ipRanges(&mut self) -> ::protobuf::RepeatedField<IPRange> {
        ::std::mem::replace(&mut self.ipRanges, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Range {
    fn is_initialized(&self) -> bool {
        for v in &self.ipRanges {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.ipRanges)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.key.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.ipRanges {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.key.as_ref() {
            os.write_string(1, &v)?;
        }
        for v in &self.ipRanges {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Range {
        Range::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "key",
                |m: &Range| { &m.key },
                |m: &mut Range| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<IPRange>>(
                "ipRanges",
                |m: &Range| { &m.ipRanges },
                |m: &mut Range| { &mut m.ipRanges },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Range>(
                "Range",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Range {
        static instance: ::protobuf::rt::LazyV2<Range> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Range::new)
    }
}

impl ::protobuf::Clear for Range {
    fn clear(&mut self) {
        self.key.clear();
        self.ipRanges.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Range {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Range {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ReconcilerState {
    // message fields
    state: ::protobuf::SingularField<::std::string::String>,
    observation: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ReconcilerState {
    fn default() -> &'a ReconcilerState {
        <ReconcilerState as ::protobuf::Message>::default_instance()
    }
}

impl ReconcilerState {
    pub fn new() -> ReconcilerState {
        ::std::default::Default::default()
    }

    // optional string state = 1;


    pub fn get_state(&self) -> &str {
        match self.state.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_state(&mut self) {
        self.state.clear();
    }

    pub fn has_state(&self) -> bool {
        self.state.is_some()
    }

    // Param is passed by value, moved
    pub fn set_state(&mut self, v: ::std::string::String) {
        self.state = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_state(&mut self) -> &mut ::std::string::String {
        if self.state.is_none() {
            self.state.set_default();
        }
        self.state.as_mut().unwrap()
    }

    // Take field
    pub fn take_state(&mut self) -> ::std::string::String {
        self.state.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string observation = 2;


    pub fn get_observation(&self) -> &str {
        match self.observation.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_observation(&mut self) {
        self.observation.clear();
    }

    pub fn has_observation(&self) -> bool {
        self.observation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_observation(&mut self, v: ::std::string::String) {
        self.observation = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_observation(&mut self) -> &mut ::std::string::String {
        if self.observation.is_none() {
            self.observation.set_default();
        }
        self.observation.as_mut().unwrap()
    }

    // Take field
    pub fn take_observation(&mut self) -> ::std::string::String {
        self.observation.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for ReconcilerState {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.state)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.observation)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.state.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.observation.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.state.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.observation.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ReconcilerState {
        ReconcilerState::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "state",
                |m: &ReconcilerState| { &m.state },
                |m: &mut ReconcilerState| { &mut m.state },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "observation",
                |m: &ReconcilerState| { &m.observation },
                |m: &mut ReconcilerState| { &mut m.observation },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ReconcilerState>(
                "ReconcilerState",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ReconcilerState {
        static instance: ::protobuf::rt::LazyV2<ReconcilerState> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ReconcilerState::new)
    }
}

impl ::protobuf::Clear for ReconcilerState {
    fn clear(&mut self) {
        self.state.clear();
        self.observation.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ReconcilerState {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ReconcilerState {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ResourceReference {
    // message fields
    pub objectReference: ::protobuf::SingularPtrField<super::generated::ObjectReference>,
    pub contrailFqName: ::protobuf::SingularPtrField<ContrailFqName>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ResourceReference {
    fn default() -> &'a ResourceReference {
        <ResourceReference as ::protobuf::Message>::default_instance()
    }
}

impl ResourceReference {
    pub fn new() -> ResourceReference {
        ::std::default::Default::default()
    }

    // optional .k8s.io.api.core.v1.ObjectReference objectReference = 1;


    pub fn get_objectReference(&self) -> &super::generated::ObjectReference {
        self.objectReference.as_ref().unwrap_or_else(|| <super::generated::ObjectReference as ::protobuf::Message>::default_instance())
    }
    pub fn clear_objectReference(&mut self) {
        self.objectReference.clear();
    }

    pub fn has_objectReference(&self) -> bool {
        self.objectReference.is_some()
    }

    // Param is passed by value, moved
    pub fn set_objectReference(&mut self, v: super::generated::ObjectReference) {
        self.objectReference = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_objectReference(&mut self) -> &mut super::generated::ObjectReference {
        if self.objectReference.is_none() {
            self.objectReference.set_default();
        }
        self.objectReference.as_mut().unwrap()
    }

    // Take field
    pub fn take_objectReference(&mut self) -> super::generated::ObjectReference {
        self.objectReference.take().unwrap_or_else(|| super::generated::ObjectReference::new())
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ContrailFqName contrailFqName = 2;


    pub fn get_contrailFqName(&self) -> &ContrailFqName {
        self.contrailFqName.as_ref().unwrap_or_else(|| <ContrailFqName as ::protobuf::Message>::default_instance())
    }
    pub fn clear_contrailFqName(&mut self) {
        self.contrailFqName.clear();
    }

    pub fn has_contrailFqName(&self) -> bool {
        self.contrailFqName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_contrailFqName(&mut self, v: ContrailFqName) {
        self.contrailFqName = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_contrailFqName(&mut self) -> &mut ContrailFqName {
        if self.contrailFqName.is_none() {
            self.contrailFqName.set_default();
        }
        self.contrailFqName.as_mut().unwrap()
    }

    // Take field
    pub fn take_contrailFqName(&mut self) -> ContrailFqName {
        self.contrailFqName.take().unwrap_or_else(|| ContrailFqName::new())
    }
}

impl ::protobuf::Message for ResourceReference {
    fn is_initialized(&self) -> bool {
        for v in &self.objectReference {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.contrailFqName {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.objectReference)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.contrailFqName)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.objectReference.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.contrailFqName.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.objectReference.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.contrailFqName.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ResourceReference {
        ResourceReference::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::generated::ObjectReference>>(
                "objectReference",
                |m: &ResourceReference| { &m.objectReference },
                |m: &mut ResourceReference| { &mut m.objectReference },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ContrailFqName>>(
                "contrailFqName",
                |m: &ResourceReference| { &m.contrailFqName },
                |m: &mut ResourceReference| { &mut m.contrailFqName },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ResourceReference>(
                "ResourceReference",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ResourceReference {
        static instance: ::protobuf::rt::LazyV2<ResourceReference> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ResourceReference::new)
    }
}

impl ::protobuf::Clear for ResourceReference {
    fn clear(&mut self) {
        self.objectReference.clear();
        self.contrailFqName.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ResourceReference {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResourceReference {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RouteOriginOverride {
    // message fields
    originOverride: ::std::option::Option<bool>,
    origin: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RouteOriginOverride {
    fn default() -> &'a RouteOriginOverride {
        <RouteOriginOverride as ::protobuf::Message>::default_instance()
    }
}

impl RouteOriginOverride {
    pub fn new() -> RouteOriginOverride {
        ::std::default::Default::default()
    }

    // optional bool originOverride = 1;


    pub fn get_originOverride(&self) -> bool {
        self.originOverride.unwrap_or(false)
    }
    pub fn clear_originOverride(&mut self) {
        self.originOverride = ::std::option::Option::None;
    }

    pub fn has_originOverride(&self) -> bool {
        self.originOverride.is_some()
    }

    // Param is passed by value, moved
    pub fn set_originOverride(&mut self, v: bool) {
        self.originOverride = ::std::option::Option::Some(v);
    }

    // optional string origin = 2;


    pub fn get_origin(&self) -> &str {
        match self.origin.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_origin(&mut self) {
        self.origin.clear();
    }

    pub fn has_origin(&self) -> bool {
        self.origin.is_some()
    }

    // Param is passed by value, moved
    pub fn set_origin(&mut self, v: ::std::string::String) {
        self.origin = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_origin(&mut self) -> &mut ::std::string::String {
        if self.origin.is_none() {
            self.origin.set_default();
        }
        self.origin.as_mut().unwrap()
    }

    // Take field
    pub fn take_origin(&mut self) -> ::std::string::String {
        self.origin.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for RouteOriginOverride {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.originOverride = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.origin)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.originOverride {
            my_size += 2;
        }
        if let Some(ref v) = self.origin.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.originOverride {
            os.write_bool(1, v)?;
        }
        if let Some(ref v) = self.origin.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RouteOriginOverride {
        RouteOriginOverride::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "originOverride",
                |m: &RouteOriginOverride| { &m.originOverride },
                |m: &mut RouteOriginOverride| { &mut m.originOverride },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "origin",
                |m: &RouteOriginOverride| { &m.origin },
                |m: &mut RouteOriginOverride| { &mut m.origin },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RouteOriginOverride>(
                "RouteOriginOverride",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RouteOriginOverride {
        static instance: ::protobuf::rt::LazyV2<RouteOriginOverride> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RouteOriginOverride::new)
    }
}

impl ::protobuf::Clear for RouteOriginOverride {
    fn clear(&mut self) {
        self.originOverride = ::std::option::Option::None;
        self.origin.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RouteOriginOverride {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RouteOriginOverride {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RouteTarget {
    // message fields
    pub metadata: ::protobuf::SingularPtrField<super::meta::ObjectMeta>,
    pub spec: ::protobuf::SingularPtrField<RouteTargetSpec>,
    pub status: ::protobuf::SingularPtrField<RouteTargetStatus>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RouteTarget {
    fn default() -> &'a RouteTarget {
        <RouteTarget as ::protobuf::Message>::default_instance()
    }
}

impl RouteTarget {
    pub fn new() -> RouteTarget {
        ::std::default::Default::default()
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;


    pub fn get_metadata(&self) -> &super::meta::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <super::meta::ObjectMeta as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::meta::ObjectMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::meta::ObjectMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::meta::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| super::meta::ObjectMeta::new())
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RouteTargetSpec spec = 2;


    pub fn get_spec(&self) -> &RouteTargetSpec {
        self.spec.as_ref().unwrap_or_else(|| <RouteTargetSpec as ::protobuf::Message>::default_instance())
    }
    pub fn clear_spec(&mut self) {
        self.spec.clear();
    }

    pub fn has_spec(&self) -> bool {
        self.spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spec(&mut self, v: RouteTargetSpec) {
        self.spec = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spec(&mut self) -> &mut RouteTargetSpec {
        if self.spec.is_none() {
            self.spec.set_default();
        }
        self.spec.as_mut().unwrap()
    }

    // Take field
    pub fn take_spec(&mut self) -> RouteTargetSpec {
        self.spec.take().unwrap_or_else(|| RouteTargetSpec::new())
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RouteTargetStatus status = 3;


    pub fn get_status(&self) -> &RouteTargetStatus {
        self.status.as_ref().unwrap_or_else(|| <RouteTargetStatus as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: RouteTargetStatus) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut RouteTargetStatus {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> RouteTargetStatus {
        self.status.take().unwrap_or_else(|| RouteTargetStatus::new())
    }
}

impl ::protobuf::Message for RouteTarget {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.spec {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.spec)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.spec.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RouteTarget {
        RouteTarget::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::meta::ObjectMeta>>(
                "metadata",
                |m: &RouteTarget| { &m.metadata },
                |m: &mut RouteTarget| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RouteTargetSpec>>(
                "spec",
                |m: &RouteTarget| { &m.spec },
                |m: &mut RouteTarget| { &mut m.spec },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RouteTargetStatus>>(
                "status",
                |m: &RouteTarget| { &m.status },
                |m: &mut RouteTarget| { &mut m.status },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RouteTarget>(
                "RouteTarget",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RouteTarget {
        static instance: ::protobuf::rt::LazyV2<RouteTarget> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RouteTarget::new)
    }
}

impl ::protobuf::Clear for RouteTarget {
    fn clear(&mut self) {
        self.metadata.clear();
        self.spec.clear();
        self.status.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RouteTarget {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RouteTarget {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RouteTargetList {
    // message fields
    pub metadata: ::protobuf::SingularPtrField<super::meta::ListMeta>,
    pub items: ::protobuf::RepeatedField<RouteTarget>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RouteTargetList {
    fn default() -> &'a RouteTargetList {
        <RouteTargetList as ::protobuf::Message>::default_instance()
    }
}

impl RouteTargetList {
    pub fn new() -> RouteTargetList {
        ::std::default::Default::default()
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;


    pub fn get_metadata(&self) -> &super::meta::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <super::meta::ListMeta as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::meta::ListMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::meta::ListMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::meta::ListMeta {
        self.metadata.take().unwrap_or_else(|| super::meta::ListMeta::new())
    }

    // repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RouteTarget items = 2;


    pub fn get_items(&self) -> &[RouteTarget] {
        &self.items
    }
    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::protobuf::RepeatedField<RouteTarget>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::protobuf::RepeatedField<RouteTarget> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::protobuf::RepeatedField<RouteTarget> {
        ::std::mem::replace(&mut self.items, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for RouteTargetList {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.items {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.items)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.items {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RouteTargetList {
        RouteTargetList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::meta::ListMeta>>(
                "metadata",
                |m: &RouteTargetList| { &m.metadata },
                |m: &mut RouteTargetList| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RouteTarget>>(
                "items",
                |m: &RouteTargetList| { &m.items },
                |m: &mut RouteTargetList| { &mut m.items },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RouteTargetList>(
                "RouteTargetList",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RouteTargetList {
        static instance: ::protobuf::rt::LazyV2<RouteTargetList> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RouteTargetList::new)
    }
}

impl ::protobuf::Clear for RouteTargetList {
    fn clear(&mut self) {
        self.metadata.clear();
        self.items.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RouteTargetList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RouteTargetList {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RouteTargetReference {
    // message fields
    pub resourceReference: ::protobuf::SingularPtrField<ResourceReference>,
    pub attributes: ::protobuf::SingularPtrField<RouteTargetReferenceAttributes>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RouteTargetReference {
    fn default() -> &'a RouteTargetReference {
        <RouteTargetReference as ::protobuf::Message>::default_instance()
    }
}

impl RouteTargetReference {
    pub fn new() -> RouteTargetReference {
        ::std::default::Default::default()
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ResourceReference resourceReference = 1;


    pub fn get_resourceReference(&self) -> &ResourceReference {
        self.resourceReference.as_ref().unwrap_or_else(|| <ResourceReference as ::protobuf::Message>::default_instance())
    }
    pub fn clear_resourceReference(&mut self) {
        self.resourceReference.clear();
    }

    pub fn has_resourceReference(&self) -> bool {
        self.resourceReference.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resourceReference(&mut self, v: ResourceReference) {
        self.resourceReference = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_resourceReference(&mut self) -> &mut ResourceReference {
        if self.resourceReference.is_none() {
            self.resourceReference.set_default();
        }
        self.resourceReference.as_mut().unwrap()
    }

    // Take field
    pub fn take_resourceReference(&mut self) -> ResourceReference {
        self.resourceReference.take().unwrap_or_else(|| ResourceReference::new())
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RouteTargetReferenceAttributes attributes = 2;


    pub fn get_attributes(&self) -> &RouteTargetReferenceAttributes {
        self.attributes.as_ref().unwrap_or_else(|| <RouteTargetReferenceAttributes as ::protobuf::Message>::default_instance())
    }
    pub fn clear_attributes(&mut self) {
        self.attributes.clear();
    }

    pub fn has_attributes(&self) -> bool {
        self.attributes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attributes(&mut self, v: RouteTargetReferenceAttributes) {
        self.attributes = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_attributes(&mut self) -> &mut RouteTargetReferenceAttributes {
        if self.attributes.is_none() {
            self.attributes.set_default();
        }
        self.attributes.as_mut().unwrap()
    }

    // Take field
    pub fn take_attributes(&mut self) -> RouteTargetReferenceAttributes {
        self.attributes.take().unwrap_or_else(|| RouteTargetReferenceAttributes::new())
    }
}

impl ::protobuf::Message for RouteTargetReference {
    fn is_initialized(&self) -> bool {
        for v in &self.resourceReference {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.attributes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.resourceReference)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.attributes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.resourceReference.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.attributes.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.resourceReference.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.attributes.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RouteTargetReference {
        RouteTargetReference::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResourceReference>>(
                "resourceReference",
                |m: &RouteTargetReference| { &m.resourceReference },
                |m: &mut RouteTargetReference| { &mut m.resourceReference },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RouteTargetReferenceAttributes>>(
                "attributes",
                |m: &RouteTargetReference| { &m.attributes },
                |m: &mut RouteTargetReference| { &mut m.attributes },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RouteTargetReference>(
                "RouteTargetReference",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RouteTargetReference {
        static instance: ::protobuf::rt::LazyV2<RouteTargetReference> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RouteTargetReference::new)
    }
}

impl ::protobuf::Clear for RouteTargetReference {
    fn clear(&mut self) {
        self.resourceReference.clear();
        self.attributes.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RouteTargetReference {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RouteTargetReference {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RouteTargetReferenceAttributes {
    // message fields
    importExport: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RouteTargetReferenceAttributes {
    fn default() -> &'a RouteTargetReferenceAttributes {
        <RouteTargetReferenceAttributes as ::protobuf::Message>::default_instance()
    }
}

impl RouteTargetReferenceAttributes {
    pub fn new() -> RouteTargetReferenceAttributes {
        ::std::default::Default::default()
    }

    // optional string importExport = 1;


    pub fn get_importExport(&self) -> &str {
        match self.importExport.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_importExport(&mut self) {
        self.importExport.clear();
    }

    pub fn has_importExport(&self) -> bool {
        self.importExport.is_some()
    }

    // Param is passed by value, moved
    pub fn set_importExport(&mut self, v: ::std::string::String) {
        self.importExport = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_importExport(&mut self) -> &mut ::std::string::String {
        if self.importExport.is_none() {
            self.importExport.set_default();
        }
        self.importExport.as_mut().unwrap()
    }

    // Take field
    pub fn take_importExport(&mut self) -> ::std::string::String {
        self.importExport.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for RouteTargetReferenceAttributes {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.importExport)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.importExport.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.importExport.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RouteTargetReferenceAttributes {
        RouteTargetReferenceAttributes::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "importExport",
                |m: &RouteTargetReferenceAttributes| { &m.importExport },
                |m: &mut RouteTargetReferenceAttributes| { &mut m.importExport },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RouteTargetReferenceAttributes>(
                "RouteTargetReferenceAttributes",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RouteTargetReferenceAttributes {
        static instance: ::protobuf::rt::LazyV2<RouteTargetReferenceAttributes> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RouteTargetReferenceAttributes::new)
    }
}

impl ::protobuf::Clear for RouteTargetReferenceAttributes {
    fn clear(&mut self) {
        self.importExport.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RouteTargetReferenceAttributes {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RouteTargetReferenceAttributes {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RouteTargetSpec {
    // message fields
    pub commonSpec: ::protobuf::SingularPtrField<CommonSpec>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RouteTargetSpec {
    fn default() -> &'a RouteTargetSpec {
        <RouteTargetSpec as ::protobuf::Message>::default_instance()
    }
}

impl RouteTargetSpec {
    pub fn new() -> RouteTargetSpec {
        ::std::default::Default::default()
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonSpec commonSpec = 1;


    pub fn get_commonSpec(&self) -> &CommonSpec {
        self.commonSpec.as_ref().unwrap_or_else(|| <CommonSpec as ::protobuf::Message>::default_instance())
    }
    pub fn clear_commonSpec(&mut self) {
        self.commonSpec.clear();
    }

    pub fn has_commonSpec(&self) -> bool {
        self.commonSpec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_commonSpec(&mut self, v: CommonSpec) {
        self.commonSpec = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_commonSpec(&mut self) -> &mut CommonSpec {
        if self.commonSpec.is_none() {
            self.commonSpec.set_default();
        }
        self.commonSpec.as_mut().unwrap()
    }

    // Take field
    pub fn take_commonSpec(&mut self) -> CommonSpec {
        self.commonSpec.take().unwrap_or_else(|| CommonSpec::new())
    }
}

impl ::protobuf::Message for RouteTargetSpec {
    fn is_initialized(&self) -> bool {
        for v in &self.commonSpec {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.commonSpec)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.commonSpec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.commonSpec.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RouteTargetSpec {
        RouteTargetSpec::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommonSpec>>(
                "commonSpec",
                |m: &RouteTargetSpec| { &m.commonSpec },
                |m: &mut RouteTargetSpec| { &mut m.commonSpec },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RouteTargetSpec>(
                "RouteTargetSpec",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RouteTargetSpec {
        static instance: ::protobuf::rt::LazyV2<RouteTargetSpec> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RouteTargetSpec::new)
    }
}

impl ::protobuf::Clear for RouteTargetSpec {
    fn clear(&mut self) {
        self.commonSpec.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RouteTargetSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RouteTargetSpec {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RouteTargetStatus {
    // message fields
    pub commonStatus: ::protobuf::SingularPtrField<CommonStatus>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RouteTargetStatus {
    fn default() -> &'a RouteTargetStatus {
        <RouteTargetStatus as ::protobuf::Message>::default_instance()
    }
}

impl RouteTargetStatus {
    pub fn new() -> RouteTargetStatus {
        ::std::default::Default::default()
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonStatus commonStatus = 1;


    pub fn get_commonStatus(&self) -> &CommonStatus {
        self.commonStatus.as_ref().unwrap_or_else(|| <CommonStatus as ::protobuf::Message>::default_instance())
    }
    pub fn clear_commonStatus(&mut self) {
        self.commonStatus.clear();
    }

    pub fn has_commonStatus(&self) -> bool {
        self.commonStatus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_commonStatus(&mut self, v: CommonStatus) {
        self.commonStatus = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_commonStatus(&mut self) -> &mut CommonStatus {
        if self.commonStatus.is_none() {
            self.commonStatus.set_default();
        }
        self.commonStatus.as_mut().unwrap()
    }

    // Take field
    pub fn take_commonStatus(&mut self) -> CommonStatus {
        self.commonStatus.take().unwrap_or_else(|| CommonStatus::new())
    }
}

impl ::protobuf::Message for RouteTargetStatus {
    fn is_initialized(&self) -> bool {
        for v in &self.commonStatus {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.commonStatus)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.commonStatus.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.commonStatus.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RouteTargetStatus {
        RouteTargetStatus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommonStatus>>(
                "commonStatus",
                |m: &RouteTargetStatus| { &m.commonStatus },
                |m: &mut RouteTargetStatus| { &mut m.commonStatus },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RouteTargetStatus>(
                "RouteTargetStatus",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RouteTargetStatus {
        static instance: ::protobuf::rt::LazyV2<RouteTargetStatus> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RouteTargetStatus::new)
    }
}

impl ::protobuf::Clear for RouteTargetStatus {
    fn clear(&mut self) {
        self.commonStatus.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RouteTargetStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RouteTargetStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RoutingInstance {
    // message fields
    pub metadata: ::protobuf::SingularPtrField<super::meta::ObjectMeta>,
    pub spec: ::protobuf::SingularPtrField<RoutingInstanceSpec>,
    pub status: ::protobuf::SingularPtrField<RoutingInstanceStatus>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RoutingInstance {
    fn default() -> &'a RoutingInstance {
        <RoutingInstance as ::protobuf::Message>::default_instance()
    }
}

impl RoutingInstance {
    pub fn new() -> RoutingInstance {
        ::std::default::Default::default()
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;


    pub fn get_metadata(&self) -> &super::meta::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <super::meta::ObjectMeta as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::meta::ObjectMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::meta::ObjectMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::meta::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| super::meta::ObjectMeta::new())
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RoutingInstanceSpec spec = 2;


    pub fn get_spec(&self) -> &RoutingInstanceSpec {
        self.spec.as_ref().unwrap_or_else(|| <RoutingInstanceSpec as ::protobuf::Message>::default_instance())
    }
    pub fn clear_spec(&mut self) {
        self.spec.clear();
    }

    pub fn has_spec(&self) -> bool {
        self.spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spec(&mut self, v: RoutingInstanceSpec) {
        self.spec = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spec(&mut self) -> &mut RoutingInstanceSpec {
        if self.spec.is_none() {
            self.spec.set_default();
        }
        self.spec.as_mut().unwrap()
    }

    // Take field
    pub fn take_spec(&mut self) -> RoutingInstanceSpec {
        self.spec.take().unwrap_or_else(|| RoutingInstanceSpec::new())
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RoutingInstanceStatus status = 3;


    pub fn get_status(&self) -> &RoutingInstanceStatus {
        self.status.as_ref().unwrap_or_else(|| <RoutingInstanceStatus as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: RoutingInstanceStatus) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut RoutingInstanceStatus {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> RoutingInstanceStatus {
        self.status.take().unwrap_or_else(|| RoutingInstanceStatus::new())
    }
}

impl ::protobuf::Message for RoutingInstance {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.spec {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.spec)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.spec.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RoutingInstance {
        RoutingInstance::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::meta::ObjectMeta>>(
                "metadata",
                |m: &RoutingInstance| { &m.metadata },
                |m: &mut RoutingInstance| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RoutingInstanceSpec>>(
                "spec",
                |m: &RoutingInstance| { &m.spec },
                |m: &mut RoutingInstance| { &mut m.spec },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RoutingInstanceStatus>>(
                "status",
                |m: &RoutingInstance| { &m.status },
                |m: &mut RoutingInstance| { &mut m.status },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RoutingInstance>(
                "RoutingInstance",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RoutingInstance {
        static instance: ::protobuf::rt::LazyV2<RoutingInstance> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RoutingInstance::new)
    }
}

impl ::protobuf::Clear for RoutingInstance {
    fn clear(&mut self) {
        self.metadata.clear();
        self.spec.clear();
        self.status.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RoutingInstance {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RoutingInstance {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RoutingInstanceList {
    // message fields
    pub metadata: ::protobuf::SingularPtrField<super::meta::ListMeta>,
    pub items: ::protobuf::RepeatedField<RoutingInstance>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RoutingInstanceList {
    fn default() -> &'a RoutingInstanceList {
        <RoutingInstanceList as ::protobuf::Message>::default_instance()
    }
}

impl RoutingInstanceList {
    pub fn new() -> RoutingInstanceList {
        ::std::default::Default::default()
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;


    pub fn get_metadata(&self) -> &super::meta::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <super::meta::ListMeta as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::meta::ListMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::meta::ListMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::meta::ListMeta {
        self.metadata.take().unwrap_or_else(|| super::meta::ListMeta::new())
    }

    // repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RoutingInstance items = 2;


    pub fn get_items(&self) -> &[RoutingInstance] {
        &self.items
    }
    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::protobuf::RepeatedField<RoutingInstance>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::protobuf::RepeatedField<RoutingInstance> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::protobuf::RepeatedField<RoutingInstance> {
        ::std::mem::replace(&mut self.items, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for RoutingInstanceList {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.items {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.items)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.items {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RoutingInstanceList {
        RoutingInstanceList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::meta::ListMeta>>(
                "metadata",
                |m: &RoutingInstanceList| { &m.metadata },
                |m: &mut RoutingInstanceList| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RoutingInstance>>(
                "items",
                |m: &RoutingInstanceList| { &m.items },
                |m: &mut RoutingInstanceList| { &mut m.items },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RoutingInstanceList>(
                "RoutingInstanceList",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RoutingInstanceList {
        static instance: ::protobuf::rt::LazyV2<RoutingInstanceList> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RoutingInstanceList::new)
    }
}

impl ::protobuf::Clear for RoutingInstanceList {
    fn clear(&mut self) {
        self.metadata.clear();
        self.items.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RoutingInstanceList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RoutingInstanceList {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RoutingInstanceReference {
    // message fields
    pub resourceReference: ::protobuf::SingularPtrField<ResourceReference>,
    pub attributes: ::protobuf::SingularPtrField<PolicyBasedForwardingRule>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RoutingInstanceReference {
    fn default() -> &'a RoutingInstanceReference {
        <RoutingInstanceReference as ::protobuf::Message>::default_instance()
    }
}

impl RoutingInstanceReference {
    pub fn new() -> RoutingInstanceReference {
        ::std::default::Default::default()
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ResourceReference resourceReference = 1;


    pub fn get_resourceReference(&self) -> &ResourceReference {
        self.resourceReference.as_ref().unwrap_or_else(|| <ResourceReference as ::protobuf::Message>::default_instance())
    }
    pub fn clear_resourceReference(&mut self) {
        self.resourceReference.clear();
    }

    pub fn has_resourceReference(&self) -> bool {
        self.resourceReference.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resourceReference(&mut self, v: ResourceReference) {
        self.resourceReference = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_resourceReference(&mut self) -> &mut ResourceReference {
        if self.resourceReference.is_none() {
            self.resourceReference.set_default();
        }
        self.resourceReference.as_mut().unwrap()
    }

    // Take field
    pub fn take_resourceReference(&mut self) -> ResourceReference {
        self.resourceReference.take().unwrap_or_else(|| ResourceReference::new())
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.PolicyBasedForwardingRule attributes = 2;


    pub fn get_attributes(&self) -> &PolicyBasedForwardingRule {
        self.attributes.as_ref().unwrap_or_else(|| <PolicyBasedForwardingRule as ::protobuf::Message>::default_instance())
    }
    pub fn clear_attributes(&mut self) {
        self.attributes.clear();
    }

    pub fn has_attributes(&self) -> bool {
        self.attributes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attributes(&mut self, v: PolicyBasedForwardingRule) {
        self.attributes = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_attributes(&mut self) -> &mut PolicyBasedForwardingRule {
        if self.attributes.is_none() {
            self.attributes.set_default();
        }
        self.attributes.as_mut().unwrap()
    }

    // Take field
    pub fn take_attributes(&mut self) -> PolicyBasedForwardingRule {
        self.attributes.take().unwrap_or_else(|| PolicyBasedForwardingRule::new())
    }
}

impl ::protobuf::Message for RoutingInstanceReference {
    fn is_initialized(&self) -> bool {
        for v in &self.resourceReference {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.attributes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.resourceReference)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.attributes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.resourceReference.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.attributes.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.resourceReference.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.attributes.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RoutingInstanceReference {
        RoutingInstanceReference::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResourceReference>>(
                "resourceReference",
                |m: &RoutingInstanceReference| { &m.resourceReference },
                |m: &mut RoutingInstanceReference| { &mut m.resourceReference },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PolicyBasedForwardingRule>>(
                "attributes",
                |m: &RoutingInstanceReference| { &m.attributes },
                |m: &mut RoutingInstanceReference| { &mut m.attributes },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RoutingInstanceReference>(
                "RoutingInstanceReference",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RoutingInstanceReference {
        static instance: ::protobuf::rt::LazyV2<RoutingInstanceReference> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RoutingInstanceReference::new)
    }
}

impl ::protobuf::Clear for RoutingInstanceReference {
    fn clear(&mut self) {
        self.resourceReference.clear();
        self.attributes.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RoutingInstanceReference {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RoutingInstanceReference {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RoutingInstanceSpec {
    // message fields
    pub commonSpec: ::protobuf::SingularPtrField<CommonSpec>,
    pub parent: ::protobuf::SingularPtrField<super::generated::ObjectReference>,
    pub routeTargetReferences: ::protobuf::RepeatedField<RouteTargetReference>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RoutingInstanceSpec {
    fn default() -> &'a RoutingInstanceSpec {
        <RoutingInstanceSpec as ::protobuf::Message>::default_instance()
    }
}

impl RoutingInstanceSpec {
    pub fn new() -> RoutingInstanceSpec {
        ::std::default::Default::default()
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonSpec commonSpec = 1;


    pub fn get_commonSpec(&self) -> &CommonSpec {
        self.commonSpec.as_ref().unwrap_or_else(|| <CommonSpec as ::protobuf::Message>::default_instance())
    }
    pub fn clear_commonSpec(&mut self) {
        self.commonSpec.clear();
    }

    pub fn has_commonSpec(&self) -> bool {
        self.commonSpec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_commonSpec(&mut self, v: CommonSpec) {
        self.commonSpec = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_commonSpec(&mut self) -> &mut CommonSpec {
        if self.commonSpec.is_none() {
            self.commonSpec.set_default();
        }
        self.commonSpec.as_mut().unwrap()
    }

    // Take field
    pub fn take_commonSpec(&mut self) -> CommonSpec {
        self.commonSpec.take().unwrap_or_else(|| CommonSpec::new())
    }

    // optional .k8s.io.api.core.v1.ObjectReference parent = 2;


    pub fn get_parent(&self) -> &super::generated::ObjectReference {
        self.parent.as_ref().unwrap_or_else(|| <super::generated::ObjectReference as ::protobuf::Message>::default_instance())
    }
    pub fn clear_parent(&mut self) {
        self.parent.clear();
    }

    pub fn has_parent(&self) -> bool {
        self.parent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_parent(&mut self, v: super::generated::ObjectReference) {
        self.parent = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent(&mut self) -> &mut super::generated::ObjectReference {
        if self.parent.is_none() {
            self.parent.set_default();
        }
        self.parent.as_mut().unwrap()
    }

    // Take field
    pub fn take_parent(&mut self) -> super::generated::ObjectReference {
        self.parent.take().unwrap_or_else(|| super::generated::ObjectReference::new())
    }

    // repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RouteTargetReference routeTargetReferences = 3;


    pub fn get_routeTargetReferences(&self) -> &[RouteTargetReference] {
        &self.routeTargetReferences
    }
    pub fn clear_routeTargetReferences(&mut self) {
        self.routeTargetReferences.clear();
    }

    // Param is passed by value, moved
    pub fn set_routeTargetReferences(&mut self, v: ::protobuf::RepeatedField<RouteTargetReference>) {
        self.routeTargetReferences = v;
    }

    // Mutable pointer to the field.
    pub fn mut_routeTargetReferences(&mut self) -> &mut ::protobuf::RepeatedField<RouteTargetReference> {
        &mut self.routeTargetReferences
    }

    // Take field
    pub fn take_routeTargetReferences(&mut self) -> ::protobuf::RepeatedField<RouteTargetReference> {
        ::std::mem::replace(&mut self.routeTargetReferences, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for RoutingInstanceSpec {
    fn is_initialized(&self) -> bool {
        for v in &self.commonSpec {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.parent {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.routeTargetReferences {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.commonSpec)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.parent)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.routeTargetReferences)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.commonSpec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.parent.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.routeTargetReferences {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.commonSpec.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.parent.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.routeTargetReferences {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RoutingInstanceSpec {
        RoutingInstanceSpec::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommonSpec>>(
                "commonSpec",
                |m: &RoutingInstanceSpec| { &m.commonSpec },
                |m: &mut RoutingInstanceSpec| { &mut m.commonSpec },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::generated::ObjectReference>>(
                "parent",
                |m: &RoutingInstanceSpec| { &m.parent },
                |m: &mut RoutingInstanceSpec| { &mut m.parent },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RouteTargetReference>>(
                "routeTargetReferences",
                |m: &RoutingInstanceSpec| { &m.routeTargetReferences },
                |m: &mut RoutingInstanceSpec| { &mut m.routeTargetReferences },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RoutingInstanceSpec>(
                "RoutingInstanceSpec",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RoutingInstanceSpec {
        static instance: ::protobuf::rt::LazyV2<RoutingInstanceSpec> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RoutingInstanceSpec::new)
    }
}

impl ::protobuf::Clear for RoutingInstanceSpec {
    fn clear(&mut self) {
        self.commonSpec.clear();
        self.parent.clear();
        self.routeTargetReferences.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RoutingInstanceSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RoutingInstanceSpec {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RoutingInstanceStatus {
    // message fields
    pub commonStatus: ::protobuf::SingularPtrField<CommonStatus>,
    isDefault: ::std::option::Option<bool>,
    routingInstanceFabricSNAT: ::std::option::Option<bool>,
    pub defaultRouteTargetReference: ::protobuf::SingularPtrField<RouteTargetReference>,
    pub virtualNetworkRouterRouteTargetReferences: ::std::collections::HashMap<::std::string::String, VirtualNetworkRouteTargetReferenceList>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RoutingInstanceStatus {
    fn default() -> &'a RoutingInstanceStatus {
        <RoutingInstanceStatus as ::protobuf::Message>::default_instance()
    }
}

impl RoutingInstanceStatus {
    pub fn new() -> RoutingInstanceStatus {
        ::std::default::Default::default()
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonStatus commonStatus = 1;


    pub fn get_commonStatus(&self) -> &CommonStatus {
        self.commonStatus.as_ref().unwrap_or_else(|| <CommonStatus as ::protobuf::Message>::default_instance())
    }
    pub fn clear_commonStatus(&mut self) {
        self.commonStatus.clear();
    }

    pub fn has_commonStatus(&self) -> bool {
        self.commonStatus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_commonStatus(&mut self, v: CommonStatus) {
        self.commonStatus = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_commonStatus(&mut self) -> &mut CommonStatus {
        if self.commonStatus.is_none() {
            self.commonStatus.set_default();
        }
        self.commonStatus.as_mut().unwrap()
    }

    // Take field
    pub fn take_commonStatus(&mut self) -> CommonStatus {
        self.commonStatus.take().unwrap_or_else(|| CommonStatus::new())
    }

    // optional bool isDefault = 2;


    pub fn get_isDefault(&self) -> bool {
        self.isDefault.unwrap_or(false)
    }
    pub fn clear_isDefault(&mut self) {
        self.isDefault = ::std::option::Option::None;
    }

    pub fn has_isDefault(&self) -> bool {
        self.isDefault.is_some()
    }

    // Param is passed by value, moved
    pub fn set_isDefault(&mut self, v: bool) {
        self.isDefault = ::std::option::Option::Some(v);
    }

    // optional bool routingInstanceFabricSNAT = 3;


    pub fn get_routingInstanceFabricSNAT(&self) -> bool {
        self.routingInstanceFabricSNAT.unwrap_or(false)
    }
    pub fn clear_routingInstanceFabricSNAT(&mut self) {
        self.routingInstanceFabricSNAT = ::std::option::Option::None;
    }

    pub fn has_routingInstanceFabricSNAT(&self) -> bool {
        self.routingInstanceFabricSNAT.is_some()
    }

    // Param is passed by value, moved
    pub fn set_routingInstanceFabricSNAT(&mut self, v: bool) {
        self.routingInstanceFabricSNAT = ::std::option::Option::Some(v);
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RouteTargetReference defaultRouteTargetReference = 4;


    pub fn get_defaultRouteTargetReference(&self) -> &RouteTargetReference {
        self.defaultRouteTargetReference.as_ref().unwrap_or_else(|| <RouteTargetReference as ::protobuf::Message>::default_instance())
    }
    pub fn clear_defaultRouteTargetReference(&mut self) {
        self.defaultRouteTargetReference.clear();
    }

    pub fn has_defaultRouteTargetReference(&self) -> bool {
        self.defaultRouteTargetReference.is_some()
    }

    // Param is passed by value, moved
    pub fn set_defaultRouteTargetReference(&mut self, v: RouteTargetReference) {
        self.defaultRouteTargetReference = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_defaultRouteTargetReference(&mut self) -> &mut RouteTargetReference {
        if self.defaultRouteTargetReference.is_none() {
            self.defaultRouteTargetReference.set_default();
        }
        self.defaultRouteTargetReference.as_mut().unwrap()
    }

    // Take field
    pub fn take_defaultRouteTargetReference(&mut self) -> RouteTargetReference {
        self.defaultRouteTargetReference.take().unwrap_or_else(|| RouteTargetReference::new())
    }

    // repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RoutingInstanceStatus.VirtualNetworkRouterRouteTargetReferencesEntry virtualNetworkRouterRouteTargetReferences = 5;


    pub fn get_virtualNetworkRouterRouteTargetReferences(&self) -> &::std::collections::HashMap<::std::string::String, VirtualNetworkRouteTargetReferenceList> {
        &self.virtualNetworkRouterRouteTargetReferences
    }
    pub fn clear_virtualNetworkRouterRouteTargetReferences(&mut self) {
        self.virtualNetworkRouterRouteTargetReferences.clear();
    }

    // Param is passed by value, moved
    pub fn set_virtualNetworkRouterRouteTargetReferences(&mut self, v: ::std::collections::HashMap<::std::string::String, VirtualNetworkRouteTargetReferenceList>) {
        self.virtualNetworkRouterRouteTargetReferences = v;
    }

    // Mutable pointer to the field.
    pub fn mut_virtualNetworkRouterRouteTargetReferences(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, VirtualNetworkRouteTargetReferenceList> {
        &mut self.virtualNetworkRouterRouteTargetReferences
    }

    // Take field
    pub fn take_virtualNetworkRouterRouteTargetReferences(&mut self) -> ::std::collections::HashMap<::std::string::String, VirtualNetworkRouteTargetReferenceList> {
        ::std::mem::replace(&mut self.virtualNetworkRouterRouteTargetReferences, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for RoutingInstanceStatus {
    fn is_initialized(&self) -> bool {
        for v in &self.commonStatus {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.defaultRouteTargetReference {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.commonStatus)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.isDefault = ::std::option::Option::Some(tmp);
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.routingInstanceFabricSNAT = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.defaultRouteTargetReference)?;
                },
                5 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<VirtualNetworkRouteTargetReferenceList>>(wire_type, is, &mut self.virtualNetworkRouterRouteTargetReferences)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.commonStatus.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.isDefault {
            my_size += 2;
        }
        if let Some(v) = self.routingInstanceFabricSNAT {
            my_size += 2;
        }
        if let Some(ref v) = self.defaultRouteTargetReference.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<VirtualNetworkRouteTargetReferenceList>>(5, &self.virtualNetworkRouterRouteTargetReferences);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.commonStatus.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.isDefault {
            os.write_bool(2, v)?;
        }
        if let Some(v) = self.routingInstanceFabricSNAT {
            os.write_bool(3, v)?;
        }
        if let Some(ref v) = self.defaultRouteTargetReference.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<VirtualNetworkRouteTargetReferenceList>>(5, &self.virtualNetworkRouterRouteTargetReferences, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RoutingInstanceStatus {
        RoutingInstanceStatus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommonStatus>>(
                "commonStatus",
                |m: &RoutingInstanceStatus| { &m.commonStatus },
                |m: &mut RoutingInstanceStatus| { &mut m.commonStatus },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "isDefault",
                |m: &RoutingInstanceStatus| { &m.isDefault },
                |m: &mut RoutingInstanceStatus| { &mut m.isDefault },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "routingInstanceFabricSNAT",
                |m: &RoutingInstanceStatus| { &m.routingInstanceFabricSNAT },
                |m: &mut RoutingInstanceStatus| { &mut m.routingInstanceFabricSNAT },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RouteTargetReference>>(
                "defaultRouteTargetReference",
                |m: &RoutingInstanceStatus| { &m.defaultRouteTargetReference },
                |m: &mut RoutingInstanceStatus| { &mut m.defaultRouteTargetReference },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<VirtualNetworkRouteTargetReferenceList>>(
                "virtualNetworkRouterRouteTargetReferences",
                |m: &RoutingInstanceStatus| { &m.virtualNetworkRouterRouteTargetReferences },
                |m: &mut RoutingInstanceStatus| { &mut m.virtualNetworkRouterRouteTargetReferences },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RoutingInstanceStatus>(
                "RoutingInstanceStatus",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RoutingInstanceStatus {
        static instance: ::protobuf::rt::LazyV2<RoutingInstanceStatus> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RoutingInstanceStatus::new)
    }
}

impl ::protobuf::Clear for RoutingInstanceStatus {
    fn clear(&mut self) {
        self.commonStatus.clear();
        self.isDefault = ::std::option::Option::None;
        self.routingInstanceFabricSNAT = ::std::option::Option::None;
        self.defaultRouteTargetReference.clear();
        self.virtualNetworkRouterRouteTargetReferences.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RoutingInstanceStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RoutingInstanceStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Subnet {
    // message fields
    pub metadata: ::protobuf::SingularPtrField<super::meta::ObjectMeta>,
    pub spec: ::protobuf::SingularPtrField<SubnetSpec>,
    pub status: ::protobuf::SingularPtrField<SubnetStatus>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Subnet {
    fn default() -> &'a Subnet {
        <Subnet as ::protobuf::Message>::default_instance()
    }
}

impl Subnet {
    pub fn new() -> Subnet {
        ::std::default::Default::default()
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;


    pub fn get_metadata(&self) -> &super::meta::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <super::meta::ObjectMeta as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::meta::ObjectMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::meta::ObjectMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::meta::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| super::meta::ObjectMeta::new())
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.SubnetSpec spec = 2;


    pub fn get_spec(&self) -> &SubnetSpec {
        self.spec.as_ref().unwrap_or_else(|| <SubnetSpec as ::protobuf::Message>::default_instance())
    }
    pub fn clear_spec(&mut self) {
        self.spec.clear();
    }

    pub fn has_spec(&self) -> bool {
        self.spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spec(&mut self, v: SubnetSpec) {
        self.spec = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spec(&mut self) -> &mut SubnetSpec {
        if self.spec.is_none() {
            self.spec.set_default();
        }
        self.spec.as_mut().unwrap()
    }

    // Take field
    pub fn take_spec(&mut self) -> SubnetSpec {
        self.spec.take().unwrap_or_else(|| SubnetSpec::new())
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.SubnetStatus status = 3;


    pub fn get_status(&self) -> &SubnetStatus {
        self.status.as_ref().unwrap_or_else(|| <SubnetStatus as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: SubnetStatus) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut SubnetStatus {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> SubnetStatus {
        self.status.take().unwrap_or_else(|| SubnetStatus::new())
    }
}

impl ::protobuf::Message for Subnet {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.spec {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.spec)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.spec.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Subnet {
        Subnet::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::meta::ObjectMeta>>(
                "metadata",
                |m: &Subnet| { &m.metadata },
                |m: &mut Subnet| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SubnetSpec>>(
                "spec",
                |m: &Subnet| { &m.spec },
                |m: &mut Subnet| { &mut m.spec },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SubnetStatus>>(
                "status",
                |m: &Subnet| { &m.status },
                |m: &mut Subnet| { &mut m.status },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Subnet>(
                "Subnet",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Subnet {
        static instance: ::protobuf::rt::LazyV2<Subnet> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Subnet::new)
    }
}

impl ::protobuf::Clear for Subnet {
    fn clear(&mut self) {
        self.metadata.clear();
        self.spec.clear();
        self.status.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Subnet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Subnet {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SubnetList {
    // message fields
    pub metadata: ::protobuf::SingularPtrField<super::meta::ListMeta>,
    pub items: ::protobuf::RepeatedField<Subnet>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SubnetList {
    fn default() -> &'a SubnetList {
        <SubnetList as ::protobuf::Message>::default_instance()
    }
}

impl SubnetList {
    pub fn new() -> SubnetList {
        ::std::default::Default::default()
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;


    pub fn get_metadata(&self) -> &super::meta::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <super::meta::ListMeta as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::meta::ListMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::meta::ListMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::meta::ListMeta {
        self.metadata.take().unwrap_or_else(|| super::meta::ListMeta::new())
    }

    // repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.Subnet items = 2;


    pub fn get_items(&self) -> &[Subnet] {
        &self.items
    }
    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::protobuf::RepeatedField<Subnet>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::protobuf::RepeatedField<Subnet> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::protobuf::RepeatedField<Subnet> {
        ::std::mem::replace(&mut self.items, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for SubnetList {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.items {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.items)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.items {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SubnetList {
        SubnetList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::meta::ListMeta>>(
                "metadata",
                |m: &SubnetList| { &m.metadata },
                |m: &mut SubnetList| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Subnet>>(
                "items",
                |m: &SubnetList| { &m.items },
                |m: &mut SubnetList| { &mut m.items },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SubnetList>(
                "SubnetList",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SubnetList {
        static instance: ::protobuf::rt::LazyV2<SubnetList> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SubnetList::new)
    }
}

impl ::protobuf::Clear for SubnetList {
    fn clear(&mut self) {
        self.metadata.clear();
        self.items.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SubnetList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubnetList {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SubnetReference {
    // message fields
    pub resourceReference: ::protobuf::SingularPtrField<ResourceReference>,
    pub attributes: ::protobuf::SingularPtrField<BGPSessionIPAttributes>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SubnetReference {
    fn default() -> &'a SubnetReference {
        <SubnetReference as ::protobuf::Message>::default_instance()
    }
}

impl SubnetReference {
    pub fn new() -> SubnetReference {
        ::std::default::Default::default()
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ResourceReference resourceReference = 1;


    pub fn get_resourceReference(&self) -> &ResourceReference {
        self.resourceReference.as_ref().unwrap_or_else(|| <ResourceReference as ::protobuf::Message>::default_instance())
    }
    pub fn clear_resourceReference(&mut self) {
        self.resourceReference.clear();
    }

    pub fn has_resourceReference(&self) -> bool {
        self.resourceReference.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resourceReference(&mut self, v: ResourceReference) {
        self.resourceReference = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_resourceReference(&mut self) -> &mut ResourceReference {
        if self.resourceReference.is_none() {
            self.resourceReference.set_default();
        }
        self.resourceReference.as_mut().unwrap()
    }

    // Take field
    pub fn take_resourceReference(&mut self) -> ResourceReference {
        self.resourceReference.take().unwrap_or_else(|| ResourceReference::new())
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPSessionIPAttributes attributes = 2;


    pub fn get_attributes(&self) -> &BGPSessionIPAttributes {
        self.attributes.as_ref().unwrap_or_else(|| <BGPSessionIPAttributes as ::protobuf::Message>::default_instance())
    }
    pub fn clear_attributes(&mut self) {
        self.attributes.clear();
    }

    pub fn has_attributes(&self) -> bool {
        self.attributes.is_some()
    }

    // Param is passed by value, moved
    pub fn set_attributes(&mut self, v: BGPSessionIPAttributes) {
        self.attributes = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_attributes(&mut self) -> &mut BGPSessionIPAttributes {
        if self.attributes.is_none() {
            self.attributes.set_default();
        }
        self.attributes.as_mut().unwrap()
    }

    // Take field
    pub fn take_attributes(&mut self) -> BGPSessionIPAttributes {
        self.attributes.take().unwrap_or_else(|| BGPSessionIPAttributes::new())
    }
}

impl ::protobuf::Message for SubnetReference {
    fn is_initialized(&self) -> bool {
        for v in &self.resourceReference {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.attributes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.resourceReference)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.attributes)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.resourceReference.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.attributes.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.resourceReference.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.attributes.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SubnetReference {
        SubnetReference::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResourceReference>>(
                "resourceReference",
                |m: &SubnetReference| { &m.resourceReference },
                |m: &mut SubnetReference| { &mut m.resourceReference },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BGPSessionIPAttributes>>(
                "attributes",
                |m: &SubnetReference| { &m.attributes },
                |m: &mut SubnetReference| { &mut m.attributes },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SubnetReference>(
                "SubnetReference",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SubnetReference {
        static instance: ::protobuf::rt::LazyV2<SubnetReference> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SubnetReference::new)
    }
}

impl ::protobuf::Clear for SubnetReference {
    fn clear(&mut self) {
        self.resourceReference.clear();
        self.attributes.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SubnetReference {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubnetReference {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SubnetSpec {
    // message fields
    pub commonSpec: ::protobuf::SingularPtrField<CommonSpec>,
    cidr: ::protobuf::SingularField<::std::string::String>,
    defaultGateway: ::protobuf::SingularField<::std::string::String>,
    pub dnsNameservers: ::protobuf::RepeatedField<::std::string::String>,
    pub ranges: ::protobuf::RepeatedField<Range>,
    disableBGPaaSIPAutoAllocation: ::std::option::Option<bool>,
    bgpaasPrimaryIP: ::protobuf::SingularField<::std::string::String>,
    bgpaasSecondaryIP: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SubnetSpec {
    fn default() -> &'a SubnetSpec {
        <SubnetSpec as ::protobuf::Message>::default_instance()
    }
}

impl SubnetSpec {
    pub fn new() -> SubnetSpec {
        ::std::default::Default::default()
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonSpec commonSpec = 1;


    pub fn get_commonSpec(&self) -> &CommonSpec {
        self.commonSpec.as_ref().unwrap_or_else(|| <CommonSpec as ::protobuf::Message>::default_instance())
    }
    pub fn clear_commonSpec(&mut self) {
        self.commonSpec.clear();
    }

    pub fn has_commonSpec(&self) -> bool {
        self.commonSpec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_commonSpec(&mut self, v: CommonSpec) {
        self.commonSpec = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_commonSpec(&mut self) -> &mut CommonSpec {
        if self.commonSpec.is_none() {
            self.commonSpec.set_default();
        }
        self.commonSpec.as_mut().unwrap()
    }

    // Take field
    pub fn take_commonSpec(&mut self) -> CommonSpec {
        self.commonSpec.take().unwrap_or_else(|| CommonSpec::new())
    }

    // optional string cidr = 3;


    pub fn get_cidr(&self) -> &str {
        match self.cidr.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_cidr(&mut self) {
        self.cidr.clear();
    }

    pub fn has_cidr(&self) -> bool {
        self.cidr.is_some()
    }

    // Param is passed by value, moved
    pub fn set_cidr(&mut self, v: ::std::string::String) {
        self.cidr = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_cidr(&mut self) -> &mut ::std::string::String {
        if self.cidr.is_none() {
            self.cidr.set_default();
        }
        self.cidr.as_mut().unwrap()
    }

    // Take field
    pub fn take_cidr(&mut self) -> ::std::string::String {
        self.cidr.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string defaultGateway = 4;


    pub fn get_defaultGateway(&self) -> &str {
        match self.defaultGateway.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_defaultGateway(&mut self) {
        self.defaultGateway.clear();
    }

    pub fn has_defaultGateway(&self) -> bool {
        self.defaultGateway.is_some()
    }

    // Param is passed by value, moved
    pub fn set_defaultGateway(&mut self, v: ::std::string::String) {
        self.defaultGateway = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_defaultGateway(&mut self) -> &mut ::std::string::String {
        if self.defaultGateway.is_none() {
            self.defaultGateway.set_default();
        }
        self.defaultGateway.as_mut().unwrap()
    }

    // Take field
    pub fn take_defaultGateway(&mut self) -> ::std::string::String {
        self.defaultGateway.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated string dnsNameservers = 5;


    pub fn get_dnsNameservers(&self) -> &[::std::string::String] {
        &self.dnsNameservers
    }
    pub fn clear_dnsNameservers(&mut self) {
        self.dnsNameservers.clear();
    }

    // Param is passed by value, moved
    pub fn set_dnsNameservers(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.dnsNameservers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_dnsNameservers(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.dnsNameservers
    }

    // Take field
    pub fn take_dnsNameservers(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.dnsNameservers, ::protobuf::RepeatedField::new())
    }

    // repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.Range ranges = 6;


    pub fn get_ranges(&self) -> &[Range] {
        &self.ranges
    }
    pub fn clear_ranges(&mut self) {
        self.ranges.clear();
    }

    // Param is passed by value, moved
    pub fn set_ranges(&mut self, v: ::protobuf::RepeatedField<Range>) {
        self.ranges = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ranges(&mut self) -> &mut ::protobuf::RepeatedField<Range> {
        &mut self.ranges
    }

    // Take field
    pub fn take_ranges(&mut self) -> ::protobuf::RepeatedField<Range> {
        ::std::mem::replace(&mut self.ranges, ::protobuf::RepeatedField::new())
    }

    // optional bool disableBGPaaSIPAutoAllocation = 7;


    pub fn get_disableBGPaaSIPAutoAllocation(&self) -> bool {
        self.disableBGPaaSIPAutoAllocation.unwrap_or(false)
    }
    pub fn clear_disableBGPaaSIPAutoAllocation(&mut self) {
        self.disableBGPaaSIPAutoAllocation = ::std::option::Option::None;
    }

    pub fn has_disableBGPaaSIPAutoAllocation(&self) -> bool {
        self.disableBGPaaSIPAutoAllocation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_disableBGPaaSIPAutoAllocation(&mut self, v: bool) {
        self.disableBGPaaSIPAutoAllocation = ::std::option::Option::Some(v);
    }

    // optional string bgpaasPrimaryIP = 8;


    pub fn get_bgpaasPrimaryIP(&self) -> &str {
        match self.bgpaasPrimaryIP.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_bgpaasPrimaryIP(&mut self) {
        self.bgpaasPrimaryIP.clear();
    }

    pub fn has_bgpaasPrimaryIP(&self) -> bool {
        self.bgpaasPrimaryIP.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bgpaasPrimaryIP(&mut self, v: ::std::string::String) {
        self.bgpaasPrimaryIP = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bgpaasPrimaryIP(&mut self) -> &mut ::std::string::String {
        if self.bgpaasPrimaryIP.is_none() {
            self.bgpaasPrimaryIP.set_default();
        }
        self.bgpaasPrimaryIP.as_mut().unwrap()
    }

    // Take field
    pub fn take_bgpaasPrimaryIP(&mut self) -> ::std::string::String {
        self.bgpaasPrimaryIP.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string bgpaasSecondaryIP = 9;


    pub fn get_bgpaasSecondaryIP(&self) -> &str {
        match self.bgpaasSecondaryIP.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_bgpaasSecondaryIP(&mut self) {
        self.bgpaasSecondaryIP.clear();
    }

    pub fn has_bgpaasSecondaryIP(&self) -> bool {
        self.bgpaasSecondaryIP.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bgpaasSecondaryIP(&mut self, v: ::std::string::String) {
        self.bgpaasSecondaryIP = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bgpaasSecondaryIP(&mut self) -> &mut ::std::string::String {
        if self.bgpaasSecondaryIP.is_none() {
            self.bgpaasSecondaryIP.set_default();
        }
        self.bgpaasSecondaryIP.as_mut().unwrap()
    }

    // Take field
    pub fn take_bgpaasSecondaryIP(&mut self) -> ::std::string::String {
        self.bgpaasSecondaryIP.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for SubnetSpec {
    fn is_initialized(&self) -> bool {
        for v in &self.commonSpec {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ranges {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.commonSpec)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.cidr)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.defaultGateway)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.dnsNameservers)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.ranges)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.disableBGPaaSIPAutoAllocation = ::std::option::Option::Some(tmp);
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.bgpaasPrimaryIP)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.bgpaasSecondaryIP)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.commonSpec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.cidr.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.defaultGateway.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        for value in &self.dnsNameservers {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        for value in &self.ranges {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.disableBGPaaSIPAutoAllocation {
            my_size += 2;
        }
        if let Some(ref v) = self.bgpaasPrimaryIP.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(ref v) = self.bgpaasSecondaryIP.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.commonSpec.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.cidr.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.defaultGateway.as_ref() {
            os.write_string(4, &v)?;
        }
        for v in &self.dnsNameservers {
            os.write_string(5, &v)?;
        };
        for v in &self.ranges {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.disableBGPaaSIPAutoAllocation {
            os.write_bool(7, v)?;
        }
        if let Some(ref v) = self.bgpaasPrimaryIP.as_ref() {
            os.write_string(8, &v)?;
        }
        if let Some(ref v) = self.bgpaasSecondaryIP.as_ref() {
            os.write_string(9, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SubnetSpec {
        SubnetSpec::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommonSpec>>(
                "commonSpec",
                |m: &SubnetSpec| { &m.commonSpec },
                |m: &mut SubnetSpec| { &mut m.commonSpec },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "cidr",
                |m: &SubnetSpec| { &m.cidr },
                |m: &mut SubnetSpec| { &mut m.cidr },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "defaultGateway",
                |m: &SubnetSpec| { &m.defaultGateway },
                |m: &mut SubnetSpec| { &mut m.defaultGateway },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "dnsNameservers",
                |m: &SubnetSpec| { &m.dnsNameservers },
                |m: &mut SubnetSpec| { &mut m.dnsNameservers },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Range>>(
                "ranges",
                |m: &SubnetSpec| { &m.ranges },
                |m: &mut SubnetSpec| { &mut m.ranges },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "disableBGPaaSIPAutoAllocation",
                |m: &SubnetSpec| { &m.disableBGPaaSIPAutoAllocation },
                |m: &mut SubnetSpec| { &mut m.disableBGPaaSIPAutoAllocation },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "bgpaasPrimaryIP",
                |m: &SubnetSpec| { &m.bgpaasPrimaryIP },
                |m: &mut SubnetSpec| { &mut m.bgpaasPrimaryIP },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "bgpaasSecondaryIP",
                |m: &SubnetSpec| { &m.bgpaasSecondaryIP },
                |m: &mut SubnetSpec| { &mut m.bgpaasSecondaryIP },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SubnetSpec>(
                "SubnetSpec",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SubnetSpec {
        static instance: ::protobuf::rt::LazyV2<SubnetSpec> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SubnetSpec::new)
    }
}

impl ::protobuf::Clear for SubnetSpec {
    fn clear(&mut self) {
        self.commonSpec.clear();
        self.cidr.clear();
        self.defaultGateway.clear();
        self.dnsNameservers.clear();
        self.ranges.clear();
        self.disableBGPaaSIPAutoAllocation = ::std::option::Option::None;
        self.bgpaasPrimaryIP.clear();
        self.bgpaasSecondaryIP.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SubnetSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubnetSpec {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct SubnetStatus {
    // message fields
    pub commonStatus: ::protobuf::SingularPtrField<CommonStatus>,
    ipCount: ::std::option::Option<i64>,
    allocationUsage: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SubnetStatus {
    fn default() -> &'a SubnetStatus {
        <SubnetStatus as ::protobuf::Message>::default_instance()
    }
}

impl SubnetStatus {
    pub fn new() -> SubnetStatus {
        ::std::default::Default::default()
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonStatus commonStatus = 1;


    pub fn get_commonStatus(&self) -> &CommonStatus {
        self.commonStatus.as_ref().unwrap_or_else(|| <CommonStatus as ::protobuf::Message>::default_instance())
    }
    pub fn clear_commonStatus(&mut self) {
        self.commonStatus.clear();
    }

    pub fn has_commonStatus(&self) -> bool {
        self.commonStatus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_commonStatus(&mut self, v: CommonStatus) {
        self.commonStatus = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_commonStatus(&mut self) -> &mut CommonStatus {
        if self.commonStatus.is_none() {
            self.commonStatus.set_default();
        }
        self.commonStatus.as_mut().unwrap()
    }

    // Take field
    pub fn take_commonStatus(&mut self) -> CommonStatus {
        self.commonStatus.take().unwrap_or_else(|| CommonStatus::new())
    }

    // optional int64 ipCount = 2;


    pub fn get_ipCount(&self) -> i64 {
        self.ipCount.unwrap_or(0)
    }
    pub fn clear_ipCount(&mut self) {
        self.ipCount = ::std::option::Option::None;
    }

    pub fn has_ipCount(&self) -> bool {
        self.ipCount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_ipCount(&mut self, v: i64) {
        self.ipCount = ::std::option::Option::Some(v);
    }

    // optional string allocationUsage = 3;


    pub fn get_allocationUsage(&self) -> &str {
        match self.allocationUsage.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_allocationUsage(&mut self) {
        self.allocationUsage.clear();
    }

    pub fn has_allocationUsage(&self) -> bool {
        self.allocationUsage.is_some()
    }

    // Param is passed by value, moved
    pub fn set_allocationUsage(&mut self, v: ::std::string::String) {
        self.allocationUsage = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_allocationUsage(&mut self) -> &mut ::std::string::String {
        if self.allocationUsage.is_none() {
            self.allocationUsage.set_default();
        }
        self.allocationUsage.as_mut().unwrap()
    }

    // Take field
    pub fn take_allocationUsage(&mut self) -> ::std::string::String {
        self.allocationUsage.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for SubnetStatus {
    fn is_initialized(&self) -> bool {
        for v in &self.commonStatus {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.commonStatus)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.ipCount = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.allocationUsage)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.commonStatus.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.ipCount {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.allocationUsage.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.commonStatus.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.ipCount {
            os.write_int64(2, v)?;
        }
        if let Some(ref v) = self.allocationUsage.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SubnetStatus {
        SubnetStatus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommonStatus>>(
                "commonStatus",
                |m: &SubnetStatus| { &m.commonStatus },
                |m: &mut SubnetStatus| { &mut m.commonStatus },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "ipCount",
                |m: &SubnetStatus| { &m.ipCount },
                |m: &mut SubnetStatus| { &mut m.ipCount },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "allocationUsage",
                |m: &SubnetStatus| { &m.allocationUsage },
                |m: &mut SubnetStatus| { &mut m.allocationUsage },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<SubnetStatus>(
                "SubnetStatus",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static SubnetStatus {
        static instance: ::protobuf::rt::LazyV2<SubnetStatus> = ::protobuf::rt::LazyV2::INIT;
        instance.get(SubnetStatus::new)
    }
}

impl ::protobuf::Clear for SubnetStatus {
    fn clear(&mut self) {
        self.commonStatus.clear();
        self.ipCount = ::std::option::Option::None;
        self.allocationUsage.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SubnetStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubnetStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Tag {
    // message fields
    pub metadata: ::protobuf::SingularPtrField<super::meta::ObjectMeta>,
    pub spec: ::protobuf::SingularPtrField<TagSpec>,
    pub status: ::protobuf::SingularPtrField<TagStatus>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Tag {
    fn default() -> &'a Tag {
        <Tag as ::protobuf::Message>::default_instance()
    }
}

impl Tag {
    pub fn new() -> Tag {
        ::std::default::Default::default()
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;


    pub fn get_metadata(&self) -> &super::meta::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <super::meta::ObjectMeta as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::meta::ObjectMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::meta::ObjectMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::meta::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| super::meta::ObjectMeta::new())
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagSpec spec = 2;


    pub fn get_spec(&self) -> &TagSpec {
        self.spec.as_ref().unwrap_or_else(|| <TagSpec as ::protobuf::Message>::default_instance())
    }
    pub fn clear_spec(&mut self) {
        self.spec.clear();
    }

    pub fn has_spec(&self) -> bool {
        self.spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spec(&mut self, v: TagSpec) {
        self.spec = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spec(&mut self) -> &mut TagSpec {
        if self.spec.is_none() {
            self.spec.set_default();
        }
        self.spec.as_mut().unwrap()
    }

    // Take field
    pub fn take_spec(&mut self) -> TagSpec {
        self.spec.take().unwrap_or_else(|| TagSpec::new())
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagStatus status = 3;


    pub fn get_status(&self) -> &TagStatus {
        self.status.as_ref().unwrap_or_else(|| <TagStatus as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: TagStatus) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut TagStatus {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> TagStatus {
        self.status.take().unwrap_or_else(|| TagStatus::new())
    }
}

impl ::protobuf::Message for Tag {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.spec {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.spec)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.spec.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Tag {
        Tag::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::meta::ObjectMeta>>(
                "metadata",
                |m: &Tag| { &m.metadata },
                |m: &mut Tag| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TagSpec>>(
                "spec",
                |m: &Tag| { &m.spec },
                |m: &mut Tag| { &mut m.spec },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TagStatus>>(
                "status",
                |m: &Tag| { &m.status },
                |m: &mut Tag| { &mut m.status },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Tag>(
                "Tag",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Tag {
        static instance: ::protobuf::rt::LazyV2<Tag> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Tag::new)
    }
}

impl ::protobuf::Clear for Tag {
    fn clear(&mut self) {
        self.metadata.clear();
        self.spec.clear();
        self.status.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Tag {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Tag {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TagList {
    // message fields
    pub metadata: ::protobuf::SingularPtrField<super::meta::ListMeta>,
    pub items: ::protobuf::RepeatedField<Tag>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TagList {
    fn default() -> &'a TagList {
        <TagList as ::protobuf::Message>::default_instance()
    }
}

impl TagList {
    pub fn new() -> TagList {
        ::std::default::Default::default()
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;


    pub fn get_metadata(&self) -> &super::meta::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <super::meta::ListMeta as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::meta::ListMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::meta::ListMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::meta::ListMeta {
        self.metadata.take().unwrap_or_else(|| super::meta::ListMeta::new())
    }

    // repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.Tag items = 2;


    pub fn get_items(&self) -> &[Tag] {
        &self.items
    }
    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::protobuf::RepeatedField<Tag>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::protobuf::RepeatedField<Tag> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::protobuf::RepeatedField<Tag> {
        ::std::mem::replace(&mut self.items, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for TagList {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.items {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.items)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.items {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TagList {
        TagList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::meta::ListMeta>>(
                "metadata",
                |m: &TagList| { &m.metadata },
                |m: &mut TagList| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Tag>>(
                "items",
                |m: &TagList| { &m.items },
                |m: &mut TagList| { &mut m.items },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TagList>(
                "TagList",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TagList {
        static instance: ::protobuf::rt::LazyV2<TagList> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TagList::new)
    }
}

impl ::protobuf::Clear for TagList {
    fn clear(&mut self) {
        self.metadata.clear();
        self.items.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TagList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TagList {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TagSpec {
    // message fields
    pub commonSpec: ::protobuf::SingularPtrField<CommonSpec>,
    tagTypeName: ::protobuf::SingularField<::std::string::String>,
    tagValue: ::protobuf::SingularField<::std::string::String>,
    pub tagTypeReference: ::protobuf::SingularPtrField<ResourceReference>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TagSpec {
    fn default() -> &'a TagSpec {
        <TagSpec as ::protobuf::Message>::default_instance()
    }
}

impl TagSpec {
    pub fn new() -> TagSpec {
        ::std::default::Default::default()
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonSpec commonSpec = 1;


    pub fn get_commonSpec(&self) -> &CommonSpec {
        self.commonSpec.as_ref().unwrap_or_else(|| <CommonSpec as ::protobuf::Message>::default_instance())
    }
    pub fn clear_commonSpec(&mut self) {
        self.commonSpec.clear();
    }

    pub fn has_commonSpec(&self) -> bool {
        self.commonSpec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_commonSpec(&mut self, v: CommonSpec) {
        self.commonSpec = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_commonSpec(&mut self) -> &mut CommonSpec {
        if self.commonSpec.is_none() {
            self.commonSpec.set_default();
        }
        self.commonSpec.as_mut().unwrap()
    }

    // Take field
    pub fn take_commonSpec(&mut self) -> CommonSpec {
        self.commonSpec.take().unwrap_or_else(|| CommonSpec::new())
    }

    // optional string tagTypeName = 2;


    pub fn get_tagTypeName(&self) -> &str {
        match self.tagTypeName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_tagTypeName(&mut self) {
        self.tagTypeName.clear();
    }

    pub fn has_tagTypeName(&self) -> bool {
        self.tagTypeName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tagTypeName(&mut self, v: ::std::string::String) {
        self.tagTypeName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tagTypeName(&mut self) -> &mut ::std::string::String {
        if self.tagTypeName.is_none() {
            self.tagTypeName.set_default();
        }
        self.tagTypeName.as_mut().unwrap()
    }

    // Take field
    pub fn take_tagTypeName(&mut self) -> ::std::string::String {
        self.tagTypeName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string tagValue = 3;


    pub fn get_tagValue(&self) -> &str {
        match self.tagValue.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_tagValue(&mut self) {
        self.tagValue.clear();
    }

    pub fn has_tagValue(&self) -> bool {
        self.tagValue.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tagValue(&mut self, v: ::std::string::String) {
        self.tagValue = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tagValue(&mut self) -> &mut ::std::string::String {
        if self.tagValue.is_none() {
            self.tagValue.set_default();
        }
        self.tagValue.as_mut().unwrap()
    }

    // Take field
    pub fn take_tagValue(&mut self) -> ::std::string::String {
        self.tagValue.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ResourceReference tagTypeReference = 4;


    pub fn get_tagTypeReference(&self) -> &ResourceReference {
        self.tagTypeReference.as_ref().unwrap_or_else(|| <ResourceReference as ::protobuf::Message>::default_instance())
    }
    pub fn clear_tagTypeReference(&mut self) {
        self.tagTypeReference.clear();
    }

    pub fn has_tagTypeReference(&self) -> bool {
        self.tagTypeReference.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tagTypeReference(&mut self, v: ResourceReference) {
        self.tagTypeReference = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tagTypeReference(&mut self) -> &mut ResourceReference {
        if self.tagTypeReference.is_none() {
            self.tagTypeReference.set_default();
        }
        self.tagTypeReference.as_mut().unwrap()
    }

    // Take field
    pub fn take_tagTypeReference(&mut self) -> ResourceReference {
        self.tagTypeReference.take().unwrap_or_else(|| ResourceReference::new())
    }
}

impl ::protobuf::Message for TagSpec {
    fn is_initialized(&self) -> bool {
        for v in &self.commonSpec {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tagTypeReference {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.commonSpec)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.tagTypeName)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.tagValue)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.tagTypeReference)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.commonSpec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.tagTypeName.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.tagValue.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.tagTypeReference.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.commonSpec.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.tagTypeName.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.tagValue.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.tagTypeReference.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TagSpec {
        TagSpec::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommonSpec>>(
                "commonSpec",
                |m: &TagSpec| { &m.commonSpec },
                |m: &mut TagSpec| { &mut m.commonSpec },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "tagTypeName",
                |m: &TagSpec| { &m.tagTypeName },
                |m: &mut TagSpec| { &mut m.tagTypeName },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "tagValue",
                |m: &TagSpec| { &m.tagValue },
                |m: &mut TagSpec| { &mut m.tagValue },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResourceReference>>(
                "tagTypeReference",
                |m: &TagSpec| { &m.tagTypeReference },
                |m: &mut TagSpec| { &mut m.tagTypeReference },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TagSpec>(
                "TagSpec",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TagSpec {
        static instance: ::protobuf::rt::LazyV2<TagSpec> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TagSpec::new)
    }
}

impl ::protobuf::Clear for TagSpec {
    fn clear(&mut self) {
        self.commonSpec.clear();
        self.tagTypeName.clear();
        self.tagValue.clear();
        self.tagTypeReference.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TagSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TagSpec {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TagStatus {
    // message fields
    pub commonStatus: ::protobuf::SingularPtrField<CommonStatus>,
    tagId: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TagStatus {
    fn default() -> &'a TagStatus {
        <TagStatus as ::protobuf::Message>::default_instance()
    }
}

impl TagStatus {
    pub fn new() -> TagStatus {
        ::std::default::Default::default()
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonStatus commonStatus = 1;


    pub fn get_commonStatus(&self) -> &CommonStatus {
        self.commonStatus.as_ref().unwrap_or_else(|| <CommonStatus as ::protobuf::Message>::default_instance())
    }
    pub fn clear_commonStatus(&mut self) {
        self.commonStatus.clear();
    }

    pub fn has_commonStatus(&self) -> bool {
        self.commonStatus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_commonStatus(&mut self, v: CommonStatus) {
        self.commonStatus = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_commonStatus(&mut self) -> &mut CommonStatus {
        if self.commonStatus.is_none() {
            self.commonStatus.set_default();
        }
        self.commonStatus.as_mut().unwrap()
    }

    // Take field
    pub fn take_commonStatus(&mut self) -> CommonStatus {
        self.commonStatus.take().unwrap_or_else(|| CommonStatus::new())
    }

    // optional string tagId = 2;


    pub fn get_tagId(&self) -> &str {
        match self.tagId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_tagId(&mut self) {
        self.tagId.clear();
    }

    pub fn has_tagId(&self) -> bool {
        self.tagId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tagId(&mut self, v: ::std::string::String) {
        self.tagId = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tagId(&mut self) -> &mut ::std::string::String {
        if self.tagId.is_none() {
            self.tagId.set_default();
        }
        self.tagId.as_mut().unwrap()
    }

    // Take field
    pub fn take_tagId(&mut self) -> ::std::string::String {
        self.tagId.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for TagStatus {
    fn is_initialized(&self) -> bool {
        for v in &self.commonStatus {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.commonStatus)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.tagId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.commonStatus.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.tagId.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.commonStatus.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.tagId.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TagStatus {
        TagStatus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommonStatus>>(
                "commonStatus",
                |m: &TagStatus| { &m.commonStatus },
                |m: &mut TagStatus| { &mut m.commonStatus },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "tagId",
                |m: &TagStatus| { &m.tagId },
                |m: &mut TagStatus| { &mut m.tagId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TagStatus>(
                "TagStatus",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TagStatus {
        static instance: ::protobuf::rt::LazyV2<TagStatus> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TagStatus::new)
    }
}

impl ::protobuf::Clear for TagStatus {
    fn clear(&mut self) {
        self.commonStatus.clear();
        self.tagId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TagStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TagStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TagType {
    // message fields
    pub metadata: ::protobuf::SingularPtrField<super::meta::ObjectMeta>,
    pub spec: ::protobuf::SingularPtrField<TagTypeSpec>,
    pub status: ::protobuf::SingularPtrField<TagTypeStatus>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TagType {
    fn default() -> &'a TagType {
        <TagType as ::protobuf::Message>::default_instance()
    }
}

impl TagType {
    pub fn new() -> TagType {
        ::std::default::Default::default()
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;


    pub fn get_metadata(&self) -> &super::meta::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <super::meta::ObjectMeta as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::meta::ObjectMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::meta::ObjectMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::meta::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| super::meta::ObjectMeta::new())
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagTypeSpec spec = 2;


    pub fn get_spec(&self) -> &TagTypeSpec {
        self.spec.as_ref().unwrap_or_else(|| <TagTypeSpec as ::protobuf::Message>::default_instance())
    }
    pub fn clear_spec(&mut self) {
        self.spec.clear();
    }

    pub fn has_spec(&self) -> bool {
        self.spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spec(&mut self, v: TagTypeSpec) {
        self.spec = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spec(&mut self) -> &mut TagTypeSpec {
        if self.spec.is_none() {
            self.spec.set_default();
        }
        self.spec.as_mut().unwrap()
    }

    // Take field
    pub fn take_spec(&mut self) -> TagTypeSpec {
        self.spec.take().unwrap_or_else(|| TagTypeSpec::new())
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagTypeStatus status = 3;


    pub fn get_status(&self) -> &TagTypeStatus {
        self.status.as_ref().unwrap_or_else(|| <TagTypeStatus as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: TagTypeStatus) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut TagTypeStatus {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> TagTypeStatus {
        self.status.take().unwrap_or_else(|| TagTypeStatus::new())
    }
}

impl ::protobuf::Message for TagType {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.spec {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.spec)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.spec.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TagType {
        TagType::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::meta::ObjectMeta>>(
                "metadata",
                |m: &TagType| { &m.metadata },
                |m: &mut TagType| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TagTypeSpec>>(
                "spec",
                |m: &TagType| { &m.spec },
                |m: &mut TagType| { &mut m.spec },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TagTypeStatus>>(
                "status",
                |m: &TagType| { &m.status },
                |m: &mut TagType| { &mut m.status },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TagType>(
                "TagType",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TagType {
        static instance: ::protobuf::rt::LazyV2<TagType> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TagType::new)
    }
}

impl ::protobuf::Clear for TagType {
    fn clear(&mut self) {
        self.metadata.clear();
        self.spec.clear();
        self.status.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TagType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TagType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TagTypeList {
    // message fields
    pub metadata: ::protobuf::SingularPtrField<super::meta::ListMeta>,
    pub items: ::protobuf::RepeatedField<TagType>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TagTypeList {
    fn default() -> &'a TagTypeList {
        <TagTypeList as ::protobuf::Message>::default_instance()
    }
}

impl TagTypeList {
    pub fn new() -> TagTypeList {
        ::std::default::Default::default()
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;


    pub fn get_metadata(&self) -> &super::meta::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <super::meta::ListMeta as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::meta::ListMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::meta::ListMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::meta::ListMeta {
        self.metadata.take().unwrap_or_else(|| super::meta::ListMeta::new())
    }

    // repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagType items = 2;


    pub fn get_items(&self) -> &[TagType] {
        &self.items
    }
    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::protobuf::RepeatedField<TagType>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::protobuf::RepeatedField<TagType> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::protobuf::RepeatedField<TagType> {
        ::std::mem::replace(&mut self.items, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for TagTypeList {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.items {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.items)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.items {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TagTypeList {
        TagTypeList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::meta::ListMeta>>(
                "metadata",
                |m: &TagTypeList| { &m.metadata },
                |m: &mut TagTypeList| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TagType>>(
                "items",
                |m: &TagTypeList| { &m.items },
                |m: &mut TagTypeList| { &mut m.items },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TagTypeList>(
                "TagTypeList",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TagTypeList {
        static instance: ::protobuf::rt::LazyV2<TagTypeList> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TagTypeList::new)
    }
}

impl ::protobuf::Clear for TagTypeList {
    fn clear(&mut self) {
        self.metadata.clear();
        self.items.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TagTypeList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TagTypeList {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TagTypeSpec {
    // message fields
    pub commonSpec: ::protobuf::SingularPtrField<CommonSpec>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TagTypeSpec {
    fn default() -> &'a TagTypeSpec {
        <TagTypeSpec as ::protobuf::Message>::default_instance()
    }
}

impl TagTypeSpec {
    pub fn new() -> TagTypeSpec {
        ::std::default::Default::default()
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonSpec commonSpec = 1;


    pub fn get_commonSpec(&self) -> &CommonSpec {
        self.commonSpec.as_ref().unwrap_or_else(|| <CommonSpec as ::protobuf::Message>::default_instance())
    }
    pub fn clear_commonSpec(&mut self) {
        self.commonSpec.clear();
    }

    pub fn has_commonSpec(&self) -> bool {
        self.commonSpec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_commonSpec(&mut self, v: CommonSpec) {
        self.commonSpec = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_commonSpec(&mut self) -> &mut CommonSpec {
        if self.commonSpec.is_none() {
            self.commonSpec.set_default();
        }
        self.commonSpec.as_mut().unwrap()
    }

    // Take field
    pub fn take_commonSpec(&mut self) -> CommonSpec {
        self.commonSpec.take().unwrap_or_else(|| CommonSpec::new())
    }
}

impl ::protobuf::Message for TagTypeSpec {
    fn is_initialized(&self) -> bool {
        for v in &self.commonSpec {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.commonSpec)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.commonSpec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.commonSpec.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TagTypeSpec {
        TagTypeSpec::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommonSpec>>(
                "commonSpec",
                |m: &TagTypeSpec| { &m.commonSpec },
                |m: &mut TagTypeSpec| { &mut m.commonSpec },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TagTypeSpec>(
                "TagTypeSpec",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TagTypeSpec {
        static instance: ::protobuf::rt::LazyV2<TagTypeSpec> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TagTypeSpec::new)
    }
}

impl ::protobuf::Clear for TagTypeSpec {
    fn clear(&mut self) {
        self.commonSpec.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TagTypeSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TagTypeSpec {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TagTypeStatus {
    // message fields
    pub commonStatus: ::protobuf::SingularPtrField<CommonStatus>,
    tagTypeId: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TagTypeStatus {
    fn default() -> &'a TagTypeStatus {
        <TagTypeStatus as ::protobuf::Message>::default_instance()
    }
}

impl TagTypeStatus {
    pub fn new() -> TagTypeStatus {
        ::std::default::Default::default()
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonStatus commonStatus = 1;


    pub fn get_commonStatus(&self) -> &CommonStatus {
        self.commonStatus.as_ref().unwrap_or_else(|| <CommonStatus as ::protobuf::Message>::default_instance())
    }
    pub fn clear_commonStatus(&mut self) {
        self.commonStatus.clear();
    }

    pub fn has_commonStatus(&self) -> bool {
        self.commonStatus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_commonStatus(&mut self, v: CommonStatus) {
        self.commonStatus = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_commonStatus(&mut self) -> &mut CommonStatus {
        if self.commonStatus.is_none() {
            self.commonStatus.set_default();
        }
        self.commonStatus.as_mut().unwrap()
    }

    // Take field
    pub fn take_commonStatus(&mut self) -> CommonStatus {
        self.commonStatus.take().unwrap_or_else(|| CommonStatus::new())
    }

    // optional string tagTypeId = 2;


    pub fn get_tagTypeId(&self) -> &str {
        match self.tagTypeId.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_tagTypeId(&mut self) {
        self.tagTypeId.clear();
    }

    pub fn has_tagTypeId(&self) -> bool {
        self.tagTypeId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tagTypeId(&mut self, v: ::std::string::String) {
        self.tagTypeId = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tagTypeId(&mut self) -> &mut ::std::string::String {
        if self.tagTypeId.is_none() {
            self.tagTypeId.set_default();
        }
        self.tagTypeId.as_mut().unwrap()
    }

    // Take field
    pub fn take_tagTypeId(&mut self) -> ::std::string::String {
        self.tagTypeId.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for TagTypeStatus {
    fn is_initialized(&self) -> bool {
        for v in &self.commonStatus {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.commonStatus)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.tagTypeId)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.commonStatus.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.tagTypeId.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.commonStatus.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.tagTypeId.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TagTypeStatus {
        TagTypeStatus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommonStatus>>(
                "commonStatus",
                |m: &TagTypeStatus| { &m.commonStatus },
                |m: &mut TagTypeStatus| { &mut m.commonStatus },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "tagTypeId",
                |m: &TagTypeStatus| { &m.tagTypeId },
                |m: &mut TagTypeStatus| { &mut m.tagTypeId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TagTypeStatus>(
                "TagTypeStatus",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TagTypeStatus {
        static instance: ::protobuf::rt::LazyV2<TagTypeStatus> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TagTypeStatus::new)
    }
}

impl ::protobuf::Clear for TagTypeStatus {
    fn clear(&mut self) {
        self.commonStatus.clear();
        self.tagTypeId.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TagTypeStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TagTypeStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VirtualMachine {
    // message fields
    pub metadata: ::protobuf::SingularPtrField<super::meta::ObjectMeta>,
    pub spec: ::protobuf::SingularPtrField<VirtualMachineSpec>,
    pub status: ::protobuf::SingularPtrField<VirtualMachineStatus>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VirtualMachine {
    fn default() -> &'a VirtualMachine {
        <VirtualMachine as ::protobuf::Message>::default_instance()
    }
}

impl VirtualMachine {
    pub fn new() -> VirtualMachine {
        ::std::default::Default::default()
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;


    pub fn get_metadata(&self) -> &super::meta::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <super::meta::ObjectMeta as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::meta::ObjectMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::meta::ObjectMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::meta::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| super::meta::ObjectMeta::new())
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineSpec spec = 2;


    pub fn get_spec(&self) -> &VirtualMachineSpec {
        self.spec.as_ref().unwrap_or_else(|| <VirtualMachineSpec as ::protobuf::Message>::default_instance())
    }
    pub fn clear_spec(&mut self) {
        self.spec.clear();
    }

    pub fn has_spec(&self) -> bool {
        self.spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spec(&mut self, v: VirtualMachineSpec) {
        self.spec = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spec(&mut self) -> &mut VirtualMachineSpec {
        if self.spec.is_none() {
            self.spec.set_default();
        }
        self.spec.as_mut().unwrap()
    }

    // Take field
    pub fn take_spec(&mut self) -> VirtualMachineSpec {
        self.spec.take().unwrap_or_else(|| VirtualMachineSpec::new())
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineStatus status = 3;


    pub fn get_status(&self) -> &VirtualMachineStatus {
        self.status.as_ref().unwrap_or_else(|| <VirtualMachineStatus as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: VirtualMachineStatus) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut VirtualMachineStatus {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> VirtualMachineStatus {
        self.status.take().unwrap_or_else(|| VirtualMachineStatus::new())
    }
}

impl ::protobuf::Message for VirtualMachine {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.spec {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.spec)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.spec.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VirtualMachine {
        VirtualMachine::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::meta::ObjectMeta>>(
                "metadata",
                |m: &VirtualMachine| { &m.metadata },
                |m: &mut VirtualMachine| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<VirtualMachineSpec>>(
                "spec",
                |m: &VirtualMachine| { &m.spec },
                |m: &mut VirtualMachine| { &mut m.spec },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<VirtualMachineStatus>>(
                "status",
                |m: &VirtualMachine| { &m.status },
                |m: &mut VirtualMachine| { &mut m.status },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VirtualMachine>(
                "VirtualMachine",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VirtualMachine {
        static instance: ::protobuf::rt::LazyV2<VirtualMachine> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VirtualMachine::new)
    }
}

impl ::protobuf::Clear for VirtualMachine {
    fn clear(&mut self) {
        self.metadata.clear();
        self.spec.clear();
        self.status.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VirtualMachine {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VirtualMachine {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VirtualMachineInterface {
    // message fields
    pub metadata: ::protobuf::SingularPtrField<super::meta::ObjectMeta>,
    pub spec: ::protobuf::SingularPtrField<VirtualMachineInterfaceSpec>,
    pub status: ::protobuf::SingularPtrField<VirtualMachineInterfaceStatus>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VirtualMachineInterface {
    fn default() -> &'a VirtualMachineInterface {
        <VirtualMachineInterface as ::protobuf::Message>::default_instance()
    }
}

impl VirtualMachineInterface {
    pub fn new() -> VirtualMachineInterface {
        ::std::default::Default::default()
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;


    pub fn get_metadata(&self) -> &super::meta::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <super::meta::ObjectMeta as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::meta::ObjectMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::meta::ObjectMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::meta::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| super::meta::ObjectMeta::new())
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterfaceSpec spec = 2;


    pub fn get_spec(&self) -> &VirtualMachineInterfaceSpec {
        self.spec.as_ref().unwrap_or_else(|| <VirtualMachineInterfaceSpec as ::protobuf::Message>::default_instance())
    }
    pub fn clear_spec(&mut self) {
        self.spec.clear();
    }

    pub fn has_spec(&self) -> bool {
        self.spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spec(&mut self, v: VirtualMachineInterfaceSpec) {
        self.spec = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spec(&mut self) -> &mut VirtualMachineInterfaceSpec {
        if self.spec.is_none() {
            self.spec.set_default();
        }
        self.spec.as_mut().unwrap()
    }

    // Take field
    pub fn take_spec(&mut self) -> VirtualMachineInterfaceSpec {
        self.spec.take().unwrap_or_else(|| VirtualMachineInterfaceSpec::new())
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterfaceStatus status = 3;


    pub fn get_status(&self) -> &VirtualMachineInterfaceStatus {
        self.status.as_ref().unwrap_or_else(|| <VirtualMachineInterfaceStatus as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: VirtualMachineInterfaceStatus) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut VirtualMachineInterfaceStatus {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> VirtualMachineInterfaceStatus {
        self.status.take().unwrap_or_else(|| VirtualMachineInterfaceStatus::new())
    }
}

impl ::protobuf::Message for VirtualMachineInterface {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.spec {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.spec)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.spec.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VirtualMachineInterface {
        VirtualMachineInterface::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::meta::ObjectMeta>>(
                "metadata",
                |m: &VirtualMachineInterface| { &m.metadata },
                |m: &mut VirtualMachineInterface| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<VirtualMachineInterfaceSpec>>(
                "spec",
                |m: &VirtualMachineInterface| { &m.spec },
                |m: &mut VirtualMachineInterface| { &mut m.spec },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<VirtualMachineInterfaceStatus>>(
                "status",
                |m: &VirtualMachineInterface| { &m.status },
                |m: &mut VirtualMachineInterface| { &mut m.status },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VirtualMachineInterface>(
                "VirtualMachineInterface",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VirtualMachineInterface {
        static instance: ::protobuf::rt::LazyV2<VirtualMachineInterface> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VirtualMachineInterface::new)
    }
}

impl ::protobuf::Clear for VirtualMachineInterface {
    fn clear(&mut self) {
        self.metadata.clear();
        self.spec.clear();
        self.status.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VirtualMachineInterface {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VirtualMachineInterface {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VirtualMachineInterfaceList {
    // message fields
    pub metadata: ::protobuf::SingularPtrField<super::meta::ListMeta>,
    pub items: ::protobuf::RepeatedField<VirtualMachineInterface>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VirtualMachineInterfaceList {
    fn default() -> &'a VirtualMachineInterfaceList {
        <VirtualMachineInterfaceList as ::protobuf::Message>::default_instance()
    }
}

impl VirtualMachineInterfaceList {
    pub fn new() -> VirtualMachineInterfaceList {
        ::std::default::Default::default()
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;


    pub fn get_metadata(&self) -> &super::meta::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <super::meta::ListMeta as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::meta::ListMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::meta::ListMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::meta::ListMeta {
        self.metadata.take().unwrap_or_else(|| super::meta::ListMeta::new())
    }

    // repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterface items = 2;


    pub fn get_items(&self) -> &[VirtualMachineInterface] {
        &self.items
    }
    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::protobuf::RepeatedField<VirtualMachineInterface>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::protobuf::RepeatedField<VirtualMachineInterface> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::protobuf::RepeatedField<VirtualMachineInterface> {
        ::std::mem::replace(&mut self.items, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for VirtualMachineInterfaceList {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.items {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.items)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.items {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VirtualMachineInterfaceList {
        VirtualMachineInterfaceList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::meta::ListMeta>>(
                "metadata",
                |m: &VirtualMachineInterfaceList| { &m.metadata },
                |m: &mut VirtualMachineInterfaceList| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<VirtualMachineInterface>>(
                "items",
                |m: &VirtualMachineInterfaceList| { &m.items },
                |m: &mut VirtualMachineInterfaceList| { &mut m.items },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VirtualMachineInterfaceList>(
                "VirtualMachineInterfaceList",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VirtualMachineInterfaceList {
        static instance: ::protobuf::rt::LazyV2<VirtualMachineInterfaceList> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VirtualMachineInterfaceList::new)
    }
}

impl ::protobuf::Clear for VirtualMachineInterfaceList {
    fn clear(&mut self) {
        self.metadata.clear();
        self.items.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VirtualMachineInterfaceList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VirtualMachineInterfaceList {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VirtualMachineInterfaceProperties {
    // message fields
    subInterfaceVlanTag: ::std::option::Option<u32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VirtualMachineInterfaceProperties {
    fn default() -> &'a VirtualMachineInterfaceProperties {
        <VirtualMachineInterfaceProperties as ::protobuf::Message>::default_instance()
    }
}

impl VirtualMachineInterfaceProperties {
    pub fn new() -> VirtualMachineInterfaceProperties {
        ::std::default::Default::default()
    }

    // optional uint32 subInterfaceVlanTag = 1;


    pub fn get_subInterfaceVlanTag(&self) -> u32 {
        self.subInterfaceVlanTag.unwrap_or(0)
    }
    pub fn clear_subInterfaceVlanTag(&mut self) {
        self.subInterfaceVlanTag = ::std::option::Option::None;
    }

    pub fn has_subInterfaceVlanTag(&self) -> bool {
        self.subInterfaceVlanTag.is_some()
    }

    // Param is passed by value, moved
    pub fn set_subInterfaceVlanTag(&mut self, v: u32) {
        self.subInterfaceVlanTag = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for VirtualMachineInterfaceProperties {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_uint32()?;
                    self.subInterfaceVlanTag = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.subInterfaceVlanTag {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.subInterfaceVlanTag {
            os.write_uint32(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VirtualMachineInterfaceProperties {
        VirtualMachineInterfaceProperties::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeUint32>(
                "subInterfaceVlanTag",
                |m: &VirtualMachineInterfaceProperties| { &m.subInterfaceVlanTag },
                |m: &mut VirtualMachineInterfaceProperties| { &mut m.subInterfaceVlanTag },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VirtualMachineInterfaceProperties>(
                "VirtualMachineInterfaceProperties",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VirtualMachineInterfaceProperties {
        static instance: ::protobuf::rt::LazyV2<VirtualMachineInterfaceProperties> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VirtualMachineInterfaceProperties::new)
    }
}

impl ::protobuf::Clear for VirtualMachineInterfaceProperties {
    fn clear(&mut self) {
        self.subInterfaceVlanTag = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VirtualMachineInterfaceProperties {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VirtualMachineInterfaceProperties {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VirtualMachineInterfaceSpec {
    // message fields
    pub commonSpec: ::protobuf::SingularPtrField<CommonSpec>,
    pub parent: ::protobuf::SingularPtrField<super::generated::ObjectReference>,
    pub virtualMachineInterfaceMacAddresses: ::protobuf::SingularPtrField<MACAddresses>,
    pub virtualNetworkReference: ::protobuf::SingularPtrField<ResourceReference>,
    pub virtualMachineReferences: ::protobuf::RepeatedField<ResourceReference>,
    virtualMachineInterfaceDisablePolicy: ::std::option::Option<bool>,
    pub allowedAddressPairs: ::protobuf::SingularPtrField<AllowedAddressPairs>,
    portSecurityEnabled: ::std::option::Option<bool>,
    pub virtualMachineInterfaceReferences: ::protobuf::RepeatedField<ResourceReference>,
    pub properties: ::protobuf::SingularPtrField<VirtualMachineInterfaceProperties>,
    pub tagReferences: ::protobuf::RepeatedField<ResourceReference>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VirtualMachineInterfaceSpec {
    fn default() -> &'a VirtualMachineInterfaceSpec {
        <VirtualMachineInterfaceSpec as ::protobuf::Message>::default_instance()
    }
}

impl VirtualMachineInterfaceSpec {
    pub fn new() -> VirtualMachineInterfaceSpec {
        ::std::default::Default::default()
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonSpec commonSpec = 1;


    pub fn get_commonSpec(&self) -> &CommonSpec {
        self.commonSpec.as_ref().unwrap_or_else(|| <CommonSpec as ::protobuf::Message>::default_instance())
    }
    pub fn clear_commonSpec(&mut self) {
        self.commonSpec.clear();
    }

    pub fn has_commonSpec(&self) -> bool {
        self.commonSpec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_commonSpec(&mut self, v: CommonSpec) {
        self.commonSpec = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_commonSpec(&mut self) -> &mut CommonSpec {
        if self.commonSpec.is_none() {
            self.commonSpec.set_default();
        }
        self.commonSpec.as_mut().unwrap()
    }

    // Take field
    pub fn take_commonSpec(&mut self) -> CommonSpec {
        self.commonSpec.take().unwrap_or_else(|| CommonSpec::new())
    }

    // optional .k8s.io.api.core.v1.ObjectReference parent = 2;


    pub fn get_parent(&self) -> &super::generated::ObjectReference {
        self.parent.as_ref().unwrap_or_else(|| <super::generated::ObjectReference as ::protobuf::Message>::default_instance())
    }
    pub fn clear_parent(&mut self) {
        self.parent.clear();
    }

    pub fn has_parent(&self) -> bool {
        self.parent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_parent(&mut self, v: super::generated::ObjectReference) {
        self.parent = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent(&mut self) -> &mut super::generated::ObjectReference {
        if self.parent.is_none() {
            self.parent.set_default();
        }
        self.parent.as_mut().unwrap()
    }

    // Take field
    pub fn take_parent(&mut self) -> super::generated::ObjectReference {
        self.parent.take().unwrap_or_else(|| super::generated::ObjectReference::new())
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.MACAddresses virtualMachineInterfaceMacAddresses = 3;


    pub fn get_virtualMachineInterfaceMacAddresses(&self) -> &MACAddresses {
        self.virtualMachineInterfaceMacAddresses.as_ref().unwrap_or_else(|| <MACAddresses as ::protobuf::Message>::default_instance())
    }
    pub fn clear_virtualMachineInterfaceMacAddresses(&mut self) {
        self.virtualMachineInterfaceMacAddresses.clear();
    }

    pub fn has_virtualMachineInterfaceMacAddresses(&self) -> bool {
        self.virtualMachineInterfaceMacAddresses.is_some()
    }

    // Param is passed by value, moved
    pub fn set_virtualMachineInterfaceMacAddresses(&mut self, v: MACAddresses) {
        self.virtualMachineInterfaceMacAddresses = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_virtualMachineInterfaceMacAddresses(&mut self) -> &mut MACAddresses {
        if self.virtualMachineInterfaceMacAddresses.is_none() {
            self.virtualMachineInterfaceMacAddresses.set_default();
        }
        self.virtualMachineInterfaceMacAddresses.as_mut().unwrap()
    }

    // Take field
    pub fn take_virtualMachineInterfaceMacAddresses(&mut self) -> MACAddresses {
        self.virtualMachineInterfaceMacAddresses.take().unwrap_or_else(|| MACAddresses::new())
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ResourceReference virtualNetworkReference = 4;


    pub fn get_virtualNetworkReference(&self) -> &ResourceReference {
        self.virtualNetworkReference.as_ref().unwrap_or_else(|| <ResourceReference as ::protobuf::Message>::default_instance())
    }
    pub fn clear_virtualNetworkReference(&mut self) {
        self.virtualNetworkReference.clear();
    }

    pub fn has_virtualNetworkReference(&self) -> bool {
        self.virtualNetworkReference.is_some()
    }

    // Param is passed by value, moved
    pub fn set_virtualNetworkReference(&mut self, v: ResourceReference) {
        self.virtualNetworkReference = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_virtualNetworkReference(&mut self) -> &mut ResourceReference {
        if self.virtualNetworkReference.is_none() {
            self.virtualNetworkReference.set_default();
        }
        self.virtualNetworkReference.as_mut().unwrap()
    }

    // Take field
    pub fn take_virtualNetworkReference(&mut self) -> ResourceReference {
        self.virtualNetworkReference.take().unwrap_or_else(|| ResourceReference::new())
    }

    // repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ResourceReference virtualMachineReferences = 5;


    pub fn get_virtualMachineReferences(&self) -> &[ResourceReference] {
        &self.virtualMachineReferences
    }
    pub fn clear_virtualMachineReferences(&mut self) {
        self.virtualMachineReferences.clear();
    }

    // Param is passed by value, moved
    pub fn set_virtualMachineReferences(&mut self, v: ::protobuf::RepeatedField<ResourceReference>) {
        self.virtualMachineReferences = v;
    }

    // Mutable pointer to the field.
    pub fn mut_virtualMachineReferences(&mut self) -> &mut ::protobuf::RepeatedField<ResourceReference> {
        &mut self.virtualMachineReferences
    }

    // Take field
    pub fn take_virtualMachineReferences(&mut self) -> ::protobuf::RepeatedField<ResourceReference> {
        ::std::mem::replace(&mut self.virtualMachineReferences, ::protobuf::RepeatedField::new())
    }

    // optional bool virtualMachineInterfaceDisablePolicy = 6;


    pub fn get_virtualMachineInterfaceDisablePolicy(&self) -> bool {
        self.virtualMachineInterfaceDisablePolicy.unwrap_or(false)
    }
    pub fn clear_virtualMachineInterfaceDisablePolicy(&mut self) {
        self.virtualMachineInterfaceDisablePolicy = ::std::option::Option::None;
    }

    pub fn has_virtualMachineInterfaceDisablePolicy(&self) -> bool {
        self.virtualMachineInterfaceDisablePolicy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_virtualMachineInterfaceDisablePolicy(&mut self, v: bool) {
        self.virtualMachineInterfaceDisablePolicy = ::std::option::Option::Some(v);
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AllowedAddressPairs allowedAddressPairs = 7;


    pub fn get_allowedAddressPairs(&self) -> &AllowedAddressPairs {
        self.allowedAddressPairs.as_ref().unwrap_or_else(|| <AllowedAddressPairs as ::protobuf::Message>::default_instance())
    }
    pub fn clear_allowedAddressPairs(&mut self) {
        self.allowedAddressPairs.clear();
    }

    pub fn has_allowedAddressPairs(&self) -> bool {
        self.allowedAddressPairs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_allowedAddressPairs(&mut self, v: AllowedAddressPairs) {
        self.allowedAddressPairs = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_allowedAddressPairs(&mut self) -> &mut AllowedAddressPairs {
        if self.allowedAddressPairs.is_none() {
            self.allowedAddressPairs.set_default();
        }
        self.allowedAddressPairs.as_mut().unwrap()
    }

    // Take field
    pub fn take_allowedAddressPairs(&mut self) -> AllowedAddressPairs {
        self.allowedAddressPairs.take().unwrap_or_else(|| AllowedAddressPairs::new())
    }

    // optional bool portSecurityEnabled = 8;


    pub fn get_portSecurityEnabled(&self) -> bool {
        self.portSecurityEnabled.unwrap_or(false)
    }
    pub fn clear_portSecurityEnabled(&mut self) {
        self.portSecurityEnabled = ::std::option::Option::None;
    }

    pub fn has_portSecurityEnabled(&self) -> bool {
        self.portSecurityEnabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_portSecurityEnabled(&mut self, v: bool) {
        self.portSecurityEnabled = ::std::option::Option::Some(v);
    }

    // repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ResourceReference virtualMachineInterfaceReferences = 9;


    pub fn get_virtualMachineInterfaceReferences(&self) -> &[ResourceReference] {
        &self.virtualMachineInterfaceReferences
    }
    pub fn clear_virtualMachineInterfaceReferences(&mut self) {
        self.virtualMachineInterfaceReferences.clear();
    }

    // Param is passed by value, moved
    pub fn set_virtualMachineInterfaceReferences(&mut self, v: ::protobuf::RepeatedField<ResourceReference>) {
        self.virtualMachineInterfaceReferences = v;
    }

    // Mutable pointer to the field.
    pub fn mut_virtualMachineInterfaceReferences(&mut self) -> &mut ::protobuf::RepeatedField<ResourceReference> {
        &mut self.virtualMachineInterfaceReferences
    }

    // Take field
    pub fn take_virtualMachineInterfaceReferences(&mut self) -> ::protobuf::RepeatedField<ResourceReference> {
        ::std::mem::replace(&mut self.virtualMachineInterfaceReferences, ::protobuf::RepeatedField::new())
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterfaceProperties properties = 10;


    pub fn get_properties(&self) -> &VirtualMachineInterfaceProperties {
        self.properties.as_ref().unwrap_or_else(|| <VirtualMachineInterfaceProperties as ::protobuf::Message>::default_instance())
    }
    pub fn clear_properties(&mut self) {
        self.properties.clear();
    }

    pub fn has_properties(&self) -> bool {
        self.properties.is_some()
    }

    // Param is passed by value, moved
    pub fn set_properties(&mut self, v: VirtualMachineInterfaceProperties) {
        self.properties = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_properties(&mut self) -> &mut VirtualMachineInterfaceProperties {
        if self.properties.is_none() {
            self.properties.set_default();
        }
        self.properties.as_mut().unwrap()
    }

    // Take field
    pub fn take_properties(&mut self) -> VirtualMachineInterfaceProperties {
        self.properties.take().unwrap_or_else(|| VirtualMachineInterfaceProperties::new())
    }

    // repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ResourceReference tagReferences = 11;


    pub fn get_tagReferences(&self) -> &[ResourceReference] {
        &self.tagReferences
    }
    pub fn clear_tagReferences(&mut self) {
        self.tagReferences.clear();
    }

    // Param is passed by value, moved
    pub fn set_tagReferences(&mut self, v: ::protobuf::RepeatedField<ResourceReference>) {
        self.tagReferences = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tagReferences(&mut self) -> &mut ::protobuf::RepeatedField<ResourceReference> {
        &mut self.tagReferences
    }

    // Take field
    pub fn take_tagReferences(&mut self) -> ::protobuf::RepeatedField<ResourceReference> {
        ::std::mem::replace(&mut self.tagReferences, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for VirtualMachineInterfaceSpec {
    fn is_initialized(&self) -> bool {
        for v in &self.commonSpec {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.parent {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.virtualMachineInterfaceMacAddresses {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.virtualNetworkReference {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.virtualMachineReferences {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.allowedAddressPairs {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.virtualMachineInterfaceReferences {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.properties {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tagReferences {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.commonSpec)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.parent)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.virtualMachineInterfaceMacAddresses)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.virtualNetworkReference)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.virtualMachineReferences)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.virtualMachineInterfaceDisablePolicy = ::std::option::Option::Some(tmp);
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.allowedAddressPairs)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.portSecurityEnabled = ::std::option::Option::Some(tmp);
                },
                9 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.virtualMachineInterfaceReferences)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.properties)?;
                },
                11 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.tagReferences)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.commonSpec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.parent.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.virtualMachineInterfaceMacAddresses.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.virtualNetworkReference.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.virtualMachineReferences {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.virtualMachineInterfaceDisablePolicy {
            my_size += 2;
        }
        if let Some(ref v) = self.allowedAddressPairs.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.portSecurityEnabled {
            my_size += 2;
        }
        for value in &self.virtualMachineInterfaceReferences {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.properties.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.tagReferences {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.commonSpec.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.parent.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.virtualMachineInterfaceMacAddresses.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.virtualNetworkReference.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.virtualMachineReferences {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.virtualMachineInterfaceDisablePolicy {
            os.write_bool(6, v)?;
        }
        if let Some(ref v) = self.allowedAddressPairs.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.portSecurityEnabled {
            os.write_bool(8, v)?;
        }
        for v in &self.virtualMachineInterfaceReferences {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.properties.as_ref() {
            os.write_tag(10, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.tagReferences {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VirtualMachineInterfaceSpec {
        VirtualMachineInterfaceSpec::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommonSpec>>(
                "commonSpec",
                |m: &VirtualMachineInterfaceSpec| { &m.commonSpec },
                |m: &mut VirtualMachineInterfaceSpec| { &mut m.commonSpec },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::generated::ObjectReference>>(
                "parent",
                |m: &VirtualMachineInterfaceSpec| { &m.parent },
                |m: &mut VirtualMachineInterfaceSpec| { &mut m.parent },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<MACAddresses>>(
                "virtualMachineInterfaceMacAddresses",
                |m: &VirtualMachineInterfaceSpec| { &m.virtualMachineInterfaceMacAddresses },
                |m: &mut VirtualMachineInterfaceSpec| { &mut m.virtualMachineInterfaceMacAddresses },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResourceReference>>(
                "virtualNetworkReference",
                |m: &VirtualMachineInterfaceSpec| { &m.virtualNetworkReference },
                |m: &mut VirtualMachineInterfaceSpec| { &mut m.virtualNetworkReference },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResourceReference>>(
                "virtualMachineReferences",
                |m: &VirtualMachineInterfaceSpec| { &m.virtualMachineReferences },
                |m: &mut VirtualMachineInterfaceSpec| { &mut m.virtualMachineReferences },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "virtualMachineInterfaceDisablePolicy",
                |m: &VirtualMachineInterfaceSpec| { &m.virtualMachineInterfaceDisablePolicy },
                |m: &mut VirtualMachineInterfaceSpec| { &mut m.virtualMachineInterfaceDisablePolicy },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AllowedAddressPairs>>(
                "allowedAddressPairs",
                |m: &VirtualMachineInterfaceSpec| { &m.allowedAddressPairs },
                |m: &mut VirtualMachineInterfaceSpec| { &mut m.allowedAddressPairs },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "portSecurityEnabled",
                |m: &VirtualMachineInterfaceSpec| { &m.portSecurityEnabled },
                |m: &mut VirtualMachineInterfaceSpec| { &mut m.portSecurityEnabled },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResourceReference>>(
                "virtualMachineInterfaceReferences",
                |m: &VirtualMachineInterfaceSpec| { &m.virtualMachineInterfaceReferences },
                |m: &mut VirtualMachineInterfaceSpec| { &mut m.virtualMachineInterfaceReferences },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<VirtualMachineInterfaceProperties>>(
                "properties",
                |m: &VirtualMachineInterfaceSpec| { &m.properties },
                |m: &mut VirtualMachineInterfaceSpec| { &mut m.properties },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResourceReference>>(
                "tagReferences",
                |m: &VirtualMachineInterfaceSpec| { &m.tagReferences },
                |m: &mut VirtualMachineInterfaceSpec| { &mut m.tagReferences },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VirtualMachineInterfaceSpec>(
                "VirtualMachineInterfaceSpec",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VirtualMachineInterfaceSpec {
        static instance: ::protobuf::rt::LazyV2<VirtualMachineInterfaceSpec> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VirtualMachineInterfaceSpec::new)
    }
}

impl ::protobuf::Clear for VirtualMachineInterfaceSpec {
    fn clear(&mut self) {
        self.commonSpec.clear();
        self.parent.clear();
        self.virtualMachineInterfaceMacAddresses.clear();
        self.virtualNetworkReference.clear();
        self.virtualMachineReferences.clear();
        self.virtualMachineInterfaceDisablePolicy = ::std::option::Option::None;
        self.allowedAddressPairs.clear();
        self.portSecurityEnabled = ::std::option::Option::None;
        self.virtualMachineInterfaceReferences.clear();
        self.properties.clear();
        self.tagReferences.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VirtualMachineInterfaceSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VirtualMachineInterfaceSpec {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VirtualMachineInterfaceStatus {
    // message fields
    pub commonStatus: ::protobuf::SingularPtrField<CommonStatus>,
    pub routingInstanceReferences: ::protobuf::RepeatedField<RoutingInstanceReference>,
    pub bgpRouterReference: ::protobuf::SingularPtrField<ResourceReference>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VirtualMachineInterfaceStatus {
    fn default() -> &'a VirtualMachineInterfaceStatus {
        <VirtualMachineInterfaceStatus as ::protobuf::Message>::default_instance()
    }
}

impl VirtualMachineInterfaceStatus {
    pub fn new() -> VirtualMachineInterfaceStatus {
        ::std::default::Default::default()
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonStatus commonStatus = 1;


    pub fn get_commonStatus(&self) -> &CommonStatus {
        self.commonStatus.as_ref().unwrap_or_else(|| <CommonStatus as ::protobuf::Message>::default_instance())
    }
    pub fn clear_commonStatus(&mut self) {
        self.commonStatus.clear();
    }

    pub fn has_commonStatus(&self) -> bool {
        self.commonStatus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_commonStatus(&mut self, v: CommonStatus) {
        self.commonStatus = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_commonStatus(&mut self) -> &mut CommonStatus {
        if self.commonStatus.is_none() {
            self.commonStatus.set_default();
        }
        self.commonStatus.as_mut().unwrap()
    }

    // Take field
    pub fn take_commonStatus(&mut self) -> CommonStatus {
        self.commonStatus.take().unwrap_or_else(|| CommonStatus::new())
    }

    // repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RoutingInstanceReference routingInstanceReferences = 3;


    pub fn get_routingInstanceReferences(&self) -> &[RoutingInstanceReference] {
        &self.routingInstanceReferences
    }
    pub fn clear_routingInstanceReferences(&mut self) {
        self.routingInstanceReferences.clear();
    }

    // Param is passed by value, moved
    pub fn set_routingInstanceReferences(&mut self, v: ::protobuf::RepeatedField<RoutingInstanceReference>) {
        self.routingInstanceReferences = v;
    }

    // Mutable pointer to the field.
    pub fn mut_routingInstanceReferences(&mut self) -> &mut ::protobuf::RepeatedField<RoutingInstanceReference> {
        &mut self.routingInstanceReferences
    }

    // Take field
    pub fn take_routingInstanceReferences(&mut self) -> ::protobuf::RepeatedField<RoutingInstanceReference> {
        ::std::mem::replace(&mut self.routingInstanceReferences, ::protobuf::RepeatedField::new())
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ResourceReference bgpRouterReference = 4;


    pub fn get_bgpRouterReference(&self) -> &ResourceReference {
        self.bgpRouterReference.as_ref().unwrap_or_else(|| <ResourceReference as ::protobuf::Message>::default_instance())
    }
    pub fn clear_bgpRouterReference(&mut self) {
        self.bgpRouterReference.clear();
    }

    pub fn has_bgpRouterReference(&self) -> bool {
        self.bgpRouterReference.is_some()
    }

    // Param is passed by value, moved
    pub fn set_bgpRouterReference(&mut self, v: ResourceReference) {
        self.bgpRouterReference = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bgpRouterReference(&mut self) -> &mut ResourceReference {
        if self.bgpRouterReference.is_none() {
            self.bgpRouterReference.set_default();
        }
        self.bgpRouterReference.as_mut().unwrap()
    }

    // Take field
    pub fn take_bgpRouterReference(&mut self) -> ResourceReference {
        self.bgpRouterReference.take().unwrap_or_else(|| ResourceReference::new())
    }
}

impl ::protobuf::Message for VirtualMachineInterfaceStatus {
    fn is_initialized(&self) -> bool {
        for v in &self.commonStatus {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.routingInstanceReferences {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.bgpRouterReference {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.commonStatus)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.routingInstanceReferences)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.bgpRouterReference)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.commonStatus.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.routingInstanceReferences {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.bgpRouterReference.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.commonStatus.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.routingInstanceReferences {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.bgpRouterReference.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VirtualMachineInterfaceStatus {
        VirtualMachineInterfaceStatus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommonStatus>>(
                "commonStatus",
                |m: &VirtualMachineInterfaceStatus| { &m.commonStatus },
                |m: &mut VirtualMachineInterfaceStatus| { &mut m.commonStatus },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RoutingInstanceReference>>(
                "routingInstanceReferences",
                |m: &VirtualMachineInterfaceStatus| { &m.routingInstanceReferences },
                |m: &mut VirtualMachineInterfaceStatus| { &mut m.routingInstanceReferences },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResourceReference>>(
                "bgpRouterReference",
                |m: &VirtualMachineInterfaceStatus| { &m.bgpRouterReference },
                |m: &mut VirtualMachineInterfaceStatus| { &mut m.bgpRouterReference },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VirtualMachineInterfaceStatus>(
                "VirtualMachineInterfaceStatus",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VirtualMachineInterfaceStatus {
        static instance: ::protobuf::rt::LazyV2<VirtualMachineInterfaceStatus> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VirtualMachineInterfaceStatus::new)
    }
}

impl ::protobuf::Clear for VirtualMachineInterfaceStatus {
    fn clear(&mut self) {
        self.commonStatus.clear();
        self.routingInstanceReferences.clear();
        self.bgpRouterReference.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VirtualMachineInterfaceStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VirtualMachineInterfaceStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VirtualMachineList {
    // message fields
    pub metadata: ::protobuf::SingularPtrField<super::meta::ListMeta>,
    pub items: ::protobuf::RepeatedField<VirtualMachine>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VirtualMachineList {
    fn default() -> &'a VirtualMachineList {
        <VirtualMachineList as ::protobuf::Message>::default_instance()
    }
}

impl VirtualMachineList {
    pub fn new() -> VirtualMachineList {
        ::std::default::Default::default()
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;


    pub fn get_metadata(&self) -> &super::meta::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <super::meta::ListMeta as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::meta::ListMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::meta::ListMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::meta::ListMeta {
        self.metadata.take().unwrap_or_else(|| super::meta::ListMeta::new())
    }

    // repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachine items = 2;


    pub fn get_items(&self) -> &[VirtualMachine] {
        &self.items
    }
    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::protobuf::RepeatedField<VirtualMachine>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::protobuf::RepeatedField<VirtualMachine> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::protobuf::RepeatedField<VirtualMachine> {
        ::std::mem::replace(&mut self.items, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for VirtualMachineList {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.items {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.items)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.items {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VirtualMachineList {
        VirtualMachineList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::meta::ListMeta>>(
                "metadata",
                |m: &VirtualMachineList| { &m.metadata },
                |m: &mut VirtualMachineList| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<VirtualMachine>>(
                "items",
                |m: &VirtualMachineList| { &m.items },
                |m: &mut VirtualMachineList| { &mut m.items },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VirtualMachineList>(
                "VirtualMachineList",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VirtualMachineList {
        static instance: ::protobuf::rt::LazyV2<VirtualMachineList> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VirtualMachineList::new)
    }
}

impl ::protobuf::Clear for VirtualMachineList {
    fn clear(&mut self) {
        self.metadata.clear();
        self.items.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VirtualMachineList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VirtualMachineList {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VirtualMachineSpec {
    // message fields
    pub commonSpec: ::protobuf::SingularPtrField<CommonSpec>,
    serverType: ::protobuf::SingularField<::std::string::String>,
    serverName: ::protobuf::SingularField<::std::string::String>,
    serverNamespace: ::protobuf::SingularField<::std::string::String>,
    serverClusterName: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VirtualMachineSpec {
    fn default() -> &'a VirtualMachineSpec {
        <VirtualMachineSpec as ::protobuf::Message>::default_instance()
    }
}

impl VirtualMachineSpec {
    pub fn new() -> VirtualMachineSpec {
        ::std::default::Default::default()
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonSpec commonSpec = 1;


    pub fn get_commonSpec(&self) -> &CommonSpec {
        self.commonSpec.as_ref().unwrap_or_else(|| <CommonSpec as ::protobuf::Message>::default_instance())
    }
    pub fn clear_commonSpec(&mut self) {
        self.commonSpec.clear();
    }

    pub fn has_commonSpec(&self) -> bool {
        self.commonSpec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_commonSpec(&mut self, v: CommonSpec) {
        self.commonSpec = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_commonSpec(&mut self) -> &mut CommonSpec {
        if self.commonSpec.is_none() {
            self.commonSpec.set_default();
        }
        self.commonSpec.as_mut().unwrap()
    }

    // Take field
    pub fn take_commonSpec(&mut self) -> CommonSpec {
        self.commonSpec.take().unwrap_or_else(|| CommonSpec::new())
    }

    // optional string serverType = 2;


    pub fn get_serverType(&self) -> &str {
        match self.serverType.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_serverType(&mut self) {
        self.serverType.clear();
    }

    pub fn has_serverType(&self) -> bool {
        self.serverType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_serverType(&mut self, v: ::std::string::String) {
        self.serverType = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_serverType(&mut self) -> &mut ::std::string::String {
        if self.serverType.is_none() {
            self.serverType.set_default();
        }
        self.serverType.as_mut().unwrap()
    }

    // Take field
    pub fn take_serverType(&mut self) -> ::std::string::String {
        self.serverType.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string serverName = 3;


    pub fn get_serverName(&self) -> &str {
        match self.serverName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_serverName(&mut self) {
        self.serverName.clear();
    }

    pub fn has_serverName(&self) -> bool {
        self.serverName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_serverName(&mut self, v: ::std::string::String) {
        self.serverName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_serverName(&mut self) -> &mut ::std::string::String {
        if self.serverName.is_none() {
            self.serverName.set_default();
        }
        self.serverName.as_mut().unwrap()
    }

    // Take field
    pub fn take_serverName(&mut self) -> ::std::string::String {
        self.serverName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string serverNamespace = 4;


    pub fn get_serverNamespace(&self) -> &str {
        match self.serverNamespace.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_serverNamespace(&mut self) {
        self.serverNamespace.clear();
    }

    pub fn has_serverNamespace(&self) -> bool {
        self.serverNamespace.is_some()
    }

    // Param is passed by value, moved
    pub fn set_serverNamespace(&mut self, v: ::std::string::String) {
        self.serverNamespace = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_serverNamespace(&mut self) -> &mut ::std::string::String {
        if self.serverNamespace.is_none() {
            self.serverNamespace.set_default();
        }
        self.serverNamespace.as_mut().unwrap()
    }

    // Take field
    pub fn take_serverNamespace(&mut self) -> ::std::string::String {
        self.serverNamespace.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string serverClusterName = 5;


    pub fn get_serverClusterName(&self) -> &str {
        match self.serverClusterName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_serverClusterName(&mut self) {
        self.serverClusterName.clear();
    }

    pub fn has_serverClusterName(&self) -> bool {
        self.serverClusterName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_serverClusterName(&mut self, v: ::std::string::String) {
        self.serverClusterName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_serverClusterName(&mut self) -> &mut ::std::string::String {
        if self.serverClusterName.is_none() {
            self.serverClusterName.set_default();
        }
        self.serverClusterName.as_mut().unwrap()
    }

    // Take field
    pub fn take_serverClusterName(&mut self) -> ::std::string::String {
        self.serverClusterName.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for VirtualMachineSpec {
    fn is_initialized(&self) -> bool {
        for v in &self.commonSpec {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.commonSpec)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.serverType)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.serverName)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.serverNamespace)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.serverClusterName)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.commonSpec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.serverType.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.serverName.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.serverNamespace.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.serverClusterName.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.commonSpec.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.serverType.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.serverName.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.serverNamespace.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.serverClusterName.as_ref() {
            os.write_string(5, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VirtualMachineSpec {
        VirtualMachineSpec::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommonSpec>>(
                "commonSpec",
                |m: &VirtualMachineSpec| { &m.commonSpec },
                |m: &mut VirtualMachineSpec| { &mut m.commonSpec },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "serverType",
                |m: &VirtualMachineSpec| { &m.serverType },
                |m: &mut VirtualMachineSpec| { &mut m.serverType },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "serverName",
                |m: &VirtualMachineSpec| { &m.serverName },
                |m: &mut VirtualMachineSpec| { &mut m.serverName },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "serverNamespace",
                |m: &VirtualMachineSpec| { &m.serverNamespace },
                |m: &mut VirtualMachineSpec| { &mut m.serverNamespace },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "serverClusterName",
                |m: &VirtualMachineSpec| { &m.serverClusterName },
                |m: &mut VirtualMachineSpec| { &mut m.serverClusterName },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VirtualMachineSpec>(
                "VirtualMachineSpec",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VirtualMachineSpec {
        static instance: ::protobuf::rt::LazyV2<VirtualMachineSpec> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VirtualMachineSpec::new)
    }
}

impl ::protobuf::Clear for VirtualMachineSpec {
    fn clear(&mut self) {
        self.commonSpec.clear();
        self.serverType.clear();
        self.serverName.clear();
        self.serverNamespace.clear();
        self.serverClusterName.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VirtualMachineSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VirtualMachineSpec {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VirtualMachineStatus {
    // message fields
    pub commonStatus: ::protobuf::SingularPtrField<CommonStatus>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VirtualMachineStatus {
    fn default() -> &'a VirtualMachineStatus {
        <VirtualMachineStatus as ::protobuf::Message>::default_instance()
    }
}

impl VirtualMachineStatus {
    pub fn new() -> VirtualMachineStatus {
        ::std::default::Default::default()
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonStatus commonStatus = 1;


    pub fn get_commonStatus(&self) -> &CommonStatus {
        self.commonStatus.as_ref().unwrap_or_else(|| <CommonStatus as ::protobuf::Message>::default_instance())
    }
    pub fn clear_commonStatus(&mut self) {
        self.commonStatus.clear();
    }

    pub fn has_commonStatus(&self) -> bool {
        self.commonStatus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_commonStatus(&mut self, v: CommonStatus) {
        self.commonStatus = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_commonStatus(&mut self) -> &mut CommonStatus {
        if self.commonStatus.is_none() {
            self.commonStatus.set_default();
        }
        self.commonStatus.as_mut().unwrap()
    }

    // Take field
    pub fn take_commonStatus(&mut self) -> CommonStatus {
        self.commonStatus.take().unwrap_or_else(|| CommonStatus::new())
    }
}

impl ::protobuf::Message for VirtualMachineStatus {
    fn is_initialized(&self) -> bool {
        for v in &self.commonStatus {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.commonStatus)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.commonStatus.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.commonStatus.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VirtualMachineStatus {
        VirtualMachineStatus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommonStatus>>(
                "commonStatus",
                |m: &VirtualMachineStatus| { &m.commonStatus },
                |m: &mut VirtualMachineStatus| { &mut m.commonStatus },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VirtualMachineStatus>(
                "VirtualMachineStatus",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VirtualMachineStatus {
        static instance: ::protobuf::rt::LazyV2<VirtualMachineStatus> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VirtualMachineStatus::new)
    }
}

impl ::protobuf::Clear for VirtualMachineStatus {
    fn clear(&mut self) {
        self.commonStatus.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VirtualMachineStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VirtualMachineStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VirtualNetwork {
    // message fields
    pub metadata: ::protobuf::SingularPtrField<super::meta::ObjectMeta>,
    pub spec: ::protobuf::SingularPtrField<VirtualNetworkSpec>,
    pub status: ::protobuf::SingularPtrField<VirtualNetworkStatus>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VirtualNetwork {
    fn default() -> &'a VirtualNetwork {
        <VirtualNetwork as ::protobuf::Message>::default_instance()
    }
}

impl VirtualNetwork {
    pub fn new() -> VirtualNetwork {
        ::std::default::Default::default()
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;


    pub fn get_metadata(&self) -> &super::meta::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <super::meta::ObjectMeta as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::meta::ObjectMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::meta::ObjectMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::meta::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| super::meta::ObjectMeta::new())
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkSpec spec = 2;


    pub fn get_spec(&self) -> &VirtualNetworkSpec {
        self.spec.as_ref().unwrap_or_else(|| <VirtualNetworkSpec as ::protobuf::Message>::default_instance())
    }
    pub fn clear_spec(&mut self) {
        self.spec.clear();
    }

    pub fn has_spec(&self) -> bool {
        self.spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spec(&mut self, v: VirtualNetworkSpec) {
        self.spec = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spec(&mut self) -> &mut VirtualNetworkSpec {
        if self.spec.is_none() {
            self.spec.set_default();
        }
        self.spec.as_mut().unwrap()
    }

    // Take field
    pub fn take_spec(&mut self) -> VirtualNetworkSpec {
        self.spec.take().unwrap_or_else(|| VirtualNetworkSpec::new())
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkStatus status = 3;


    pub fn get_status(&self) -> &VirtualNetworkStatus {
        self.status.as_ref().unwrap_or_else(|| <VirtualNetworkStatus as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: VirtualNetworkStatus) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut VirtualNetworkStatus {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> VirtualNetworkStatus {
        self.status.take().unwrap_or_else(|| VirtualNetworkStatus::new())
    }
}

impl ::protobuf::Message for VirtualNetwork {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.spec {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.spec)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.spec.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VirtualNetwork {
        VirtualNetwork::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::meta::ObjectMeta>>(
                "metadata",
                |m: &VirtualNetwork| { &m.metadata },
                |m: &mut VirtualNetwork| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<VirtualNetworkSpec>>(
                "spec",
                |m: &VirtualNetwork| { &m.spec },
                |m: &mut VirtualNetwork| { &mut m.spec },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<VirtualNetworkStatus>>(
                "status",
                |m: &VirtualNetwork| { &m.status },
                |m: &mut VirtualNetwork| { &mut m.status },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VirtualNetwork>(
                "VirtualNetwork",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VirtualNetwork {
        static instance: ::protobuf::rt::LazyV2<VirtualNetwork> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VirtualNetwork::new)
    }
}

impl ::protobuf::Clear for VirtualNetwork {
    fn clear(&mut self) {
        self.metadata.clear();
        self.spec.clear();
        self.status.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VirtualNetwork {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VirtualNetwork {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VirtualNetworkList {
    // message fields
    pub metadata: ::protobuf::SingularPtrField<super::meta::ListMeta>,
    pub items: ::protobuf::RepeatedField<VirtualNetwork>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VirtualNetworkList {
    fn default() -> &'a VirtualNetworkList {
        <VirtualNetworkList as ::protobuf::Message>::default_instance()
    }
}

impl VirtualNetworkList {
    pub fn new() -> VirtualNetworkList {
        ::std::default::Default::default()
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;


    pub fn get_metadata(&self) -> &super::meta::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <super::meta::ListMeta as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::meta::ListMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::meta::ListMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::meta::ListMeta {
        self.metadata.take().unwrap_or_else(|| super::meta::ListMeta::new())
    }

    // repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetwork items = 2;


    pub fn get_items(&self) -> &[VirtualNetwork] {
        &self.items
    }
    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::protobuf::RepeatedField<VirtualNetwork>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::protobuf::RepeatedField<VirtualNetwork> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::protobuf::RepeatedField<VirtualNetwork> {
        ::std::mem::replace(&mut self.items, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for VirtualNetworkList {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.items {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.items)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.items {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VirtualNetworkList {
        VirtualNetworkList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::meta::ListMeta>>(
                "metadata",
                |m: &VirtualNetworkList| { &m.metadata },
                |m: &mut VirtualNetworkList| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<VirtualNetwork>>(
                "items",
                |m: &VirtualNetworkList| { &m.items },
                |m: &mut VirtualNetworkList| { &mut m.items },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VirtualNetworkList>(
                "VirtualNetworkList",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VirtualNetworkList {
        static instance: ::protobuf::rt::LazyV2<VirtualNetworkList> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VirtualNetworkList::new)
    }
}

impl ::protobuf::Clear for VirtualNetworkList {
    fn clear(&mut self) {
        self.metadata.clear();
        self.items.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VirtualNetworkList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VirtualNetworkList {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VirtualNetworkRouteTargetReferenceList {
    // message fields
    pub routeTargetReferences: ::protobuf::RepeatedField<RouteTargetReference>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VirtualNetworkRouteTargetReferenceList {
    fn default() -> &'a VirtualNetworkRouteTargetReferenceList {
        <VirtualNetworkRouteTargetReferenceList as ::protobuf::Message>::default_instance()
    }
}

impl VirtualNetworkRouteTargetReferenceList {
    pub fn new() -> VirtualNetworkRouteTargetReferenceList {
        ::std::default::Default::default()
    }

    // repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RouteTargetReference routeTargetReferences = 1;


    pub fn get_routeTargetReferences(&self) -> &[RouteTargetReference] {
        &self.routeTargetReferences
    }
    pub fn clear_routeTargetReferences(&mut self) {
        self.routeTargetReferences.clear();
    }

    // Param is passed by value, moved
    pub fn set_routeTargetReferences(&mut self, v: ::protobuf::RepeatedField<RouteTargetReference>) {
        self.routeTargetReferences = v;
    }

    // Mutable pointer to the field.
    pub fn mut_routeTargetReferences(&mut self) -> &mut ::protobuf::RepeatedField<RouteTargetReference> {
        &mut self.routeTargetReferences
    }

    // Take field
    pub fn take_routeTargetReferences(&mut self) -> ::protobuf::RepeatedField<RouteTargetReference> {
        ::std::mem::replace(&mut self.routeTargetReferences, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for VirtualNetworkRouteTargetReferenceList {
    fn is_initialized(&self) -> bool {
        for v in &self.routeTargetReferences {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.routeTargetReferences)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.routeTargetReferences {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.routeTargetReferences {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VirtualNetworkRouteTargetReferenceList {
        VirtualNetworkRouteTargetReferenceList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<RouteTargetReference>>(
                "routeTargetReferences",
                |m: &VirtualNetworkRouteTargetReferenceList| { &m.routeTargetReferences },
                |m: &mut VirtualNetworkRouteTargetReferenceList| { &mut m.routeTargetReferences },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VirtualNetworkRouteTargetReferenceList>(
                "VirtualNetworkRouteTargetReferenceList",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VirtualNetworkRouteTargetReferenceList {
        static instance: ::protobuf::rt::LazyV2<VirtualNetworkRouteTargetReferenceList> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VirtualNetworkRouteTargetReferenceList::new)
    }
}

impl ::protobuf::Clear for VirtualNetworkRouteTargetReferenceList {
    fn clear(&mut self) {
        self.routeTargetReferences.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VirtualNetworkRouteTargetReferenceList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VirtualNetworkRouteTargetReferenceList {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VirtualNetworkRouter {
    // message fields
    pub metadata: ::protobuf::SingularPtrField<super::meta::ObjectMeta>,
    pub spec: ::protobuf::SingularPtrField<VirtualNetworkRouterSpec>,
    pub status: ::protobuf::SingularPtrField<VirtualNetworkRouterStatus>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VirtualNetworkRouter {
    fn default() -> &'a VirtualNetworkRouter {
        <VirtualNetworkRouter as ::protobuf::Message>::default_instance()
    }
}

impl VirtualNetworkRouter {
    pub fn new() -> VirtualNetworkRouter {
        ::std::default::Default::default()
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;


    pub fn get_metadata(&self) -> &super::meta::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <super::meta::ObjectMeta as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::meta::ObjectMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::meta::ObjectMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::meta::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| super::meta::ObjectMeta::new())
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkRouterSpec spec = 2;


    pub fn get_spec(&self) -> &VirtualNetworkRouterSpec {
        self.spec.as_ref().unwrap_or_else(|| <VirtualNetworkRouterSpec as ::protobuf::Message>::default_instance())
    }
    pub fn clear_spec(&mut self) {
        self.spec.clear();
    }

    pub fn has_spec(&self) -> bool {
        self.spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spec(&mut self, v: VirtualNetworkRouterSpec) {
        self.spec = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spec(&mut self) -> &mut VirtualNetworkRouterSpec {
        if self.spec.is_none() {
            self.spec.set_default();
        }
        self.spec.as_mut().unwrap()
    }

    // Take field
    pub fn take_spec(&mut self) -> VirtualNetworkRouterSpec {
        self.spec.take().unwrap_or_else(|| VirtualNetworkRouterSpec::new())
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkRouterStatus status = 3;


    pub fn get_status(&self) -> &VirtualNetworkRouterStatus {
        self.status.as_ref().unwrap_or_else(|| <VirtualNetworkRouterStatus as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: VirtualNetworkRouterStatus) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut VirtualNetworkRouterStatus {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> VirtualNetworkRouterStatus {
        self.status.take().unwrap_or_else(|| VirtualNetworkRouterStatus::new())
    }
}

impl ::protobuf::Message for VirtualNetworkRouter {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.spec {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.spec)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.spec.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VirtualNetworkRouter {
        VirtualNetworkRouter::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::meta::ObjectMeta>>(
                "metadata",
                |m: &VirtualNetworkRouter| { &m.metadata },
                |m: &mut VirtualNetworkRouter| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<VirtualNetworkRouterSpec>>(
                "spec",
                |m: &VirtualNetworkRouter| { &m.spec },
                |m: &mut VirtualNetworkRouter| { &mut m.spec },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<VirtualNetworkRouterStatus>>(
                "status",
                |m: &VirtualNetworkRouter| { &m.status },
                |m: &mut VirtualNetworkRouter| { &mut m.status },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VirtualNetworkRouter>(
                "VirtualNetworkRouter",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VirtualNetworkRouter {
        static instance: ::protobuf::rt::LazyV2<VirtualNetworkRouter> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VirtualNetworkRouter::new)
    }
}

impl ::protobuf::Clear for VirtualNetworkRouter {
    fn clear(&mut self) {
        self.metadata.clear();
        self.spec.clear();
        self.status.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VirtualNetworkRouter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VirtualNetworkRouter {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VirtualNetworkRouterEntry {
    // message fields
    pub virtualNetworkRouterSelector: ::protobuf::SingularPtrField<super::meta::LabelSelector>,
    pub namespaceSelector: ::protobuf::SingularPtrField<super::meta::LabelSelector>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VirtualNetworkRouterEntry {
    fn default() -> &'a VirtualNetworkRouterEntry {
        <VirtualNetworkRouterEntry as ::protobuf::Message>::default_instance()
    }
}

impl VirtualNetworkRouterEntry {
    pub fn new() -> VirtualNetworkRouterEntry {
        ::std::default::Default::default()
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector virtualNetworkRouterSelector = 1;


    pub fn get_virtualNetworkRouterSelector(&self) -> &super::meta::LabelSelector {
        self.virtualNetworkRouterSelector.as_ref().unwrap_or_else(|| <super::meta::LabelSelector as ::protobuf::Message>::default_instance())
    }
    pub fn clear_virtualNetworkRouterSelector(&mut self) {
        self.virtualNetworkRouterSelector.clear();
    }

    pub fn has_virtualNetworkRouterSelector(&self) -> bool {
        self.virtualNetworkRouterSelector.is_some()
    }

    // Param is passed by value, moved
    pub fn set_virtualNetworkRouterSelector(&mut self, v: super::meta::LabelSelector) {
        self.virtualNetworkRouterSelector = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_virtualNetworkRouterSelector(&mut self) -> &mut super::meta::LabelSelector {
        if self.virtualNetworkRouterSelector.is_none() {
            self.virtualNetworkRouterSelector.set_default();
        }
        self.virtualNetworkRouterSelector.as_mut().unwrap()
    }

    // Take field
    pub fn take_virtualNetworkRouterSelector(&mut self) -> super::meta::LabelSelector {
        self.virtualNetworkRouterSelector.take().unwrap_or_else(|| super::meta::LabelSelector::new())
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector namespaceSelector = 2;


    pub fn get_namespaceSelector(&self) -> &super::meta::LabelSelector {
        self.namespaceSelector.as_ref().unwrap_or_else(|| <super::meta::LabelSelector as ::protobuf::Message>::default_instance())
    }
    pub fn clear_namespaceSelector(&mut self) {
        self.namespaceSelector.clear();
    }

    pub fn has_namespaceSelector(&self) -> bool {
        self.namespaceSelector.is_some()
    }

    // Param is passed by value, moved
    pub fn set_namespaceSelector(&mut self, v: super::meta::LabelSelector) {
        self.namespaceSelector = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_namespaceSelector(&mut self) -> &mut super::meta::LabelSelector {
        if self.namespaceSelector.is_none() {
            self.namespaceSelector.set_default();
        }
        self.namespaceSelector.as_mut().unwrap()
    }

    // Take field
    pub fn take_namespaceSelector(&mut self) -> super::meta::LabelSelector {
        self.namespaceSelector.take().unwrap_or_else(|| super::meta::LabelSelector::new())
    }
}

impl ::protobuf::Message for VirtualNetworkRouterEntry {
    fn is_initialized(&self) -> bool {
        for v in &self.virtualNetworkRouterSelector {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.namespaceSelector {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.virtualNetworkRouterSelector)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.namespaceSelector)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.virtualNetworkRouterSelector.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.namespaceSelector.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.virtualNetworkRouterSelector.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.namespaceSelector.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VirtualNetworkRouterEntry {
        VirtualNetworkRouterEntry::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::meta::LabelSelector>>(
                "virtualNetworkRouterSelector",
                |m: &VirtualNetworkRouterEntry| { &m.virtualNetworkRouterSelector },
                |m: &mut VirtualNetworkRouterEntry| { &mut m.virtualNetworkRouterSelector },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::meta::LabelSelector>>(
                "namespaceSelector",
                |m: &VirtualNetworkRouterEntry| { &m.namespaceSelector },
                |m: &mut VirtualNetworkRouterEntry| { &mut m.namespaceSelector },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VirtualNetworkRouterEntry>(
                "VirtualNetworkRouterEntry",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VirtualNetworkRouterEntry {
        static instance: ::protobuf::rt::LazyV2<VirtualNetworkRouterEntry> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VirtualNetworkRouterEntry::new)
    }
}

impl ::protobuf::Clear for VirtualNetworkRouterEntry {
    fn clear(&mut self) {
        self.virtualNetworkRouterSelector.clear();
        self.namespaceSelector.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VirtualNetworkRouterEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VirtualNetworkRouterEntry {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VirtualNetworkRouterList {
    // message fields
    pub metadata: ::protobuf::SingularPtrField<super::meta::ListMeta>,
    pub items: ::protobuf::RepeatedField<VirtualNetworkRouter>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VirtualNetworkRouterList {
    fn default() -> &'a VirtualNetworkRouterList {
        <VirtualNetworkRouterList as ::protobuf::Message>::default_instance()
    }
}

impl VirtualNetworkRouterList {
    pub fn new() -> VirtualNetworkRouterList {
        ::std::default::Default::default()
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;


    pub fn get_metadata(&self) -> &super::meta::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <super::meta::ListMeta as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::meta::ListMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::meta::ListMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::meta::ListMeta {
        self.metadata.take().unwrap_or_else(|| super::meta::ListMeta::new())
    }

    // repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkRouter items = 2;


    pub fn get_items(&self) -> &[VirtualNetworkRouter] {
        &self.items
    }
    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::protobuf::RepeatedField<VirtualNetworkRouter>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::protobuf::RepeatedField<VirtualNetworkRouter> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::protobuf::RepeatedField<VirtualNetworkRouter> {
        ::std::mem::replace(&mut self.items, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for VirtualNetworkRouterList {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.items {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.items)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.items {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VirtualNetworkRouterList {
        VirtualNetworkRouterList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::meta::ListMeta>>(
                "metadata",
                |m: &VirtualNetworkRouterList| { &m.metadata },
                |m: &mut VirtualNetworkRouterList| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<VirtualNetworkRouter>>(
                "items",
                |m: &VirtualNetworkRouterList| { &m.items },
                |m: &mut VirtualNetworkRouterList| { &mut m.items },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VirtualNetworkRouterList>(
                "VirtualNetworkRouterList",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VirtualNetworkRouterList {
        static instance: ::protobuf::rt::LazyV2<VirtualNetworkRouterList> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VirtualNetworkRouterList::new)
    }
}

impl ::protobuf::Clear for VirtualNetworkRouterList {
    fn clear(&mut self) {
        self.metadata.clear();
        self.items.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VirtualNetworkRouterList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VirtualNetworkRouterList {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VirtualNetworkRouterSpec {
    // message fields
    pub commonSpec: ::protobuf::SingularPtrField<CommonSpec>,
    field_type: ::protobuf::SingularField<::std::string::String>,
    pub virtualNetworkSelector: ::protobuf::SingularPtrField<super::meta::LabelSelector>,
    pub import: ::protobuf::SingularPtrField<ImportVirtualNetworkRouter>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VirtualNetworkRouterSpec {
    fn default() -> &'a VirtualNetworkRouterSpec {
        <VirtualNetworkRouterSpec as ::protobuf::Message>::default_instance()
    }
}

impl VirtualNetworkRouterSpec {
    pub fn new() -> VirtualNetworkRouterSpec {
        ::std::default::Default::default()
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonSpec commonSpec = 1;


    pub fn get_commonSpec(&self) -> &CommonSpec {
        self.commonSpec.as_ref().unwrap_or_else(|| <CommonSpec as ::protobuf::Message>::default_instance())
    }
    pub fn clear_commonSpec(&mut self) {
        self.commonSpec.clear();
    }

    pub fn has_commonSpec(&self) -> bool {
        self.commonSpec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_commonSpec(&mut self, v: CommonSpec) {
        self.commonSpec = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_commonSpec(&mut self) -> &mut CommonSpec {
        if self.commonSpec.is_none() {
            self.commonSpec.set_default();
        }
        self.commonSpec.as_mut().unwrap()
    }

    // Take field
    pub fn take_commonSpec(&mut self) -> CommonSpec {
        self.commonSpec.take().unwrap_or_else(|| CommonSpec::new())
    }

    // optional string type = 2;


    pub fn get_field_type(&self) -> &str {
        match self.field_type.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ::std::string::String) {
        self.field_type = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut ::std::string::String {
        if self.field_type.is_none() {
            self.field_type.set_default();
        }
        self.field_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_field_type(&mut self) -> ::std::string::String {
        self.field_type.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector virtualNetworkSelector = 3;


    pub fn get_virtualNetworkSelector(&self) -> &super::meta::LabelSelector {
        self.virtualNetworkSelector.as_ref().unwrap_or_else(|| <super::meta::LabelSelector as ::protobuf::Message>::default_instance())
    }
    pub fn clear_virtualNetworkSelector(&mut self) {
        self.virtualNetworkSelector.clear();
    }

    pub fn has_virtualNetworkSelector(&self) -> bool {
        self.virtualNetworkSelector.is_some()
    }

    // Param is passed by value, moved
    pub fn set_virtualNetworkSelector(&mut self, v: super::meta::LabelSelector) {
        self.virtualNetworkSelector = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_virtualNetworkSelector(&mut self) -> &mut super::meta::LabelSelector {
        if self.virtualNetworkSelector.is_none() {
            self.virtualNetworkSelector.set_default();
        }
        self.virtualNetworkSelector.as_mut().unwrap()
    }

    // Take field
    pub fn take_virtualNetworkSelector(&mut self) -> super::meta::LabelSelector {
        self.virtualNetworkSelector.take().unwrap_or_else(|| super::meta::LabelSelector::new())
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ImportVirtualNetworkRouter import = 4;


    pub fn get_import(&self) -> &ImportVirtualNetworkRouter {
        self.import.as_ref().unwrap_or_else(|| <ImportVirtualNetworkRouter as ::protobuf::Message>::default_instance())
    }
    pub fn clear_import(&mut self) {
        self.import.clear();
    }

    pub fn has_import(&self) -> bool {
        self.import.is_some()
    }

    // Param is passed by value, moved
    pub fn set_import(&mut self, v: ImportVirtualNetworkRouter) {
        self.import = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_import(&mut self) -> &mut ImportVirtualNetworkRouter {
        if self.import.is_none() {
            self.import.set_default();
        }
        self.import.as_mut().unwrap()
    }

    // Take field
    pub fn take_import(&mut self) -> ImportVirtualNetworkRouter {
        self.import.take().unwrap_or_else(|| ImportVirtualNetworkRouter::new())
    }
}

impl ::protobuf::Message for VirtualNetworkRouterSpec {
    fn is_initialized(&self) -> bool {
        for v in &self.commonSpec {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.virtualNetworkSelector {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.import {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.commonSpec)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.field_type)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.virtualNetworkSelector)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.import)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.commonSpec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.field_type.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.virtualNetworkSelector.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.import.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.commonSpec.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.field_type.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.virtualNetworkSelector.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.import.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VirtualNetworkRouterSpec {
        VirtualNetworkRouterSpec::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommonSpec>>(
                "commonSpec",
                |m: &VirtualNetworkRouterSpec| { &m.commonSpec },
                |m: &mut VirtualNetworkRouterSpec| { &mut m.commonSpec },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "type",
                |m: &VirtualNetworkRouterSpec| { &m.field_type },
                |m: &mut VirtualNetworkRouterSpec| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::meta::LabelSelector>>(
                "virtualNetworkSelector",
                |m: &VirtualNetworkRouterSpec| { &m.virtualNetworkSelector },
                |m: &mut VirtualNetworkRouterSpec| { &mut m.virtualNetworkSelector },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ImportVirtualNetworkRouter>>(
                "import",
                |m: &VirtualNetworkRouterSpec| { &m.import },
                |m: &mut VirtualNetworkRouterSpec| { &mut m.import },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VirtualNetworkRouterSpec>(
                "VirtualNetworkRouterSpec",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VirtualNetworkRouterSpec {
        static instance: ::protobuf::rt::LazyV2<VirtualNetworkRouterSpec> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VirtualNetworkRouterSpec::new)
    }
}

impl ::protobuf::Clear for VirtualNetworkRouterSpec {
    fn clear(&mut self) {
        self.commonSpec.clear();
        self.field_type.clear();
        self.virtualNetworkSelector.clear();
        self.import.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VirtualNetworkRouterSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VirtualNetworkRouterSpec {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VirtualNetworkRouterStatus {
    // message fields
    pub commonStatus: ::protobuf::SingularPtrField<CommonStatus>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VirtualNetworkRouterStatus {
    fn default() -> &'a VirtualNetworkRouterStatus {
        <VirtualNetworkRouterStatus as ::protobuf::Message>::default_instance()
    }
}

impl VirtualNetworkRouterStatus {
    pub fn new() -> VirtualNetworkRouterStatus {
        ::std::default::Default::default()
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonStatus commonStatus = 1;


    pub fn get_commonStatus(&self) -> &CommonStatus {
        self.commonStatus.as_ref().unwrap_or_else(|| <CommonStatus as ::protobuf::Message>::default_instance())
    }
    pub fn clear_commonStatus(&mut self) {
        self.commonStatus.clear();
    }

    pub fn has_commonStatus(&self) -> bool {
        self.commonStatus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_commonStatus(&mut self, v: CommonStatus) {
        self.commonStatus = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_commonStatus(&mut self) -> &mut CommonStatus {
        if self.commonStatus.is_none() {
            self.commonStatus.set_default();
        }
        self.commonStatus.as_mut().unwrap()
    }

    // Take field
    pub fn take_commonStatus(&mut self) -> CommonStatus {
        self.commonStatus.take().unwrap_or_else(|| CommonStatus::new())
    }
}

impl ::protobuf::Message for VirtualNetworkRouterStatus {
    fn is_initialized(&self) -> bool {
        for v in &self.commonStatus {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.commonStatus)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.commonStatus.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.commonStatus.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VirtualNetworkRouterStatus {
        VirtualNetworkRouterStatus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommonStatus>>(
                "commonStatus",
                |m: &VirtualNetworkRouterStatus| { &m.commonStatus },
                |m: &mut VirtualNetworkRouterStatus| { &mut m.commonStatus },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VirtualNetworkRouterStatus>(
                "VirtualNetworkRouterStatus",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VirtualNetworkRouterStatus {
        static instance: ::protobuf::rt::LazyV2<VirtualNetworkRouterStatus> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VirtualNetworkRouterStatus::new)
    }
}

impl ::protobuf::Clear for VirtualNetworkRouterStatus {
    fn clear(&mut self) {
        self.commonStatus.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VirtualNetworkRouterStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VirtualNetworkRouterStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VirtualNetworkSpec {
    // message fields
    pub commonSpec: ::protobuf::SingularPtrField<CommonSpec>,
    fabricSNAT: ::std::option::Option<bool>,
    pub v4SubnetReference: ::protobuf::SingularPtrField<ResourceReference>,
    pub v6SubnetReference: ::protobuf::SingularPtrField<ResourceReference>,
    pub routeTargetList: ::protobuf::RepeatedField<::std::string::String>,
    pub importRouteTargetList: ::protobuf::RepeatedField<::std::string::String>,
    pub exportRouteTargetList: ::protobuf::RepeatedField<::std::string::String>,
    pub virtualNetworkProperties: ::protobuf::SingularPtrField<VirtualNetworkType>,
    pub providerNetworkReference: ::protobuf::SingularPtrField<ResourceReference>,
    isProviderNetwork: ::std::option::Option<bool>,
    fabricForwarding: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VirtualNetworkSpec {
    fn default() -> &'a VirtualNetworkSpec {
        <VirtualNetworkSpec as ::protobuf::Message>::default_instance()
    }
}

impl VirtualNetworkSpec {
    pub fn new() -> VirtualNetworkSpec {
        ::std::default::Default::default()
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonSpec commonSpec = 1;


    pub fn get_commonSpec(&self) -> &CommonSpec {
        self.commonSpec.as_ref().unwrap_or_else(|| <CommonSpec as ::protobuf::Message>::default_instance())
    }
    pub fn clear_commonSpec(&mut self) {
        self.commonSpec.clear();
    }

    pub fn has_commonSpec(&self) -> bool {
        self.commonSpec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_commonSpec(&mut self, v: CommonSpec) {
        self.commonSpec = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_commonSpec(&mut self) -> &mut CommonSpec {
        if self.commonSpec.is_none() {
            self.commonSpec.set_default();
        }
        self.commonSpec.as_mut().unwrap()
    }

    // Take field
    pub fn take_commonSpec(&mut self) -> CommonSpec {
        self.commonSpec.take().unwrap_or_else(|| CommonSpec::new())
    }

    // optional bool fabricSNAT = 2;


    pub fn get_fabricSNAT(&self) -> bool {
        self.fabricSNAT.unwrap_or(false)
    }
    pub fn clear_fabricSNAT(&mut self) {
        self.fabricSNAT = ::std::option::Option::None;
    }

    pub fn has_fabricSNAT(&self) -> bool {
        self.fabricSNAT.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fabricSNAT(&mut self, v: bool) {
        self.fabricSNAT = ::std::option::Option::Some(v);
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ResourceReference v4SubnetReference = 3;


    pub fn get_v4SubnetReference(&self) -> &ResourceReference {
        self.v4SubnetReference.as_ref().unwrap_or_else(|| <ResourceReference as ::protobuf::Message>::default_instance())
    }
    pub fn clear_v4SubnetReference(&mut self) {
        self.v4SubnetReference.clear();
    }

    pub fn has_v4SubnetReference(&self) -> bool {
        self.v4SubnetReference.is_some()
    }

    // Param is passed by value, moved
    pub fn set_v4SubnetReference(&mut self, v: ResourceReference) {
        self.v4SubnetReference = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_v4SubnetReference(&mut self) -> &mut ResourceReference {
        if self.v4SubnetReference.is_none() {
            self.v4SubnetReference.set_default();
        }
        self.v4SubnetReference.as_mut().unwrap()
    }

    // Take field
    pub fn take_v4SubnetReference(&mut self) -> ResourceReference {
        self.v4SubnetReference.take().unwrap_or_else(|| ResourceReference::new())
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ResourceReference v6SubnetReference = 4;


    pub fn get_v6SubnetReference(&self) -> &ResourceReference {
        self.v6SubnetReference.as_ref().unwrap_or_else(|| <ResourceReference as ::protobuf::Message>::default_instance())
    }
    pub fn clear_v6SubnetReference(&mut self) {
        self.v6SubnetReference.clear();
    }

    pub fn has_v6SubnetReference(&self) -> bool {
        self.v6SubnetReference.is_some()
    }

    // Param is passed by value, moved
    pub fn set_v6SubnetReference(&mut self, v: ResourceReference) {
        self.v6SubnetReference = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_v6SubnetReference(&mut self) -> &mut ResourceReference {
        if self.v6SubnetReference.is_none() {
            self.v6SubnetReference.set_default();
        }
        self.v6SubnetReference.as_mut().unwrap()
    }

    // Take field
    pub fn take_v6SubnetReference(&mut self) -> ResourceReference {
        self.v6SubnetReference.take().unwrap_or_else(|| ResourceReference::new())
    }

    // repeated string routeTargetList = 5;


    pub fn get_routeTargetList(&self) -> &[::std::string::String] {
        &self.routeTargetList
    }
    pub fn clear_routeTargetList(&mut self) {
        self.routeTargetList.clear();
    }

    // Param is passed by value, moved
    pub fn set_routeTargetList(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.routeTargetList = v;
    }

    // Mutable pointer to the field.
    pub fn mut_routeTargetList(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.routeTargetList
    }

    // Take field
    pub fn take_routeTargetList(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.routeTargetList, ::protobuf::RepeatedField::new())
    }

    // repeated string importRouteTargetList = 6;


    pub fn get_importRouteTargetList(&self) -> &[::std::string::String] {
        &self.importRouteTargetList
    }
    pub fn clear_importRouteTargetList(&mut self) {
        self.importRouteTargetList.clear();
    }

    // Param is passed by value, moved
    pub fn set_importRouteTargetList(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.importRouteTargetList = v;
    }

    // Mutable pointer to the field.
    pub fn mut_importRouteTargetList(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.importRouteTargetList
    }

    // Take field
    pub fn take_importRouteTargetList(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.importRouteTargetList, ::protobuf::RepeatedField::new())
    }

    // repeated string exportRouteTargetList = 7;


    pub fn get_exportRouteTargetList(&self) -> &[::std::string::String] {
        &self.exportRouteTargetList
    }
    pub fn clear_exportRouteTargetList(&mut self) {
        self.exportRouteTargetList.clear();
    }

    // Param is passed by value, moved
    pub fn set_exportRouteTargetList(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.exportRouteTargetList = v;
    }

    // Mutable pointer to the field.
    pub fn mut_exportRouteTargetList(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.exportRouteTargetList
    }

    // Take field
    pub fn take_exportRouteTargetList(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.exportRouteTargetList, ::protobuf::RepeatedField::new())
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkType virtualNetworkProperties = 8;


    pub fn get_virtualNetworkProperties(&self) -> &VirtualNetworkType {
        self.virtualNetworkProperties.as_ref().unwrap_or_else(|| <VirtualNetworkType as ::protobuf::Message>::default_instance())
    }
    pub fn clear_virtualNetworkProperties(&mut self) {
        self.virtualNetworkProperties.clear();
    }

    pub fn has_virtualNetworkProperties(&self) -> bool {
        self.virtualNetworkProperties.is_some()
    }

    // Param is passed by value, moved
    pub fn set_virtualNetworkProperties(&mut self, v: VirtualNetworkType) {
        self.virtualNetworkProperties = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_virtualNetworkProperties(&mut self) -> &mut VirtualNetworkType {
        if self.virtualNetworkProperties.is_none() {
            self.virtualNetworkProperties.set_default();
        }
        self.virtualNetworkProperties.as_mut().unwrap()
    }

    // Take field
    pub fn take_virtualNetworkProperties(&mut self) -> VirtualNetworkType {
        self.virtualNetworkProperties.take().unwrap_or_else(|| VirtualNetworkType::new())
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ResourceReference providerNetworkReference = 9;


    pub fn get_providerNetworkReference(&self) -> &ResourceReference {
        self.providerNetworkReference.as_ref().unwrap_or_else(|| <ResourceReference as ::protobuf::Message>::default_instance())
    }
    pub fn clear_providerNetworkReference(&mut self) {
        self.providerNetworkReference.clear();
    }

    pub fn has_providerNetworkReference(&self) -> bool {
        self.providerNetworkReference.is_some()
    }

    // Param is passed by value, moved
    pub fn set_providerNetworkReference(&mut self, v: ResourceReference) {
        self.providerNetworkReference = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_providerNetworkReference(&mut self) -> &mut ResourceReference {
        if self.providerNetworkReference.is_none() {
            self.providerNetworkReference.set_default();
        }
        self.providerNetworkReference.as_mut().unwrap()
    }

    // Take field
    pub fn take_providerNetworkReference(&mut self) -> ResourceReference {
        self.providerNetworkReference.take().unwrap_or_else(|| ResourceReference::new())
    }

    // optional bool isProviderNetwork = 10;


    pub fn get_isProviderNetwork(&self) -> bool {
        self.isProviderNetwork.unwrap_or(false)
    }
    pub fn clear_isProviderNetwork(&mut self) {
        self.isProviderNetwork = ::std::option::Option::None;
    }

    pub fn has_isProviderNetwork(&self) -> bool {
        self.isProviderNetwork.is_some()
    }

    // Param is passed by value, moved
    pub fn set_isProviderNetwork(&mut self, v: bool) {
        self.isProviderNetwork = ::std::option::Option::Some(v);
    }

    // optional bool fabricForwarding = 11;


    pub fn get_fabricForwarding(&self) -> bool {
        self.fabricForwarding.unwrap_or(false)
    }
    pub fn clear_fabricForwarding(&mut self) {
        self.fabricForwarding = ::std::option::Option::None;
    }

    pub fn has_fabricForwarding(&self) -> bool {
        self.fabricForwarding.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fabricForwarding(&mut self, v: bool) {
        self.fabricForwarding = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for VirtualNetworkSpec {
    fn is_initialized(&self) -> bool {
        for v in &self.commonSpec {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.v4SubnetReference {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.v6SubnetReference {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.virtualNetworkProperties {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.providerNetworkReference {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.commonSpec)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.fabricSNAT = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.v4SubnetReference)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.v6SubnetReference)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.routeTargetList)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.importRouteTargetList)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.exportRouteTargetList)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.virtualNetworkProperties)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.providerNetworkReference)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.isProviderNetwork = ::std::option::Option::Some(tmp);
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.fabricForwarding = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.commonSpec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.fabricSNAT {
            my_size += 2;
        }
        if let Some(ref v) = self.v4SubnetReference.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.v6SubnetReference.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.routeTargetList {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        for value in &self.importRouteTargetList {
            my_size += ::protobuf::rt::string_size(6, &value);
        };
        for value in &self.exportRouteTargetList {
            my_size += ::protobuf::rt::string_size(7, &value);
        };
        if let Some(ref v) = self.virtualNetworkProperties.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.providerNetworkReference.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.isProviderNetwork {
            my_size += 2;
        }
        if let Some(v) = self.fabricForwarding {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.commonSpec.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.fabricSNAT {
            os.write_bool(2, v)?;
        }
        if let Some(ref v) = self.v4SubnetReference.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.v6SubnetReference.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.routeTargetList {
            os.write_string(5, &v)?;
        };
        for v in &self.importRouteTargetList {
            os.write_string(6, &v)?;
        };
        for v in &self.exportRouteTargetList {
            os.write_string(7, &v)?;
        };
        if let Some(ref v) = self.virtualNetworkProperties.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.providerNetworkReference.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.isProviderNetwork {
            os.write_bool(10, v)?;
        }
        if let Some(v) = self.fabricForwarding {
            os.write_bool(11, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VirtualNetworkSpec {
        VirtualNetworkSpec::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommonSpec>>(
                "commonSpec",
                |m: &VirtualNetworkSpec| { &m.commonSpec },
                |m: &mut VirtualNetworkSpec| { &mut m.commonSpec },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "fabricSNAT",
                |m: &VirtualNetworkSpec| { &m.fabricSNAT },
                |m: &mut VirtualNetworkSpec| { &mut m.fabricSNAT },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResourceReference>>(
                "v4SubnetReference",
                |m: &VirtualNetworkSpec| { &m.v4SubnetReference },
                |m: &mut VirtualNetworkSpec| { &mut m.v4SubnetReference },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResourceReference>>(
                "v6SubnetReference",
                |m: &VirtualNetworkSpec| { &m.v6SubnetReference },
                |m: &mut VirtualNetworkSpec| { &mut m.v6SubnetReference },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "routeTargetList",
                |m: &VirtualNetworkSpec| { &m.routeTargetList },
                |m: &mut VirtualNetworkSpec| { &mut m.routeTargetList },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "importRouteTargetList",
                |m: &VirtualNetworkSpec| { &m.importRouteTargetList },
                |m: &mut VirtualNetworkSpec| { &mut m.importRouteTargetList },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "exportRouteTargetList",
                |m: &VirtualNetworkSpec| { &m.exportRouteTargetList },
                |m: &mut VirtualNetworkSpec| { &mut m.exportRouteTargetList },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<VirtualNetworkType>>(
                "virtualNetworkProperties",
                |m: &VirtualNetworkSpec| { &m.virtualNetworkProperties },
                |m: &mut VirtualNetworkSpec| { &mut m.virtualNetworkProperties },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResourceReference>>(
                "providerNetworkReference",
                |m: &VirtualNetworkSpec| { &m.providerNetworkReference },
                |m: &mut VirtualNetworkSpec| { &mut m.providerNetworkReference },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "isProviderNetwork",
                |m: &VirtualNetworkSpec| { &m.isProviderNetwork },
                |m: &mut VirtualNetworkSpec| { &mut m.isProviderNetwork },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "fabricForwarding",
                |m: &VirtualNetworkSpec| { &m.fabricForwarding },
                |m: &mut VirtualNetworkSpec| { &mut m.fabricForwarding },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VirtualNetworkSpec>(
                "VirtualNetworkSpec",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VirtualNetworkSpec {
        static instance: ::protobuf::rt::LazyV2<VirtualNetworkSpec> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VirtualNetworkSpec::new)
    }
}

impl ::protobuf::Clear for VirtualNetworkSpec {
    fn clear(&mut self) {
        self.commonSpec.clear();
        self.fabricSNAT = ::std::option::Option::None;
        self.v4SubnetReference.clear();
        self.v6SubnetReference.clear();
        self.routeTargetList.clear();
        self.importRouteTargetList.clear();
        self.exportRouteTargetList.clear();
        self.virtualNetworkProperties.clear();
        self.providerNetworkReference.clear();
        self.isProviderNetwork = ::std::option::Option::None;
        self.fabricForwarding = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VirtualNetworkSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VirtualNetworkSpec {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VirtualNetworkStatus {
    // message fields
    pub commonStatus: ::protobuf::SingularPtrField<CommonStatus>,
    virtualNetworkNetworkId: ::std::option::Option<i64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VirtualNetworkStatus {
    fn default() -> &'a VirtualNetworkStatus {
        <VirtualNetworkStatus as ::protobuf::Message>::default_instance()
    }
}

impl VirtualNetworkStatus {
    pub fn new() -> VirtualNetworkStatus {
        ::std::default::Default::default()
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonStatus commonStatus = 1;


    pub fn get_commonStatus(&self) -> &CommonStatus {
        self.commonStatus.as_ref().unwrap_or_else(|| <CommonStatus as ::protobuf::Message>::default_instance())
    }
    pub fn clear_commonStatus(&mut self) {
        self.commonStatus.clear();
    }

    pub fn has_commonStatus(&self) -> bool {
        self.commonStatus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_commonStatus(&mut self, v: CommonStatus) {
        self.commonStatus = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_commonStatus(&mut self) -> &mut CommonStatus {
        if self.commonStatus.is_none() {
            self.commonStatus.set_default();
        }
        self.commonStatus.as_mut().unwrap()
    }

    // Take field
    pub fn take_commonStatus(&mut self) -> CommonStatus {
        self.commonStatus.take().unwrap_or_else(|| CommonStatus::new())
    }

    // optional int64 virtualNetworkNetworkId = 2;


    pub fn get_virtualNetworkNetworkId(&self) -> i64 {
        self.virtualNetworkNetworkId.unwrap_or(0)
    }
    pub fn clear_virtualNetworkNetworkId(&mut self) {
        self.virtualNetworkNetworkId = ::std::option::Option::None;
    }

    pub fn has_virtualNetworkNetworkId(&self) -> bool {
        self.virtualNetworkNetworkId.is_some()
    }

    // Param is passed by value, moved
    pub fn set_virtualNetworkNetworkId(&mut self, v: i64) {
        self.virtualNetworkNetworkId = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for VirtualNetworkStatus {
    fn is_initialized(&self) -> bool {
        for v in &self.commonStatus {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.commonStatus)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.virtualNetworkNetworkId = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.commonStatus.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.virtualNetworkNetworkId {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.commonStatus.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.virtualNetworkNetworkId {
            os.write_int64(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VirtualNetworkStatus {
        VirtualNetworkStatus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommonStatus>>(
                "commonStatus",
                |m: &VirtualNetworkStatus| { &m.commonStatus },
                |m: &mut VirtualNetworkStatus| { &mut m.commonStatus },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "virtualNetworkNetworkId",
                |m: &VirtualNetworkStatus| { &m.virtualNetworkNetworkId },
                |m: &mut VirtualNetworkStatus| { &mut m.virtualNetworkNetworkId },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VirtualNetworkStatus>(
                "VirtualNetworkStatus",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VirtualNetworkStatus {
        static instance: ::protobuf::rt::LazyV2<VirtualNetworkStatus> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VirtualNetworkStatus::new)
    }
}

impl ::protobuf::Clear for VirtualNetworkStatus {
    fn clear(&mut self) {
        self.commonStatus.clear();
        self.virtualNetworkNetworkId = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VirtualNetworkStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VirtualNetworkStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VirtualNetworkType {
    // message fields
    rpf: ::protobuf::SingularField<::std::string::String>,
    forwardingMode: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VirtualNetworkType {
    fn default() -> &'a VirtualNetworkType {
        <VirtualNetworkType as ::protobuf::Message>::default_instance()
    }
}

impl VirtualNetworkType {
    pub fn new() -> VirtualNetworkType {
        ::std::default::Default::default()
    }

    // optional string rpf = 1;


    pub fn get_rpf(&self) -> &str {
        match self.rpf.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_rpf(&mut self) {
        self.rpf.clear();
    }

    pub fn has_rpf(&self) -> bool {
        self.rpf.is_some()
    }

    // Param is passed by value, moved
    pub fn set_rpf(&mut self, v: ::std::string::String) {
        self.rpf = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rpf(&mut self) -> &mut ::std::string::String {
        if self.rpf.is_none() {
            self.rpf.set_default();
        }
        self.rpf.as_mut().unwrap()
    }

    // Take field
    pub fn take_rpf(&mut self) -> ::std::string::String {
        self.rpf.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string forwardingMode = 2;


    pub fn get_forwardingMode(&self) -> &str {
        match self.forwardingMode.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_forwardingMode(&mut self) {
        self.forwardingMode.clear();
    }

    pub fn has_forwardingMode(&self) -> bool {
        self.forwardingMode.is_some()
    }

    // Param is passed by value, moved
    pub fn set_forwardingMode(&mut self, v: ::std::string::String) {
        self.forwardingMode = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_forwardingMode(&mut self) -> &mut ::std::string::String {
        if self.forwardingMode.is_none() {
            self.forwardingMode.set_default();
        }
        self.forwardingMode.as_mut().unwrap()
    }

    // Take field
    pub fn take_forwardingMode(&mut self) -> ::std::string::String {
        self.forwardingMode.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for VirtualNetworkType {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.rpf)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.forwardingMode)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.rpf.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.forwardingMode.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.rpf.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.forwardingMode.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VirtualNetworkType {
        VirtualNetworkType::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "rpf",
                |m: &VirtualNetworkType| { &m.rpf },
                |m: &mut VirtualNetworkType| { &mut m.rpf },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "forwardingMode",
                |m: &VirtualNetworkType| { &m.forwardingMode },
                |m: &mut VirtualNetworkType| { &mut m.forwardingMode },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VirtualNetworkType>(
                "VirtualNetworkType",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VirtualNetworkType {
        static instance: ::protobuf::rt::LazyV2<VirtualNetworkType> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VirtualNetworkType::new)
    }
}

impl ::protobuf::Clear for VirtualNetworkType {
    fn clear(&mut self) {
        self.rpf.clear();
        self.forwardingMode.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VirtualNetworkType {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VirtualNetworkType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VirtualRouter {
    // message fields
    pub metadata: ::protobuf::SingularPtrField<super::meta::ObjectMeta>,
    pub spec: ::protobuf::SingularPtrField<VirtualRouterSpec>,
    pub status: ::protobuf::SingularPtrField<VirtualRouterStatus>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VirtualRouter {
    fn default() -> &'a VirtualRouter {
        <VirtualRouter as ::protobuf::Message>::default_instance()
    }
}

impl VirtualRouter {
    pub fn new() -> VirtualRouter {
        ::std::default::Default::default()
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;


    pub fn get_metadata(&self) -> &super::meta::ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <super::meta::ObjectMeta as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::meta::ObjectMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::meta::ObjectMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::meta::ObjectMeta {
        self.metadata.take().unwrap_or_else(|| super::meta::ObjectMeta::new())
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualRouterSpec spec = 2;


    pub fn get_spec(&self) -> &VirtualRouterSpec {
        self.spec.as_ref().unwrap_or_else(|| <VirtualRouterSpec as ::protobuf::Message>::default_instance())
    }
    pub fn clear_spec(&mut self) {
        self.spec.clear();
    }

    pub fn has_spec(&self) -> bool {
        self.spec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_spec(&mut self, v: VirtualRouterSpec) {
        self.spec = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_spec(&mut self) -> &mut VirtualRouterSpec {
        if self.spec.is_none() {
            self.spec.set_default();
        }
        self.spec.as_mut().unwrap()
    }

    // Take field
    pub fn take_spec(&mut self) -> VirtualRouterSpec {
        self.spec.take().unwrap_or_else(|| VirtualRouterSpec::new())
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualRouterStatus status = 3;


    pub fn get_status(&self) -> &VirtualRouterStatus {
        self.status.as_ref().unwrap_or_else(|| <VirtualRouterStatus as ::protobuf::Message>::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: VirtualRouterStatus) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut VirtualRouterStatus {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> VirtualRouterStatus {
        self.status.take().unwrap_or_else(|| VirtualRouterStatus::new())
    }
}

impl ::protobuf::Message for VirtualRouter {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.spec {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.spec)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.spec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.spec.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VirtualRouter {
        VirtualRouter::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::meta::ObjectMeta>>(
                "metadata",
                |m: &VirtualRouter| { &m.metadata },
                |m: &mut VirtualRouter| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<VirtualRouterSpec>>(
                "spec",
                |m: &VirtualRouter| { &m.spec },
                |m: &mut VirtualRouter| { &mut m.spec },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<VirtualRouterStatus>>(
                "status",
                |m: &VirtualRouter| { &m.status },
                |m: &mut VirtualRouter| { &mut m.status },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VirtualRouter>(
                "VirtualRouter",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VirtualRouter {
        static instance: ::protobuf::rt::LazyV2<VirtualRouter> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VirtualRouter::new)
    }
}

impl ::protobuf::Clear for VirtualRouter {
    fn clear(&mut self) {
        self.metadata.clear();
        self.spec.clear();
        self.status.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VirtualRouter {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VirtualRouter {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VirtualRouterList {
    // message fields
    pub metadata: ::protobuf::SingularPtrField<super::meta::ListMeta>,
    pub items: ::protobuf::RepeatedField<VirtualRouter>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VirtualRouterList {
    fn default() -> &'a VirtualRouterList {
        <VirtualRouterList as ::protobuf::Message>::default_instance()
    }
}

impl VirtualRouterList {
    pub fn new() -> VirtualRouterList {
        ::std::default::Default::default()
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;


    pub fn get_metadata(&self) -> &super::meta::ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <super::meta::ListMeta as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: super::meta::ListMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut super::meta::ListMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> super::meta::ListMeta {
        self.metadata.take().unwrap_or_else(|| super::meta::ListMeta::new())
    }

    // repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualRouter items = 2;


    pub fn get_items(&self) -> &[VirtualRouter] {
        &self.items
    }
    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::protobuf::RepeatedField<VirtualRouter>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::protobuf::RepeatedField<VirtualRouter> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::protobuf::RepeatedField<VirtualRouter> {
        ::std::mem::replace(&mut self.items, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for VirtualRouterList {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.items {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.items)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.items {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VirtualRouterList {
        VirtualRouterList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::meta::ListMeta>>(
                "metadata",
                |m: &VirtualRouterList| { &m.metadata },
                |m: &mut VirtualRouterList| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<VirtualRouter>>(
                "items",
                |m: &VirtualRouterList| { &m.items },
                |m: &mut VirtualRouterList| { &mut m.items },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VirtualRouterList>(
                "VirtualRouterList",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VirtualRouterList {
        static instance: ::protobuf::rt::LazyV2<VirtualRouterList> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VirtualRouterList::new)
    }
}

impl ::protobuf::Clear for VirtualRouterList {
    fn clear(&mut self) {
        self.metadata.clear();
        self.items.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VirtualRouterList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VirtualRouterList {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VirtualRouterSpec {
    // message fields
    pub commonSpec: ::protobuf::SingularPtrField<CommonSpec>,
    pub parent: ::protobuf::SingularPtrField<super::generated::ObjectReference>,
    virtualRouterDpdkEnabled: ::std::option::Option<bool>,
    virtualRouterIPAddress: ::protobuf::SingularField<::std::string::String>,
    virtualRouterType: ::protobuf::SingularField<::std::string::String>,
    pub virtualMachineReferences: ::protobuf::RepeatedField<ResourceReference>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VirtualRouterSpec {
    fn default() -> &'a VirtualRouterSpec {
        <VirtualRouterSpec as ::protobuf::Message>::default_instance()
    }
}

impl VirtualRouterSpec {
    pub fn new() -> VirtualRouterSpec {
        ::std::default::Default::default()
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonSpec commonSpec = 1;


    pub fn get_commonSpec(&self) -> &CommonSpec {
        self.commonSpec.as_ref().unwrap_or_else(|| <CommonSpec as ::protobuf::Message>::default_instance())
    }
    pub fn clear_commonSpec(&mut self) {
        self.commonSpec.clear();
    }

    pub fn has_commonSpec(&self) -> bool {
        self.commonSpec.is_some()
    }

    // Param is passed by value, moved
    pub fn set_commonSpec(&mut self, v: CommonSpec) {
        self.commonSpec = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_commonSpec(&mut self) -> &mut CommonSpec {
        if self.commonSpec.is_none() {
            self.commonSpec.set_default();
        }
        self.commonSpec.as_mut().unwrap()
    }

    // Take field
    pub fn take_commonSpec(&mut self) -> CommonSpec {
        self.commonSpec.take().unwrap_or_else(|| CommonSpec::new())
    }

    // optional .k8s.io.api.core.v1.ObjectReference parent = 2;


    pub fn get_parent(&self) -> &super::generated::ObjectReference {
        self.parent.as_ref().unwrap_or_else(|| <super::generated::ObjectReference as ::protobuf::Message>::default_instance())
    }
    pub fn clear_parent(&mut self) {
        self.parent.clear();
    }

    pub fn has_parent(&self) -> bool {
        self.parent.is_some()
    }

    // Param is passed by value, moved
    pub fn set_parent(&mut self, v: super::generated::ObjectReference) {
        self.parent = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_parent(&mut self) -> &mut super::generated::ObjectReference {
        if self.parent.is_none() {
            self.parent.set_default();
        }
        self.parent.as_mut().unwrap()
    }

    // Take field
    pub fn take_parent(&mut self) -> super::generated::ObjectReference {
        self.parent.take().unwrap_or_else(|| super::generated::ObjectReference::new())
    }

    // optional bool virtualRouterDpdkEnabled = 3;


    pub fn get_virtualRouterDpdkEnabled(&self) -> bool {
        self.virtualRouterDpdkEnabled.unwrap_or(false)
    }
    pub fn clear_virtualRouterDpdkEnabled(&mut self) {
        self.virtualRouterDpdkEnabled = ::std::option::Option::None;
    }

    pub fn has_virtualRouterDpdkEnabled(&self) -> bool {
        self.virtualRouterDpdkEnabled.is_some()
    }

    // Param is passed by value, moved
    pub fn set_virtualRouterDpdkEnabled(&mut self, v: bool) {
        self.virtualRouterDpdkEnabled = ::std::option::Option::Some(v);
    }

    // optional string virtualRouterIPAddress = 4;


    pub fn get_virtualRouterIPAddress(&self) -> &str {
        match self.virtualRouterIPAddress.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_virtualRouterIPAddress(&mut self) {
        self.virtualRouterIPAddress.clear();
    }

    pub fn has_virtualRouterIPAddress(&self) -> bool {
        self.virtualRouterIPAddress.is_some()
    }

    // Param is passed by value, moved
    pub fn set_virtualRouterIPAddress(&mut self, v: ::std::string::String) {
        self.virtualRouterIPAddress = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_virtualRouterIPAddress(&mut self) -> &mut ::std::string::String {
        if self.virtualRouterIPAddress.is_none() {
            self.virtualRouterIPAddress.set_default();
        }
        self.virtualRouterIPAddress.as_mut().unwrap()
    }

    // Take field
    pub fn take_virtualRouterIPAddress(&mut self) -> ::std::string::String {
        self.virtualRouterIPAddress.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string virtualRouterType = 5;


    pub fn get_virtualRouterType(&self) -> &str {
        match self.virtualRouterType.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_virtualRouterType(&mut self) {
        self.virtualRouterType.clear();
    }

    pub fn has_virtualRouterType(&self) -> bool {
        self.virtualRouterType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_virtualRouterType(&mut self, v: ::std::string::String) {
        self.virtualRouterType = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_virtualRouterType(&mut self) -> &mut ::std::string::String {
        if self.virtualRouterType.is_none() {
            self.virtualRouterType.set_default();
        }
        self.virtualRouterType.as_mut().unwrap()
    }

    // Take field
    pub fn take_virtualRouterType(&mut self) -> ::std::string::String {
        self.virtualRouterType.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ResourceReference virtualMachineReferences = 6;


    pub fn get_virtualMachineReferences(&self) -> &[ResourceReference] {
        &self.virtualMachineReferences
    }
    pub fn clear_virtualMachineReferences(&mut self) {
        self.virtualMachineReferences.clear();
    }

    // Param is passed by value, moved
    pub fn set_virtualMachineReferences(&mut self, v: ::protobuf::RepeatedField<ResourceReference>) {
        self.virtualMachineReferences = v;
    }

    // Mutable pointer to the field.
    pub fn mut_virtualMachineReferences(&mut self) -> &mut ::protobuf::RepeatedField<ResourceReference> {
        &mut self.virtualMachineReferences
    }

    // Take field
    pub fn take_virtualMachineReferences(&mut self) -> ::protobuf::RepeatedField<ResourceReference> {
        ::std::mem::replace(&mut self.virtualMachineReferences, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for VirtualRouterSpec {
    fn is_initialized(&self) -> bool {
        for v in &self.commonSpec {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.parent {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.virtualMachineReferences {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.commonSpec)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.parent)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.virtualRouterDpdkEnabled = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.virtualRouterIPAddress)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.virtualRouterType)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.virtualMachineReferences)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.commonSpec.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.parent.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.virtualRouterDpdkEnabled {
            my_size += 2;
        }
        if let Some(ref v) = self.virtualRouterIPAddress.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.virtualRouterType.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        for value in &self.virtualMachineReferences {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.commonSpec.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.parent.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.virtualRouterDpdkEnabled {
            os.write_bool(3, v)?;
        }
        if let Some(ref v) = self.virtualRouterIPAddress.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.virtualRouterType.as_ref() {
            os.write_string(5, &v)?;
        }
        for v in &self.virtualMachineReferences {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VirtualRouterSpec {
        VirtualRouterSpec::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommonSpec>>(
                "commonSpec",
                |m: &VirtualRouterSpec| { &m.commonSpec },
                |m: &mut VirtualRouterSpec| { &mut m.commonSpec },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::generated::ObjectReference>>(
                "parent",
                |m: &VirtualRouterSpec| { &m.parent },
                |m: &mut VirtualRouterSpec| { &mut m.parent },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "virtualRouterDpdkEnabled",
                |m: &VirtualRouterSpec| { &m.virtualRouterDpdkEnabled },
                |m: &mut VirtualRouterSpec| { &mut m.virtualRouterDpdkEnabled },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "virtualRouterIPAddress",
                |m: &VirtualRouterSpec| { &m.virtualRouterIPAddress },
                |m: &mut VirtualRouterSpec| { &mut m.virtualRouterIPAddress },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "virtualRouterType",
                |m: &VirtualRouterSpec| { &m.virtualRouterType },
                |m: &mut VirtualRouterSpec| { &mut m.virtualRouterType },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResourceReference>>(
                "virtualMachineReferences",
                |m: &VirtualRouterSpec| { &m.virtualMachineReferences },
                |m: &mut VirtualRouterSpec| { &mut m.virtualMachineReferences },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VirtualRouterSpec>(
                "VirtualRouterSpec",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VirtualRouterSpec {
        static instance: ::protobuf::rt::LazyV2<VirtualRouterSpec> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VirtualRouterSpec::new)
    }
}

impl ::protobuf::Clear for VirtualRouterSpec {
    fn clear(&mut self) {
        self.commonSpec.clear();
        self.parent.clear();
        self.virtualRouterDpdkEnabled = ::std::option::Option::None;
        self.virtualRouterIPAddress.clear();
        self.virtualRouterType.clear();
        self.virtualMachineReferences.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VirtualRouterSpec {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VirtualRouterSpec {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct VirtualRouterStatus {
    // message fields
    pub commonStatus: ::protobuf::SingularPtrField<CommonStatus>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a VirtualRouterStatus {
    fn default() -> &'a VirtualRouterStatus {
        <VirtualRouterStatus as ::protobuf::Message>::default_instance()
    }
}

impl VirtualRouterStatus {
    pub fn new() -> VirtualRouterStatus {
        ::std::default::Default::default()
    }

    // optional .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonStatus commonStatus = 1;


    pub fn get_commonStatus(&self) -> &CommonStatus {
        self.commonStatus.as_ref().unwrap_or_else(|| <CommonStatus as ::protobuf::Message>::default_instance())
    }
    pub fn clear_commonStatus(&mut self) {
        self.commonStatus.clear();
    }

    pub fn has_commonStatus(&self) -> bool {
        self.commonStatus.is_some()
    }

    // Param is passed by value, moved
    pub fn set_commonStatus(&mut self, v: CommonStatus) {
        self.commonStatus = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_commonStatus(&mut self) -> &mut CommonStatus {
        if self.commonStatus.is_none() {
            self.commonStatus.set_default();
        }
        self.commonStatus.as_mut().unwrap()
    }

    // Take field
    pub fn take_commonStatus(&mut self) -> CommonStatus {
        self.commonStatus.take().unwrap_or_else(|| CommonStatus::new())
    }
}

impl ::protobuf::Message for VirtualRouterStatus {
    fn is_initialized(&self) -> bool {
        for v in &self.commonStatus {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.commonStatus)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.commonStatus.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.commonStatus.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> VirtualRouterStatus {
        VirtualRouterStatus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<CommonStatus>>(
                "commonStatus",
                |m: &VirtualRouterStatus| { &m.commonStatus },
                |m: &mut VirtualRouterStatus| { &mut m.commonStatus },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<VirtualRouterStatus>(
                "VirtualRouterStatus",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static VirtualRouterStatus {
        static instance: ::protobuf::rt::LazyV2<VirtualRouterStatus> = ::protobuf::rt::LazyV2::INIT;
        instance.get(VirtualRouterStatus::new)
    }
}

impl ::protobuf::Clear for VirtualRouterStatus {
    fn clear(&mut self) {
        self.commonStatus.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for VirtualRouterStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VirtualRouterStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \nOssd-git.juniper.net/contrail/cn2/contrail/pkg/apis/core/v1alpha1/cont\
    rail.proto\x12@ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v\
    1alpha1\x1a\"k8s.io/api/core/v1/generated.proto\x1a/k8s.io/apimachinery/\
    pkg/apis/meta/v1/meta.proto\x1a/k8s.io/apimachinery/pkg/runtime/generate\
    d.proto\x1a6k8s.io/apimachinery/pkg/runtime/schema/generated.proto\x1a3k\
    8s.io/apimachinery/pkg/util/intstr/generated.proto\x1aassd-git.juniper.n\
    et/contrail/cn2/third_party/apiserver-builder-alpha/pkg/builders/generat\
    ed.proto\"*\n\x0cAPSAttribute\x12\x1a\n\x08sequence\x18\x01\x20\x01(\tR\
    \x08sequence\")\n\x0fAddressFamilies\x12\x16\n\x06family\x18\x01\x20\x03\
    (\tR\x06family\"\xb2\x02\n\x0cAddressGroup\x12L\n\x08metadata\x18\x01\
    \x20\x01(\x0b20.k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMetaR\x08meta\
    data\x12f\n\x04spec\x18\x02\x20\x01(\x0b2R.ssd_git.juniper.net.contrail.\
    cn2.contrail.pkg.apis.core.v1alpha1.AddressGroupSpecR\x04spec\x12l\n\x06\
    status\x18\x03\x20\x01(\x0b2T.ssd_git.juniper.net.contrail.cn2.contrail.\
    pkg.apis.core.v1alpha1.AddressGroupStatusR\x06status\"\xc4\x01\n\x10Addr\
    essGroupList\x12J\n\x08metadata\x18\x01\x20\x01(\x0b2..k8s.io.apimachine\
    ry.pkg.apis.meta.v1.ListMetaR\x08metadata\x12d\n\x05items\x18\x02\x20\
    \x03(\x0b2N.ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1al\
    pha1.AddressGroupR\x05items\"~\n\x12AddressGroupPrefix\x12h\n\x06subnet\
    \x18\x01\x20\x03(\x0b2P.ssd_git.juniper.net.contrail.cn2.contrail.pkg.ap\
    is.core.v1alpha1.FirewallSubnetR\x06subnet\"\x8b\x02\n\x10AddressGroupSp\
    ec\x12l\n\ncommonSpec\x18\x01\x20\x01(\x0b2L.ssd_git.juniper.net.contrai\
    l.cn2.contrail.pkg.apis.core.v1alpha1.CommonSpecR\ncommonSpec\x12\x88\
    \x01\n\x14addressGroupPrefixes\x18\x02\x20\x01(\x0b2T.ssd_git.juniper.ne\
    t.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AddressGroupPrefixR\x14ad\
    dressGroupPrefixes\"\x88\x01\n\x12AddressGroupStatus\x12r\n\x0ccommonSta\
    tus\x18\x01\x20\x01(\x0b2N.ssd_git.juniper.net.contrail.cn2.contrail.pkg\
    .apis.core.v1alpha1.CommonStatusR\x0ccommonStatus\"\xb4\x01\n\x12Allowed\
    AddressPair\x12j\n\x02ip\x18\x01\x20\x01(\x0b2Z.ssd_git.juniper.net.cont\
    rail.cn2.contrail.pkg.apis.core.v1alpha1.AllowedAddressPairSubnetR\x02ip\
    \x12\x10\n\x03mac\x18\x02\x20\x01(\tR\x03mac\x12\x20\n\x0baddressMode\
    \x18\x03\x20\x01(\tR\x0baddressMode\"\x8a\x01\n\x18AllowedAddressPairSub\
    net\x12\x1a\n\x08ipPrefix\x18\x01\x20\x01(\tR\x08ipPrefix\x12R\n\x0bipPr\
    efixLen\x18\x02\x20\x01(\x0b20.k8s.io.apimachinery.pkg.util.intstr.IntOr\
    StringR\x0bipPrefixLen\"\x9c\x01\n\x13AllowedAddressPairs\x12\x84\x01\n\
    \x12allowedAddressPair\x18\x01\x20\x03(\x0b2T.ssd_git.juniper.net.contra\
    il.cn2.contrail.pkg.apis.core.v1alpha1.AllowedAddressPairR\x12allowedAdd\
    ressPair\"\xca\x02\n\x14ApplicationPolicySet\x12L\n\x08metadata\x18\x01\
    \x20\x01(\x0b20.k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMetaR\x08meta\
    data\x12n\n\x04spec\x18\x02\x20\x01(\x0b2Z.ssd_git.juniper.net.contrail.\
    cn2.contrail.pkg.apis.core.v1alpha1.ApplicationPolicySetSpecR\x04spec\
    \x12t\n\x06status\x18\x03\x20\x01(\x0b2\\.ssd_git.juniper.net.contrail.c\
    n2.contrail.pkg.apis.core.v1alpha1.ApplicationPolicySetStatusR\x06status\
    \"\xd4\x01\n\x18ApplicationPolicySetList\x12J\n\x08metadata\x18\x01\x20\
    \x01(\x0b2..k8s.io.apimachinery.pkg.apis.meta.v1.ListMetaR\x08metadata\
    \x12l\n\x05items\x18\x02\x20\x03(\x0b2V.ssd_git.juniper.net.contrail.cn2\
    .contrail.pkg.apis.core.v1alpha1.ApplicationPolicySetR\x05items\"\x9b\
    \x03\n\x18ApplicationPolicySetSpec\x12l\n\ncommonSpec\x18\x01\x20\x01(\
    \x0b2L.ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.\
    CommonSpecR\ncommonSpec\x12\x95\x01\n\x18firewallPolicyReferences\x18\
    \x02\x20\x03(\x0b2Y.ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.c\
    ore.v1alpha1.FirewallPolicyReferenceR\x18firewallPolicyReferences\x12y\n\
    \rtagReferences\x18\x03\x20\x03(\x0b2S.ssd_git.juniper.net.contrail.cn2.\
    contrail.pkg.apis.core.v1alpha1.ResourceReferenceR\rtagReferences\"\xba\
    \x01\n\x1aApplicationPolicySetStatus\x12r\n\x0ccommonStatus\x18\x01\x20\
    \x01(\x0b2N.ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1al\
    pha1.CommonStatusR\x0ccommonStatus\x12(\n\x0fallApplications\x18\x03\x20\
    \x01(\x08R\x0fallApplications\"\xa3\x01\n\x12AuthenticationData\x12\x18\
    \n\x07keyType\x18\x01\x20\x01(\tR\x07keyType\x12s\n\x08keyItems\x18\x02\
    \x20\x03(\x0b2W.ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.\
    v1alpha1.AuthenticationKeyItemR\x08keyItems\"?\n\x15AuthenticationKeyIte\
    m\x12\x14\n\x05keyId\x18\x01\x20\x01(\x05R\x05keyId\x12\x10\n\x03key\x18\
    \x02\x20\x01(\tR\x03key\"\xb5\x02\n\rBGPAsAService\x12L\n\x08metadata\
    \x18\x01\x20\x01(\x0b20.k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMetaR\
    \x08metadata\x12g\n\x04spec\x18\x02\x20\x01(\x0b2S.ssd_git.juniper.net.c\
    ontrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPAsAServiceSpecR\x04spec\
    \x12m\n\x06status\x18\x03\x20\x01(\x0b2U.ssd_git.juniper.net.contrail.cn\
    2.contrail.pkg.apis.core.v1alpha1.BGPAsAServiceStatusR\x06status\"\xc6\
    \x01\n\x11BGPAsAServiceList\x12J\n\x08metadata\x18\x01\x20\x01(\x0b2..k8\
    s.io.apimachinery.pkg.apis.meta.v1.ListMetaR\x08metadata\x12e\n\x05items\
    \x18\x02\x20\x03(\x0b2O.ssd_git.juniper.net.contrail.cn2.contrail.pkg.ap\
    is.core.v1alpha1.BGPAsAServiceR\x05items\"\x9f\x06\n\x11BGPAsAServiceSpe\
    c\x12l\n\ncommonSpec\x18\x01\x20\x01(\x0b2L.ssd_git.juniper.net.contrail\
    .cn2.contrail.pkg.apis.core.v1alpha1.CommonSpecR\ncommonSpec\x12\x16\n\
    \x06shared\x18\x02\x20\x01(\x08R\x06shared\x12\x1c\n\tipAddress\x18\x03\
    \x20\x01(\tR\tipAddress\x12*\n\x10autonomousSystem\x18\x04\x20\x01(\x05R\
    \x10autonomousSystem\x12>\n\x1asuppressRouteAdvertisement\x18\x05\x20\
    \x01(\x08R\x1asuppressRouteAdvertisement\x124\n\x15ipv4MappedIPv6NextHop\
    \x18\x06\x20\x01(\x08R\x15ipv4MappedIPv6NextHop\x12\x9e\x01\n\x1ebgpAsAS\
    erviceSessionAttributes\x18\x07\x20\x01(\x0b2V.ssd_git.juniper.net.contr\
    ail.cn2.contrail.pkg.apis.core.v1alpha1.BGPSessionAttributesR\x1ebgpAsAS\
    erviceSessionAttributes\x12\xa1\x01\n!virtualMachineInterfaceReferences\
    \x18\x08\x20\x03(\x0b2S.ssd_git.juniper.net.contrail.cn2.contrail.pkg.ap\
    is.core.v1alpha1.ResourceReferenceR!virtualMachineInterfaceReferences\
    \x12\x7f\n\x20virtualMachineInterfacesSelector\x18\t\x20\x03(\x0b23.k8s.\
    io.apimachinery.pkg.apis.meta.v1.LabelSelectorR\x20virtualMachineInterfa\
    cesSelector\"\x91\x03\n\x13BGPAsAServiceStatus\x12r\n\x0ccommonStatus\
    \x18\x01\x20\x01(\x0b2N.ssd_git.juniper.net.contrail.cn2.contrail.pkg.ap\
    is.core.v1alpha1.CommonStatusR\x0ccommonStatus\x12\x86\x01\n\x13bgpRoute\
    rReferences\x18\x02\x20\x03(\x0b2T.ssd_git.juniper.net.contrail.cn2.cont\
    rail.pkg.apis.core.v1alpha1.BGPRouterReferenceR\x13bgpRouterReferences\
    \x12}\n\x10subnetReferences\x18\x03\x20\x03(\x0b2Q.ssd_git.juniper.net.c\
    ontrail.cn2.contrail.pkg.apis.core.v1alpha1.SubnetReferenceR\x10subnetRe\
    ferences\"\xfd\x01\n\x13BGPFamilyAttributes\x12$\n\raddressFamily\x18\
    \x01\x20\x01(\tR\raddressFamily\x12\x1c\n\tloopCount\x18\x02\x20\x01(\
    \x05R\tloopCount\x12r\n\x0bprefixLimit\x18\x03\x20\x01(\x0b2P.ssd_git.ju\
    niper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPPrefixLimitR\
    \x0bprefixLimit\x12.\n\x12defaultTunnelEncap\x18\x04\x20\x03(\tR\x12defa\
    ultTunnelEncap\"L\n\x0eBGPPrefixLimit\x12\x20\n\x0bidleTimeout\x18\x01\
    \x20\x01(\x05R\x0bidleTimeout\x12\x18\n\x07maximum\x18\x02\x20\x01(\x05R\
    \x07maximum\"\xa9\x02\n\tBGPRouter\x12L\n\x08metadata\x18\x01\x20\x01(\
    \x0b20.k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMetaR\x08metadata\x12c\
    \n\x04spec\x18\x02\x20\x01(\x0b2O.ssd_git.juniper.net.contrail.cn2.contr\
    ail.pkg.apis.core.v1alpha1.BGPRouterSpecR\x04spec\x12i\n\x06status\x18\
    \x03\x20\x01(\x0b2Q.ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.c\
    ore.v1alpha1.BGPRouterStatusR\x06status\"\xbe\x01\n\rBGPRouterList\x12J\
    \n\x08metadata\x18\x01\x20\x01(\x0b2..k8s.io.apimachinery.pkg.apis.meta.\
    v1.ListMetaR\x08metadata\x12a\n\x05items\x18\x02\x20\x03(\x0b2K.ssd_git.\
    juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterR\x05i\
    tems\"\xbc\x05\n\x13BGPRouterParameters\x12\x1c\n\tadminDown\x18\x01\x20\
    \x01(\x08R\tadminDown\x12\x16\n\x06vendor\x18\x02\x20\x01(\tR\x06vendor\
    \x12\x1c\n\tclusterID\x18\x03\x20\x01(\x03R\tclusterID\x12*\n\x10autonom\
    ousSystem\x18\x04\x20\x01(\x05R\x10autonomousSystem\x12\x1e\n\nidentifie\
    r\x18\x05\x20\x01(\tR\nidentifier\x12\x18\n\x07address\x18\x06\x20\x01(\
    \tR\x07address\x12\x12\n\x04port\x18\x07\x20\x01(\x05R\x04port\x12\x1e\n\
    \nsourcePort\x18\x08\x20\x01(\x05R\nsourcePort\x12\x1a\n\x08holdTime\x18\
    \t\x20\x01(\x05R\x08holdTime\x12{\n\x0faddressFamilies\x18\n\x20\x01(\
    \x0b2Q.ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.\
    AddressFamiliesR\x0faddressFamilies\x12p\n\x08authData\x18\x0b\x20\x01(\
    \x0b2T.ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.\
    AuthenticationDataR\x08authData\x124\n\x15localAutonomousSystem\x18\x0c\
    \x20\x01(\x05R\x15localAutonomousSystem\x12\x1e\n\nrouterType\x18\r\x20\
    \x01(\tR\nrouterType\x12&\n\x0egatewayAddress\x18\x0e\x20\x01(\tR\x0egat\
    ewayAddress\x12.\n\x12ipv6GatewayAddress\x18\x0f\x20\x01(\tR\x12ipv6Gate\
    wayAddress\"\x98\x02\n\x12BGPRouterReference\x12\x81\x01\n\x11resourceRe\
    ference\x18\x01\x20\x01(\x0b2S.ssd_git.juniper.net.contrail.cn2.contrail\
    .pkg.apis.core.v1alpha1.ResourceReferenceR\x11resourceReference\x12~\n\n\
    attributes\x18\x02\x20\x01(\x0b2^.ssd_git.juniper.net.contrail.cn2.contr\
    ail.pkg.apis.core.v1alpha1.BGPRouterReferenceAttributesR\nattributes\"\
    \x86\x01\n\x1cBGPRouterReferenceAttributes\x12f\n\x07session\x18\x01\x20\
    \x03(\x0b2L.ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1al\
    pha1.BGPSessionR\x07session\"\xcd\x03\n\rBGPRouterSpec\x12l\n\ncommonSpe\
    c\x18\x01\x20\x01(\x0b2L.ssd_git.juniper.net.contrail.cn2.contrail.pkg.a\
    pis.core.v1alpha1.CommonSpecR\ncommonSpec\x12;\n\x06parent\x18\x02\x20\
    \x01(\x0b2#.k8s.io.api.core.v1.ObjectReferenceR\x06parent\x12\x86\x01\n\
    \x13bgpRouterReferences\x18\x04\x20\x03(\x0b2T.ssd_git.juniper.net.contr\
    ail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRouterReferenceR\x13bgpRouter\
    References\x12\x87\x01\n\x13bgpRouterParameters\x18\x03\x20\x01(\x0b2U.s\
    sd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.BGPRoute\
    rParametersR\x13bgpRouterParameters\"\x85\x01\n\x0fBGPRouterStatus\x12r\
    \n\x0ccommonStatus\x18\x01\x20\x01(\x0b2N.ssd_git.juniper.net.contrail.c\
    n2.contrail.pkg.apis.core.v1alpha1.CommonStatusR\x0ccommonStatus\"\x93\
    \x01\n\nBGPSession\x12\x84\x01\n\x11sessionAttributes\x18\x01\x20\x03(\
    \x0b2V.ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.\
    BGPSessionAttributesR\x11sessionAttributes\"\xa3\x06\n\x14BGPSessionAttr\
    ibutes\x12\x1c\n\tbgpRouter\x18\x01\x20\x01(\tR\tbgpRouter\x12\x1c\n\tad\
    minDown\x18\x02\x20\x01(\x08R\tadminDown\x12\x18\n\x07passive\x18\x03\
    \x20\x01(\x08R\x07passive\x12\x1e\n\nasOverride\x18\x04\x20\x01(\x08R\na\
    sOverride\x12\x1a\n\x08holdTime\x18\x05\x20\x01(\x05R\x08holdTime\x12\
    \x1c\n\tloopCount\x18\x06\x20\x01(\x05R\tloopCount\x124\n\x15localAutono\
    mousSystem\x18\x07\x20\x01(\x05R\x15localAutonomousSystem\x12{\n\x0faddr\
    essFamilies\x18\x08\x20\x01(\x0b2Q.ssd_git.juniper.net.contrail.cn2.cont\
    rail.pkg.apis.core.v1alpha1.AddressFamiliesR\x0faddressFamilies\x12p\n\
    \x08authData\x18\t\x20\x01(\x0b2T.ssd_git.juniper.net.contrail.cn2.contr\
    ail.pkg.apis.core.v1alpha1.AuthenticationDataR\x08authData\x12\x81\x01\n\
    \x10familyAttributes\x18\n\x20\x03(\x0b2U.ssd_git.juniper.net.contrail.c\
    n2.contrail.pkg.apis.core.v1alpha1.BGPFamilyAttributesR\x10familyAttribu\
    tes\x12(\n\x0fprivateAsAction\x18\x0b\x20\x01(\tR\x0fprivateAsAction\x12\
    \x87\x01\n\x13routeOriginOverride\x18\x0c\x20\x01(\x0b2U.ssd_git.juniper\
    .net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RouteOriginOverrideR\
    \x13routeOriginOverride\"p\n\x16BGPSessionIPAttributes\x12(\n\x0fbgpaasP\
    rimaryIP\x18\x01\x20\x01(\tR\x0fbgpaasPrimaryIP\x12,\n\x11bgpaasSecondar\
    yIP\x18\x02\x20\x01(\tR\x11bgpaasSecondaryIP\"\x86\x01\n\nCommonSpec\x12\
    x\n\x0econtrailFqName\x18\x01\x20\x01(\x0b2P.ssd_git.juniper.net.contrai\
    l.cn2.contrail.pkg.apis.core.v1alpha1.ContrailFqNameR\x0econtrailFqName\
    \"\x8b\x01\n\x0cCommonStatus\x12{\n\x0freconcilerState\x18\x01\x20\x01(\
    \x0b2Q.ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.\
    ReconcilerStateR\x0freconcilerState\"(\n\x0eContrailFqName\x12\x16\n\x06\
    fqName\x18\x01\x20\x03(\tR\x06fqName\"?\n\x17EncapsulationPriorities\x12\
    $\n\rencapsulation\x18\x01\x20\x03(\tR\rencapsulation\"<\n\x16FirewallAc\
    tionListType\x12\"\n\x0csimpleAction\x18\x01\x20\x01(\tR\x0csimpleAction\
    \"\xb8\x02\n\x0eFirewallPolicy\x12L\n\x08metadata\x18\x01\x20\x01(\x0b20\
    .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMetaR\x08metadata\x12h\n\x04\
    spec\x18\x02\x20\x01(\x0b2T.ssd_git.juniper.net.contrail.cn2.contrail.pk\
    g.apis.core.v1alpha1.FirewallPolicySpecR\x04spec\x12n\n\x06status\x18\
    \x03\x20\x01(\x0b2V.ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.c\
    ore.v1alpha1.FirewallPolicyStatusR\x06status\"5\n\x17FirewallPolicyAttri\
    bute\x12\x1a\n\x08sequence\x18\x01\x20\x01(\tR\x08sequence\"\xc8\x01\n\
    \x12FirewallPolicyList\x12J\n\x08metadata\x18\x01\x20\x01(\x0b2..k8s.io.\
    apimachinery.pkg.apis.meta.v1.ListMetaR\x08metadata\x12f\n\x05items\x18\
    \x02\x20\x03(\x0b2P.ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.c\
    ore.v1alpha1.FirewallPolicyR\x05items\"\x8d\x02\n\x17FirewallPolicyRefer\
    ence\x12\x81\x01\n\x11resourceReference\x18\x01\x20\x01(\x0b2S.ssd_git.j\
    uniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ResourceReferenc\
    eR\x11resourceReference\x12n\n\nattributes\x18\x02\x20\x01(\x0b2N.ssd_gi\
    t.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.APSAttributeR\
    \nattributes\"\xff\x01\n\x12FirewallPolicySpec\x12l\n\ncommonSpec\x18\
    \x01\x20\x01(\x0b2L.ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.c\
    ore.v1alpha1.CommonSpecR\ncommonSpec\x12{\n\x0cfirewallRule\x18\x03\x20\
    \x03(\x0b2W.ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1al\
    pha1.FirewallRuleReferenceR\x0cfirewallRule\"\x8a\x01\n\x14FirewallPolic\
    yStatus\x12r\n\x0ccommonStatus\x18\x01\x20\x01(\x0b2N.ssd_git.juniper.ne\
    t.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonStatusR\x0ccommonSt\
    atus\"\xb2\x02\n\x0cFirewallRule\x12L\n\x08metadata\x18\x01\x20\x01(\x0b\
    20.k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMetaR\x08metadata\x12f\n\
    \x04spec\x18\x02\x20\x01(\x0b2R.ssd_git.juniper.net.contrail.cn2.contrai\
    l.pkg.apis.core.v1alpha1.FirewallRuleSpecR\x04spec\x12l\n\x06status\x18\
    \x03\x20\x01(\x0b2T.ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.c\
    ore.v1alpha1.FirewallRuleStatusR\x06status\"\xe6\x01\n\x18FirewallRuleEn\
    dpointType\x12h\n\x06subnet\x18\x01\x20\x01(\x0b2P.ssd_git.juniper.net.c\
    ontrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallSubnetR\x06subnet\
    \x12\"\n\x0caddressGroup\x18\x03\x20\x01(\tR\x0caddressGroup\x12\x12\n\
    \x04tags\x18\x04\x20\x03(\tR\x04tags\x12\x16\n\x06tagIds\x18\x05\x20\x03\
    (\x03R\x06tagIds\x12\x10\n\x03any\x18\x06\x20\x01(\x08R\x03any\"\xc4\x01\
    \n\x10FirewallRuleList\x12J\n\x08metadata\x18\x01\x20\x01(\x0b2..k8s.io.\
    apimachinery.pkg.apis.meta.v1.ListMetaR\x08metadata\x12d\n\x05items\x18\
    \x02\x20\x03(\x0b2N.ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.c\
    ore.v1alpha1.FirewallRuleR\x05items\"\x96\x02\n\x15FirewallRuleReference\
    \x12\x81\x01\n\x11resourceReference\x18\x01\x20\x01(\x0b2S.ssd_git.junip\
    er.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ResourceReferenceR\
    \x11resourceReference\x12y\n\nattributes\x18\x02\x20\x01(\x0b2Y.ssd_git.\
    juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.FirewallPolicyA\
    ttributeR\nattributes\"\xca\x07\n\x10FirewallRuleSpec\x12l\n\ncommonSpec\
    \x18\x01\x20\x01(\x0b2L.ssd_git.juniper.net.contrail.cn2.contrail.pkg.ap\
    is.core.v1alpha1.CommonSpecR\ncommonSpec\x12\x89\x01\n\x15addressGroupRe\
    ference\x18\x02\x20\x01(\x0b2S.ssd_git.juniper.net.contrail.cn2.contrail\
    .pkg.apis.core.v1alpha1.ResourceReferenceR\x15addressGroupReference\x12x\
    \n\nactionList\x18\x03\x20\x01(\x0b2X.ssd_git.juniper.net.contrail.cn2.c\
    ontrail.pkg.apis.core.v1alpha1.FirewallActionListTypeR\nactionList\x12o\
    \n\x07service\x18\x04\x20\x01(\x0b2U.ssd_git.juniper.net.contrail.cn2.co\
    ntrail.pkg.apis.core.v1alpha1.FirewallServiceTypeR\x07service\x12x\n\tEn\
    dpoint1\x18\x05\x20\x01(\x0b2Z.ssd_git.juniper.net.contrail.cn2.contrail\
    .pkg.apis.core.v1alpha1.FirewallRuleEndpointTypeR\tEndpoint1\x12x\n\tEnd\
    point2\x18\x06\x20\x01(\x0b2Z.ssd_git.juniper.net.contrail.cn2.contrail.\
    pkg.apis.core.v1alpha1.FirewallRuleEndpointTypeR\tEndpoint2\x12\x1c\n\tm\
    atchTags\x18\x07\x20\x03(\tR\tmatchTags\x12&\n\x0ematchTagsTypes\x18\x08\
    \x20\x03(\x03R\x0ematchTagsTypes\x12\x1c\n\tdirection\x18\t\x20\x01(\tR\
    \tdirection\x12y\n\rtagReferences\x18\n\x20\x03(\x0b2S.ssd_git.juniper.n\
    et.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ResourceReferenceR\rtagR\
    eferences\"\x88\x01\n\x12FirewallRuleStatus\x12r\n\x0ccommonStatus\x18\
    \x01\x20\x01(\x0b2N.ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.c\
    ore.v1alpha1.CommonStatusR\x0ccommonStatus\"\xb7\x02\n\x13FirewallServic\
    eType\x12\x1a\n\x08protocol\x18\x01\x20\x01(\tR\x08protocol\x12\x1e\n\np\
    rotocolId\x18\x02\x20\x01(\x03R\nprotocolId\x12l\n\x0bsourcePorts\x18\
    \x03\x20\x01(\x0b2J.ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.c\
    ore.v1alpha1.PortTypeR\x0bsourcePorts\x12v\n\x10destinationPorts\x18\x04\
    \x20\x01(\x0b2J.ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.\
    v1alpha1.PortTypeR\x10destinationPorts\"\x80\x01\n\x0eFirewallSubnet\x12\
    \x1a\n\x08ipPrefix\x18\x01\x20\x01(\tR\x08ipPrefix\x12R\n\x0bipPrefixLen\
    \x18\x02\x20\x01(\x0b20.k8s.io.apimachinery.pkg.util.intstr.IntOrStringR\
    \x0bipPrefixLen\"\xac\x02\n\nFloatingIP\x12L\n\x08metadata\x18\x01\x20\
    \x01(\x0b20.k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMetaR\x08metadata\
    \x12d\n\x04spec\x18\x02\x20\x01(\x0b2P.ssd_git.juniper.net.contrail.cn2.\
    contrail.pkg.apis.core.v1alpha1.FloatingIPSpecR\x04spec\x12j\n\x06status\
    \x18\x03\x20\x01(\x0b2R.ssd_git.juniper.net.contrail.cn2.contrail.pkg.ap\
    is.core.v1alpha1.FloatingIPStatusR\x06status\"\xc0\x01\n\x0eFloatingIPLi\
    st\x12J\n\x08metadata\x18\x01\x20\x01(\x0b2..k8s.io.apimachinery.pkg.api\
    s.meta.v1.ListMetaR\x08metadata\x12b\n\x05items\x18\x02\x20\x03(\x0b2L.s\
    sd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.Floating\
    IPR\x05items\"\x99\x01\n\x16FloatingIPPortMappings\x12\x7f\n\x0cportMapp\
    ings\x18\x01\x20\x03(\x0b2[.ssd_git.juniper.net.contrail.cn2.contrail.pk\
    g.apis.core.v1alpha1.FloatingIPPortPortMappingR\x0cportMappings\"k\n\x19\
    FloatingIPPortPortMapping\x12\x18\n\x07srcPort\x18\x01\x20\x01(\x05R\x07\
    srcPort\x12\x18\n\x07dstPort\x18\x02\x20\x01(\x05R\x07dstPort\x12\x1a\n\
    \x08protocol\x18\x03\x20\x01(\tR\x08protocol\"\xa4\x05\n\x0eFloatingIPSp\
    ec\x12l\n\ncommonSpec\x18\x01\x20\x01(\x0b2L.ssd_git.juniper.net.contrai\
    l.cn2.contrail.pkg.apis.core.v1alpha1.CommonSpecR\ncommonSpec\x12,\n\x11\
    floatingIPAddress\x18\x02\x20\x01(\tR\x11floatingIPAddress\x12\x90\x01\n\
    \x16floatingIPPortMappings\x18\x03\x20\x01(\x0b2X.ssd_git.juniper.net.co\
    ntrail.cn2.contrail.pkg.apis.core.v1alpha1.FloatingIPPortMappingsR\x16fl\
    oatingIPPortMappings\x12>\n\x1afloatingIPTrafficDirection\x18\x04\x20\
    \x01(\tR\x1afloatingIPTrafficDirection\x12;\n\x06parent\x18\x05\x20\x01(\
    \x0b2#.k8s.io.api.core.v1.ObjectReferenceR\x06parent\x12\xa1\x01\n!virtu\
    alMachineInterfaceReferences\x18\x07\x20\x03(\x0b2S.ssd_git.juniper.net.\
    contrail.cn2.contrail.pkg.apis.core.v1alpha1.ResourceReferenceR!virtualM\
    achineInterfaceReferences\x12B\n\x1cfloatingIPPortMappingsEnable\x18\x08\
    \x20\x01(\x08R\x1cfloatingIPPortMappingsEnable\"\x85\x02\n\x10FloatingIP\
    Status\x12r\n\x0ccommonStatus\x18\x01\x20\x01(\x0b2N.ssd_git.juniper.net\
    .contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonStatusR\x0ccommonSta\
    tus\x12}\n\x0fsubnetReference\x18\x02\x20\x01(\x0b2S.ssd_git.juniper.net\
    .contrail.cn2.contrail.pkg.apis.core.v1alpha1.ResourceReferenceR\x0fsubn\
    etReference\"\xc4\x02\n\x12GlobalSystemConfig\x12L\n\x08metadata\x18\x01\
    \x20\x01(\x0b20.k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMetaR\x08meta\
    data\x12l\n\x04spec\x18\x02\x20\x01(\x0b2X.ssd_git.juniper.net.contrail.\
    cn2.contrail.pkg.apis.core.v1alpha1.GlobalSystemConfigSpecR\x04spec\x12r\
    \n\x06status\x18\x03\x20\x01(\x0b2Z.ssd_git.juniper.net.contrail.cn2.con\
    trail.pkg.apis.core.v1alpha1.GlobalSystemConfigStatusR\x06status\"\xd0\
    \x01\n\x16GlobalSystemConfigList\x12J\n\x08metadata\x18\x01\x20\x01(\x0b\
    2..k8s.io.apimachinery.pkg.apis.meta.v1.ListMetaR\x08metadata\x12j\n\x05\
    items\x18\x02\x20\x03(\x0b2T.ssd_git.juniper.net.contrail.cn2.contrail.p\
    kg.apis.core.v1alpha1.GlobalSystemConfigR\x05items\"\xb4\x03\n\x16Global\
    SystemConfigSpec\x12l\n\ncommonSpec\x18\x01\x20\x01(\x0b2L.ssd_git.junip\
    er.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonSpecR\ncommonS\
    pec\x12&\n\x0eenable4bytesAS\x18\x02\x20\x01(\x08R\x0eenable4bytesAS\x12\
    *\n\x10autonomousSystem\x18\x03\x20\x01(\x05R\x10autonomousSystem\x12\
    \x85\x01\n\x13bgpRouterReferences\x18\x04\x20\x03(\x0b2S.ssd_git.juniper\
    .net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ResourceReferenceR\x13\
    bgpRouterReferences\x12\"\n\x0cibgpAutoMesh\x18\x05\x20\x01(\x08R\x0cibg\
    pAutoMesh\x12,\n\x11defaultEnableSNAT\x18\x06\x20\x01(\x08R\x11defaultEn\
    ableSNAT\"\x8e\x01\n\x18GlobalSystemConfigStatus\x12r\n\x0ccommonStatus\
    \x18\x01\x20\x01(\x0b2N.ssd_git.juniper.net.contrail.cn2.contrail.pkg.ap\
    is.core.v1alpha1.CommonStatusR\x0ccommonStatus\"\xc7\x02\n\x13GlobalVrou\
    terConfig\x12L\n\x08metadata\x18\x01\x20\x01(\x0b20.k8s.io.apimachinery.\
    pkg.apis.meta.v1.ObjectMetaR\x08metadata\x12m\n\x04spec\x18\x02\x20\x01(\
    \x0b2Y.ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.\
    GlobalVrouterConfigSpecR\x04spec\x12s\n\x06status\x18\x03\x20\x01(\x0b2[\
    .ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.Global\
    VrouterConfigStatusR\x06status\"\xd2\x01\n\x17GlobalVrouterConfigList\
    \x12J\n\x08metadata\x18\x01\x20\x01(\x0b2..k8s.io.apimachinery.pkg.apis.\
    meta.v1.ListMetaR\x08metadata\x12k\n\x05items\x18\x02\x20\x03(\x0b2U.ssd\
    _git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.GlobalVrou\
    terConfigR\x05items\"\x93\x05\n\x17GlobalVrouterConfigSpec\x12l\n\ncommo\
    nSpec\x18\x01\x20\x01(\x0b2L.ssd_git.juniper.net.contrail.cn2.contrail.p\
    kg.apis.core.v1alpha1.CommonSpecR\ncommonSpec\x12;\n\x06parent\x18\x02\
    \x20\x01(\x0b2#.k8s.io.api.core.v1.ObjectReferenceR\x06parent\x12\x93\
    \x01\n\x17encapsulationPriorities\x18\x03\x20\x01(\x0b2Y.ssd_git.juniper\
    .net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.EncapsulationPrioritie\
    sR\x17encapsulationPriorities\x12\x81\x01\n\x11linklocalServices\x18\x04\
    \x20\x01(\x0b2S.ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.\
    v1alpha1.LinklocalServicesR\x11linklocalServices\x12\x8a\x01\n\x14portTr\
    anslationPools\x18\x05\x20\x01(\x0b2V.ssd_git.juniper.net.contrail.cn2.c\
    ontrail.pkg.apis.core.v1alpha1.PortTranslationPoolsR\x14portTranslationP\
    ools\x12&\n\x0eflowExportRate\x18\x06\x20\x01(\x05R\x0eflowExportRate\"\
    \x8f\x01\n\x19GlobalVrouterConfigStatus\x12r\n\x0ccommonStatus\x18\x01\
    \x20\x01(\x0b2N.ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.\
    v1alpha1.CommonStatusR\x0ccommonStatus\"-\n\x07IPRange\x12\x12\n\x04from\
    \x18\x01\x20\x01(\tR\x04from\x12\x0e\n\x02to\x18\x02\x20\x01(\tR\x02to\"\
    \xb0\x01\n\x1aImportVirtualNetworkRouter\x12\x91\x01\n\x15virtualNetwork\
    Routers\x18\x01\x20\x03(\x0b2[.ssd_git.juniper.net.contrail.cn2.contrail\
    .pkg.apis.core.v1alpha1.VirtualNetworkRouterEntryR\x15virtualNetworkRout\
    ers\"\xac\x02\n\nInstanceIP\x12L\n\x08metadata\x18\x01\x20\x01(\x0b20.k8\
    s.io.apimachinery.pkg.apis.meta.v1.ObjectMetaR\x08metadata\x12d\n\x04spe\
    c\x18\x02\x20\x01(\x0b2P.ssd_git.juniper.net.contrail.cn2.contrail.pkg.a\
    pis.core.v1alpha1.InstanceIPSpecR\x04spec\x12j\n\x06status\x18\x03\x20\
    \x01(\x0b2R.ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1al\
    pha1.InstanceIPStatusR\x06status\"\xc0\x01\n\x0eInstanceIPList\x12J\n\
    \x08metadata\x18\x01\x20\x01(\x0b2..k8s.io.apimachinery.pkg.apis.meta.v1\
    .ListMetaR\x08metadata\x12b\n\x05items\x18\x02\x20\x03(\x0b2L.ssd_git.ju\
    niper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.InstanceIPR\x05it\
    ems\"\xc2\x04\n\x0eInstanceIPSpec\x12l\n\ncommonSpec\x18\x01\x20\x01(\
    \x0b2L.ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.\
    CommonSpecR\ncommonSpec\x12,\n\x11instanceIPAddress\x18\x02\x20\x01(\tR\
    \x11instanceIPAddress\x12*\n\x10instanceIPFamily\x18\x03\x20\x01(\tR\x10\
    instanceIPFamily\x12\x12\n\x04cidr\x18\x04\x20\x01(\tR\x04cidr\x12\x8d\
    \x01\n\x17virtualNetworkReference\x18\x05\x20\x01(\x0b2S.ssd_git.juniper\
    .net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ResourceReferenceR\x17\
    virtualNetworkReference\x12\xa1\x01\n!virtualMachineInterfaceReferences\
    \x18\x06\x20\x03(\x0b2S.ssd_git.juniper.net.contrail.cn2.contrail.pkg.ap\
    is.core.v1alpha1.ResourceReferenceR!virtualMachineInterfaceReferences\
    \x12\x20\n\x0bipRangeKeys\x18\x07\x20\x03(\tR\x0bipRangeKeys\"\x85\x02\n\
    \x10InstanceIPStatus\x12r\n\x0ccommonStatus\x18\x01\x20\x01(\x0b2N.ssd_g\
    it.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonStatus\
    R\x0ccommonStatus\x12}\n\x0fsubnetReference\x18\x02\x20\x01(\x0b2S.ssd_g\
    it.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ResourceRefe\
    renceR\x0fsubnetReference\"\xcb\x02\n\x19LinklocalServiceEntryType\x126\
    \n\x16ipFabricDNSServiceName\x18\x01\x20\x01(\tR\x16ipFabricDNSServiceNa\
    me\x12,\n\x11ipFabricServiceIP\x18\x02\x20\x03(\tR\x11ipFabricServiceIP\
    \x120\n\x13ipFabricServicePort\x18\x03\x20\x01(\x05R\x13ipFabricServiceP\
    ort\x12.\n\x12linklocalServiceIP\x18\x04\x20\x01(\tR\x12linklocalService\
    IP\x122\n\x14linklocalServiceName\x18\x05\x20\x01(\tR\x14linklocalServic\
    eName\x122\n\x14linklocalServicePort\x18\x06\x20\x01(\x05R\x14linklocalS\
    ervicePort\"\xa7\x01\n\x11LinklocalServices\x12\x91\x01\n\x15linklocalSe\
    rviceEntry\x18\x01\x20\x03(\x0b2[.ssd_git.juniper.net.contrail.cn2.contr\
    ail.pkg.apis.core.v1alpha1.LinklocalServiceEntryTypeR\x15linklocalServic\
    eEntry\".\n\x0cMACAddresses\x12\x1e\n\nmacAddress\x18\x01\x20\x03(\tR\nm\
    acAddress\"9\n\x19PolicyBasedForwardingRule\x12\x1c\n\tdirection\x18\x01\
    \x20\x01(\tR\tdirection\"C\n\tPortRange\x12\x1c\n\tstartPort\x18\x01\x20\
    \x01(\x05R\tstartPort\x12\x18\n\x07endPort\x18\x02\x20\x01(\x05R\x07endP\
    ort\"\xba\x01\n\x13PortTranslationPool\x12\x1a\n\x08protocol\x18\x01\x20\
    \x01(\tR\x08protocol\x12i\n\tportRange\x18\x02\x20\x01(\x0b2K.ssd_git.ju\
    niper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.PortRangeR\tportR\
    ange\x12\x1c\n\tportCount\x18\x03\x20\x01(\x05R\tportCount\"\x83\x01\n\
    \x14PortTranslationPools\x12k\n\x05pools\x18\x01\x20\x03(\x0b2U.ssd_git.\
    juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.PortTranslation\
    PoolR\x05pools\"B\n\x08PortType\x12\x1c\n\tstartPort\x18\x01\x20\x01(\
    \x03R\tstartPort\x12\x18\n\x07endPort\x18\x02\x20\x01(\x03R\x07endPort\"\
    \x80\x01\n\x05Range\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12e\n\
    \x08ipRanges\x18\x02\x20\x03(\x0b2I.ssd_git.juniper.net.contrail.cn2.con\
    trail.pkg.apis.core.v1alpha1.IPRangeR\x08ipRanges\"I\n\x0fReconcilerStat\
    e\x12\x14\n\x05state\x18\x01\x20\x01(\tR\x05state\x12\x20\n\x0bobservati\
    on\x18\x02\x20\x01(\tR\x0bobservation\"\xdc\x01\n\x11ResourceReference\
    \x12M\n\x0fobjectReference\x18\x01\x20\x01(\x0b2#.k8s.io.api.core.v1.Obj\
    ectReferenceR\x0fobjectReference\x12x\n\x0econtrailFqName\x18\x02\x20\
    \x01(\x0b2P.ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1al\
    pha1.ContrailFqNameR\x0econtrailFqName\"U\n\x13RouteOriginOverride\x12&\
    \n\x0eoriginOverride\x18\x01\x20\x01(\x08R\x0eoriginOverride\x12\x16\n\
    \x06origin\x18\x02\x20\x01(\tR\x06origin\"\xaf\x02\n\x0bRouteTarget\x12L\
    \n\x08metadata\x18\x01\x20\x01(\x0b20.k8s.io.apimachinery.pkg.apis.meta.\
    v1.ObjectMetaR\x08metadata\x12e\n\x04spec\x18\x02\x20\x01(\x0b2Q.ssd_git\
    .juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RouteTargetSpe\
    cR\x04spec\x12k\n\x06status\x18\x03\x20\x01(\x0b2S.ssd_git.juniper.net.c\
    ontrail.cn2.contrail.pkg.apis.core.v1alpha1.RouteTargetStatusR\x06status\
    \"\xc2\x01\n\x0fRouteTargetList\x12J\n\x08metadata\x18\x01\x20\x01(\x0b2\
    ..k8s.io.apimachinery.pkg.apis.meta.v1.ListMetaR\x08metadata\x12c\n\x05i\
    tems\x18\x02\x20\x03(\x0b2M.ssd_git.juniper.net.contrail.cn2.contrail.pk\
    g.apis.core.v1alpha1.RouteTargetR\x05items\"\x9d\x02\n\x14RouteTargetRef\
    erence\x12\x81\x01\n\x11resourceReference\x18\x01\x20\x01(\x0b2S.ssd_git\
    .juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ResourceRefere\
    nceR\x11resourceReference\x12\x80\x01\n\nattributes\x18\x02\x20\x01(\x0b\
    2`.ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.Rout\
    eTargetReferenceAttributesR\nattributes\"D\n\x1eRouteTargetReferenceAttr\
    ibutes\x12\"\n\x0cimportExport\x18\x01\x20\x01(\tR\x0cimportExport\"\x7f\
    \n\x0fRouteTargetSpec\x12l\n\ncommonSpec\x18\x01\x20\x01(\x0b2L.ssd_git.\
    juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonSpecR\nco\
    mmonSpec\"\x87\x01\n\x11RouteTargetStatus\x12r\n\x0ccommonStatus\x18\x01\
    \x20\x01(\x0b2N.ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.\
    v1alpha1.CommonStatusR\x0ccommonStatus\"\xbb\x02\n\x0fRoutingInstance\
    \x12L\n\x08metadata\x18\x01\x20\x01(\x0b20.k8s.io.apimachinery.pkg.apis.\
    meta.v1.ObjectMetaR\x08metadata\x12i\n\x04spec\x18\x02\x20\x01(\x0b2U.ss\
    d_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RoutingIn\
    stanceSpecR\x04spec\x12o\n\x06status\x18\x03\x20\x01(\x0b2W.ssd_git.juni\
    per.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RoutingInstanceStat\
    usR\x06status\"\xca\x01\n\x13RoutingInstanceList\x12J\n\x08metadata\x18\
    \x01\x20\x01(\x0b2..k8s.io.apimachinery.pkg.apis.meta.v1.ListMetaR\x08me\
    tadata\x12g\n\x05items\x18\x02\x20\x03(\x0b2Q.ssd_git.juniper.net.contra\
    il.cn2.contrail.pkg.apis.core.v1alpha1.RoutingInstanceR\x05items\"\x9b\
    \x02\n\x18RoutingInstanceReference\x12\x81\x01\n\x11resourceReference\
    \x18\x01\x20\x01(\x0b2S.ssd_git.juniper.net.contrail.cn2.contrail.pkg.ap\
    is.core.v1alpha1.ResourceReferenceR\x11resourceReference\x12{\n\nattribu\
    tes\x18\x02\x20\x01(\x0b2[.ssd_git.juniper.net.contrail.cn2.contrail.pkg\
    .apis.core.v1alpha1.PolicyBasedForwardingRuleR\nattributes\"\xcf\x02\n\
    \x13RoutingInstanceSpec\x12l\n\ncommonSpec\x18\x01\x20\x01(\x0b2L.ssd_gi\
    t.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonSpecR\n\
    commonSpec\x12;\n\x06parent\x18\x02\x20\x01(\x0b2#.k8s.io.api.core.v1.Ob\
    jectReferenceR\x06parent\x12\x8c\x01\n\x15routeTargetReferences\x18\x03\
    \x20\x03(\x0b2V.ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.\
    v1alpha1.RouteTargetReferenceR\x15routeTargetReferences\"\xb3\x06\n\x15R\
    outingInstanceStatus\x12r\n\x0ccommonStatus\x18\x01\x20\x01(\x0b2N.ssd_g\
    it.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonStatus\
    R\x0ccommonStatus\x12\x1c\n\tisDefault\x18\x02\x20\x01(\x08R\tisDefault\
    \x12<\n\x19routingInstanceFabricSNAT\x18\x03\x20\x01(\x08R\x19routingIns\
    tanceFabricSNAT\x12\x98\x01\n\x1bdefaultRouteTargetReference\x18\x04\x20\
    \x01(\x0b2V.ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1al\
    pha1.RouteTargetReferenceR\x1bdefaultRouteTargetReference\x12\xe5\x01\n)\
    virtualNetworkRouterRouteTargetReferences\x18\x05\x20\x03(\x0b2\x86\x01.\
    ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.Routing\
    InstanceStatus.VirtualNetworkRouterRouteTargetReferencesEntryR)virtualNe\
    tworkRouterRouteTargetReferences\x1a\xc6\x01\n.VirtualNetworkRouterRoute\
    TargetReferencesEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12~\n\
    \x05value\x18\x02\x20\x01(\x0b2h.ssd_git.juniper.net.contrail.cn2.contra\
    il.pkg.apis.core.v1alpha1.VirtualNetworkRouteTargetReferenceListR\x05val\
    ue:\x028\x01\"\xa0\x02\n\x06Subnet\x12L\n\x08metadata\x18\x01\x20\x01(\
    \x0b20.k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMetaR\x08metadata\x12`\
    \n\x04spec\x18\x02\x20\x01(\x0b2L.ssd_git.juniper.net.contrail.cn2.contr\
    ail.pkg.apis.core.v1alpha1.SubnetSpecR\x04spec\x12f\n\x06status\x18\x03\
    \x20\x01(\x0b2N.ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.\
    v1alpha1.SubnetStatusR\x06status\"\xb8\x01\n\nSubnetList\x12J\n\x08metad\
    ata\x18\x01\x20\x01(\x0b2..k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta\
    R\x08metadata\x12^\n\x05items\x18\x02\x20\x03(\x0b2H.ssd_git.juniper.net\
    .contrail.cn2.contrail.pkg.apis.core.v1alpha1.SubnetR\x05items\"\x8f\x02\
    \n\x0fSubnetReference\x12\x81\x01\n\x11resourceReference\x18\x01\x20\x01\
    (\x0b2S.ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1\
    .ResourceReferenceR\x11resourceReference\x12x\n\nattributes\x18\x02\x20\
    \x01(\x0b2X.ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1al\
    pha1.BGPSessionIPAttributesR\nattributes\"\xdd\x03\n\nSubnetSpec\x12l\n\
    \ncommonSpec\x18\x01\x20\x01(\x0b2L.ssd_git.juniper.net.contrail.cn2.con\
    trail.pkg.apis.core.v1alpha1.CommonSpecR\ncommonSpec\x12\x12\n\x04cidr\
    \x18\x03\x20\x01(\tR\x04cidr\x12&\n\x0edefaultGateway\x18\x04\x20\x01(\t\
    R\x0edefaultGateway\x12&\n\x0ednsNameservers\x18\x05\x20\x03(\tR\x0ednsN\
    ameservers\x12_\n\x06ranges\x18\x06\x20\x03(\x0b2G.ssd_git.juniper.net.c\
    ontrail.cn2.contrail.pkg.apis.core.v1alpha1.RangeR\x06ranges\x12D\n\x1dd\
    isableBGPaaSIPAutoAllocation\x18\x07\x20\x01(\x08R\x1ddisableBGPaaSIPAut\
    oAllocation\x12(\n\x0fbgpaasPrimaryIP\x18\x08\x20\x01(\tR\x0fbgpaasPrima\
    ryIP\x12,\n\x11bgpaasSecondaryIP\x18\t\x20\x01(\tR\x11bgpaasSecondaryIP\
    \"\xc6\x01\n\x0cSubnetStatus\x12r\n\x0ccommonStatus\x18\x01\x20\x01(\x0b\
    2N.ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.Comm\
    onStatusR\x0ccommonStatus\x12\x18\n\x07ipCount\x18\x02\x20\x01(\x03R\x07\
    ipCount\x12(\n\x0fallocationUsage\x18\x03\x20\x01(\tR\x0fallocationUsage\
    \"\x97\x02\n\x03Tag\x12L\n\x08metadata\x18\x01\x20\x01(\x0b20.k8s.io.api\
    machinery.pkg.apis.meta.v1.ObjectMetaR\x08metadata\x12]\n\x04spec\x18\
    \x02\x20\x01(\x0b2I.ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.c\
    ore.v1alpha1.TagSpecR\x04spec\x12c\n\x06status\x18\x03\x20\x01(\x0b2K.ss\
    d_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagStatus\
    R\x06status\"\xb2\x01\n\x07TagList\x12J\n\x08metadata\x18\x01\x20\x01(\
    \x0b2..k8s.io.apimachinery.pkg.apis.meta.v1.ListMetaR\x08metadata\x12[\n\
    \x05items\x18\x02\x20\x03(\x0b2E.ssd_git.juniper.net.contrail.cn2.contra\
    il.pkg.apis.core.v1alpha1.TagR\x05items\"\xb6\x02\n\x07TagSpec\x12l\n\nc\
    ommonSpec\x18\x01\x20\x01(\x0b2L.ssd_git.juniper.net.contrail.cn2.contra\
    il.pkg.apis.core.v1alpha1.CommonSpecR\ncommonSpec\x12\x20\n\x0btagTypeNa\
    me\x18\x02\x20\x01(\tR\x0btagTypeName\x12\x1a\n\x08tagValue\x18\x03\x20\
    \x01(\tR\x08tagValue\x12\x7f\n\x10tagTypeReference\x18\x04\x20\x01(\x0b2\
    S.ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.Resou\
    rceReferenceR\x10tagTypeReference\"\x95\x01\n\tTagStatus\x12r\n\x0ccommo\
    nStatus\x18\x01\x20\x01(\x0b2N.ssd_git.juniper.net.contrail.cn2.contrail\
    .pkg.apis.core.v1alpha1.CommonStatusR\x0ccommonStatus\x12\x14\n\x05tagId\
    \x18\x02\x20\x01(\tR\x05tagId\"\xa3\x02\n\x07TagType\x12L\n\x08metadata\
    \x18\x01\x20\x01(\x0b20.k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMetaR\
    \x08metadata\x12a\n\x04spec\x18\x02\x20\x01(\x0b2M.ssd_git.juniper.net.c\
    ontrail.cn2.contrail.pkg.apis.core.v1alpha1.TagTypeSpecR\x04spec\x12g\n\
    \x06status\x18\x03\x20\x01(\x0b2O.ssd_git.juniper.net.contrail.cn2.contr\
    ail.pkg.apis.core.v1alpha1.TagTypeStatusR\x06status\"\xba\x01\n\x0bTagTy\
    peList\x12J\n\x08metadata\x18\x01\x20\x01(\x0b2..k8s.io.apimachinery.pkg\
    .apis.meta.v1.ListMetaR\x08metadata\x12_\n\x05items\x18\x02\x20\x03(\x0b\
    2I.ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.TagT\
    ypeR\x05items\"{\n\x0bTagTypeSpec\x12l\n\ncommonSpec\x18\x01\x20\x01(\
    \x0b2L.ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.\
    CommonSpecR\ncommonSpec\"\xa1\x01\n\rTagTypeStatus\x12r\n\x0ccommonStatu\
    s\x18\x01\x20\x01(\x0b2N.ssd_git.juniper.net.contrail.cn2.contrail.pkg.a\
    pis.core.v1alpha1.CommonStatusR\x0ccommonStatus\x12\x1c\n\ttagTypeId\x18\
    \x02\x20\x01(\tR\ttagTypeId\"\xb8\x02\n\x0eVirtualMachine\x12L\n\x08meta\
    data\x18\x01\x20\x01(\x0b20.k8s.io.apimachinery.pkg.apis.meta.v1.ObjectM\
    etaR\x08metadata\x12h\n\x04spec\x18\x02\x20\x01(\x0b2T.ssd_git.juniper.n\
    et.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineSpecR\x04s\
    pec\x12n\n\x06status\x18\x03\x20\x01(\x0b2V.ssd_git.juniper.net.contrail\
    .cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineStatusR\x06status\"\
    \xd3\x02\n\x17VirtualMachineInterface\x12L\n\x08metadata\x18\x01\x20\x01\
    (\x0b20.k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMetaR\x08metadata\x12\
    q\n\x04spec\x18\x02\x20\x01(\x0b2].ssd_git.juniper.net.contrail.cn2.cont\
    rail.pkg.apis.core.v1alpha1.VirtualMachineInterfaceSpecR\x04spec\x12w\n\
    \x06status\x18\x03\x20\x01(\x0b2_.ssd_git.juniper.net.contrail.cn2.contr\
    ail.pkg.apis.core.v1alpha1.VirtualMachineInterfaceStatusR\x06status\"\
    \xda\x01\n\x1bVirtualMachineInterfaceList\x12J\n\x08metadata\x18\x01\x20\
    \x01(\x0b2..k8s.io.apimachinery.pkg.apis.meta.v1.ListMetaR\x08metadata\
    \x12o\n\x05items\x18\x02\x20\x03(\x0b2Y.ssd_git.juniper.net.contrail.cn2\
    .contrail.pkg.apis.core.v1alpha1.VirtualMachineInterfaceR\x05items\"U\n!\
    VirtualMachineInterfaceProperties\x120\n\x13subInterfaceVlanTag\x18\x01\
    \x20\x01(\rR\x13subInterfaceVlanTag\"\xc2\n\n\x1bVirtualMachineInterface\
    Spec\x12l\n\ncommonSpec\x18\x01\x20\x01(\x0b2L.ssd_git.juniper.net.contr\
    ail.cn2.contrail.pkg.apis.core.v1alpha1.CommonSpecR\ncommonSpec\x12;\n\
    \x06parent\x18\x02\x20\x01(\x0b2#.k8s.io.api.core.v1.ObjectReferenceR\
    \x06parent\x12\xa0\x01\n#virtualMachineInterfaceMacAddresses\x18\x03\x20\
    \x01(\x0b2N.ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1al\
    pha1.MACAddressesR#virtualMachineInterfaceMacAddresses\x12\x8d\x01\n\x17\
    virtualNetworkReference\x18\x04\x20\x01(\x0b2S.ssd_git.juniper.net.contr\
    ail.cn2.contrail.pkg.apis.core.v1alpha1.ResourceReferenceR\x17virtualNet\
    workReference\x12\x8f\x01\n\x18virtualMachineReferences\x18\x05\x20\x03(\
    \x0b2S.ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.\
    ResourceReferenceR\x18virtualMachineReferences\x12R\n$virtualMachineInte\
    rfaceDisablePolicy\x18\x06\x20\x01(\x08R$virtualMachineInterfaceDisableP\
    olicy\x12\x87\x01\n\x13allowedAddressPairs\x18\x07\x20\x01(\x0b2U.ssd_gi\
    t.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.AllowedAddres\
    sPairsR\x13allowedAddressPairs\x120\n\x13portSecurityEnabled\x18\x08\x20\
    \x01(\x08R\x13portSecurityEnabled\x12\xa1\x01\n!virtualMachineInterfaceR\
    eferences\x18\t\x20\x03(\x0b2S.ssd_git.juniper.net.contrail.cn2.contrail\
    .pkg.apis.core.v1alpha1.ResourceReferenceR!virtualMachineInterfaceRefere\
    nces\x12\x83\x01\n\nproperties\x18\n\x20\x01(\x0b2c.ssd_git.juniper.net.\
    contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualMachineInterfaceProp\
    ertiesR\nproperties\x12y\n\rtagReferences\x18\x0b\x20\x03(\x0b2S.ssd_git\
    .juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ResourceRefere\
    nceR\rtagReferences\"\xb4\x03\n\x1dVirtualMachineInterfaceStatus\x12r\n\
    \x0ccommonStatus\x18\x01\x20\x01(\x0b2N.ssd_git.juniper.net.contrail.cn2\
    .contrail.pkg.apis.core.v1alpha1.CommonStatusR\x0ccommonStatus\x12\x98\
    \x01\n\x19routingInstanceReferences\x18\x03\x20\x03(\x0b2Z.ssd_git.junip\
    er.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.RoutingInstanceRefer\
    enceR\x19routingInstanceReferences\x12\x83\x01\n\x12bgpRouterReference\
    \x18\x04\x20\x01(\x0b2S.ssd_git.juniper.net.contrail.cn2.contrail.pkg.ap\
    is.core.v1alpha1.ResourceReferenceR\x12bgpRouterReference\"\xc8\x01\n\
    \x12VirtualMachineList\x12J\n\x08metadata\x18\x01\x20\x01(\x0b2..k8s.io.\
    apimachinery.pkg.apis.meta.v1.ListMetaR\x08metadata\x12f\n\x05items\x18\
    \x02\x20\x03(\x0b2P.ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.c\
    ore.v1alpha1.VirtualMachineR\x05items\"\x9a\x02\n\x12VirtualMachineSpec\
    \x12l\n\ncommonSpec\x18\x01\x20\x01(\x0b2L.ssd_git.juniper.net.contrail.\
    cn2.contrail.pkg.apis.core.v1alpha1.CommonSpecR\ncommonSpec\x12\x1e\n\ns\
    erverType\x18\x02\x20\x01(\tR\nserverType\x12\x1e\n\nserverName\x18\x03\
    \x20\x01(\tR\nserverName\x12(\n\x0fserverNamespace\x18\x04\x20\x01(\tR\
    \x0fserverNamespace\x12,\n\x11serverClusterName\x18\x05\x20\x01(\tR\x11s\
    erverClusterName\"\x8a\x01\n\x14VirtualMachineStatus\x12r\n\x0ccommonSta\
    tus\x18\x01\x20\x01(\x0b2N.ssd_git.juniper.net.contrail.cn2.contrail.pkg\
    .apis.core.v1alpha1.CommonStatusR\x0ccommonStatus\"\xb8\x02\n\x0eVirtual\
    Network\x12L\n\x08metadata\x18\x01\x20\x01(\x0b20.k8s.io.apimachinery.pk\
    g.apis.meta.v1.ObjectMetaR\x08metadata\x12h\n\x04spec\x18\x02\x20\x01(\
    \x0b2T.ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.\
    VirtualNetworkSpecR\x04spec\x12n\n\x06status\x18\x03\x20\x01(\x0b2V.ssd_\
    git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetw\
    orkStatusR\x06status\"\xc8\x01\n\x12VirtualNetworkList\x12J\n\x08metadat\
    a\x18\x01\x20\x01(\x0b2..k8s.io.apimachinery.pkg.apis.meta.v1.ListMetaR\
    \x08metadata\x12f\n\x05items\x18\x02\x20\x03(\x0b2P.ssd_git.juniper.net.\
    contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkR\x05items\"\
    \xb7\x01\n&VirtualNetworkRouteTargetReferenceList\x12\x8c\x01\n\x15route\
    TargetReferences\x18\x01\x20\x03(\x0b2V.ssd_git.juniper.net.contrail.cn2\
    .contrail.pkg.apis.core.v1alpha1.RouteTargetReferenceR\x15routeTargetRef\
    erences\"\xca\x02\n\x14VirtualNetworkRouter\x12L\n\x08metadata\x18\x01\
    \x20\x01(\x0b20.k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMetaR\x08meta\
    data\x12n\n\x04spec\x18\x02\x20\x01(\x0b2Z.ssd_git.juniper.net.contrail.\
    cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkRouterSpecR\x04spec\
    \x12t\n\x06status\x18\x03\x20\x01(\x0b2\\.ssd_git.juniper.net.contrail.c\
    n2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkRouterStatusR\x06status\
    \"\xf7\x01\n\x19VirtualNetworkRouterEntry\x12w\n\x1cvirtualNetworkRouter\
    Selector\x18\x01\x20\x01(\x0b23.k8s.io.apimachinery.pkg.apis.meta.v1.Lab\
    elSelectorR\x1cvirtualNetworkRouterSelector\x12a\n\x11namespaceSelector\
    \x18\x02\x20\x01(\x0b23.k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelect\
    orR\x11namespaceSelector\"\xd4\x01\n\x18VirtualNetworkRouterList\x12J\n\
    \x08metadata\x18\x01\x20\x01(\x0b2..k8s.io.apimachinery.pkg.apis.meta.v1\
    .ListMetaR\x08metadata\x12l\n\x05items\x18\x02\x20\x03(\x0b2V.ssd_git.ju\
    niper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualNetworkRou\
    terR\x05items\"\xff\x02\n\x18VirtualNetworkRouterSpec\x12l\n\ncommonSpec\
    \x18\x01\x20\x01(\x0b2L.ssd_git.juniper.net.contrail.cn2.contrail.pkg.ap\
    is.core.v1alpha1.CommonSpecR\ncommonSpec\x12\x12\n\x04type\x18\x02\x20\
    \x01(\tR\x04type\x12k\n\x16virtualNetworkSelector\x18\x03\x20\x01(\x0b23\
    .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelectorR\x16virtualNetworkSe\
    lector\x12t\n\x06import\x18\x04\x20\x01(\x0b2\\.ssd_git.juniper.net.cont\
    rail.cn2.contrail.pkg.apis.core.v1alpha1.ImportVirtualNetworkRouterR\x06\
    import\"\x90\x01\n\x1aVirtualNetworkRouterStatus\x12r\n\x0ccommonStatus\
    \x18\x01\x20\x01(\x0b2N.ssd_git.juniper.net.contrail.cn2.contrail.pkg.ap\
    is.core.v1alpha1.CommonStatusR\x0ccommonStatus\"\xbf\x07\n\x12VirtualNet\
    workSpec\x12l\n\ncommonSpec\x18\x01\x20\x01(\x0b2L.ssd_git.juniper.net.c\
    ontrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonSpecR\ncommonSpec\x12\
    \x1e\n\nfabricSNAT\x18\x02\x20\x01(\x08R\nfabricSNAT\x12\x81\x01\n\x11v4\
    SubnetReference\x18\x03\x20\x01(\x0b2S.ssd_git.juniper.net.contrail.cn2.\
    contrail.pkg.apis.core.v1alpha1.ResourceReferenceR\x11v4SubnetReference\
    \x12\x81\x01\n\x11v6SubnetReference\x18\x04\x20\x01(\x0b2S.ssd_git.junip\
    er.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.ResourceReferenceR\
    \x11v6SubnetReference\x12(\n\x0frouteTargetList\x18\x05\x20\x03(\tR\x0fr\
    outeTargetList\x124\n\x15importRouteTargetList\x18\x06\x20\x03(\tR\x15im\
    portRouteTargetList\x124\n\x15exportRouteTargetList\x18\x07\x20\x03(\tR\
    \x15exportRouteTargetList\x12\x90\x01\n\x18virtualNetworkProperties\x18\
    \x08\x20\x01(\x0b2T.ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.c\
    ore.v1alpha1.VirtualNetworkTypeR\x18virtualNetworkProperties\x12\x8f\x01\
    \n\x18providerNetworkReference\x18\t\x20\x01(\x0b2S.ssd_git.juniper.net.\
    contrail.cn2.contrail.pkg.apis.core.v1alpha1.ResourceReferenceR\x18provi\
    derNetworkReference\x12,\n\x11isProviderNetwork\x18\n\x20\x01(\x08R\x11i\
    sProviderNetwork\x12*\n\x10fabricForwarding\x18\x0b\x20\x01(\x08R\x10fab\
    ricForwarding\"\xc4\x01\n\x14VirtualNetworkStatus\x12r\n\x0ccommonStatus\
    \x18\x01\x20\x01(\x0b2N.ssd_git.juniper.net.contrail.cn2.contrail.pkg.ap\
    is.core.v1alpha1.CommonStatusR\x0ccommonStatus\x128\n\x17virtualNetworkN\
    etworkId\x18\x02\x20\x01(\x03R\x17virtualNetworkNetworkId\"N\n\x12Virtua\
    lNetworkType\x12\x10\n\x03rpf\x18\x01\x20\x01(\tR\x03rpf\x12&\n\x0eforwa\
    rdingMode\x18\x02\x20\x01(\tR\x0eforwardingMode\"\xb5\x02\n\rVirtualRout\
    er\x12L\n\x08metadata\x18\x01\x20\x01(\x0b20.k8s.io.apimachinery.pkg.api\
    s.meta.v1.ObjectMetaR\x08metadata\x12g\n\x04spec\x18\x02\x20\x01(\x0b2S.\
    ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.Virtual\
    RouterSpecR\x04spec\x12m\n\x06status\x18\x03\x20\x01(\x0b2U.ssd_git.juni\
    per.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.VirtualRouterStatus\
    R\x06status\"\xc6\x01\n\x11VirtualRouterList\x12J\n\x08metadata\x18\x01\
    \x20\x01(\x0b2..k8s.io.apimachinery.pkg.apis.meta.v1.ListMetaR\x08metada\
    ta\x12e\n\x05items\x18\x02\x20\x03(\x0b2O.ssd_git.juniper.net.contrail.c\
    n2.contrail.pkg.apis.core.v1alpha1.VirtualRouterR\x05items\"\xf2\x03\n\
    \x11VirtualRouterSpec\x12l\n\ncommonSpec\x18\x01\x20\x01(\x0b2L.ssd_git.\
    juniper.net.contrail.cn2.contrail.pkg.apis.core.v1alpha1.CommonSpecR\nco\
    mmonSpec\x12;\n\x06parent\x18\x02\x20\x01(\x0b2#.k8s.io.api.core.v1.Obje\
    ctReferenceR\x06parent\x12:\n\x18virtualRouterDpdkEnabled\x18\x03\x20\
    \x01(\x08R\x18virtualRouterDpdkEnabled\x126\n\x16virtualRouterIPAddress\
    \x18\x04\x20\x01(\tR\x16virtualRouterIPAddress\x12,\n\x11virtualRouterTy\
    pe\x18\x05\x20\x01(\tR\x11virtualRouterType\x12\x8f\x01\n\x18virtualMach\
    ineReferences\x18\x06\x20\x03(\x0b2S.ssd_git.juniper.net.contrail.cn2.co\
    ntrail.pkg.apis.core.v1alpha1.ResourceReferenceR\x18virtualMachineRefere\
    nces\"\x89\x01\n\x13VirtualRouterStatus\x12r\n\x0ccommonStatus\x18\x01\
    \x20\x01(\x0b2N.ssd_git.juniper.net.contrail.cn2.contrail.pkg.apis.core.\
    v1alpha1.CommonStatusR\x0ccommonStatusB\nZ\x08v1alpha1J\x8d\x94\x05\n\
    \x07\x12\x05\x11\0\x98\x10\x01\n\x81\x05\n\x01\x0c\x12\x03\x11\0\x122\
    \xab\x04\nCopyright\x202020\x20Juniper\x20Networks.\n\nLicensed\x20under\
    \x20the\x20Apache\x20License,\x20Version\x202.0\x20(the\x20\"License\");\
    \nyou\x20may\x20not\x20use\x20this\x20file\x20except\x20in\x20compliance\
    \x20with\x20the\x20License.\nYou\x20may\x20obtain\x20a\x20copy\x20of\x20\
    the\x20License\x20at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUn\
    less\x20required\x20by\x20applicable\x20law\x20or\x20agreed\x20to\x20in\
    \x20writing,\x20software\ndistributed\x20under\x20the\x20License\x20is\
    \x20distributed\x20on\x20an\x20\"AS\x20IS\"\x20BASIS,\nWITHOUT\x20WARRAN\
    TIES\x20OR\x20CONDITIONS\x20OF\x20ANY\x20KIND,\x20either\x20express\x20o\
    r\x20implied.\nSee\x20the\x20License\x20for\x20the\x20specific\x20langua\
    ge\x20governing\x20permissions\x20and\nlimitations\x20under\x20the\x20Li\
    cense.\n2I\x20This\x20file\x20was\x20autogenerated\x20by\x20go-to-protob\
    uf.\x20Do\x20not\x20edit\x20it\x20manually!\n\n\x08\n\x01\x02\x12\x03\
    \x13\x08H\n\t\n\x02\x03\0\x12\x03\x15\x07+\n\t\n\x02\x03\x01\x12\x03\x16\
    \x078\n\t\n\x02\x03\x02\x12\x03\x17\x078\n\t\n\x02\x03\x03\x12\x03\x18\
    \x07?\n\t\n\x02\x03\x04\x12\x03\x19\x07<\n\t\n\x02\x03\x05\x12\x03\x1a\
    \x07j\n\x08\n\x01\x08\x12\x03\x1d\0\x1f\nA\n\x04\x08\xe7\x07\0\x12\x03\
    \x1d\0\x1f\x1a4\x20Package-wide\x20variables\x20from\x20generator\x20\"g\
    enerated\".\n\n\x0c\n\x05\x08\xe7\x07\0\x02\x12\x03\x1d\x07\x11\n\r\n\
    \x06\x08\xe7\x07\0\x02\0\x12\x03\x1d\x07\x11\n\x0e\n\x07\x08\xe7\x07\0\
    \x02\0\x01\x12\x03\x1d\x07\x11\n\x0c\n\x05\x08\xe7\x07\0\x07\x12\x03\x1d\
    \x14\x1e\nm\n\x02\x04\0\x12\x04\x20\0#\x01\x1aa\x20APSAttribute\x20defin\
    es\x20the\x20sequence\x20number\x20associated\x20with\x20FireWall\x20Pol\
    icy\x20referred\x20by\x20given\x20APS.\n\n\n\n\x03\x04\0\x01\x12\x03\x20\
    \x08\x14\n2\n\x04\x04\0\x02\0\x12\x03\"\x02\x1f\x1a%\x20Sequence\x20numb\
    er\x20of\x20a\x20FireWallPolicy\n\n\x0c\n\x05\x04\0\x02\0\x04\x12\x03\"\
    \x02\n\n\x0c\n\x05\x04\0\x02\0\x05\x12\x03\"\x0b\x11\n\x0c\n\x05\x04\0\
    \x02\0\x01\x12\x03\"\x12\x1a\n\x0c\n\x05\x04\0\x02\0\x03\x12\x03\"\x1d\
    \x1e\n]\n\x02\x04\x01\x12\x04&\0)\x01\x1aQ\x20AddressFamilies\x20contain\
    s\x20a\x20list\x20of\x20BGP\x20address\x20families\x20supported\x20by\
    \x20BGP\x20router\n\n\n\n\x03\x04\x01\x01\x12\x03&\x08\x17\n;\n\x04\x04\
    \x01\x02\0\x12\x03(\x02\x1d\x1a.\x20BGP\x20address\x20families\x20suppor\
    ted\x20by\x20BGP\x20router\n\n\x0c\n\x05\x04\x01\x02\0\x04\x12\x03(\x02\
    \n\n\x0c\n\x05\x04\x01\x02\0\x05\x12\x03(\x0b\x11\n\x0c\n\x05\x04\x01\
    \x02\0\x01\x12\x03(\x12\x18\n\x0c\n\x05\x04\x01\x02\0\x03\x12\x03(\x1b\
    \x1c\n\xde\x01\n\x02\x04\x02\x12\x04.\0@\x01\x1a\xd1\x01\x20AddressGroup\
    \x20describes\x20the\x20set\x20of\x20CIDRs\x20associated\x20with\x20the\
    \x20FirewallRule\x20resource.\n\x20+k8s:openapi-gen=true\n\x20+resource:\
    path=addressgroups,strategy=AddressGroupStrategy,shortname=ag,categories\
    =contrail;security\n\n\n\n\x03\x04\x02\x01\x12\x03.\x08\x14\n\x9f\x01\n\
    \x04\x04\x02\x02\0\x12\x032\x02H\x1a\x91\x01\x20Standard\x20object's\x20\
    metadata.\n\x20More\x20info:\x20https://git.k8s.io/community/contributor\
    s/devel/sig-architecture/api-conventions.md#metadata\n\x20+optional\n\n\
    \x0c\n\x05\x04\x02\x02\0\x04\x12\x032\x02\n\n\x0c\n\x05\x04\x02\x02\0\
    \x06\x12\x032\x0b:\n\x0c\n\x05\x04\x02\x02\0\x01\x12\x032;C\n\x0c\n\x05\
    \x04\x02\x02\0\x03\x12\x032FG\n\xc2\x01\n\x04\x04\x02\x02\x01\x12\x037\
    \x02%\x1a\xb4\x01\x20Specification\x20of\x20the\x20desired\x20state\x20o\
    f\x20the\x20AddressGroup.\n\x20More\x20info:\x20https://git.k8s.io/commu\
    nity/contributors/devel/sig-architecture/api-conventions.md#spec-and-sta\
    tus\n\x20+optional\n\n\x0c\n\x05\x04\x02\x02\x01\x04\x12\x037\x02\n\n\
    \x0c\n\x05\x04\x02\x02\x01\x06\x12\x037\x0b\x1b\n\x0c\n\x05\x04\x02\x02\
    \x01\x01\x12\x037\x1c\x20\n\x0c\n\x05\x04\x02\x02\x01\x03\x12\x037#$\n\
    \x89\x02\n\x04\x04\x02\x02\x02\x12\x03?\x02)\x1a\xfb\x01\x20The\x20most\
    \x20recently\x20observed\x20status\x20of\x20the\x20AddressGroup.\n\x20Th\
    is\x20data\x20may\x20not\x20be\x20up-to-date.\n\x20Populated\x20by\x20th\
    e\x20system.\n\x20Read-only.\n\x20More\x20info:\x20https://git.k8s.io/co\
    mmunity/contributors/devel/sig-architecture/api-conventions.md#spec-and-\
    status\n\x20+optional\n\n\x0c\n\x05\x04\x02\x02\x02\x04\x12\x03?\x02\n\n\
    \x0c\n\x05\x04\x02\x02\x02\x06\x12\x03?\x0b\x1d\n\x0c\n\x05\x04\x02\x02\
    \x02\x01\x12\x03?\x1e$\n\x0c\n\x05\x04\x02\x02\x02\x03\x12\x03?'(\n9\n\
    \x02\x04\x03\x12\x04C\0K\x01\x1a-\x20AddressGroupList\x20is\x20a\x20list\
    \x20of\x20AddressGroup.\n\n\n\n\x03\x04\x03\x01\x12\x03C\x08\x18\n\xab\
    \x01\n\x04\x04\x03\x02\0\x12\x03G\x02F\x1a\x9d\x01\x20Standard\x20list's\
    \x20metadata.\n\x20More\x20info:\x20https://git.k8s.io/community/contrib\
    utors/devel/sig-architecture/api-conventions.md#lists-and-simple-kinds\n\
    \x20+optional\n\n\x0c\n\x05\x04\x03\x02\0\x04\x12\x03G\x02\n\n\x0c\n\x05\
    \x04\x03\x02\0\x06\x12\x03G\x0b8\n\x0c\n\x05\x04\x03\x02\0\x01\x12\x03G9\
    A\n\x0c\n\x05\x04\x03\x02\0\x03\x12\x03GDE\nX\n\x04\x04\x03\x02\x01\x12\
    \x03J\x02\"\x1aK\x20Items\x20contains\x20all\x20of\x20the\x20AddressGrou\
    p\x20instances\x20in\x20the\x20AddressGroupList.\n\n\x0c\n\x05\x04\x03\
    \x02\x01\x04\x12\x03J\x02\n\n\x0c\n\x05\x04\x03\x02\x01\x06\x12\x03J\x0b\
    \x17\n\x0c\n\x05\x04\x03\x02\x01\x01\x12\x03J\x18\x1d\n\x0c\n\x05\x04\
    \x03\x02\x01\x03\x12\x03J\x20!\nB\n\x02\x04\x04\x12\x04N\0Q\x01\x1a6\x20\
    AddressGroupPrefix\x20describes\x20the\x20CIDR\x20configuration.\n\n\n\n\
    \x03\x04\x04\x01\x12\x03N\x08\x1a\n7\n\x04\x04\x04\x02\0\x12\x03P\x02%\
    \x1a*\x20Subnet\x20defines\x20the\x20IP\x20prefix\x20and\x20length.\n\n\
    \x0c\n\x05\x04\x04\x02\0\x04\x12\x03P\x02\n\n\x0c\n\x05\x04\x04\x02\0\
    \x06\x12\x03P\x0b\x19\n\x0c\n\x05\x04\x04\x02\0\x01\x12\x03P\x1a\x20\n\
    \x0c\n\x05\x04\x04\x02\0\x03\x12\x03P#$\nd\n\x02\x04\x05\x12\x04T\0[\x01\
    \x1aX\x20AddressGroupSpec\x20describes\x20the\x20set\x20of\x20CIDRs\x20a\
    ssociated\x20with\x20the\x20FirewallRule\x20resource.\n\n\n\n\x03\x04\
    \x05\x01\x12\x03T\x08\x18\n!\n\x04\x04\x05\x02\0\x12\x03V\x02%\x1a\x14\
    \x20Common\x20spec\x20fields\n\n\x0c\n\x05\x04\x05\x02\0\x04\x12\x03V\
    \x02\n\n\x0c\n\x05\x04\x05\x02\0\x06\x12\x03V\x0b\x15\n\x0c\n\x05\x04\
    \x05\x02\0\x01\x12\x03V\x16\x20\n\x0c\n\x05\x04\x05\x02\0\x03\x12\x03V#$\
    \nj\n\x04\x04\x05\x02\x01\x12\x03Z\x027\x1a]\x20AddressGroupPrefixes\x20\
    defines\x20list\x20of\x20subnets\x20used\x20to\x20match\x20a\x20group\
    \x20of\x20workloads.\n\x20+optional\n\n\x0c\n\x05\x04\x05\x02\x01\x04\
    \x12\x03Z\x02\n\n\x0c\n\x05\x04\x05\x02\x01\x06\x12\x03Z\x0b\x1d\n\x0c\n\
    \x05\x04\x05\x02\x01\x01\x12\x03Z\x1e2\n\x0c\n\x05\x04\x05\x02\x01\x03\
    \x12\x03Z56\nL\n\x02\x04\x06\x12\x04^\0a\x01\x1a@\x20AddressGroupStatus\
    \x20defines\x20the\x20observed\x20state\x20of\x20AddressGroup.\n\n\n\n\
    \x03\x04\x06\x01\x12\x03^\x08\x1a\n#\n\x04\x04\x06\x02\0\x12\x03`\x02)\
    \x1a\x16\x20Common\x20status\x20fields\n\n\x0c\n\x05\x04\x06\x02\0\x04\
    \x12\x03`\x02\n\n\x0c\n\x05\x04\x06\x02\0\x06\x12\x03`\x0b\x17\n\x0c\n\
    \x05\x04\x06\x02\0\x01\x12\x03`\x18$\n\x0c\n\x05\x04\x06\x02\0\x03\x12\
    \x03`'(\n\xa3\x01\n\x02\x04\x07\x12\x04e\0r\x01\x1a\x96\x01\x20AllowedAd\
    dressPair\x20allows\x20the\x20additional\x20IP/MAC\x20pairs\x20to\x20the\
    \x20guest\n\x20interface.\x20The\x20traffic\x20matching\x20to\x20specifi\
    ed\x20value\x20of\x20IP/MAC\x20will\x20be\x20redirected.\n\n\n\n\x03\x04\
    \x07\x01\x12\x03e\x08\x1a\nQ\n\x04\x04\x07\x02\0\x12\x03h\x02+\x1aD\x20I\
    PAddress\x20defines\x20the\x20IPv4\x20or\x20IPv6\x20address\x20of\x20the\
    \x20pair.\n\x20+optional\n\n\x0c\n\x05\x04\x07\x02\0\x04\x12\x03h\x02\n\
    \n\x0c\n\x05\x04\x07\x02\0\x06\x12\x03h\x0b#\n\x0c\n\x05\x04\x07\x02\0\
    \x01\x12\x03h$&\n\x0c\n\x05\x04\x07\x02\0\x03\x12\x03h)*\nU\n\x04\x04\
    \x07\x02\x01\x12\x03l\x02\x1a\x1aH\x20MACAddress\x20defines\x20the\x20me\
    dia\x20access\x20control\x20ID\x20of\x20the\x20NIC..\n\x20+optional\n\n\
    \x0c\n\x05\x04\x07\x02\x01\x04\x12\x03l\x02\n\n\x0c\n\x05\x04\x07\x02\
    \x01\x05\x12\x03l\x0b\x11\n\x0c\n\x05\x04\x07\x02\x01\x01\x12\x03l\x12\
    \x15\n\x0c\n\x05\x04\x07\x02\x01\x03\x12\x03l\x18\x19\n{\n\x04\x04\x07\
    \x02\x02\x12\x03q\x02\"\x1an\x20AddressMode\x20active-standby\x20is\x20u\
    sed\x20for\x20VRRP\x20address.\n\x20AddressMode\x20active-active\x20is\
    \x20used\x20for\x20ECMP.\n\x20+optional\n\n\x0c\n\x05\x04\x07\x02\x02\
    \x04\x12\x03q\x02\n\n\x0c\n\x05\x04\x07\x02\x02\x05\x12\x03q\x0b\x11\n\
    \x0c\n\x05\x04\x07\x02\x02\x01\x12\x03q\x12\x1d\n\x0c\n\x05\x04\x07\x02\
    \x02\x03\x12\x03q\x20!\nH\n\x02\x04\x08\x12\x04u\0{\x01\x1a<\x20AllowedA\
    ddressPairSubnet\x20defines\x20the\x20IP\x20prefix\x20and\x20length.\n\n\
    \n\n\x03\x04\x08\x01\x12\x03u\x08\x20\n\x1d\n\x04\x04\x08\x02\0\x12\x03w\
    \x02\x1f\x1a\x10\x20Network\x20prefix\n\n\x0c\n\x05\x04\x08\x02\0\x04\
    \x12\x03w\x02\n\n\x0c\n\x05\x04\x08\x02\0\x05\x12\x03w\x0b\x11\n\x0c\n\
    \x05\x04\x08\x02\0\x01\x12\x03w\x12\x1a\n\x0c\n\x05\x04\x08\x02\0\x03\
    \x12\x03w\x1d\x1e\n$\n\x04\x04\x08\x02\x01\x12\x03z\x02K\x1a\x17\x20Netw\
    ork\x20prefix\x20length\n\n\x0c\n\x05\x04\x08\x02\x01\x04\x12\x03z\x02\n\
    \n\x0c\n\x05\x04\x08\x02\x01\x06\x12\x03z\x0b:\n\x0c\n\x05\x04\x08\x02\
    \x01\x01\x12\x03z;F\n\x0c\n\x05\x04\x08\x02\x01\x03\x12\x03zIJ\nC\n\x02\
    \x04\t\x12\x05~\0\x80\x01\x01\x1a6\x20AllowedAddressPairs\x20is\x20a\x20\
    list\x20of\x20AllowedAddressPair.\n\n\n\n\x03\x04\t\x01\x12\x03~\x08\x1b\
    \n\x0b\n\x04\x04\t\x02\0\x12\x03\x7f\x025\n\x0c\n\x05\x04\t\x02\0\x04\
    \x12\x03\x7f\x02\n\n\x0c\n\x05\x04\t\x02\0\x06\x12\x03\x7f\x0b\x1d\n\x0c\
    \n\x05\x04\t\x02\0\x01\x12\x03\x7f\x1e0\n\x0c\n\x05\x04\t\x02\0\x03\x12\
    \x03\x7f34\n\xf8\x02\n\x02\x04\n\x12\x06\x87\x01\0\x99\x01\x01\x1a\xe9\
    \x02\x20+genclient\n\x20+k8s:deepcopy-gen:interfaces=k8s.io/apimachinery\
    /pkg/runtime.Object\n\x20ApplicationPolicy\x20defines\x20set\x20of\x20fi\
    rewall\x20policies\x20belonging\x20to\x20a\x20given\x20application\x20ta\
    g\x20for\x20project/namespace\x20resources\x20(VN,\x20VM\x20or\x20VMI).\
    \n\x20+k8s:openapi-gen=true\n\x20+resource:path=applicationpolicysets,st\
    rategy=ApplicationPolicySetStrategy,shortname=aps,categories=contrail;se\
    curity\n\n\x0b\n\x03\x04\n\x01\x12\x04\x87\x01\x08\x1c\n\xa0\x01\n\x04\
    \x04\n\x02\0\x12\x04\x8b\x01\x02H\x1a\x91\x01\x20Standard\x20object's\
    \x20metadata.\n\x20More\x20info:\x20https://git.k8s.io/community/contrib\
    utors/devel/sig-architecture/api-conventions.md#metadata\n\x20+optional\
    \n\n\r\n\x05\x04\n\x02\0\x04\x12\x04\x8b\x01\x02\n\n\r\n\x05\x04\n\x02\0\
    \x06\x12\x04\x8b\x01\x0b:\n\r\n\x05\x04\n\x02\0\x01\x12\x04\x8b\x01;C\n\
    \r\n\x05\x04\n\x02\0\x03\x12\x04\x8b\x01FG\n\xcb\x01\n\x04\x04\n\x02\x01\
    \x12\x04\x90\x01\x02-\x1a\xbc\x01\x20Specification\x20of\x20the\x20desir\
    ed\x20state\x20of\x20the\x20ApplicationPolicySet.\n\x20More\x20info:\x20\
    https://git.k8s.io/community/contributors/devel/sig-architecture/api-con\
    ventions.md#spec-and-status\n\x20+optional\n\n\r\n\x05\x04\n\x02\x01\x04\
    \x12\x04\x90\x01\x02\n\n\r\n\x05\x04\n\x02\x01\x06\x12\x04\x90\x01\x0b#\
    \n\r\n\x05\x04\n\x02\x01\x01\x12\x04\x90\x01$(\n\r\n\x05\x04\n\x02\x01\
    \x03\x12\x04\x90\x01+,\n\x92\x02\n\x04\x04\n\x02\x02\x12\x04\x98\x01\x02\
    1\x1a\x83\x02\x20The\x20most\x20recently\x20observed\x20status\x20of\x20\
    the\x20ApplicationPolicySet.\n\x20This\x20data\x20may\x20not\x20be\x20up\
    -to-date.\n\x20Populated\x20by\x20the\x20system.\n\x20Read-only.\n\x20Mo\
    re\x20info:\x20https://git.k8s.io/community/contributors/devel/sig-archi\
    tecture/api-conventions.md#spec-and-status\n\x20+optional\n\n\r\n\x05\
    \x04\n\x02\x02\x04\x12\x04\x98\x01\x02\n\n\r\n\x05\x04\n\x02\x02\x06\x12\
    \x04\x98\x01\x0b%\n\r\n\x05\x04\n\x02\x02\x01\x12\x04\x98\x01&,\n\r\n\
    \x05\x04\n\x02\x02\x03\x12\x04\x98\x01/0\nK\n\x02\x04\x0b\x12\x06\x9c\
    \x01\0\xa4\x01\x01\x1a=\x20ApplicationPolicySetList\x20is\x20a\x20list\
    \x20of\x20ApplicationPolicySet.\n\n\x0b\n\x03\x04\x0b\x01\x12\x04\x9c\
    \x01\x08\x20\n\xac\x01\n\x04\x04\x0b\x02\0\x12\x04\xa0\x01\x02F\x1a\x9d\
    \x01\x20Standard\x20list's\x20metadata.\n\x20More\x20info:\x20https://gi\
    t.k8s.io/community/contributors/devel/sig-architecture/api-conventions.m\
    d#lists-and-simple-kinds\n\x20+optional\n\n\r\n\x05\x04\x0b\x02\0\x04\
    \x12\x04\xa0\x01\x02\n\n\r\n\x05\x04\x0b\x02\0\x06\x12\x04\xa0\x01\x0b8\
    \n\r\n\x05\x04\x0b\x02\0\x01\x12\x04\xa0\x019A\n\r\n\x05\x04\x0b\x02\0\
    \x03\x12\x04\xa0\x01DE\ni\n\x04\x04\x0b\x02\x01\x12\x04\xa3\x01\x02*\x1a\
    [\x20Items\x20contains\x20all\x20of\x20the\x20ApplicationPolicySet\x20in\
    stances\x20in\x20the\x20ApplicationPolicySetList.\n\n\r\n\x05\x04\x0b\
    \x02\x01\x04\x12\x04\xa3\x01\x02\n\n\r\n\x05\x04\x0b\x02\x01\x06\x12\x04\
    \xa3\x01\x0b\x1f\n\r\n\x05\x04\x0b\x02\x01\x01\x12\x04\xa3\x01\x20%\n\r\
    \n\x05\x04\x0b\x02\x01\x03\x12\x04\xa3\x01()\nW\n\x02\x04\x0c\x12\x06\
    \xa7\x01\0\xb0\x01\x01\x1aI\x20ApplicationPolicySetSpec\x20defines\x20th\
    e\x20desired\x20state\x20of\x20a\x20FirewallPolicy.\n\n\x0b\n\x03\x04\
    \x0c\x01\x12\x04\xa7\x01\x08\x20\n\"\n\x04\x04\x0c\x02\0\x12\x04\xa9\x01\
    \x02%\x1a\x14\x20Common\x20spec\x20fields\n\n\r\n\x05\x04\x0c\x02\0\x04\
    \x12\x04\xa9\x01\x02\n\n\r\n\x05\x04\x0c\x02\0\x06\x12\x04\xa9\x01\x0b\
    \x15\n\r\n\x05\x04\x0c\x02\0\x01\x12\x04\xa9\x01\x16\x20\n\r\n\x05\x04\
    \x0c\x02\0\x03\x12\x04\xa9\x01#$\nx\n\x04\x04\x0c\x02\x01\x12\x04\xac\
    \x01\x02@\x1aj\x20FirewallPolicyReferences\x20contains\x20references\x20\
    to\x20FirewallPolicy\x20associated\x20with\x20the\x20ApplicationPolicySe\
    t.\n\n\r\n\x05\x04\x0c\x02\x01\x04\x12\x04\xac\x01\x02\n\n\r\n\x05\x04\
    \x0c\x02\x01\x06\x12\x04\xac\x01\x0b\"\n\r\n\x05\x04\x0c\x02\x01\x01\x12\
    \x04\xac\x01#;\n\r\n\x05\x04\x0c\x02\x01\x03\x12\x04\xac\x01>?\n_\n\x04\
    \x04\x0c\x02\x02\x12\x04\xaf\x01\x02/\x1aQ\x20TagReferences\x20contains\
    \x20references\x20to\x20Tags\x20attached\x20to\x20the\x20ApplicationPoli\
    cySet.\n\n\r\n\x05\x04\x0c\x02\x02\x04\x12\x04\xaf\x01\x02\n\n\r\n\x05\
    \x04\x0c\x02\x02\x06\x12\x04\xaf\x01\x0b\x1c\n\r\n\x05\x04\x0c\x02\x02\
    \x01\x12\x04\xaf\x01\x1d*\n\r\n\x05\x04\x0c\x02\x02\x03\x12\x04\xaf\x01-\
    .\n^\n\x02\x04\r\x12\x06\xb3\x01\0\xb9\x01\x01\x1aP\x20ApplicationPolicy\
    SetStatus\x20defines\x20the\x20observed\x20state\x20of\x20ApplicationPol\
    icySet.\n\n\x0b\n\x03\x04\r\x01\x12\x04\xb3\x01\x08\"\n$\n\x04\x04\r\x02\
    \0\x12\x04\xb5\x01\x02)\x1a\x16\x20Common\x20status\x20fields\n\n\r\n\
    \x05\x04\r\x02\0\x04\x12\x04\xb5\x01\x02\n\n\r\n\x05\x04\r\x02\0\x06\x12\
    \x04\xb5\x01\x0b\x17\n\r\n\x05\x04\r\x02\0\x01\x12\x04\xb5\x01\x18$\n\r\
    \n\x05\x04\r\x02\0\x03\x12\x04\xb5\x01'(\nJ\n\x04\x04\r\x02\x01\x12\x04\
    \xb8\x01\x02$\x1a<\x20ApplicatioPolicySet\x20to\x20be\x20applied\x20to\
    \x20all\x20application\x20tags.\n\n\r\n\x05\x04\r\x02\x01\x04\x12\x04\
    \xb8\x01\x02\n\n\r\n\x05\x04\r\x02\x01\x05\x12\x04\xb8\x01\x0b\x0f\n\r\n\
    \x05\x04\r\x02\x01\x01\x12\x04\xb8\x01\x10\x1f\n\r\n\x05\x04\r\x02\x01\
    \x03\x12\x04\xb8\x01\"#\n\x81\x01\n\x02\x04\x0e\x12\x06\xbd\x01\0\xc5\
    \x01\x01\x1as\x20Authentication\x20related\x20configuration\x20for\x20th\
    is\x20session\x20like\x20type,\x20keys\x20etc.\n\x20Only\x20md5\x20authe\
    ntication\x20is\x20supported.\n\n\x0b\n\x03\x04\x0e\x01\x12\x04\xbd\x01\
    \x08\x1a\nb\n\x04\x04\x0e\x02\0\x12\x04\xc0\x01\x02\x1e\x1aT\x20Authenti\
    cation\x20type\x20for\x20this\x20session.\x20Currently,\x20only\x20MD5\
    \x20is\x20supported.\n\x20+optional\n\n\r\n\x05\x04\x0e\x02\0\x04\x12\
    \x04\xc0\x01\x02\n\n\r\n\x05\x04\x0e\x02\0\x05\x12\x04\xc0\x01\x0b\x11\n\
    \r\n\x05\x04\x0e\x02\0\x01\x12\x04\xc0\x01\x12\x19\n\r\n\x05\x04\x0e\x02\
    \0\x03\x12\x04\xc0\x01\x1c\x1d\n`\n\x04\x04\x0e\x02\x01\x12\x04\xc4\x01\
    \x02.\x1aR\x20Upto\x20two\x20keys\x20can\x20be\x20specified.\x20Currentl\
    y,\x20only\x20one\x20key\x20is\x20supported.\n\x20+optional\n\n\r\n\x05\
    \x04\x0e\x02\x01\x04\x12\x04\xc4\x01\x02\n\n\r\n\x05\x04\x0e\x02\x01\x06\
    \x12\x04\xc4\x01\x0b\x20\n\r\n\x05\x04\x0e\x02\x01\x01\x12\x04\xc4\x01!)\
    \n\r\n\x05\x04\x0e\x02\x01\x03\x12\x04\xc4\x01,-\n[\n\x02\x04\x0f\x12\
    \x06\xc8\x01\0\xcc\x01\x01\x1aM\x20AuthenticationKeyItem\x20is\x20used\
    \x20for\x20BGP\x20session\x20authentication\x20configuration.\n\n\x0b\n\
    \x03\x04\x0f\x01\x12\x04\xc8\x01\x08\x1d\n\x0c\n\x04\x04\x0f\x02\0\x12\
    \x04\xc9\x01\x02\x1b\n\r\n\x05\x04\x0f\x02\0\x04\x12\x04\xc9\x01\x02\n\n\
    \r\n\x05\x04\x0f\x02\0\x05\x12\x04\xc9\x01\x0b\x10\n\r\n\x05\x04\x0f\x02\
    \0\x01\x12\x04\xc9\x01\x11\x16\n\r\n\x05\x04\x0f\x02\0\x03\x12\x04\xc9\
    \x01\x19\x1a\n\x0c\n\x04\x04\x0f\x02\x01\x12\x04\xcb\x01\x02\x1a\n\r\n\
    \x05\x04\x0f\x02\x01\x04\x12\x04\xcb\x01\x02\n\n\r\n\x05\x04\x0f\x02\x01\
    \x05\x12\x04\xcb\x01\x0b\x11\n\r\n\x05\x04\x0f\x02\x01\x01\x12\x04\xcb\
    \x01\x12\x15\n\r\n\x05\x04\x0f\x02\x01\x03\x12\x04\xcb\x01\x18\x19\n\xc0\
    \x02\n\x02\x04\x10\x12\x06\xd3\x01\0\xe5\x01\x01\x1a\xb1\x02\x20BGPAsASe\
    rvice\x20determines\x20the\x20configuration\x20of\x20BGP\x20peers.\n\x20\
    All\x20the\x20BGP\x20peers\x20involved\x20in\x20Contrail\x20are\x20prese\
    nt\x20inthe\x20default\n\x20RoutingInstance\x20of\x20the\x20default\x20V\
    irtualNetwork.\n\x20+k8s:openapi-gen=true\n\x20+resource:path=bgpasaserv\
    ices,strategy=BGPAsAServiceStrategy,shortname=bgpaas,categories=contrail\
    ;networking\n\n\x0b\n\x03\x04\x10\x01\x12\x04\xd3\x01\x08\x15\n\xa0\x01\
    \n\x04\x04\x10\x02\0\x12\x04\xd7\x01\x02H\x1a\x91\x01\x20Standard\x20obj\
    ect's\x20metadata.\n\x20More\x20info:\x20https://git.k8s.io/community/co\
    ntributors/devel/sig-architecture/api-conventions.md#metadata\n\x20+opti\
    onal\n\n\r\n\x05\x04\x10\x02\0\x04\x12\x04\xd7\x01\x02\n\n\r\n\x05\x04\
    \x10\x02\0\x06\x12\x04\xd7\x01\x0b:\n\r\n\x05\x04\x10\x02\0\x01\x12\x04\
    \xd7\x01;C\n\r\n\x05\x04\x10\x02\0\x03\x12\x04\xd7\x01FG\n\xc4\x01\n\x04\
    \x04\x10\x02\x01\x12\x04\xdc\x01\x02&\x1a\xb5\x01\x20Specification\x20of\
    \x20the\x20desired\x20state\x20of\x20the\x20BGPAsAService.\n\x20More\x20\
    info:\x20https://git.k8s.io/community/contributors/devel/sig-architectur\
    e/api-conventions.md#spec-and-status\n\x20+optional\n\n\r\n\x05\x04\x10\
    \x02\x01\x04\x12\x04\xdc\x01\x02\n\n\r\n\x05\x04\x10\x02\x01\x06\x12\x04\
    \xdc\x01\x0b\x1c\n\r\n\x05\x04\x10\x02\x01\x01\x12\x04\xdc\x01\x1d!\n\r\
    \n\x05\x04\x10\x02\x01\x03\x12\x04\xdc\x01$%\n\x8b\x02\n\x04\x04\x10\x02\
    \x02\x12\x04\xe4\x01\x02*\x1a\xfc\x01\x20The\x20most\x20recently\x20obse\
    rved\x20status\x20of\x20the\x20BGPAsAService.\n\x20This\x20data\x20may\
    \x20not\x20be\x20up-to-date.\n\x20Populated\x20by\x20the\x20system.\n\
    \x20Read-only.\n\x20More\x20info:\x20https://git.k8s.io/community/contri\
    butors/devel/sig-architecture/api-conventions.md#spec-and-status\n\x20+o\
    ptional\n\n\r\n\x05\x04\x10\x02\x02\x04\x12\x04\xe4\x01\x02\n\n\r\n\x05\
    \x04\x10\x02\x02\x06\x12\x04\xe4\x01\x0b\x1e\n\r\n\x05\x04\x10\x02\x02\
    \x01\x12\x04\xe4\x01\x1f%\n\r\n\x05\x04\x10\x02\x02\x03\x12\x04\xe4\x01(\
    )\n=\n\x02\x04\x11\x12\x06\xe8\x01\0\xf0\x01\x01\x1a/\x20BGPAsAServiceLi\
    st\x20is\x20a\x20list\x20of\x20BGPAsAService.\n\n\x0b\n\x03\x04\x11\x01\
    \x12\x04\xe8\x01\x08\x19\n\xac\x01\n\x04\x04\x11\x02\0\x12\x04\xec\x01\
    \x02F\x1a\x9d\x01\x20Standard\x20list's\x20metadata.\n\x20More\x20info:\
    \x20https://git.k8s.io/community/contributors/devel/sig-architecture/api\
    -conventions.md#lists-and-simple-kinds\n\x20+optional\n\n\r\n\x05\x04\
    \x11\x02\0\x04\x12\x04\xec\x01\x02\n\n\r\n\x05\x04\x11\x02\0\x06\x12\x04\
    \xec\x01\x0b8\n\r\n\x05\x04\x11\x02\0\x01\x12\x04\xec\x019A\n\r\n\x05\
    \x04\x11\x02\0\x03\x12\x04\xec\x01DE\n[\n\x04\x04\x11\x02\x01\x12\x04\
    \xef\x01\x02#\x1aM\x20Items\x20contains\x20all\x20of\x20the\x20BGPAsASer\
    vice\x20instances\x20in\x20the\x20BGPAsAServiceList.\n\n\r\n\x05\x04\x11\
    \x02\x01\x04\x12\x04\xef\x01\x02\n\n\r\n\x05\x04\x11\x02\x01\x06\x12\x04\
    \xef\x01\x0b\x18\n\r\n\x05\x04\x11\x02\x01\x01\x12\x04\xef\x01\x19\x1e\n\
    \r\n\x05\x04\x11\x02\x01\x03\x12\x04\xef\x01!\"\nO\n\x02\x04\x12\x12\x06\
    \xf3\x01\0\xa0\x02\x01\x1aA\x20BGPAsAServiceSpec\x20defines\x20the\x20de\
    sired\x20state\x20of\x20a\x20BGPAsAService.\n\n\x0b\n\x03\x04\x12\x01\
    \x12\x04\xf3\x01\x08\x19\n\"\n\x04\x04\x12\x02\0\x12\x04\xf5\x01\x02%\
    \x1a\x14\x20Common\x20spec\x20fields\n\n\r\n\x05\x04\x12\x02\0\x04\x12\
    \x04\xf5\x01\x02\n\n\r\n\x05\x04\x12\x02\0\x06\x12\x04\xf5\x01\x0b\x15\n\
    \r\n\x05\x04\x12\x02\0\x01\x12\x04\xf5\x01\x16\x20\n\r\n\x05\x04\x12\x02\
    \0\x03\x12\x04\xf5\x01#$\n\xc9\x01\n\x04\x04\x12\x02\x01\x12\x04\xfb\x01\
    \x02\x1b\x1a\xba\x01\x20Shared\x20is\x20enabled\x20to\x20link\x20all\x20\
    VMIs\x20with\x20the\x20common\x20bgp-router\x20object.\n\x20When\x20fals\
    e\x20(default),\x20each\x20virtual\x20machine\x20interface\x20individual\
    ly\x20links\x20to\n\x20its\x20own\x20bgp-router\x20object.\n\x20+optiona\
    l\n\n\r\n\x05\x04\x12\x02\x01\x04\x12\x04\xfb\x01\x02\n\n\r\n\x05\x04\
    \x12\x02\x01\x05\x12\x04\xfb\x01\x0b\x0f\n\r\n\x05\x04\x12\x02\x01\x01\
    \x12\x04\xfb\x01\x10\x16\n\r\n\x05\x04\x12\x02\x01\x03\x12\x04\xfb\x01\
    \x19\x1a\nU\n\x04\x04\x12\x02\x02\x12\x04\xff\x01\x02\x20\x1aG\x20IPAddr\
    ess\x20specifies\x20the\x20source-address\x20of\x20a\x20BGPaaS\x20VM/pod\
    .\n\x20+optional\n\n\r\n\x05\x04\x12\x02\x02\x04\x12\x04\xff\x01\x02\n\n\
    \r\n\x05\x04\x12\x02\x02\x05\x12\x04\xff\x01\x0b\x11\n\r\n\x05\x04\x12\
    \x02\x02\x01\x12\x04\xff\x01\x12\x1b\n\r\n\x05\x04\x12\x02\x02\x03\x12\
    \x04\xff\x01\x1e\x1f\nX\n\x04\x04\x12\x02\x03\x12\x04\x82\x02\x02&\x1aJ\
    \x20AutonomousSystem\x20is\x2016-bit\x20BGP\x20Autonomous\x20System\x20n\
    umber\x20for\x20the\x20cluster.\n\n\r\n\x05\x04\x12\x02\x03\x04\x12\x04\
    \x82\x02\x02\n\n\r\n\x05\x04\x12\x02\x03\x05\x12\x04\x82\x02\x0b\x10\n\r\
    \n\x05\x04\x12\x02\x03\x01\x12\x04\x82\x02\x11!\n\r\n\x05\x04\x12\x02\
    \x03\x03\x12\x04\x82\x02$%\n\xda\x01\n\x04\x04\x12\x02\x04\x12\x04\x88\
    \x02\x02/\x1a\xcb\x01\x20SuppressRouteAdvertisement\x20indicates\x20that\
    \x20the\x20server\x20should\x20not\x20advertise\n\x20any\x20routes\x20to\
    \x20the\x20client\x20i.e.\x20the\x20client\x20has\x20static\x20routes\
    \x20(typically\x20a\n\x20default)\x20configured,\x20default\x20set\x20to\
    \x20false.\n\x20+optional\n\n\r\n\x05\x04\x12\x02\x04\x04\x12\x04\x88\
    \x02\x02\n\n\r\n\x05\x04\x12\x02\x04\x05\x12\x04\x88\x02\x0b\x0f\n\r\n\
    \x05\x04\x12\x02\x04\x01\x12\x04\x88\x02\x10*\n\r\n\x05\x04\x12\x02\x04\
    \x03\x12\x04\x88\x02-.\n\xd5\x01\n\x04\x04\x12\x02\x05\x12\x04\x8e\x02\
    \x02*\x1a\xc6\x01\x20IPv4MappedIPv6NextHop\x20indicates\x20if\x20the\x20\
    client\x20bgp\x20implementation\x20expects\n\x20to\x20receive\x20a\x20ip\
    v4-mapped\x20ipv6\x20address\x20(as\x20opposed\x20to\x20regular\x20ipv6\
    \n\x20address)\x20as\x20the\x20bgp\x20nexthop\x20for\x20ipv6\x20routes.\
    \n\x20+optional\n\n\r\n\x05\x04\x12\x02\x05\x04\x12\x04\x8e\x02\x02\n\n\
    \r\n\x05\x04\x12\x02\x05\x05\x12\x04\x8e\x02\x0b\x0f\n\r\n\x05\x04\x12\
    \x02\x05\x01\x12\x04\x8e\x02\x10%\n\r\n\x05\x04\x12\x02\x05\x03\x12\x04\
    \x8e\x02()\n\x85\x01\n\x04\x04\x12\x02\x06\x12\x04\x93\x02\x02C\x1aw\x20\
    BGPAsAServiceSessionAttributes\x20defines\x20session\x20attributes\x20su\
    ch\x20as\x20hold\x20time,\n\x20route\x20origin\x20and\x20loop\x20count.\
    \n\x20+optional\n\n\r\n\x05\x04\x12\x02\x06\x04\x12\x04\x93\x02\x02\n\n\
    \r\n\x05\x04\x12\x02\x06\x06\x12\x04\x93\x02\x0b\x1f\n\r\n\x05\x04\x12\
    \x02\x06\x01\x12\x04\x93\x02\x20>\n\r\n\x05\x04\x12\x02\x06\x03\x12\x04\
    \x93\x02AB\n\x8f\x01\n\x04\x04\x12\x02\x07\x12\x04\x98\x02\x02C\x1a\x80\
    \x01\x20VirtualMachineInterfaceReferences\x20determines\x20the\x20Virtua\
    lMachineInterfaces\n\x20on\x20which\x20BGPaaS\x20BGP\x20peering\x20will\
    \x20happen.\n\x20+optional\n\n\r\n\x05\x04\x12\x02\x07\x04\x12\x04\x98\
    \x02\x02\n\n\r\n\x05\x04\x12\x02\x07\x06\x12\x04\x98\x02\x0b\x1c\n\r\n\
    \x05\x04\x12\x02\x07\x01\x12\x04\x98\x02\x1d>\n\r\n\x05\x04\x12\x02\x07\
    \x03\x12\x04\x98\x02AB\n\xa2\x02\n\x04\x04\x12\x02\x08\x12\x04\x9f\x02\
    \x02c\x1a\x93\x02\x20VirtualMachineInterfacesSelector\x20selects\x20Virt\
    ualMachineInterfaces\x20using\n\x20the\x20'core.juniper.net/bgpaasVN'\
    \x20label\x20defined\x20on\x20pods.\x20BGPAsAService\x20will\x20be\x20co\
    nfigured\x20on\n\x20the\x20union\x20of\x20VMIs\x20selected\x20by\x20labe\
    l\x20and\x20VMI\x20specified\x20through\n\x20VirtualMachineInterfaceRefe\
    rences.\n\x20+optional\n\n\r\n\x05\x04\x12\x02\x08\x04\x12\x04\x9f\x02\
    \x02\n\n\r\n\x05\x04\x12\x02\x08\x06\x12\x04\x9f\x02\x0b=\n\r\n\x05\x04\
    \x12\x02\x08\x01\x12\x04\x9f\x02>^\n\r\n\x05\x04\x12\x02\x08\x03\x12\x04\
    \x9f\x02ab\nP\n\x02\x04\x13\x12\x06\xa3\x02\0\xb0\x02\x01\x1aB\x20BGPAsA\
    ServiceStatus\x20defines\x20the\x20observed\x20state\x20of\x20BGPAsAServ\
    ice.\n\n\x0b\n\x03\x04\x13\x01\x12\x04\xa3\x02\x08\x1b\n$\n\x04\x04\x13\
    \x02\0\x12\x04\xa5\x02\x02)\x1a\x16\x20Common\x20status\x20fields\n\n\r\
    \n\x05\x04\x13\x02\0\x04\x12\x04\xa5\x02\x02\n\n\r\n\x05\x04\x13\x02\0\
    \x06\x12\x04\xa5\x02\x0b\x17\n\r\n\x05\x04\x13\x02\0\x01\x12\x04\xa5\x02\
    \x18$\n\r\n\x05\x04\x13\x02\0\x03\x12\x04\xa5\x02'(\n~\n\x04\x04\x13\x02\
    \x01\x12\x04\xaa\x02\x026\x1ap\x20BGPRouterReferences\x20contains\x20ref\
    erences\x20to\x20all\x20BGPRouters\x20created\n\x20for\x20a\x20for\x20BG\
    PAsAService\x20session.\n\x20+optional\n\n\r\n\x05\x04\x13\x02\x01\x04\
    \x12\x04\xaa\x02\x02\n\n\r\n\x05\x04\x13\x02\x01\x06\x12\x04\xaa\x02\x0b\
    \x1d\n\r\n\x05\x04\x13\x02\x01\x01\x12\x04\xaa\x02\x1e1\n\r\n\x05\x04\
    \x13\x02\x01\x03\x12\x04\xaa\x0245\n\x97\x01\n\x04\x04\x13\x02\x02\x12\
    \x04\xaf\x02\x020\x1a\x88\x01\x20SubnetReferences\x20contains\x20referen\
    ces\x20to\x20all\x20subnets\x20associated\x20with\n\x20the\x20selected\
    \x20VirtualMachineInterfaces'\x20VirtualNetwork.\n\x20+optional\n\n\r\n\
    \x05\x04\x13\x02\x02\x04\x12\x04\xaf\x02\x02\n\n\r\n\x05\x04\x13\x02\x02\
    \x06\x12\x04\xaf\x02\x0b\x1a\n\r\n\x05\x04\x13\x02\x02\x01\x12\x04\xaf\
    \x02\x1b+\n\r\n\x05\x04\x13\x02\x02\x03\x12\x04\xaf\x02./\n\xb2\x02\n\
    \x02\x04\x14\x12\x06\xb8\x02\0\xc9\x02\x01\x1a\xa3\x02\x20This\x20type\
    \x20is\x20used\x20to\x20configure\x20per\x20address-family\x20parameters\
    \n\x20for\x20a\x20BgpSession.\n\x20*\x20loop-count\x20is\x20the\x20numbe\
    r\x20of\x20times\x20the\x20local\x20bgp-router's\x20AS\x20is\n\x20\x20\
    \x20allowed\x20in\x20the\x20AS_PATH\x20attribute.\n\x20*\x20prefix-limit\
    \x20contains\x20the\x20maximum\x20number\x20of\x20prefixes\x20that\x20ar\
    e\n\x20\x20\x20allowed\x20to\x20be\x20received\x20on\x20the\x20session.\
    \n\n\x0b\n\x03\x04\x14\x01\x12\x04\xb8\x02\x08\x1b\nQ\n\x04\x04\x14\x02\
    \0\x12\x04\xbb\x02\x02$\x1aC\x20Address\x20family\x20for\x20which\x20the\
    se\x20parameters\x20are\x20applied.\n\x20+optional\n\n\r\n\x05\x04\x14\
    \x02\0\x04\x12\x04\xbb\x02\x02\n\n\r\n\x05\x04\x14\x02\0\x05\x12\x04\xbb\
    \x02\x0b\x11\n\r\n\x05\x04\x14\x02\0\x01\x12\x04\xbb\x02\x12\x1f\n\r\n\
    \x05\x04\x14\x02\0\x03\x12\x04\xbb\x02\"#\n\x98\x01\n\x04\x04\x14\x02\
    \x01\x12\x04\xc0\x02\x02\x1f\x1a\x89\x01\x20For\x20routing\x20loop\x20de\
    tection,\x20loop-count\x20is\x20the\x20number\x20of\x20times\x20the\x20l\
    ocal\x20bgp-routers\x20AS\x20is\n\x20allowed\x20in\x20the\x20AS_PATH\x20\
    attribute.\n\x20+optional\n\n\r\n\x05\x04\x14\x02\x01\x04\x12\x04\xc0\
    \x02\x02\n\n\r\n\x05\x04\x14\x02\x01\x05\x12\x04\xc0\x02\x0b\x10\n\r\n\
    \x05\x04\x14\x02\x01\x01\x12\x04\xc0\x02\x11\x1a\n\r\n\x05\x04\x14\x02\
    \x01\x03\x12\x04\xc0\x02\x1d\x1e\n\x97\x01\n\x04\x04\x14\x02\x02\x12\x04\
    \xc4\x02\x02*\x1a\x88\x01\x20PrefixLimit\x20contains\x20the\x20maximum\
    \x20number\x20of\x20prefixes\x20that\x20are\x20allowed\x20to\x20be\x20re\
    ceived\x20on\x20the\x20session\x20for\x20this\x20address\x20family.\n\
    \x20+optional\n\n\r\n\x05\x04\x14\x02\x02\x04\x12\x04\xc4\x02\x02\n\n\r\
    \n\x05\x04\x14\x02\x02\x06\x12\x04\xc4\x02\x0b\x19\n\r\n\x05\x04\x14\x02\
    \x02\x01\x12\x04\xc4\x02\x1a%\n\r\n\x05\x04\x14\x02\x02\x03\x12\x04\xc4\
    \x02()\nI\n\x04\x04\x14\x02\x03\x12\x04\xc8\x02\x02)\x1a;\x20Default\x20\
    prioritized\x20tunnel\x20encapsulation\x20list.\n\x20+optional\n\n\r\n\
    \x05\x04\x14\x02\x03\x04\x12\x04\xc8\x02\x02\n\n\r\n\x05\x04\x14\x02\x03\
    \x05\x12\x04\xc8\x02\x0b\x11\n\r\n\x05\x04\x14\x02\x03\x01\x12\x04\xc8\
    \x02\x12$\n\r\n\x05\x04\x14\x02\x03\x03\x12\x04\xc8\x02'(\n\x98\x01\n\
    \x02\x04\x15\x12\x06\xcd\x02\0\xd5\x02\x01\x1a\x89\x01\x20This\x20is\x20\
    used\x20to\x20configure\x20the\x20maximum\x20number\x20of\x20received\
    \x20prefixes\n\x20and\x20control\x20the\x20behavior\x20of\x20the\x20sess\
    ion\x20when\x20the\x20maximum\x20is\x20reached.\n\n\x0b\n\x03\x04\x15\
    \x01\x12\x04\xcd\x02\x08\x16\nm\n\x04\x04\x15\x02\0\x12\x04\xd0\x02\x02!\
    \x1a_\x20Time\x20in\x20seconds\x20after\x20which\x20the\x20session\x20is\
    \x20allowed\x20to\x20re-establish\x20after\x20teardown.\n\x20+optional\n\
    \n\r\n\x05\x04\x15\x02\0\x04\x12\x04\xd0\x02\x02\n\n\r\n\x05\x04\x15\x02\
    \0\x05\x12\x04\xd0\x02\x0b\x10\n\r\n\x05\x04\x15\x02\0\x01\x12\x04\xd0\
    \x02\x11\x1c\n\r\n\x05\x04\x15\x02\0\x03\x12\x04\xd0\x02\x1f\x20\nL\n\
    \x04\x04\x15\x02\x01\x12\x04\xd4\x02\x02\x1d\x1a>\x20Maximum\x20number\
    \x20of\x20prefixes\x20allowed\x20to\x20be\x20recieved\n\x20+optional\n\n\
    \r\n\x05\x04\x15\x02\x01\x04\x12\x04\xd4\x02\x02\n\n\r\n\x05\x04\x15\x02\
    \x01\x05\x12\x04\xd4\x02\x0b\x10\n\r\n\x05\x04\x15\x02\x01\x01\x12\x04\
    \xd4\x02\x11\x18\n\r\n\x05\x04\x15\x02\x01\x03\x12\x04\xd4\x02\x1b\x1c\n\
    \xb0\x02\n\x02\x04\x16\x12\x06\xdc\x02\0\xed\x02\x01\x1a\xa1\x02\x20BGPR\
    outer\x20object\x20represent\x20configuration\x20of\x20BGP\x20peers.\n\
    \x20All\x20the\x20BGP\x20peers\x20involved\x20in\x20Contrail\x20system\
    \x20are\x20under\x20default\x20Routing\n\x20Instance\x20of\x20the\x20def\
    ault\x20Virtual\x20Network.\n\x20+k8s:openapi-gen=true\n\x20+resource:pa\
    th=bgprouters,strategy=BGPRouterStrategy,shortname=br,categories=contrai\
    l;routing\n\n\x0b\n\x03\x04\x16\x01\x12\x04\xdc\x02\x08\x11\n\xa0\x01\n\
    \x04\x04\x16\x02\0\x12\x04\xe0\x02\x02H\x1a\x91\x01\x20Standard\x20objec\
    t's\x20metadata.\n\x20More\x20info:\x20https://git.k8s.io/community/cont\
    ributors/devel/sig-architecture/api-conventions.md#metadata\n\x20+option\
    al\n\n\r\n\x05\x04\x16\x02\0\x04\x12\x04\xe0\x02\x02\n\n\r\n\x05\x04\x16\
    \x02\0\x06\x12\x04\xe0\x02\x0b:\n\r\n\x05\x04\x16\x02\0\x01\x12\x04\xe0\
    \x02;C\n\r\n\x05\x04\x16\x02\0\x03\x12\x04\xe0\x02FG\n\xb6\x01\n\x04\x04\
    \x16\x02\x01\x12\x04\xe4\x02\x02\"\x1a\xa7\x01\x20BGPRouterSpec\x20defin\
    es\x20the\x20desired\x20state\x20of\x20BGPRouter.\n\x20More\x20info:\x20\
    https://git.k8s.io/community/contributors/devel/sig-architecture/api-con\
    ventions.md#spec-and-status\n\n\r\n\x05\x04\x16\x02\x01\x04\x12\x04\xe4\
    \x02\x02\n\n\r\n\x05\x04\x16\x02\x01\x06\x12\x04\xe4\x02\x0b\x18\n\r\n\
    \x05\x04\x16\x02\x01\x01\x12\x04\xe4\x02\x19\x1d\n\r\n\x05\x04\x16\x02\
    \x01\x03\x12\x04\xe4\x02\x20!\n\x8b\x02\n\x04\x04\x16\x02\x02\x12\x04\
    \xec\x02\x02&\x1a\xfc\x01\x20BGPRouterStatus\x20defines\x20the\x20observ\
    ed\x20state\x20of\x20BGPRouter\n\x20This\x20data\x20may\x20not\x20be\x20\
    up-to-date.\n\x20Populated\x20by\x20the\x20system.\n\x20Read-only.\n\x20\
    More\x20info:\x20https://git.k8s.io/community/contributors/devel/sig-arc\
    hitecture/api-conventions.md#spec-and-status\n\x20+optional\n\n\r\n\x05\
    \x04\x16\x02\x02\x04\x12\x04\xec\x02\x02\n\n\r\n\x05\x04\x16\x02\x02\x06\
    \x12\x04\xec\x02\x0b\x1a\n\r\n\x05\x04\x16\x02\x02\x01\x12\x04\xec\x02\
    \x1b!\n\r\n\x05\x04\x16\x02\x02\x03\x12\x04\xec\x02$%\n5\n\x02\x04\x17\
    \x12\x06\xf0\x02\0\xf8\x02\x01\x1a'\x20BGPRouterList\x20is\x20a\x20list\
    \x20of\x20BGPRouter.\n\n\x0b\n\x03\x04\x17\x01\x12\x04\xf0\x02\x08\x15\n\
    \xac\x01\n\x04\x04\x17\x02\0\x12\x04\xf4\x02\x02F\x1a\x9d\x01\x20Standar\
    d\x20list's\x20metadata.\n\x20More\x20info:\x20https://git.k8s.io/commun\
    ity/contributors/devel/sig-architecture/api-conventions.md#lists-and-sim\
    ple-kinds\n\x20+optional\n\n\r\n\x05\x04\x17\x02\0\x04\x12\x04\xf4\x02\
    \x02\n\n\r\n\x05\x04\x17\x02\0\x06\x12\x04\xf4\x02\x0b8\n\r\n\x05\x04\
    \x17\x02\0\x01\x12\x04\xf4\x029A\n\r\n\x05\x04\x17\x02\0\x03\x12\x04\xf4\
    \x02DE\nS\n\x04\x04\x17\x02\x01\x12\x04\xf7\x02\x02\x1f\x1aE\x20Items\
    \x20contains\x20all\x20of\x20the\x20BGPRouter\x20instances\x20in\x20the\
    \x20BGPRouterList.\n\n\r\n\x05\x04\x17\x02\x01\x04\x12\x04\xf7\x02\x02\n\
    \n\r\n\x05\x04\x17\x02\x01\x06\x12\x04\xf7\x02\x0b\x14\n\r\n\x05\x04\x17\
    \x02\x01\x01\x12\x04\xf7\x02\x15\x1a\n\r\n\x05\x04\x17\x02\x01\x03\x12\
    \x04\xf7\x02\x1d\x1e\n|\n\x02\x04\x18\x12\x06\xfc\x02\0\xcb\x03\x01\x1an\
    \x20BGPRouterParameters\x20contains\x20BGP\x20router\x20configuration\
    \x20parameters\x20like\n\x20IP\x20address,\x20AS\x20number,\x20hold\x20t\
    ime\x20etc.\n\n\x0b\n\x03\x04\x18\x01\x12\x04\xfc\x02\x08\x1b\np\n\x04\
    \x04\x18\x02\0\x12\x04\x80\x03\x02\x1e\x1ab\x20Administratively\x20up\
    \x20or\x20down\x20BGPRouter,\x20session\x20is\x20not\x20established\n\
    \x20for\x20the\x20BGPRouter.\n\x20+optional\n\n\r\n\x05\x04\x18\x02\0\
    \x04\x12\x04\x80\x03\x02\n\n\r\n\x05\x04\x18\x02\0\x05\x12\x04\x80\x03\
    \x0b\x0f\n\r\n\x05\x04\x18\x02\0\x01\x12\x04\x80\x03\x10\x19\n\r\n\x05\
    \x04\x18\x02\0\x03\x12\x04\x80\x03\x1c\x1d\n;\n\x04\x04\x18\x02\x01\x12\
    \x04\x84\x03\x02\x1d\x1a-\x20Vendor\x20name\x20for\x20this\x20BGP\x20rou\
    ter.\n\x20+optional\n\n\r\n\x05\x04\x18\x02\x01\x04\x12\x04\x84\x03\x02\
    \n\n\r\n\x05\x04\x18\x02\x01\x05\x12\x04\x84\x03\x0b\x11\n\r\n\x05\x04\
    \x18\x02\x01\x01\x12\x04\x84\x03\x12\x18\n\r\n\x05\x04\x18\x02\x01\x03\
    \x12\x04\x84\x03\x1b\x1c\n\x89\x01\n\x04\x04\x18\x02\x02\x12\x04\x89\x03\
    \x02\x1f\x1a{\x20Cluster\x20ID\x20for\x20this\x20BGP\x20router\x20(betwe\
    en\x201\x20and\x204294967295)\n\x20when\x20control\x20node\x20is\x20conf\
    igured\x20as\x20route\x20reflector.\n\x20+optional\n\n\r\n\x05\x04\x18\
    \x02\x02\x04\x12\x04\x89\x03\x02\n\n\r\n\x05\x04\x18\x02\x02\x05\x12\x04\
    \x89\x03\x0b\x10\n\r\n\x05\x04\x18\x02\x02\x01\x12\x04\x89\x03\x11\x1a\n\
    \r\n\x05\x04\x18\x02\x02\x03\x12\x04\x89\x03\x1d\x1e\n\xa0\x01\n\x04\x04\
    \x18\x02\x03\x12\x04\x8e\x03\x02&\x1a\x91\x01\x20Autonomous\x20System\
    \x20number\x20for\x20this\x20BGP\x20router.\x20For\x20contrail\x20contro\
    l\x20nodes,\n\x20this\x20is\x20derived\x20from\x20GlobalSystemConfig\x20\
    AutonomousSystem.\n\x20+optional\n\n\r\n\x05\x04\x18\x02\x03\x04\x12\x04\
    \x8e\x03\x02\n\n\r\n\x05\x04\x18\x02\x03\x05\x12\x04\x8e\x03\x0b\x10\n\r\
    \n\x05\x04\x18\x02\x03\x01\x12\x04\x8e\x03\x11!\n\r\n\x05\x04\x18\x02\
    \x03\x03\x12\x04\x8e\x03$%\n\xa3\x01\n\x04\x04\x18\x02\x04\x12\x04\x93\
    \x03\x02!\x1a\x94\x01\x20Router\x20ID\x20for\x20this\x20BGP\x20router.\
    \x20Dotted\x20ip\x20notation.\x20For\x20Contrail\n\x20control-nodes\x20s\
    ystem\x20will\x20automatically\x20assign\x20value\x20of\x20address\x20fi\
    eld.\n\x20+optional\n\n\r\n\x05\x04\x18\x02\x04\x04\x12\x04\x93\x03\x02\
    \n\n\r\n\x05\x04\x18\x02\x04\x05\x12\x04\x93\x03\x0b\x11\n\r\n\x05\x04\
    \x18\x02\x04\x01\x12\x04\x93\x03\x12\x1c\n\r\n\x05\x04\x18\x02\x04\x03\
    \x12\x04\x93\x03\x1f\x20\nR\n\x04\x04\x18\x02\x05\x12\x04\x97\x03\x02\
    \x1e\x1aD\x20IP\x20address\x20used\x20to\x20reach\x20this\x20BGP\x20rout\
    er\x20by\x20the\x20system.\n\x20+optional\n\n\r\n\x05\x04\x18\x02\x05\
    \x04\x12\x04\x97\x03\x02\n\n\r\n\x05\x04\x18\x02\x05\x05\x12\x04\x97\x03\
    \x0b\x11\n\r\n\x05\x04\x18\x02\x05\x01\x12\x04\x97\x03\x12\x19\n\r\n\x05\
    \x04\x18\x02\x05\x03\x12\x04\x97\x03\x1c\x1d\no\n\x04\x04\x18\x02\x06\
    \x12\x04\x9c\x03\x02\x1a\x1aa\x20TCP\x20port\x20number\x20on\x20which\
    \x20BGP\x20protocol\x20connections\x20are\x20accepted.\n\x20Default\x20i\
    s\x20port\x20179\n\x20+optional\n\n\r\n\x05\x04\x18\x02\x06\x04\x12\x04\
    \x9c\x03\x02\n\n\r\n\x05\x04\x18\x02\x06\x05\x12\x04\x9c\x03\x0b\x10\n\r\
    \n\x05\x04\x18\x02\x06\x01\x12\x04\x9c\x03\x11\x15\n\r\n\x05\x04\x18\x02\
    \x06\x03\x12\x04\x9c\x03\x18\x19\nE\n\x04\x04\x18\x02\x07\x12\x04\xa0\
    \x03\x02\x20\x1a7\x20For\x20system\x20internal\x20use\x20in\x20BGPaaS\
    \x20service.\n\x20+optional\n\n\r\n\x05\x04\x18\x02\x07\x04\x12\x04\xa0\
    \x03\x02\n\n\r\n\x05\x04\x18\x02\x07\x05\x12\x04\xa0\x03\x0b\x10\n\r\n\
    \x05\x04\x18\x02\x07\x01\x12\x04\xa0\x03\x11\x1b\n\r\n\x05\x04\x18\x02\
    \x07\x03\x12\x04\xa0\x03\x1e\x1f\n\xa5\x01\n\x04\x04\x18\x02\x08\x12\x04\
    \xa5\x03\x02\x1e\x1a\x96\x01\x20BGPHoldTime\x20is\x20time\x20in\x20secon\
    ds\x20[0-65535],\x20maximum\x20time\x20to\x20detect\n\x20liveliness\x20t\
    o\x20peer.\x20Value\x200\x20will\x20result\x20in\x20default\x20value\x20\
    of\x2090\x20seconds.\n\x20+optional\n\n\r\n\x05\x04\x18\x02\x08\x04\x12\
    \x04\xa5\x03\x02\n\n\r\n\x05\x04\x18\x02\x08\x05\x12\x04\xa5\x03\x0b\x10\
    \n\r\n\x05\x04\x18\x02\x08\x01\x12\x04\xa5\x03\x11\x19\n\r\n\x05\x04\x18\
    \x02\x08\x03\x12\x04\xa5\x03\x1c\x1d\n\xdb\x01\n\x04\x04\x18\x02\t\x12\
    \x04\xac\x03\x020\x1a\xcc\x01\x20BGP\x20address\x20families\x20supported\
    \x20by\x20BGP\x20router.\x20If\x20not\x20specified\n\x20these\x20address\
    \x20families\x20are\x20enabled:\n\x20\"inet,\x20inet-labeled,\x20inet-vp\
    n,\x20e-vpn,\x20erm-vpn,\x20route-target,\x20inet6,\n\x20inet-mvpn,\x20i\
    net6-vpn\"\n\x20+optional\n\n\r\n\x05\x04\x18\x02\t\x04\x12\x04\xac\x03\
    \x02\n\n\r\n\x05\x04\x18\x02\t\x06\x12\x04\xac\x03\x0b\x1a\n\r\n\x05\x04\
    \x18\x02\t\x01\x12\x04\xac\x03\x1b*\n\r\n\x05\x04\x18\x02\t\x03\x12\x04\
    \xac\x03-/\nT\n\x04\x04\x18\x02\n\x12\x04\xb0\x03\x02,\x1aF\x20Authentic\
    ation\x20related\x20configuration\x20like\x20type,\x20keys\x20etc.\n\x20\
    +optional\n\n\r\n\x05\x04\x18\x02\n\x04\x12\x04\xb0\x03\x02\n\n\r\n\x05\
    \x04\x18\x02\n\x06\x12\x04\xb0\x03\x0b\x1d\n\r\n\x05\x04\x18\x02\n\x01\
    \x12\x04\xb0\x03\x1e&\n\r\n\x05\x04\x18\x02\n\x03\x12\x04\xb0\x03)+\n\
    \xcf\x01\n\x04\x04\x18\x02\x0b\x12\x04\xb6\x03\x02,\x1a\xc0\x01\x20BGPRo\
    uter\x20specific\x20Autonomous\x20System\x20number\x20if\x20different\
    \x20from\x20global\x20AS\n\x20number.\x20Typically\x20used\x20when\x20cl\
    usters\x20of\x20control\x20nodes\x20in\x20same\x20contrail\n\x20system\
    \x20are\x20in\x20different\x20locations.\n\x20+optional\n\n\r\n\x05\x04\
    \x18\x02\x0b\x04\x12\x04\xb6\x03\x02\n\n\r\n\x05\x04\x18\x02\x0b\x05\x12\
    \x04\xb6\x03\x0b\x10\n\r\n\x05\x04\x18\x02\x0b\x01\x12\x04\xb6\x03\x11&\
    \n\r\n\x05\x04\x18\x02\x0b\x03\x12\x04\xb6\x03)+\n*\n\x04\x04\x18\x02\
    \x0c\x12\x04\xba\x03\x02\"\x1a\x1c\x20BGPRouter\x20type.\n\x20+optional\
    \n\n\r\n\x05\x04\x18\x02\x0c\x04\x12\x04\xba\x03\x02\n\n\r\n\x05\x04\x18\
    \x02\x0c\x05\x12\x04\xba\x03\x0b\x11\n\r\n\x05\x04\x18\x02\x0c\x01\x12\
    \x04\xba\x03\x12\x1c\n\r\n\x05\x04\x18\x02\x0c\x03\x12\x04\xba\x03\x1f!\
    \n\x87\x02\n\x04\x04\x18\x02\r\x12\x04\xc1\x03\x02&\x1a\xf8\x01\x20Gatew\
    ayAddress\x20field\x20is\x20used\x20only\x20for\x20router-type\x20bgpaas\
    -client.\n\x20It\x20holds\x20the\x20IPv4\x20gateway\x20address\x20for\
    \x20the\x20IPv4\x20subnet\x20from\x20which\x20the\n\x20client\x20has\x20\
    IP\x20address.\x20The\x20value\x20is\x20used\x20as\x20nexthop\x20when\
    \x20advertising\n\x20routes\x20to\x20the\x20client\x20via\x20bgp.\n\x20+\
    optional\n\n\r\n\x05\x04\x18\x02\r\x04\x12\x04\xc1\x03\x02\n\n\r\n\x05\
    \x04\x18\x02\r\x05\x12\x04\xc1\x03\x0b\x11\n\r\n\x05\x04\x18\x02\r\x01\
    \x12\x04\xc1\x03\x12\x20\n\r\n\x05\x04\x18\x02\r\x03\x12\x04\xc1\x03#%\n\
    \xe3\x02\n\x04\x04\x18\x02\x0e\x12\x04\xca\x03\x02*\x1a\xd4\x02\x20IPv6G\
    atewayAddress\x20field\x20is\x20used\x20only\x20for\x20router-type\x20bg\
    paas-client\n\x20It\x20holds\x20IPv6\x20gateway\x20address\x20for\x20IPv\
    6\x20subnet\x20from\x20which\x20the\x20client\x20has\n\x20IP\x20address.\
    \x20The\x20value\x20is\x20used\x20as\x20nexthop\x20when\x20advertising\
    \x20routes\x20to\x20the\n\x20client\x20via\x20bgp.\n\x20Note\x20that\x20\
    the\x20IPv6GatewayAddress\x20can\x20be\x20a\x20regular\x20IPv6\x20addres\
    s\x20or\x20a\n\x20ipv4-mapped-ipv6\x20adddress.\n\x20+optional\n\n\r\n\
    \x05\x04\x18\x02\x0e\x04\x12\x04\xca\x03\x02\n\n\r\n\x05\x04\x18\x02\x0e\
    \x05\x12\x04\xca\x03\x0b\x11\n\r\n\x05\x04\x18\x02\x0e\x01\x12\x04\xca\
    \x03\x12$\n\r\n\x05\x04\x18\x02\x0e\x03\x12\x04\xca\x03')\n^\n\x02\x04\
    \x19\x12\x06\xce\x03\0\xd6\x03\x01\x1aP\x20BGPRouterReference\x20contain\
    s\x20BGP\x20Router\x20peering\x20and\x20its\x20session\x20configurations\
    .\n\n\x0b\n\x03\x04\x19\x01\x12\x04\xce\x03\x08\x1a\nC\n\x04\x04\x19\x02\
    \0\x12\x04\xd1\x03\x023\x1a5\x20ResourceReference\x20for\x20BGPRouter\
    \x20resource\n\x20+optional\n\n\r\n\x05\x04\x19\x02\0\x04\x12\x04\xd1\
    \x03\x02\n\n\r\n\x05\x04\x19\x02\0\x06\x12\x04\xd1\x03\x0b\x1c\n\r\n\x05\
    \x04\x19\x02\0\x01\x12\x04\xd1\x03\x1d.\n\r\n\x05\x04\x19\x02\0\x03\x12\
    \x04\xd1\x0312\nP\n\x04\x04\x19\x02\x01\x12\x04\xd5\x03\x027\x1aB\x20att\
    ributes\x20configuration\x20for\x20the\x20BGPRouter\x20reference.\n\x20+\
    optional\n\n\r\n\x05\x04\x19\x02\x01\x04\x12\x04\xd5\x03\x02\n\n\r\n\x05\
    \x04\x19\x02\x01\x06\x12\x04\xd5\x03\x0b'\n\r\n\x05\x04\x19\x02\x01\x01\
    \x12\x04\xd5\x03(2\n\r\n\x05\x04\x19\x02\x01\x03\x12\x04\xd5\x0356\n\x7f\
    \n\x02\x04\x1a\x12\x06\xd9\x03\0\xdf\x03\x01\x1aq\x20BGPRouterReferenceA\
    ttributes\x20defines\x20the\x20attributes\x20for\x201\x20(typically)\x20\
    or\x20more\x20sessions\x20between\x20two\x20BGP\x20Routers.\n\n\x0b\n\
    \x03\x04\x1a\x01\x12\x04\xd9\x03\x08$\n\xaf\x01\n\x04\x04\x1a\x02\0\x12\
    \x04\xde\x03\x02\"\x1a\xa0\x01\x20Seesion\x20is\x20a\x20list\x20of\x20BG\
    P\x20sessions\x20parameters.\n\x20There\x20can\x20be\x20multiple\x20BGP\
    \x20sessions\x20between\x20two\x20BGP\x20routers.\n\x20Currently,\x20onl\
    y\x201\x20session\x20is\x20supported.\n\x20+optional\n\n\r\n\x05\x04\x1a\
    \x02\0\x04\x12\x04\xde\x03\x02\n\n\r\n\x05\x04\x1a\x02\0\x06\x12\x04\xde\
    \x03\x0b\x15\n\r\n\x05\x04\x1a\x02\0\x01\x12\x04\xde\x03\x16\x1d\n\r\n\
    \x05\x04\x1a\x02\0\x03\x12\x04\xde\x03\x20!\nD\n\x02\x04\x1b\x12\x06\xe2\
    \x03\0\xf0\x03\x01\x1a6\x20BGPRouterSpec\x20defines\x20the\x20desired\
    \x20state\x20of\x20BGPRouter\n\n\x0b\n\x03\x04\x1b\x01\x12\x04\xe2\x03\
    \x08\x15\n\"\n\x04\x04\x1b\x02\0\x12\x04\xe4\x03\x02%\x1a\x14\x20Common\
    \x20spec\x20fields\n\n\r\n\x05\x04\x1b\x02\0\x04\x12\x04\xe4\x03\x02\n\n\
    \r\n\x05\x04\x1b\x02\0\x06\x12\x04\xe4\x03\x0b\x15\n\r\n\x05\x04\x1b\x02\
    \0\x01\x12\x04\xe4\x03\x16\x20\n\r\n\x05\x04\x1b\x02\0\x03\x12\x04\xe4\
    \x03#$\n;\n\x04\x04\x1b\x02\x01\x12\x04\xe7\x03\x029\x1a-\x20Object\x20r\
    eference\x20to\x20routing-instance\x20parent\n\n\r\n\x05\x04\x1b\x02\x01\
    \x04\x12\x04\xe7\x03\x02\n\n\r\n\x05\x04\x1b\x02\x01\x06\x12\x04\xe7\x03\
    \x0b-\n\r\n\x05\x04\x1b\x02\x01\x01\x12\x04\xe7\x03.4\n\r\n\x05\x04\x1b\
    \x02\x01\x03\x12\x04\xe7\x0378\nd\n\x04\x04\x1b\x02\x02\x12\x04\xeb\x03\
    \x026\x1aV\x20BGPRouterReferences\x20list\x20of\x20references\x20to\x20a\
    ll\x20bgp\x20routers\x20in\x20the\x20cluster.\n\x20+optional\n\n\r\n\x05\
    \x04\x1b\x02\x02\x04\x12\x04\xeb\x03\x02\n\n\r\n\x05\x04\x1b\x02\x02\x06\
    \x12\x04\xeb\x03\x0b\x1d\n\r\n\x05\x04\x1b\x02\x02\x01\x12\x04\xeb\x03\
    \x1e1\n\r\n\x05\x04\x1b\x02\x02\x03\x12\x04\xeb\x0345\ni\n\x04\x04\x1b\
    \x02\x03\x12\x04\xef\x03\x027\x1a[\x20BGP\x20router\x20configuration\x20\
    parameters\x20like\x20IP\x20address,\x20AS\x20number,\x20hold\x20time\
    \x20etc.\n\x20+optional\n\n\r\n\x05\x04\x1b\x02\x03\x04\x12\x04\xef\x03\
    \x02\n\n\r\n\x05\x04\x1b\x02\x03\x06\x12\x04\xef\x03\x0b\x1e\n\r\n\x05\
    \x04\x1b\x02\x03\x01\x12\x04\xef\x03\x1f2\n\r\n\x05\x04\x1b\x02\x03\x03\
    \x12\x04\xef\x0356\nG\n\x02\x04\x1c\x12\x06\xf3\x03\0\xf6\x03\x01\x1a9\
    \x20BGPRouterStatus\x20defines\x20the\x20observed\x20state\x20of\x20BGPR\
    outer\n\n\x0b\n\x03\x04\x1c\x01\x12\x04\xf3\x03\x08\x17\n$\n\x04\x04\x1c\
    \x02\0\x12\x04\xf5\x03\x02)\x1a\x16\x20Common\x20status\x20fields\n\n\r\
    \n\x05\x04\x1c\x02\0\x04\x12\x04\xf5\x03\x02\n\n\r\n\x05\x04\x1c\x02\0\
    \x06\x12\x04\xf5\x03\x0b\x17\n\r\n\x05\x04\x1c\x02\0\x01\x12\x04\xf5\x03\
    \x18$\n\r\n\x05\x04\x1c\x02\0\x03\x12\x04\xf5\x03'(\nm\n\x02\x04\x1d\x12\
    \x06\xf9\x03\0\xff\x03\x01\x1a_\x20BGPSession\x20defines\x20the\x20attri\
    butes\x20for\x201\x20(typically)\x20or\x20more\x20sessions\x20between\
    \x20two\x20BGP\x20Routers.\n\n\x0b\n\x03\x04\x1d\x01\x12\x04\xf9\x03\x08\
    \x12\n\xd1\x01\n\x04\x04\x1d\x02\0\x12\x04\xfe\x03\x026\x1a\xc2\x01\x20T\
    here\x20can\x20be\x20up\x20to\x203\x20instances\x20BGP\x20session\x20att\
    ributes,\n\x20representing\x20configuration\x20for\x20both\x20ends\x20an\
    d\x20common.\n\x20Currently,\x20only\x201\x20instance\x20representing\
    \x20common\x20attributes\x20is\x20supported.\n\x20+optional\n\n\r\n\x05\
    \x04\x1d\x02\0\x04\x12\x04\xfe\x03\x02\n\n\r\n\x05\x04\x1d\x02\0\x06\x12\
    \x04\xfe\x03\x0b\x1f\n\r\n\x05\x04\x1d\x02\0\x01\x12\x04\xfe\x03\x201\n\
    \r\n\x05\x04\x1d\x02\0\x03\x12\x04\xfe\x0345\nV\n\x02\x04\x1e\x12\x06\
    \x82\x04\0\xc0\x04\x01\x1aH\x20BGPSessionAttributes\x20defines\x20the\
    \x20BGP\x20session\x20parameters\x20configuration.\n\n\x0b\n\x03\x04\x1e\
    \x01\x12\x04\x82\x04\x08\x1c\n\xcc\x01\n\x04\x04\x1e\x02\0\x12\x04\x87\
    \x04\x02\x20\x1a\xbd\x01\x20When\x20the\x20parameters\x20are\x20uni-dire\
    ctional\x20the\x20bgp-router\x20element\x20specifies\n\x20to\x20which\
    \x20node\x20the\x20configuration\x20applies.\x20If\x20missing\x20the\x20\
    attributes\x20apply\n\x20to\x20both\x20ends\x20of\x20the\x20session.\n\
    \x20+optional\n\n\r\n\x05\x04\x1e\x02\0\x04\x12\x04\x87\x04\x02\n\n\r\n\
    \x05\x04\x1e\x02\0\x05\x12\x04\x87\x04\x0b\x11\n\r\n\x05\x04\x1e\x02\0\
    \x01\x12\x04\x87\x04\x12\x1b\n\r\n\x05\x04\x1e\x02\0\x03\x12\x04\x87\x04\
    \x1e\x1f\nC\n\x04\x04\x1e\x02\x01\x12\x04\x8b\x04\x02\x1e\x1a5\x20Admini\
    stratively\x20mark\x20this\x20session\x20down.\n\x20+optional\n\n\r\n\
    \x05\x04\x1e\x02\x01\x04\x12\x04\x8b\x04\x02\n\n\r\n\x05\x04\x1e\x02\x01\
    \x05\x12\x04\x8b\x04\x0b\x0f\n\r\n\x05\x04\x1e\x02\x01\x01\x12\x04\x8b\
    \x04\x10\x19\n\r\n\x05\x04\x1e\x02\x01\x03\x12\x04\x8b\x04\x1c\x1d\n\xe4\
    \x01\n\x04\x04\x1e\x02\x02\x12\x04\x91\x04\x02\x1c\x1a\xd5\x01\x20This\
    \x20is\x20passive\x20session.\x20It\x20will\x20not\x20initiated\x20conne\
    ction.\n\x20This\x20is\x20not\x20relevant\x20when\x20session\x20attribut\
    es\x20represent\x20common\x20part.\n\x20It\x20is\x20recommended\x20that\
    \x20it\x20should\x20not\x20be\x20set\x20to\x20true\x20in\x20current\x20r\
    elease.\n\x20+optional\n\n\r\n\x05\x04\x1e\x02\x02\x04\x12\x04\x91\x04\
    \x02\n\n\r\n\x05\x04\x1e\x02\x02\x05\x12\x04\x91\x04\x0b\x0f\n\r\n\x05\
    \x04\x1e\x02\x02\x01\x12\x04\x91\x04\x10\x17\n\r\n\x05\x04\x1e\x02\x02\
    \x03\x12\x04\x91\x04\x1a\x1b\n\x85\x01\n\x04\x04\x1e\x02\x03\x12\x04\x96\
    \x04\x02\x1f\x1aw\x20ASOverride\x20flag\x20is\x20used\x20to\x20replace\
    \x20the\x20AS\x20number\x20of\x20the\n\x20control\x20node\x20with\x20the\
    \x20AS\x20number\x20of\x20the\x20tenant\x20VM.\n\x20+optional\n\n\r\n\
    \x05\x04\x1e\x02\x03\x04\x12\x04\x96\x04\x02\n\n\r\n\x05\x04\x1e\x02\x03\
    \x05\x12\x04\x96\x04\x0b\x0f\n\r\n\x05\x04\x1e\x02\x03\x01\x12\x04\x96\
    \x04\x10\x1a\n\r\n\x05\x04\x1e\x02\x03\x03\x12\x04\x96\x04\x1d\x1e\n\xc2\
    \x01\n\x04\x04\x1e\x02\x04\x12\x04\x9c\x04\x02\x1e\x1a\xb3\x01\x20A\x20n\
    on-zero\x20hold-time\x20overrides\x20the\x20hold-time\x20inherited\x20fr\
    om\x20the\n\x20bgp-router\x20configuration.\x20BGP\x20hold\x20time\x20in\
    \x20seconds\x20[0-65535],\n\x20Max\x20time\x20to\x20detect\x20liveliness\
    \x20of\x20peer.\n\x20+optional\n\n\r\n\x05\x04\x1e\x02\x04\x04\x12\x04\
    \x9c\x04\x02\n\n\r\n\x05\x04\x1e\x02\x04\x05\x12\x04\x9c\x04\x0b\x10\n\r\
    \n\x05\x04\x1e\x02\x04\x01\x12\x04\x9c\x04\x11\x19\n\r\n\x05\x04\x1e\x02\
    \x04\x03\x12\x04\x9c\x04\x1c\x1d\n\x8b\x01\n\x04\x04\x1e\x02\x05\x12\x04\
    \xa1\x04\x02\x1f\x1a}\x20For\x20routing\x20loop\x20detection,\x20loop-co\
    unt\x20is\x20the\x20number\x20of\x20times\n\x20the\x20local\x20AS\x20is\
    \x20allowed\x20in\x20the\x20AS_PATH\x20attribute.\n\x20+optional\n\n\r\n\
    \x05\x04\x1e\x02\x05\x04\x12\x04\xa1\x04\x02\n\n\r\n\x05\x04\x1e\x02\x05\
    \x05\x12\x04\xa1\x04\x0b\x10\n\r\n\x05\x04\x1e\x02\x05\x01\x12\x04\xa1\
    \x04\x11\x1a\n\r\n\x05\x04\x1e\x02\x05\x03\x12\x04\xa1\x04\x1d\x1e\n\xd9\
    \x01\n\x04\x04\x1e\x02\x06\x12\x04\xa7\x04\x02+\x1a\xca\x01\x20Local\x20\
    autonomous\x20system\x20number\x20used\x20for\x20this\x20particular\x20s\
    ession.\n\x20If\x20configured,\x20this\x20overrides\x20autonomous-system\
    \x20number\x20and\n\x20local-autonomous-system\x20number\x20configured\
    \x20under\x20BgpRouterParams\n\x20+optional\n\n\r\n\x05\x04\x1e\x02\x06\
    \x04\x12\x04\xa7\x04\x02\n\n\r\n\x05\x04\x1e\x02\x06\x05\x12\x04\xa7\x04\
    \x0b\x10\n\r\n\x05\x04\x1e\x02\x06\x01\x12\x04\xa7\x04\x11&\n\r\n\x05\
    \x04\x1e\x02\x06\x03\x12\x04\xa7\x04)*\n\xdd\x01\n\x04\x04\x1e\x02\x07\
    \x12\x04\xae\x04\x02/\x1a\xce\x01\x20BGP\x20address\x20families\x20suppo\
    rted\x20on\x20this\x20session.\x20If\x20not\x20specified\n\x20these\x20a\
    ddress\x20families\x20are\x20enabled:\n\x20\"inet,\x20inet-labeled,\x20i\
    net-vpn,\x20e-vpn,\x20erm-vpn,\x20route-target,\x20inet6,\n\x20inet-mvpn\
    ,\x20inet6-vpn\"\n\x20+optional\n\n\r\n\x05\x04\x1e\x02\x07\x04\x12\x04\
    \xae\x04\x02\n\n\r\n\x05\x04\x1e\x02\x07\x06\x12\x04\xae\x04\x0b\x1a\n\r\
    \n\x05\x04\x1e\x02\x07\x01\x12\x04\xae\x04\x1b*\n\r\n\x05\x04\x1e\x02\
    \x07\x03\x12\x04\xae\x04-.\n\x88\x01\n\x04\x04\x1e\x02\x08\x12\x04\xb3\
    \x04\x02+\x1az\x20Authentication\x20related\x20configuration\x20for\x20t\
    his\x20session\x20like\x20type,\x20keys.\n\x20Only\x20md5\x20authenticat\
    ion\x20is\x20supported.\n\x20+optional\n\n\r\n\x05\x04\x1e\x02\x08\x04\
    \x12\x04\xb3\x04\x02\n\n\r\n\x05\x04\x1e\x02\x08\x06\x12\x04\xb3\x04\x0b\
    \x1d\n\r\n\x05\x04\x1e\x02\x08\x01\x12\x04\xb3\x04\x1e&\n\r\n\x05\x04\
    \x1e\x02\x08\x03\x12\x04\xb3\x04)*\n\x8c\x01\n\x04\x04\x1e\x02\t\x12\x04\
    \xb7\x04\x025\x1a~\x20Session\x20attributes\x20over\x20ride\x20per\x20BG\
    P\x20address\x20family.\x20Attributes\x20like\x20address\x20family,\x20l\
    oop-count\x20and\x20prefix-limit.\n\x20+optional\n\n\r\n\x05\x04\x1e\x02\
    \t\x04\x12\x04\xb7\x04\x02\n\n\r\n\x05\x04\x1e\x02\t\x06\x12\x04\xb7\x04\
    \x0b\x1e\n\r\n\x05\x04\x1e\x02\t\x01\x12\x04\xb7\x04\x1f/\n\r\n\x05\x04\
    \x1e\x02\t\x03\x12\x04\xb7\x0424\nm\n\x04\x04\x1e\x02\n\x12\x04\xbb\x04\
    \x02'\x1a_\x20Remove\x20or\x20replace\x20private\x20ASes\x20from\x20AS\
    \x20Path\x20attributes\x20advertised\x20to\x20this\x20session.\n\x20+opt\
    ional\n\n\r\n\x05\x04\x1e\x02\n\x04\x12\x04\xbb\x04\x02\n\n\r\n\x05\x04\
    \x1e\x02\n\x05\x12\x04\xbb\x04\x0b\x11\n\r\n\x05\x04\x1e\x02\n\x01\x12\
    \x04\xbb\x04\x12!\n\r\n\x05\x04\x1e\x02\n\x03\x12\x04\xbb\x04$&\nF\n\x04\
    \x04\x1e\x02\x0b\x12\x04\xbf\x04\x028\x1a8\x20User\x20defined\x20route\
    \x20origin\x20value\x20to\x20override\n\x20+optional\n\n\r\n\x05\x04\x1e\
    \x02\x0b\x04\x12\x04\xbf\x04\x02\n\n\r\n\x05\x04\x1e\x02\x0b\x06\x12\x04\
    \xbf\x04\x0b\x1e\n\r\n\x05\x04\x1e\x02\x0b\x01\x12\x04\xbf\x04\x1f2\n\r\
    \n\x05\x04\x1e\x02\x0b\x03\x12\x04\xbf\x0457\n^\n\x02\x04\x1f\x12\x06\
    \xc3\x04\0\xcc\x04\x01\x1aP\x20BGPSessionIPAttributes\x20contains\x20BGP\
    Session\x20primary\x20and\x20secondary\x20IP\x20addresses.\n\n\x0b\n\x03\
    \x04\x1f\x01\x12\x04\xc3\x04\x08\x1e\na\n\x04\x04\x1f\x02\0\x12\x04\xc6\
    \x04\x02&\x1aS\x20BGPaaSPrimaryIP\x20defines\x20the\x20primary\x20IP\x20\
    address\x20used\x20for\x20a\x20BGP\x20session.\n\x20+optional\n\n\r\n\
    \x05\x04\x1f\x02\0\x04\x12\x04\xc6\x04\x02\n\n\r\n\x05\x04\x1f\x02\0\x05\
    \x12\x04\xc6\x04\x0b\x11\n\r\n\x05\x04\x1f\x02\0\x01\x12\x04\xc6\x04\x12\
    !\n\r\n\x05\x04\x1f\x02\0\x03\x12\x04\xc6\x04$%\n\x8c\x01\n\x04\x04\x1f\
    \x02\x01\x12\x04\xcb\x04\x02(\x1a~\x20BGPaaSSecondaryIP\x20defines\x20th\
    e\x20secondary\x20IP\x20address\x20used\x20for\x20a\x20BGP\x20session\n\
    \x20when\x20a\x20second\x20control\x20node\x20is\x20present.\n\x20+optio\
    nal\n\n\r\n\x05\x04\x1f\x02\x01\x04\x12\x04\xcb\x04\x02\n\n\r\n\x05\x04\
    \x1f\x02\x01\x05\x12\x04\xcb\x04\x0b\x11\n\r\n\x05\x04\x1f\x02\x01\x01\
    \x12\x04\xcb\x04\x12#\n\r\n\x05\x04\x1f\x02\x01\x03\x12\x04\xcb\x04&'\nd\
    \n\x02\x04\x20\x12\x06\xcf\x04\0\xd1\x04\x01\x1aV\x20CommonSpec\x20conta\
    ins\x20Contrail\x20resource\x20fields\x20all\x20types\x20must\x20impleme\
    nt\x20in\x20their\x20spec.\n\n\x0b\n\x03\x04\x20\x01\x12\x04\xcf\x04\x08\
    \x12\n\x0c\n\x04\x04\x20\x02\0\x12\x04\xd0\x04\x02-\n\r\n\x05\x04\x20\
    \x02\0\x04\x12\x04\xd0\x04\x02\n\n\r\n\x05\x04\x20\x02\0\x06\x12\x04\xd0\
    \x04\x0b\x19\n\r\n\x05\x04\x20\x02\0\x01\x12\x04\xd0\x04\x1a(\n\r\n\x05\
    \x04\x20\x02\0\x03\x12\x04\xd0\x04+,\ng\n\x02\x04!\x12\x06\xd4\x04\0\xd6\
    \x04\x01\x1aY\x20CommonStatus\x20contains\x20Contrail\x20resource\x20fie\
    lds\x20all\x20types\x20must\x20implement\x20in\x20their\x20status\n\n\
    \x0b\n\x03\x04!\x01\x12\x04\xd4\x04\x08\x14\n\x0c\n\x04\x04!\x02\0\x12\
    \x04\xd5\x04\x02/\n\r\n\x05\x04!\x02\0\x04\x12\x04\xd5\x04\x02\n\n\r\n\
    \x05\x04!\x02\0\x06\x12\x04\xd5\x04\x0b\x1a\n\r\n\x05\x04!\x02\0\x01\x12\
    \x04\xd5\x04\x1b*\n\r\n\x05\x04!\x02\0\x03\x12\x04\xd5\x04-.\nk\n\x02\
    \x04\"\x12\x06\xda\x04\0\xde\x04\x01\x1a]\x20ContrailFqName\x20contains\
    \x20the\x20specific\x20FqName\x20field\x20necessary\x20for\x20the\x20Con\
    trail\n\x20Control-node.\n\n\x0b\n\x03\x04\"\x01\x12\x04\xda\x04\x08\x16\
    \ng\n\x04\x04\"\x02\0\x12\x04\xdd\x04\x02\x1d\x1aY\x20FqName\x20is\x20th\
    e\x20list\x20of\x20resource\x20names\x20that\x20fully\x20qualify\x20a\
    \x20Contrail\x20resource.\n\x20+optional\n\n\r\n\x05\x04\"\x02\0\x04\x12\
    \x04\xdd\x04\x02\n\n\r\n\x05\x04\"\x02\0\x05\x12\x04\xdd\x04\x0b\x11\n\r\
    \n\x05\x04\"\x02\0\x01\x12\x04\xdd\x04\x12\x18\n\r\n\x05\x04\"\x02\0\x03\
    \x12\x04\xdd\x04\x1b\x1c\ny\n\x02\x04#\x12\x06\xe2\x04\0\xe7\x04\x01\x1a\
    k\x20EncapsulationPriorities\x20is\x20an\x20ordered\x20list\x20of\x20enc\
    apsulation\x20types\x20to\x20be\n\x20used\x20in\x20priority\x20by\x20the\
    \x20vrouter.\n\n\x0b\n\x03\x04#\x01\x12\x04\xe2\x04\x08\x1f\n\xb2\x01\n\
    \x04\x04#\x02\0\x12\x04\xe6\x04\x02$\x1a\xa3\x01\x20Encapsulation\x20is\
    \x20an\x20ordered\x20list\x20of\x20encapsulation\x20types\x20to\x20be\
    \x20used\x20in\n\x20priority\x20by\x20the\x20vrouter.\x20Valid\x20encaps\
    ulation\x20types\x20include\x20MPLSoGRE,\x20MPLSoUDP,\n\x20and\x20VXLAN.\
    \n\n\r\n\x05\x04#\x02\0\x04\x12\x04\xe6\x04\x02\n\n\r\n\x05\x04#\x02\0\
    \x05\x12\x04\xe6\x04\x0b\x11\n\r\n\x05\x04#\x02\0\x01\x12\x04\xe6\x04\
    \x12\x1f\n\r\n\x05\x04#\x02\0\x03\x12\x04\xe6\x04\"#\nZ\n\x02\x04$\x12\
    \x06\xea\x04\0\xee\x04\x01\x1aL\x20FirewallActionListType\x20defines\x20\
    types\x20of\x20actions\x20performed\x20by\x20FirewallRule.\n\n\x0b\n\x03\
    \x04$\x01\x12\x04\xea\x04\x08\x1e\nw\n\x04\x04$\x02\0\x12\x04\xed\x04\
    \x02#\x1ai\x20SimpleAction\x20defines\x20allow(i.e.\x20pass)\x20or\x20de\
    ny\x20action\x20for\x20traffic\x20matching\x20this\x20FirewallRule.\n\
    \x20+optional\n\n\r\n\x05\x04$\x02\0\x04\x12\x04\xed\x04\x02\n\n\r\n\x05\
    \x04$\x02\0\x05\x12\x04\xed\x04\x0b\x11\n\r\n\x05\x04$\x02\0\x01\x12\x04\
    \xed\x04\x12\x1e\n\r\n\x05\x04$\x02\0\x03\x12\x04\xed\x04!\"\n\xd6\x01\n\
    \x02\x04%\x12\x06\xf3\x04\0\x85\x05\x01\x1a\xc7\x01\x20FirewallPolicy\
    \x20contains\x20references\x20to\x20ordered\x20FirewallRule\x20objects.\
    \n\x20+k8s:openapi-gen=true\n\x20+resource:path=firewallpolicies,strateg\
    y=FirewallPolicyStrategy,shortname=fp,categories=contrail;security\n\n\
    \x0b\n\x03\x04%\x01\x12\x04\xf3\x04\x08\x16\n\xa0\x01\n\x04\x04%\x02\0\
    \x12\x04\xf7\x04\x02H\x1a\x91\x01\x20Standard\x20object's\x20metadata.\n\
    \x20More\x20info:\x20https://git.k8s.io/community/contributors/devel/sig\
    -architecture/api-conventions.md#metadata\n\x20+optional\n\n\r\n\x05\x04\
    %\x02\0\x04\x12\x04\xf7\x04\x02\n\n\r\n\x05\x04%\x02\0\x06\x12\x04\xf7\
    \x04\x0b:\n\r\n\x05\x04%\x02\0\x01\x12\x04\xf7\x04;C\n\r\n\x05\x04%\x02\
    \0\x03\x12\x04\xf7\x04FG\n\xc5\x01\n\x04\x04%\x02\x01\x12\x04\xfc\x04\
    \x02'\x1a\xb6\x01\x20Specification\x20of\x20the\x20desired\x20state\x20o\
    f\x20the\x20FirewallPolicy.\n\x20More\x20info:\x20https://git.k8s.io/com\
    munity/contributors/devel/sig-architecture/api-conventions.md#spec-and-s\
    tatus\n\x20+optional\n\n\r\n\x05\x04%\x02\x01\x04\x12\x04\xfc\x04\x02\n\
    \n\r\n\x05\x04%\x02\x01\x06\x12\x04\xfc\x04\x0b\x1d\n\r\n\x05\x04%\x02\
    \x01\x01\x12\x04\xfc\x04\x1e\"\n\r\n\x05\x04%\x02\x01\x03\x12\x04\xfc\
    \x04%&\n\x8c\x02\n\x04\x04%\x02\x02\x12\x04\x84\x05\x02+\x1a\xfd\x01\x20\
    The\x20most\x20recently\x20observed\x20status\x20of\x20the\x20FirewallPo\
    licy.\n\x20This\x20data\x20may\x20not\x20be\x20up-to-date.\n\x20Populate\
    d\x20by\x20the\x20system.\n\x20Read-only.\n\x20More\x20info:\x20https://\
    git.k8s.io/community/contributors/devel/sig-architecture/api-conventions\
    .md#spec-and-status\n\x20+optional\n\n\r\n\x05\x04%\x02\x02\x04\x12\x04\
    \x84\x05\x02\n\n\r\n\x05\x04%\x02\x02\x06\x12\x04\x84\x05\x0b\x1f\n\r\n\
    \x05\x04%\x02\x02\x01\x12\x04\x84\x05\x20&\n\r\n\x05\x04%\x02\x02\x03\
    \x12\x04\x84\x05)*\n|\n\x02\x04&\x12\x06\x88\x05\0\x8d\x05\x01\x1an\x20F\
    irewallPolicyAttribute\x20defines\x20the\x20actual\x20Sequence\x20number\
    \x20of\x20a\x20FirewallRule\x20referenced\x20by\x20a\x20FirewallPolicy.\
    \n\n\x0b\n\x03\x04&\x01\x12\x04\x88\x05\x08\x1f\n\xb9\x01\n\x04\x04&\x02\
    \0\x12\x04\x8c\x05\x02\x1f\x1a\xaa\x01\x20Sequence\x20defines\x20the\x20\
    position\x20of\x20a\x20referenced\x20FirewallRule\x20within\x20the\x20ev\
    aluation\x20order\x20of\x20a\x20FirewallPolicy.\n\x20FirewallRules\x20ar\
    e\x20evaluated\x20in\x20descending\x20order.\n\x20+optional\n\n\r\n\x05\
    \x04&\x02\0\x04\x12\x04\x8c\x05\x02\n\n\r\n\x05\x04&\x02\0\x05\x12\x04\
    \x8c\x05\x0b\x11\n\r\n\x05\x04&\x02\0\x01\x12\x04\x8c\x05\x12\x1a\n\r\n\
    \x05\x04&\x02\0\x03\x12\x04\x8c\x05\x1d\x1e\n?\n\x02\x04'\x12\x06\x90\
    \x05\0\x98\x05\x01\x1a1\x20FirewallPolicyList\x20is\x20a\x20list\x20of\
    \x20FirewallPolicy.\n\n\x0b\n\x03\x04'\x01\x12\x04\x90\x05\x08\x1a\n\xac\
    \x01\n\x04\x04'\x02\0\x12\x04\x94\x05\x02F\x1a\x9d\x01\x20Standard\x20li\
    st's\x20metadata.\n\x20More\x20info:\x20https://git.k8s.io/community/con\
    tributors/devel/sig-architecture/api-conventions.md#lists-and-simple-kin\
    ds\n\x20+optional\n\n\r\n\x05\x04'\x02\0\x04\x12\x04\x94\x05\x02\n\n\r\n\
    \x05\x04'\x02\0\x06\x12\x04\x94\x05\x0b8\n\r\n\x05\x04'\x02\0\x01\x12\
    \x04\x94\x059A\n\r\n\x05\x04'\x02\0\x03\x12\x04\x94\x05DE\n]\n\x04\x04'\
    \x02\x01\x12\x04\x97\x05\x02$\x1aO\x20Items\x20contains\x20all\x20of\x20\
    the\x20FirewallPolicy\x20instances\x20in\x20the\x20FirewallPolicyList.\n\
    \n\r\n\x05\x04'\x02\x01\x04\x12\x04\x97\x05\x02\n\n\r\n\x05\x04'\x02\x01\
    \x06\x12\x04\x97\x05\x0b\x19\n\r\n\x05\x04'\x02\x01\x01\x12\x04\x97\x05\
    \x1a\x1f\n\r\n\x05\x04'\x02\x01\x03\x12\x04\x97\x05\"#\n\x85\x01\n\x02\
    \x04(\x12\x06\x9b\x05\0\xa1\x05\x01\x1aw\x20FirewallPolicyReference\x20i\
    s\x20a\x20ResourceReference\x20to\x20a\x20FirewallPolicy\x20with\x20APSA\
    ttributes\x20containing\x20the\x20Sequence\x20number.\n\n\x0b\n\x03\x04(\
    \x01\x12\x04\x9b\x05\x08\x1f\nN\n\x04\x04(\x02\0\x12\x04\x9d\x05\x023\
    \x1a@\x20ResourceReference\x20to\x20FirewallPolicy\x20from\x20Applicatio\
    nPolicySet.\n\n\r\n\x05\x04(\x02\0\x04\x12\x04\x9d\x05\x02\n\n\r\n\x05\
    \x04(\x02\0\x06\x12\x04\x9d\x05\x0b\x1c\n\r\n\x05\x04(\x02\0\x01\x12\x04\
    \x9d\x05\x1d.\n\r\n\x05\x04(\x02\0\x03\x12\x04\x9d\x0512\np\n\x04\x04(\
    \x02\x01\x12\x04\xa0\x05\x02'\x1ab\x20Attribute\x20defines\x20the\x20seq\
    uence\x20number\x20of\x20a\x20FirewallPolicy\x20in\x20[a\x20given|the]\
    \x20ApplicationPolicySet.\n\n\r\n\x05\x04(\x02\x01\x04\x12\x04\xa0\x05\
    \x02\n\n\r\n\x05\x04(\x02\x01\x06\x12\x04\xa0\x05\x0b\x17\n\r\n\x05\x04(\
    \x02\x01\x01\x12\x04\xa0\x05\x18\"\n\r\n\x05\x04(\x02\x01\x03\x12\x04\
    \xa0\x05%&\nO\n\x02\x04)\x12\x06\xa4\x05\0\xab\x05\x01\x1aA\x20FirewallP\
    olicySpec\x20defines\x20the\x20desired\x20state\x20of\x20FirewallPolicy.\
    \n\n\x0b\n\x03\x04)\x01\x12\x04\xa4\x05\x08\x1a\n\"\n\x04\x04)\x02\0\x12\
    \x04\xa6\x05\x02%\x1a\x14\x20Common\x20spec\x20fields\n\n\r\n\x05\x04)\
    \x02\0\x04\x12\x04\xa6\x05\x02\n\n\r\n\x05\x04)\x02\0\x06\x12\x04\xa6\
    \x05\x0b\x15\n\r\n\x05\x04)\x02\0\x01\x12\x04\xa6\x05\x16\x20\n\r\n\x05\
    \x04)\x02\0\x03\x12\x04\xa6\x05#$\n\x80\x01\n\x04\x04)\x02\x01\x12\x04\
    \xaa\x05\x022\x1ar\x20FirewallRuleReferences\x20contains\x20references\
    \x20to\x20FirewallRule\x20instances\x20attached\x20to\x20this\x20Firewal\
    lPolicy.\n\x20+optional\n\n\r\n\x05\x04)\x02\x01\x04\x12\x04\xaa\x05\x02\
    \n\n\r\n\x05\x04)\x02\x01\x06\x12\x04\xaa\x05\x0b\x20\n\r\n\x05\x04)\x02\
    \x01\x01\x12\x04\xaa\x05!-\n\r\n\x05\x04)\x02\x01\x03\x12\x04\xaa\x0501\
    \nR\n\x02\x04*\x12\x06\xae\x05\0\xb1\x05\x01\x1aD\x20FirewallPolicyStatu\
    s\x20defines\x20the\x20observed\x20state\x20of\x20FirewallPolicy.\n\n\
    \x0b\n\x03\x04*\x01\x12\x04\xae\x05\x08\x1c\n$\n\x04\x04*\x02\0\x12\x04\
    \xb0\x05\x02)\x1a\x16\x20Common\x20status\x20fields\n\n\r\n\x05\x04*\x02\
    \0\x04\x12\x04\xb0\x05\x02\n\n\r\n\x05\x04*\x02\0\x06\x12\x04\xb0\x05\
    \x0b\x17\n\r\n\x05\x04*\x02\0\x01\x12\x04\xb0\x05\x18$\n\r\n\x05\x04*\
    \x02\0\x03\x12\x04\xb0\x05'(\n\x82\x02\n\x02\x04+\x12\x06\xb7\x05\0\xc9\
    \x05\x01\x1a\xf3\x01\x20FirewallRule\x20defines\x20how\x20traffic\x20is\
    \x20allowed\x20or\x20blocked\x20based\x20on\x20rules\n\x20with\x20help\
    \x20of\x20various\x20match\x20and\x20action\x20fields.\n\x20+k8s:openapi\
    -gen=true\n\x20+resource:path=firewallrules,strategy=FirewallRuleStrateg\
    y,shortname=fr,categories=contrail;security\n\n\x0b\n\x03\x04+\x01\x12\
    \x04\xb7\x05\x08\x14\n\xa0\x01\n\x04\x04+\x02\0\x12\x04\xbb\x05\x02H\x1a\
    \x91\x01\x20Standard\x20object's\x20metadata.\n\x20More\x20info:\x20http\
    s://git.k8s.io/community/contributors/devel/sig-architecture/api-convent\
    ions.md#metadata\n\x20+optional\n\n\r\n\x05\x04+\x02\0\x04\x12\x04\xbb\
    \x05\x02\n\n\r\n\x05\x04+\x02\0\x06\x12\x04\xbb\x05\x0b:\n\r\n\x05\x04+\
    \x02\0\x01\x12\x04\xbb\x05;C\n\r\n\x05\x04+\x02\0\x03\x12\x04\xbb\x05FG\
    \n\xc3\x01\n\x04\x04+\x02\x01\x12\x04\xc0\x05\x02%\x1a\xb4\x01\x20Specif\
    ication\x20of\x20the\x20desired\x20state\x20of\x20the\x20FirewallRule.\n\
    \x20More\x20info:\x20https://git.k8s.io/community/contributors/devel/sig\
    -architecture/api-conventions.md#spec-and-status\n\x20+optional\n\n\r\n\
    \x05\x04+\x02\x01\x04\x12\x04\xc0\x05\x02\n\n\r\n\x05\x04+\x02\x01\x06\
    \x12\x04\xc0\x05\x0b\x1b\n\r\n\x05\x04+\x02\x01\x01\x12\x04\xc0\x05\x1c\
    \x20\n\r\n\x05\x04+\x02\x01\x03\x12\x04\xc0\x05#$\n\x8a\x02\n\x04\x04+\
    \x02\x02\x12\x04\xc8\x05\x02)\x1a\xfb\x01\x20The\x20most\x20recently\x20\
    observed\x20status\x20of\x20the\x20FirewallRule.\n\x20This\x20data\x20ma\
    y\x20not\x20be\x20up-to-date.\n\x20Populated\x20by\x20the\x20system.\n\
    \x20Read-only.\n\x20More\x20info:\x20https://git.k8s.io/community/contri\
    butors/devel/sig-architecture/api-conventions.md#spec-and-status\n\x20+o\
    ptional\n\n\r\n\x05\x04+\x02\x02\x04\x12\x04\xc8\x05\x02\n\n\r\n\x05\x04\
    +\x02\x02\x06\x12\x04\xc8\x05\x0b\x1d\n\r\n\x05\x04+\x02\x02\x01\x12\x04\
    \xc8\x05\x1e$\n\r\n\x05\x04+\x02\x02\x03\x12\x04\xc8\x05'(\nB\n\x02\x04,\
    \x12\x06\xcc\x05\0\xe0\x05\x01\x1a4\x20FirewallRuleEndpointType\x20defin\
    es\x20the\x20EndpointType.\n\n\x0b\n\x03\x04,\x01\x12\x04\xcc\x05\x08\
    \x20\nC\n\x04\x04,\x02\0\x12\x04\xcf\x05\x02%\x1a5\x20Subnet\x20defines\
    \x20the\x20IP\x20prefix\x20and\x20length.\n\x20+optional\n\n\r\n\x05\x04\
    ,\x02\0\x04\x12\x04\xcf\x05\x02\n\n\r\n\x05\x04,\x02\0\x06\x12\x04\xcf\
    \x05\x0b\x19\n\r\n\x05\x04,\x02\0\x01\x12\x04\xcf\x05\x1a\x20\n\r\n\x05\
    \x04,\x02\0\x03\x12\x04\xcf\x05#$\nY\n\x04\x04,\x02\x01\x12\x04\xd3\x05\
    \x02#\x1aK\x20Addressgroup\x20defines\x20what\x20CIDR\x20FirewallRule\
    \x20can\x20be\x20applied\x20on.\n\x20+optional\n\n\r\n\x05\x04,\x02\x01\
    \x04\x12\x04\xd3\x05\x02\n\n\r\n\x05\x04,\x02\x01\x05\x12\x04\xd3\x05\
    \x0b\x11\n\r\n\x05\x04,\x02\x01\x01\x12\x04\xd3\x05\x12\x1e\n\r\n\x05\
    \x04,\x02\x01\x03\x12\x04\xd3\x05!\"\nA\n\x04\x04,\x02\x02\x12\x04\xd7\
    \x05\x02\x1b\x1a3\x20Tags\x20define\x20tags\x20for\x20the\x20FirewallRul\
    e.\n\x20+optional\n\n\r\n\x05\x04,\x02\x02\x04\x12\x04\xd7\x05\x02\n\n\r\
    \n\x05\x04,\x02\x02\x05\x12\x04\xd7\x05\x0b\x11\n\r\n\x05\x04,\x02\x02\
    \x01\x12\x04\xd7\x05\x12\x16\n\r\n\x05\x04,\x02\x02\x03\x12\x04\xd7\x05\
    \x19\x1a\nG\n\x04\x04,\x02\x03\x12\x04\xdb\x05\x02\x1c\x1a9\x20TagIds\
    \x20define\x20IDs\x20created\x20for\x20referred\x20Tags.\n\x20+optional\
    \n\n\r\n\x05\x04,\x02\x03\x04\x12\x04\xdb\x05\x02\n\n\r\n\x05\x04,\x02\
    \x03\x05\x12\x04\xdb\x05\x0b\x10\n\r\n\x05\x04,\x02\x03\x01\x12\x04\xdb\
    \x05\x11\x17\n\r\n\x05\x04,\x02\x03\x03\x12\x04\xdb\x05\x1a\x1b\nf\n\x04\
    \x04,\x02\x04\x12\x04\xdf\x05\x02\x18\x1aX\x20Any\x20defines\x20matching\
    \x20to\x20\"any\"\x20value\x20in\x20an\x20FirewallRuleEndpointType\x20.\
    \x20ie\x20\"*\"\n\x20+optional\n\n\r\n\x05\x04,\x02\x04\x04\x12\x04\xdf\
    \x05\x02\n\n\r\n\x05\x04,\x02\x04\x05\x12\x04\xdf\x05\x0b\x0f\n\r\n\x05\
    \x04,\x02\x04\x01\x12\x04\xdf\x05\x10\x13\n\r\n\x05\x04,\x02\x04\x03\x12\
    \x04\xdf\x05\x16\x17\n;\n\x02\x04-\x12\x06\xe3\x05\0\xeb\x05\x01\x1a-\
    \x20FirewallRuleList\x20is\x20a\x20list\x20of\x20FirewallRule.\n\n\x0b\n\
    \x03\x04-\x01\x12\x04\xe3\x05\x08\x18\n\xac\x01\n\x04\x04-\x02\0\x12\x04\
    \xe7\x05\x02F\x1a\x9d\x01\x20Standard\x20list's\x20metadata.\n\x20More\
    \x20info:\x20https://git.k8s.io/community/contributors/devel/sig-archite\
    cture/api-conventions.md#lists-and-simple-kinds\n\x20+optional\n\n\r\n\
    \x05\x04-\x02\0\x04\x12\x04\xe7\x05\x02\n\n\r\n\x05\x04-\x02\0\x06\x12\
    \x04\xe7\x05\x0b8\n\r\n\x05\x04-\x02\0\x01\x12\x04\xe7\x059A\n\r\n\x05\
    \x04-\x02\0\x03\x12\x04\xe7\x05DE\nY\n\x04\x04-\x02\x01\x12\x04\xea\x05\
    \x02\"\x1aK\x20Items\x20contains\x20all\x20of\x20the\x20FirewallRule\x20\
    instances\x20in\x20the\x20FirewallRuleList.\n\n\r\n\x05\x04-\x02\x01\x04\
    \x12\x04\xea\x05\x02\n\n\r\n\x05\x04-\x02\x01\x06\x12\x04\xea\x05\x0b\
    \x17\n\r\n\x05\x04-\x02\x01\x01\x12\x04\xea\x05\x18\x1d\n\r\n\x05\x04-\
    \x02\x01\x03\x12\x04\xea\x05\x20!\n\x8d\x01\n\x02\x04.\x12\x06\xee\x05\0\
    \xf6\x05\x01\x1a\x7f\x20FirewallRuleReference\x20is\x20a\x20ResourceRefe\
    rence\x20to\x20a\x20FirewallRule\x20with\x20a\x20FirewallPolicyAttribute\
    \x20containing\x20the\x20Sequence\x20Number.\n\n\x0b\n\x03\x04.\x01\x12\
    \x04\xee\x05\x08\x1d\nQ\n\x04\x04.\x02\0\x12\x04\xf1\x05\x023\x1aC\x20Re\
    sourceReference\x20to\x20FirewallRule\x20from\x20FirewallPolicy.\n\x20+o\
    ptional\n\n\r\n\x05\x04.\x02\0\x04\x12\x04\xf1\x05\x02\n\n\r\n\x05\x04.\
    \x02\0\x06\x12\x04\xf1\x05\x0b\x1c\n\r\n\x05\x04.\x02\0\x01\x12\x04\xf1\
    \x05\x1d.\n\r\n\x05\x04.\x02\0\x03\x12\x04\xf1\x0512\ns\n\x04\x04.\x02\
    \x01\x12\x04\xf5\x05\x022\x1ae\x20Attribute\x20defines\x20the\x20Sequenc\
    e\x20Number\x20of\x20a\x20FirewallRule\x20in\x20[a\x20given|the]\x20Fire\
    wallPolicy.\n\x20+optional\n\n\r\n\x05\x04.\x02\x01\x04\x12\x04\xf5\x05\
    \x02\n\n\r\n\x05\x04.\x02\x01\x06\x12\x04\xf5\x05\x0b\"\n\r\n\x05\x04.\
    \x02\x01\x01\x12\x04\xf5\x05#-\n\r\n\x05\x04.\x02\x01\x03\x12\x04\xf5\
    \x0501\n\x0c\n\x02\x04/\x12\x06\xf8\x05\0\x9f\x06\x01\n\x0b\n\x03\x04/\
    \x01\x12\x04\xf8\x05\x08\x18\n\"\n\x04\x04/\x02\0\x12\x04\xfa\x05\x02%\
    \x1a\x14\x20Common\x20spec\x20fields\n\n\r\n\x05\x04/\x02\0\x04\x12\x04\
    \xfa\x05\x02\n\n\r\n\x05\x04/\x02\0\x06\x12\x04\xfa\x05\x0b\x15\n\r\n\
    \x05\x04/\x02\0\x01\x12\x04\xfa\x05\x16\x20\n\r\n\x05\x04/\x02\0\x03\x12\
    \x04\xfa\x05#$\no\n\x04\x04/\x02\x01\x12\x04\xfe\x05\x027\x1aa\x20Addres\
    sGroupReference\x20refers\x20to\x20an\x20AddressGroup\x20defining\x20the\
    \x20CIDR\x20of\x20a\x20FirewallRule.\n\x20+optional\n\n\r\n\x05\x04/\x02\
    \x01\x04\x12\x04\xfe\x05\x02\n\n\r\n\x05\x04/\x02\x01\x06\x12\x04\xfe\
    \x05\x0b\x1c\n\r\n\x05\x04/\x02\x01\x01\x12\x04\xfe\x05\x1d2\n\r\n\x05\
    \x04/\x02\x01\x03\x12\x04\xfe\x0556\na\n\x04\x04/\x02\x02\x12\x04\x82\
    \x06\x021\x1aS\x20ActionList\x20defines\x20actions\x20to\x20be\x20perfor\
    med\x20if\x20packets\x20match\x20condition.\n\x20+optional\n\n\r\n\x05\
    \x04/\x02\x02\x04\x12\x04\x82\x06\x02\n\n\r\n\x05\x04/\x02\x02\x06\x12\
    \x04\x82\x06\x0b!\n\r\n\x05\x04/\x02\x02\x01\x12\x04\x82\x06\",\n\r\n\
    \x05\x04/\x02\x02\x03\x12\x04\x82\x06/0\nd\n\x04\x04/\x02\x03\x12\x04\
    \x86\x06\x02+\x1aV\x20Service\x20defines\x20the\x20service\x20(port,\x20\
    protocol)\x20for\x20packets\x20match\x20condition.\n\x20+optional\n\n\r\
    \n\x05\x04/\x02\x03\x04\x12\x04\x86\x06\x02\n\n\r\n\x05\x04/\x02\x03\x06\
    \x12\x04\x86\x06\x0b\x1e\n\r\n\x05\x04/\x02\x03\x01\x12\x04\x86\x06\x1f&\
    \n\r\n\x05\x04/\x02\x03\x03\x12\x04\x86\x06)*\nP\n\x04\x04/\x02\x04\x12\
    \x04\x8a\x06\x022\x1aB\x20Endpoint1\x20defines\x20match\x20condition\x20\
    for\x20source\x20traffic.\n\x20+optional\n\n\r\n\x05\x04/\x02\x04\x04\
    \x12\x04\x8a\x06\x02\n\n\r\n\x05\x04/\x02\x04\x06\x12\x04\x8a\x06\x0b#\n\
    \r\n\x05\x04/\x02\x04\x01\x12\x04\x8a\x06$-\n\r\n\x05\x04/\x02\x04\x03\
    \x12\x04\x8a\x0601\nU\n\x04\x04/\x02\x05\x12\x04\x8e\x06\x022\x1aG\x20En\
    dpoint2\x20defines\x20match\x20condition\x20for\x20destination\x20traffi\
    c.\n\x20+optional\n\n\r\n\x05\x04/\x02\x05\x04\x12\x04\x8e\x06\x02\n\n\r\
    \n\x05\x04/\x02\x05\x06\x12\x04\x8e\x06\x0b#\n\r\n\x05\x04/\x02\x05\x01\
    \x12\x04\x8e\x06$-\n\r\n\x05\x04/\x02\x05\x03\x12\x04\x8e\x0601\n`\n\x04\
    \x04/\x02\x06\x12\x04\x92\x06\x02\x20\x1aR\x20MatchTags\x20defines\x20ma\
    tching\x20tags\x20for\x20source\x20and\x20destination\x20endpoints.\n\
    \x20+optional\n\n\r\n\x05\x04/\x02\x06\x04\x12\x04\x92\x06\x02\n\n\r\n\
    \x05\x04/\x02\x06\x05\x12\x04\x92\x06\x0b\x11\n\r\n\x05\x04/\x02\x06\x01\
    \x12\x04\x92\x06\x12\x1b\n\r\n\x05\x04/\x02\x06\x03\x12\x04\x92\x06\x1e\
    \x1f\ni\n\x04\x04/\x02\x07\x12\x04\x96\x06\x02$\x1a[\x20MatchTagsTypes\
    \x20defines\x20matching\x20tags\x20ids\x20for\x20source\x20and\x20destin\
    ation\x20endpoints.\n\x20+optional\n\n\r\n\x05\x04/\x02\x07\x04\x12\x04\
    \x96\x06\x02\n\n\r\n\x05\x04/\x02\x07\x05\x12\x04\x96\x06\x0b\x10\n\r\n\
    \x05\x04/\x02\x07\x01\x12\x04\x96\x06\x11\x1f\n\r\n\x05\x04/\x02\x07\x03\
    \x12\x04\x96\x06\"#\nK\n\x04\x04/\x02\x08\x12\x04\x9a\x06\x02\x20\x1a=\
    \x20Direction\x20defines\x20direction\x20in\x20the\x20FirewallRule.\n\
    \x20+optional\n\n\r\n\x05\x04/\x02\x08\x04\x12\x04\x9a\x06\x02\n\n\r\n\
    \x05\x04/\x02\x08\x05\x12\x04\x9a\x06\x0b\x11\n\r\n\x05\x04/\x02\x08\x01\
    \x12\x04\x9a\x06\x12\x1b\n\r\n\x05\x04/\x02\x08\x03\x12\x04\x9a\x06\x1e\
    \x1f\nY\n\x04\x04/\x02\t\x12\x04\x9e\x06\x020\x1aK\x20TagReferences\x20r\
    efers\x20to\x20Tags\x20associated\x20with\x20the\x20FirewallRule.\n\x20+\
    optional\n\n\r\n\x05\x04/\x02\t\x04\x12\x04\x9e\x06\x02\n\n\r\n\x05\x04/\
    \x02\t\x06\x12\x04\x9e\x06\x0b\x1c\n\r\n\x05\x04/\x02\t\x01\x12\x04\x9e\
    \x06\x1d*\n\r\n\x05\x04/\x02\t\x03\x12\x04\x9e\x06-/\nN\n\x02\x040\x12\
    \x06\xa2\x06\0\xa5\x06\x01\x1a@\x20FirewallRuleStatus\x20defines\x20the\
    \x20observed\x20state\x20of\x20FirewallRule.\n\n\x0b\n\x03\x040\x01\x12\
    \x04\xa2\x06\x08\x1a\n$\n\x04\x040\x02\0\x12\x04\xa4\x06\x02)\x1a\x16\
    \x20Common\x20status\x20fields\n\n\r\n\x05\x040\x02\0\x04\x12\x04\xa4\
    \x06\x02\n\n\r\n\x05\x040\x02\0\x06\x12\x04\xa4\x06\x0b\x17\n\r\n\x05\
    \x040\x02\0\x01\x12\x04\xa4\x06\x18$\n\r\n\x05\x040\x02\0\x03\x12\x04\
    \xa4\x06'(\nB\n\x02\x041\x12\x06\xa8\x06\0\xb8\x06\x01\x1a4\x20FirewallS\
    erviceType\x20defines\x20the\x20Port\x20related\x20info.\n\n\x0b\n\x03\
    \x041\x01\x12\x04\xa8\x06\x08\x1b\nJ\n\x04\x041\x02\0\x12\x04\xab\x06\
    \x02\x1f\x1a<\x20Protocol\x20defines\x20Layer\x204\x20protocol\x20in\x20\
    IP\x20packet.\n\x20+optional\n\n\r\n\x05\x041\x02\0\x04\x12\x04\xab\x06\
    \x02\n\n\r\n\x05\x041\x02\0\x05\x12\x04\xab\x06\x0b\x11\n\r\n\x05\x041\
    \x02\0\x01\x12\x04\xab\x06\x12\x1a\n\r\n\x05\x041\x02\0\x03\x12\x04\xab\
    \x06\x1d\x1e\nO\n\x04\x041\x02\x01\x12\x04\xaf\x06\x02\x20\x1aA\x20Proto\
    colId\x20defines\x20Layer\x204\x20protocol\x20ID\x20in\x20IP\x20packet.\
    \n\x20+optional\n\n\r\n\x05\x041\x02\x01\x04\x12\x04\xaf\x06\x02\n\n\r\n\
    \x05\x041\x02\x01\x05\x12\x04\xaf\x06\x0b\x10\n\r\n\x05\x041\x02\x01\x01\
    \x12\x04\xaf\x06\x11\x1b\n\r\n\x05\x041\x02\x01\x03\x12\x04\xaf\x06\x1e\
    \x1f\ne\n\x04\x041\x02\x02\x12\x04\xb3\x06\x02$\x1aW\x20SourcePorts\x20d\
    efines\x20the\x20range\x20of\x20source\x20port\x20numbers\x20for\x20Laye\
    r\x204\x20Protocol.\n\x20+optional\n\n\r\n\x05\x041\x02\x02\x04\x12\x04\
    \xb3\x06\x02\n\n\r\n\x05\x041\x02\x02\x06\x12\x04\xb3\x06\x0b\x13\n\r\n\
    \x05\x041\x02\x02\x01\x12\x04\xb3\x06\x14\x1f\n\r\n\x05\x041\x02\x02\x03\
    \x12\x04\xb3\x06\"#\no\n\x04\x041\x02\x03\x12\x04\xb7\x06\x02)\x1aa\x20D\
    estinationPorts\x20defines\x20the\x20range\x20of\x20destination\x20port\
    \x20numbers\x20for\x20Layer\x204\x20Protocol.\n\x20+optional\n\n\r\n\x05\
    \x041\x02\x03\x04\x12\x04\xb7\x06\x02\n\n\r\n\x05\x041\x02\x03\x06\x12\
    \x04\xb7\x06\x0b\x13\n\r\n\x05\x041\x02\x03\x01\x12\x04\xb7\x06\x14$\n\r\
    \n\x05\x041\x02\x03\x03\x12\x04\xb7\x06'(\n@\n\x02\x042\x12\x06\xbb\x06\
    \0\xc1\x06\x01\x1a2\x20FirewallSubnet\x20defines\x20the\x20IP\x20prefix\
    \x20and\x20length.\n\n\x0b\n\x03\x042\x01\x12\x04\xbb\x06\x08\x16\n\x1e\
    \n\x04\x042\x02\0\x12\x04\xbd\x06\x02\x1f\x1a\x10\x20Network\x20prefix\n\
    \n\r\n\x05\x042\x02\0\x04\x12\x04\xbd\x06\x02\n\n\r\n\x05\x042\x02\0\x05\
    \x12\x04\xbd\x06\x0b\x11\n\r\n\x05\x042\x02\0\x01\x12\x04\xbd\x06\x12\
    \x1a\n\r\n\x05\x042\x02\0\x03\x12\x04\xbd\x06\x1d\x1e\n%\n\x04\x042\x02\
    \x01\x12\x04\xc0\x06\x02K\x1a\x17\x20Network\x20prefix\x20length\n\n\r\n\
    \x05\x042\x02\x01\x04\x12\x04\xc0\x06\x02\n\n\r\n\x05\x042\x02\x01\x06\
    \x12\x04\xc0\x06\x0b:\n\r\n\x05\x042\x02\x01\x01\x12\x04\xc0\x06;F\n\r\n\
    \x05\x042\x02\x01\x03\x12\x04\xc0\x06IJ\n\xbb\x01\n\x02\x043\x12\x06\xc6\
    \x06\0\xd8\x06\x01\x1a\xac\x01\x20FloatingIP\x20defines\x20a\x20floating\
    \x20IP\x20address.\n\x20+k8s:openapi-gen=true\n\x20+resource:path=floati\
    ngips,strategy=FloatingIPStrategy,shortname=fip,categories=contrail;ipam\
    ;networking\n\n\x0b\n\x03\x043\x01\x12\x04\xc6\x06\x08\x12\n\xa0\x01\n\
    \x04\x043\x02\0\x12\x04\xca\x06\x02H\x1a\x91\x01\x20Standard\x20object's\
    \x20metadata.\n\x20More\x20info:\x20https://git.k8s.io/community/contrib\
    utors/devel/sig-architecture/api-conventions.md#metadata\n\x20+optional\
    \n\n\r\n\x05\x043\x02\0\x04\x12\x04\xca\x06\x02\n\n\r\n\x05\x043\x02\0\
    \x06\x12\x04\xca\x06\x0b:\n\r\n\x05\x043\x02\0\x01\x12\x04\xca\x06;C\n\r\
    \n\x05\x043\x02\0\x03\x12\x04\xca\x06FG\n\xc1\x01\n\x04\x043\x02\x01\x12\
    \x04\xcf\x06\x02#\x1a\xb2\x01\x20Specification\x20of\x20the\x20desired\
    \x20state\x20of\x20the\x20FloatingIP.\n\x20More\x20info:\x20https://git.\
    k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#\
    spec-and-status\n\x20+optional\n\n\r\n\x05\x043\x02\x01\x04\x12\x04\xcf\
    \x06\x02\n\n\r\n\x05\x043\x02\x01\x06\x12\x04\xcf\x06\x0b\x19\n\r\n\x05\
    \x043\x02\x01\x01\x12\x04\xcf\x06\x1a\x1e\n\r\n\x05\x043\x02\x01\x03\x12\
    \x04\xcf\x06!\"\n\x88\x02\n\x04\x043\x02\x02\x12\x04\xd7\x06\x02'\x1a\
    \xf9\x01\x20The\x20most\x20recently\x20observed\x20status\x20of\x20the\
    \x20FloatingIP.\n\x20This\x20data\x20may\x20not\x20be\x20up-to-date.\n\
    \x20Populated\x20by\x20the\x20system.\n\x20Read-only.\n\x20More\x20info:\
    \x20https://git.k8s.io/community/contributors/devel/sig-architecture/api\
    -conventions.md#spec-and-status\n\x20+optional\n\n\r\n\x05\x043\x02\x02\
    \x04\x12\x04\xd7\x06\x02\n\n\r\n\x05\x043\x02\x02\x06\x12\x04\xd7\x06\
    \x0b\x1b\n\r\n\x05\x043\x02\x02\x01\x12\x04\xd7\x06\x1c\"\n\r\n\x05\x043\
    \x02\x02\x03\x12\x04\xd7\x06%&\n7\n\x02\x044\x12\x06\xdb\x06\0\xe3\x06\
    \x01\x1a)\x20FloatingIPList\x20is\x20a\x20list\x20of\x20FloatingIP.\n\n\
    \x0b\n\x03\x044\x01\x12\x04\xdb\x06\x08\x16\n\xac\x01\n\x04\x044\x02\0\
    \x12\x04\xdf\x06\x02F\x1a\x9d\x01\x20Standard\x20list's\x20metadata.\n\
    \x20More\x20info:\x20https://git.k8s.io/community/contributors/devel/sig\
    -architecture/api-conventions.md#lists-and-simple-kinds\n\x20+optional\n\
    \n\r\n\x05\x044\x02\0\x04\x12\x04\xdf\x06\x02\n\n\r\n\x05\x044\x02\0\x06\
    \x12\x04\xdf\x06\x0b8\n\r\n\x05\x044\x02\0\x01\x12\x04\xdf\x069A\n\r\n\
    \x05\x044\x02\0\x03\x12\x04\xdf\x06DE\nU\n\x04\x044\x02\x01\x12\x04\xe2\
    \x06\x02\x20\x1aG\x20Items\x20contains\x20all\x20of\x20the\x20FloatingIP\
    \x20instances\x20in\x20the\x20FloatingIPList.\n\n\r\n\x05\x044\x02\x01\
    \x04\x12\x04\xe2\x06\x02\n\n\r\n\x05\x044\x02\x01\x06\x12\x04\xe2\x06\
    \x0b\x15\n\r\n\x05\x044\x02\x01\x01\x12\x04\xe2\x06\x16\x1b\n\r\n\x05\
    \x044\x02\x01\x03\x12\x04\xe2\x06\x1e\x1f\nd\n\x02\x045\x12\x06\xe6\x06\
    \0\xe9\x06\x01\x1aV\x20FloatingIPPortMappings\x20is\x20the\x20list\x20po\
    rt\x20mappings\x20associated\x20with\x20a\x20given\x20FloatingIP.\n\n\
    \x0b\n\x03\x045\x01\x12\x04\xe6\x06\x08\x1e\nN\n\x04\x045\x02\0\x12\x04\
    \xe8\x06\x026\x1a@\x20PortMappings\x20is\x20a\x20list\x20of\x20FloatingI\
    PPortPortMapping\x20instances.\n\n\r\n\x05\x045\x02\0\x04\x12\x04\xe8\
    \x06\x02\n\n\r\n\x05\x045\x02\0\x06\x12\x04\xe8\x06\x0b$\n\r\n\x05\x045\
    \x02\0\x01\x12\x04\xe8\x06%1\n\r\n\x05\x045\x02\0\x03\x12\x04\xe8\x0645\
    \nQ\n\x02\x046\x12\x06\xec\x06\0\xf8\x06\x01\x1aC\x20FloatingIPPortPortM\
    apping\x20indicates\x20ports\x20exposed\x20by\x20the\x20service.\n\n\x0b\
    \n\x03\x046\x01\x12\x04\xec\x06\x08!\n&\n\x04\x046\x02\0\x12\x04\xef\x06\
    \x02\x1d\x1a\x18\x20Source\x20Port\n\x20+optional\n\n\r\n\x05\x046\x02\0\
    \x04\x12\x04\xef\x06\x02\n\n\r\n\x05\x046\x02\0\x05\x12\x04\xef\x06\x0b\
    \x10\n\r\n\x05\x046\x02\0\x01\x12\x04\xef\x06\x11\x18\n\r\n\x05\x046\x02\
    \0\x03\x12\x04\xef\x06\x1b\x1c\n+\n\x04\x046\x02\x01\x12\x04\xf3\x06\x02\
    \x1d\x1a\x1d\x20Destination\x20Port\n\x20+optional\n\n\r\n\x05\x046\x02\
    \x01\x04\x12\x04\xf3\x06\x02\n\n\r\n\x05\x046\x02\x01\x05\x12\x04\xf3\
    \x06\x0b\x10\n\r\n\x05\x046\x02\x01\x01\x12\x04\xf3\x06\x11\x18\n\r\n\
    \x05\x046\x02\x01\x03\x12\x04\xf3\x06\x1b\x1c\n+\n\x04\x046\x02\x02\x12\
    \x04\xf7\x06\x02\x1f\x1a\x1d\x20Network\x20protocol\n\x20+optional\n\n\r\
    \n\x05\x046\x02\x02\x04\x12\x04\xf7\x06\x02\n\n\r\n\x05\x046\x02\x02\x05\
    \x12\x04\xf7\x06\x0b\x11\n\r\n\x05\x046\x02\x02\x01\x12\x04\xf7\x06\x12\
    \x1a\n\r\n\x05\x046\x02\x02\x03\x12\x04\xf7\x06\x1d\x1e\na\n\x02\x047\
    \x12\x06\xfb\x06\0\x96\x07\x01\x1aS\x20FloatingIPSpec\x20defines\x20the\
    \x20FloatingIP\x20parameters,\x20used\x20for\x20natting\x20pod\x20IPAddr\
    ess.\n\n\x0b\n\x03\x047\x01\x12\x04\xfb\x06\x08\x16\n\"\n\x04\x047\x02\0\
    \x12\x04\xfd\x06\x02%\x1a\x14\x20Common\x20spec\x20fields\n\n\r\n\x05\
    \x047\x02\0\x04\x12\x04\xfd\x06\x02\n\n\r\n\x05\x047\x02\0\x06\x12\x04\
    \xfd\x06\x0b\x15\n\r\n\x05\x047\x02\0\x01\x12\x04\xfd\x06\x16\x20\n\r\n\
    \x05\x047\x02\0\x03\x12\x04\xfd\x06#$\n<\n\x04\x047\x02\x01\x12\x04\x81\
    \x07\x02(\x1a.\x20IP\x20address\x20value\x20for\x20floating\x20IP.\n\x20\
    +optional\n\n\r\n\x05\x047\x02\x01\x04\x12\x04\x81\x07\x02\n\n\r\n\x05\
    \x047\x02\x01\x05\x12\x04\x81\x07\x0b\x11\n\r\n\x05\x047\x02\x01\x01\x12\
    \x04\x81\x07\x12#\n\r\n\x05\x047\x02\x01\x03\x12\x04\x81\x07&'\n\x0c\n\
    \x04\x047\x02\x02\x12\x04\x83\x07\x02=\n\r\n\x05\x047\x02\x02\x04\x12\
    \x04\x83\x07\x02\n\n\r\n\x05\x047\x02\x02\x06\x12\x04\x83\x07\x0b!\n\r\n\
    \x05\x047\x02\x02\x01\x12\x04\x83\x07\"8\n\r\n\x05\x047\x02\x02\x03\x12\
    \x04\x83\x07;<\na\n\x04\x047\x02\x03\x12\x04\x87\x07\x021\x1aS\x20Define\
    s\x20traffic\x20flow\x20direction,(ingress,egress\x20or\x20both),default\
    \x20=\x20both\n\x20+optional\n\n\r\n\x05\x047\x02\x03\x04\x12\x04\x87\
    \x07\x02\n\n\r\n\x05\x047\x02\x03\x05\x12\x04\x87\x07\x0b\x11\n\r\n\x05\
    \x047\x02\x03\x01\x12\x04\x87\x07\x12,\n\r\n\x05\x047\x02\x03\x03\x12\
    \x04\x87\x07/0\nZ\n\x04\x047\x02\x04\x12\x04\x8b\x07\x029\x1aL\x20Parent\
    \x20refers\x20to\x20the\x20InstanceIP\x20associated\x20with\x20the\x20Fl\
    oatingIP.\n\x20+optional\n\n\r\n\x05\x047\x02\x04\x04\x12\x04\x8b\x07\
    \x02\n\n\r\n\x05\x047\x02\x04\x06\x12\x04\x8b\x07\x0b-\n\r\n\x05\x047\
    \x02\x04\x01\x12\x04\x8b\x07.4\n\r\n\x05\x047\x02\x04\x03\x12\x04\x8b\
    \x0778\n\x9d\x01\n\x04\x047\x02\x05\x12\x04\x90\x07\x02C\x1a\x8e\x01\x20\
    VirtualMachineInterfaceReferences\x20determines\x20the\x20VirtualMachine\
    Interface\n\x20of\x20the\x20VirtualMachine\x20associated\x20with\x20this\
    \x20floating\x20IP.\n\x20+optional\n\n\r\n\x05\x047\x02\x05\x04\x12\x04\
    \x90\x07\x02\n\n\r\n\x05\x047\x02\x05\x06\x12\x04\x90\x07\x0b\x1c\n\r\n\
    \x05\x047\x02\x05\x01\x12\x04\x90\x07\x1d>\n\r\n\x05\x047\x02\x05\x03\
    \x12\x04\x90\x07AB\n\xda\x01\n\x04\x047\x02\x06\x12\x04\x95\x07\x021\x1a\
    \xcb\x01\x20FloatingIPEnablePortMapping\x20controls\x20which\x20ports\
    \x20FloatingIP\x20NAT\x20is\x20applied\x20to.\n\x20If\x20false,\x20Float\
    ingIP\x20NAT\x20is\x20performed\x20for\x20all\x20Ports.\n\x20If\x20true,\
    \x20FloatingIP\x20NAT\x20is\x20limited\x20to\x20the\x20defined\x20list\
    \x20of\x20PortMaps.\n\n\r\n\x05\x047\x02\x06\x04\x12\x04\x95\x07\x02\n\n\
    \r\n\x05\x047\x02\x06\x05\x12\x04\x95\x07\x0b\x0f\n\r\n\x05\x047\x02\x06\
    \x01\x12\x04\x95\x07\x10,\n\r\n\x05\x047\x02\x06\x03\x12\x04\x95\x07/0\n\
    N\n\x02\x048\x12\x06\x99\x07\0\xa0\x07\x01\x1a@\x20FloatingIPStatus\x20d\
    efines\x20the\x20observed\x20state\x20of\x20the\x20FloatingIP.\n\n\x0b\n\
    \x03\x048\x01\x12\x04\x99\x07\x08\x18\n$\n\x04\x048\x02\0\x12\x04\x9b\
    \x07\x02)\x1a\x16\x20Common\x20status\x20fields\n\n\r\n\x05\x048\x02\0\
    \x04\x12\x04\x9b\x07\x02\n\n\r\n\x05\x048\x02\0\x06\x12\x04\x9b\x07\x0b\
    \x17\n\r\n\x05\x048\x02\0\x01\x12\x04\x9b\x07\x18$\n\r\n\x05\x048\x02\0\
    \x03\x12\x04\x9b\x07'(\nN\n\x04\x048\x02\x01\x12\x04\x9f\x07\x021\x1a@\
    \x20SubnetReference\x20the\x20floating\x20IP\x20address\x20belongs\x20to\
    .\n\x20+optional\n\n\r\n\x05\x048\x02\x01\x04\x12\x04\x9f\x07\x02\n\n\r\
    \n\x05\x048\x02\x01\x06\x12\x04\x9f\x07\x0b\x1c\n\r\n\x05\x048\x02\x01\
    \x01\x12\x04\x9f\x07\x1d,\n\r\n\x05\x048\x02\x01\x03\x12\x04\x9f\x07/0\n\
    \xca\x02\n\x02\x049\x12\x06\xa7\x07\0\xb9\x07\x01\x1a\xbb\x02\x20GlobalS\
    ystemConfig\x20defines\x20all\x20the\x20global\x20Contrail\x20configurat\
    ions.\x20This\x20object\n\x20must\x20be\x20unique\x20for\x20a\x20Contrai\
    l\x20deployment\x20with\x20the\x20name\n\x20'default-global-system-confi\
    g'.\n\x20+k8s:openapi-gen=true\n\x20+resource:path=globalsystemconfigs,s\
    trategy=GlobalSystemConfigStrategy,shortname=gsc,categories=contrail;con\
    trail-cluster\n\n\x0b\n\x03\x049\x01\x12\x04\xa7\x07\x08\x1a\n\xa0\x01\n\
    \x04\x049\x02\0\x12\x04\xab\x07\x02H\x1a\x91\x01\x20Standard\x20object's\
    \x20metadata.\n\x20More\x20info:\x20https://git.k8s.io/community/contrib\
    utors/devel/sig-architecture/api-conventions.md#metadata\n\x20+optional\
    \n\n\r\n\x05\x049\x02\0\x04\x12\x04\xab\x07\x02\n\n\r\n\x05\x049\x02\0\
    \x06\x12\x04\xab\x07\x0b:\n\r\n\x05\x049\x02\0\x01\x12\x04\xab\x07;C\n\r\
    \n\x05\x049\x02\0\x03\x12\x04\xab\x07FG\n\xc9\x01\n\x04\x049\x02\x01\x12\
    \x04\xb0\x07\x02+\x1a\xba\x01\x20Specification\x20of\x20the\x20desired\
    \x20state\x20of\x20the\x20GlobalSystemConfig.\n\x20More\x20info:\x20http\
    s://git.k8s.io/community/contributors/devel/sig-architecture/api-convent\
    ions.md#spec-and-status\n\x20+optional\n\n\r\n\x05\x049\x02\x01\x04\x12\
    \x04\xb0\x07\x02\n\n\r\n\x05\x049\x02\x01\x06\x12\x04\xb0\x07\x0b!\n\r\n\
    \x05\x049\x02\x01\x01\x12\x04\xb0\x07\"&\n\r\n\x05\x049\x02\x01\x03\x12\
    \x04\xb0\x07)*\n\x90\x02\n\x04\x049\x02\x02\x12\x04\xb8\x07\x02/\x1a\x81\
    \x02\x20The\x20most\x20recently\x20observed\x20status\x20of\x20the\x20Gl\
    obalSystemConfig.\n\x20This\x20data\x20may\x20not\x20be\x20up-to-date.\n\
    \x20Populated\x20by\x20the\x20system.\n\x20Read-only.\n\x20More\x20info:\
    \x20https://git.k8s.io/community/contributors/devel/sig-architecture/api\
    -conventions.md#spec-and-status\n\x20+optional\n\n\r\n\x05\x049\x02\x02\
    \x04\x12\x04\xb8\x07\x02\n\n\r\n\x05\x049\x02\x02\x06\x12\x04\xb8\x07\
    \x0b#\n\r\n\x05\x049\x02\x02\x01\x12\x04\xb8\x07$*\n\r\n\x05\x049\x02\
    \x02\x03\x12\x04\xb8\x07-.\nG\n\x02\x04:\x12\x06\xbc\x07\0\xc4\x07\x01\
    \x1a9\x20GlobalSystemConfigList\x20is\x20a\x20list\x20of\x20GlobalSystem\
    Config.\n\n\x0b\n\x03\x04:\x01\x12\x04\xbc\x07\x08\x1e\n\xac\x01\n\x04\
    \x04:\x02\0\x12\x04\xc0\x07\x02F\x1a\x9d\x01\x20Standard\x20list's\x20me\
    tadata.\n\x20More\x20info:\x20https://git.k8s.io/community/contributors/\
    devel/sig-architecture/api-conventions.md#lists-and-simple-kinds\n\x20+o\
    ptional\n\n\r\n\x05\x04:\x02\0\x04\x12\x04\xc0\x07\x02\n\n\r\n\x05\x04:\
    \x02\0\x06\x12\x04\xc0\x07\x0b8\n\r\n\x05\x04:\x02\0\x01\x12\x04\xc0\x07\
    9A\n\r\n\x05\x04:\x02\0\x03\x12\x04\xc0\x07DE\ne\n\x04\x04:\x02\x01\x12\
    \x04\xc3\x07\x02(\x1aW\x20Items\x20contains\x20all\x20of\x20the\x20Globa\
    lSystemConfig\x20instances\x20in\x20the\x20GlobalSystemConfigList.\n\n\r\
    \n\x05\x04:\x02\x01\x04\x12\x04\xc3\x07\x02\n\n\r\n\x05\x04:\x02\x01\x06\
    \x12\x04\xc3\x07\x0b\x1d\n\r\n\x05\x04:\x02\x01\x01\x12\x04\xc3\x07\x1e#\
    \n\r\n\x05\x04:\x02\x01\x03\x12\x04\xc3\x07&'\n[\n\x02\x04;\x12\x06\xc7\
    \x07\0\xe3\x07\x01\x1aM\x20GlobalSystemConfigSpec\x20defines\x20the\x20d\
    esired\x20state\x20of\x20the\x20GlobalSystemConfig.\n\n\x0b\n\x03\x04;\
    \x01\x12\x04\xc7\x07\x08\x1e\n\"\n\x04\x04;\x02\0\x12\x04\xc9\x07\x02%\
    \x1a\x14\x20Common\x20spec\x20fields\n\n\r\n\x05\x04;\x02\0\x04\x12\x04\
    \xc9\x07\x02\n\n\r\n\x05\x04;\x02\0\x06\x12\x04\xc9\x07\x0b\x15\n\r\n\
    \x05\x04;\x02\0\x01\x12\x04\xc9\x07\x16\x20\n\r\n\x05\x04;\x02\0\x03\x12\
    \x04\xc9\x07#$\n\x8f\x01\n\x04\x04;\x02\x01\x12\x04\xce\x07\x02#\x1a\x80\
    \x01\x20Enable4bytesAS\x20enables\x2032-bit\x20Autonomous\x20System\x20n\
    umber\x20support\x20when\x20true.\n\x20When\x20false\x20(the\x20default)\
    ,\x20ASN\x20is\x2016-bit.\n\x20+optional\n\n\r\n\x05\x04;\x02\x01\x04\
    \x12\x04\xce\x07\x02\n\n\r\n\x05\x04;\x02\x01\x05\x12\x04\xce\x07\x0b\
    \x0f\n\r\n\x05\x04;\x02\x01\x01\x12\x04\xce\x07\x10\x1e\n\r\n\x05\x04;\
    \x02\x01\x03\x12\x04\xce\x07!\"\n\xd8\x01\n\x04\x04;\x02\x02\x12\x04\xd4\
    \x07\x02&\x1a\xc9\x01\x20AutonomousSystem\x20number\x20for\x20the\x20clu\
    ster.\x20By\x20default,\x20this\x20number\x20is\x2016-bits\x20and\x20has\
    \n\x20a\x20maximum\x20value\x20of\x2065535\x20unless\x20Enable4bytesAS\
    \x20is\x20true,\x20in\x20which\x20case\x20the\x20maximum\n\x20value\x20i\
    s\x204294967295.\n\x20+optional\n\n\r\n\x05\x04;\x02\x02\x04\x12\x04\xd4\
    \x07\x02\n\n\r\n\x05\x04;\x02\x02\x05\x12\x04\xd4\x07\x0b\x10\n\r\n\x05\
    \x04;\x02\x02\x01\x12\x04\xd4\x07\x11!\n\r\n\x05\x04;\x02\x02\x03\x12\
    \x04\xd4\x07$%\nt\n\x04\x04;\x02\x03\x12\x04\xd9\x07\x025\x1af\x20BGPRou\
    terReferences\x20is\x20the\x20list\x20of\x20references\x20to\x20all\x20B\
    GPRouter\x20instances\n\x20in\x20the\x20cluster.\n\x20+optional\n\n\r\n\
    \x05\x04;\x02\x03\x04\x12\x04\xd9\x07\x02\n\n\r\n\x05\x04;\x02\x03\x06\
    \x12\x04\xd9\x07\x0b\x1c\n\r\n\x05\x04;\x02\x03\x01\x12\x04\xd9\x07\x1d0\
    \n\r\n\x05\x04;\x02\x03\x03\x12\x04\xd9\x0734\nh\n\x04\x04;\x02\x04\x12\
    \x04\xdd\x07\x02!\x1aZ\x20IBGPAutoMesh\x20will\x20automatically\x20creat\
    e\x20an\x20iBGP\x20mesh\x20if\x20set\x20to\x20true\x20(default).\n\x20+o\
    ptional\n\n\r\n\x05\x04;\x02\x04\x04\x12\x04\xdd\x07\x02\n\n\r\n\x05\x04\
    ;\x02\x04\x05\x12\x04\xdd\x07\x0b\x0f\n\r\n\x05\x04;\x02\x04\x01\x12\x04\
    \xdd\x07\x10\x1c\n\r\n\x05\x04;\x02\x04\x03\x12\x04\xdd\x07\x1f\x20\n\
    \x9c\x01\n\x04\x04;\x02\x05\x12\x04\xe2\x07\x02&\x1a\x8d\x01\x20DefaultE\
    nableSNAT\x20will\x20enable\x20FabricSNAT\x20by\x20default\x20on\x20all\
    \x20VNs\x20if\x20true.\n\x20VirtualNetworkSpec.FabricSNAT\x20will\x20ove\
    rride\x20this\x20value.\n\x20+optional\n\n\r\n\x05\x04;\x02\x05\x04\x12\
    \x04\xe2\x07\x02\n\n\r\n\x05\x04;\x02\x05\x05\x12\x04\xe2\x07\x0b\x0f\n\
    \r\n\x05\x04;\x02\x05\x01\x12\x04\xe2\x07\x10!\n\r\n\x05\x04;\x02\x05\
    \x03\x12\x04\xe2\x07$%\n^\n\x02\x04<\x12\x06\xe6\x07\0\xe9\x07\x01\x1aP\
    \x20GlobalSystemConfigStatus\x20defines\x20the\x20observed\x20state\x20o\
    f\x20the\x20GlobalSystemConfig.\n\n\x0b\n\x03\x04<\x01\x12\x04\xe6\x07\
    \x08\x20\n$\n\x04\x04<\x02\0\x12\x04\xe8\x07\x02)\x1a\x16\x20Common\x20s\
    tatus\x20fields\n\n\r\n\x05\x04<\x02\0\x04\x12\x04\xe8\x07\x02\n\n\r\n\
    \x05\x04<\x02\0\x06\x12\x04\xe8\x07\x0b\x17\n\r\n\x05\x04<\x02\0\x01\x12\
    \x04\xe8\x07\x18$\n\r\n\x05\x04<\x02\0\x03\x12\x04\xe8\x07'(\n\xcf\x02\n\
    \x02\x04=\x12\x06\xf0\x07\0\x82\x08\x01\x1a\xc0\x02\x20GlobalVrouterConf\
    ig\x20defines\x20all\x20the\x20vrouter\x20Contrail\x20configurations.\
    \x20This\n\x20object\x20must\x20be\x20unique\x20for\x20a\x20Contrail\x20\
    deployment\x20with\x20the\x20name\n\x20'default-global-vrouter-config'.\
    \n\x20+k8s:openapi-gen=true\n\x20+resource:path=globalvrouterconfigs,str\
    ategy=GlobalVrouterConfigStrategy,shortname=gvc,categories=contrail;cont\
    rail-cluster\n\n\x0b\n\x03\x04=\x01\x12\x04\xf0\x07\x08\x1b\n\xa0\x01\n\
    \x04\x04=\x02\0\x12\x04\xf4\x07\x02H\x1a\x91\x01\x20Standard\x20object's\
    \x20metadata.\n\x20More\x20info:\x20https://git.k8s.io/community/contrib\
    utors/devel/sig-architecture/api-conventions.md#metadata\n\x20+optional\
    \n\n\r\n\x05\x04=\x02\0\x04\x12\x04\xf4\x07\x02\n\n\r\n\x05\x04=\x02\0\
    \x06\x12\x04\xf4\x07\x0b:\n\r\n\x05\x04=\x02\0\x01\x12\x04\xf4\x07;C\n\r\
    \n\x05\x04=\x02\0\x03\x12\x04\xf4\x07FG\n\xca\x01\n\x04\x04=\x02\x01\x12\
    \x04\xf9\x07\x02,\x1a\xbb\x01\x20Specification\x20of\x20the\x20desired\
    \x20state\x20of\x20the\x20GlobalVrouterConfig.\n\x20More\x20info:\x20htt\
    ps://git.k8s.io/community/contributors/devel/sig-architecture/api-conven\
    tions.md#spec-and-status\n\x20+optional\n\n\r\n\x05\x04=\x02\x01\x04\x12\
    \x04\xf9\x07\x02\n\n\r\n\x05\x04=\x02\x01\x06\x12\x04\xf9\x07\x0b\"\n\r\
    \n\x05\x04=\x02\x01\x01\x12\x04\xf9\x07#'\n\r\n\x05\x04=\x02\x01\x03\x12\
    \x04\xf9\x07*+\n\x91\x02\n\x04\x04=\x02\x02\x12\x04\x81\x08\x020\x1a\x82\
    \x02\x20The\x20most\x20recently\x20observed\x20status\x20of\x20the\x20Gl\
    obalVrouterConfig.\n\x20This\x20data\x20may\x20not\x20be\x20up-to-date.\
    \n\x20Populated\x20by\x20the\x20system.\n\x20Read-only.\n\x20More\x20inf\
    o:\x20https://git.k8s.io/community/contributors/devel/sig-architecture/a\
    pi-conventions.md#spec-and-status\n\x20+optional\n\n\r\n\x05\x04=\x02\
    \x02\x04\x12\x04\x81\x08\x02\n\n\r\n\x05\x04=\x02\x02\x06\x12\x04\x81\
    \x08\x0b$\n\r\n\x05\x04=\x02\x02\x01\x12\x04\x81\x08%+\n\r\n\x05\x04=\
    \x02\x02\x03\x12\x04\x81\x08./\nI\n\x02\x04>\x12\x06\x85\x08\0\x8d\x08\
    \x01\x1a;\x20GlobalVrouterConfigList\x20is\x20a\x20list\x20of\x20GlobalV\
    routerConfig.\n\n\x0b\n\x03\x04>\x01\x12\x04\x85\x08\x08\x1f\n\xac\x01\n\
    \x04\x04>\x02\0\x12\x04\x89\x08\x02F\x1a\x9d\x01\x20Standard\x20list's\
    \x20metadata.\n\x20More\x20info:\x20https://git.k8s.io/community/contrib\
    utors/devel/sig-architecture/api-conventions.md#lists-and-simple-kinds\n\
    \x20+optional\n\n\r\n\x05\x04>\x02\0\x04\x12\x04\x89\x08\x02\n\n\r\n\x05\
    \x04>\x02\0\x06\x12\x04\x89\x08\x0b8\n\r\n\x05\x04>\x02\0\x01\x12\x04\
    \x89\x089A\n\r\n\x05\x04>\x02\0\x03\x12\x04\x89\x08DE\ng\n\x04\x04>\x02\
    \x01\x12\x04\x8c\x08\x02)\x1aY\x20Items\x20contains\x20all\x20of\x20the\
    \x20GlobalVrouterConfig\x20instances\x20in\x20the\x20GlobalVrouterConfig\
    List.\n\n\r\n\x05\x04>\x02\x01\x04\x12\x04\x8c\x08\x02\n\n\r\n\x05\x04>\
    \x02\x01\x06\x12\x04\x8c\x08\x0b\x1e\n\r\n\x05\x04>\x02\x01\x01\x12\x04\
    \x8c\x08\x1f$\n\r\n\x05\x04>\x02\x01\x03\x12\x04\x8c\x08'(\nX\n\x02\x04?\
    \x12\x06\x90\x08\0\xa7\x08\x01\x1aJ\x20GlobalVrouterConfigSpec\x20define\
    s\x20the\x20desired\x20state\x20of\x20GlobalVrouterConfig\n\n\x0b\n\x03\
    \x04?\x01\x12\x04\x90\x08\x08\x1f\n\"\n\x04\x04?\x02\0\x12\x04\x92\x08\
    \x02%\x1a\x14\x20Common\x20spec\x20fields\n\n\r\n\x05\x04?\x02\0\x04\x12\
    \x04\x92\x08\x02\n\n\r\n\x05\x04?\x02\0\x06\x12\x04\x92\x08\x0b\x15\n\r\
    \n\x05\x04?\x02\0\x01\x12\x04\x92\x08\x16\x20\n\r\n\x05\x04?\x02\0\x03\
    \x12\x04\x92\x08#$\nU\n\x04\x04?\x02\x01\x12\x04\x95\x08\x029\x1aG\x20Pa\
    rent\x20contains\x20the\x20ObjectReference\x20to\x20the\x20parent\x20Glo\
    balSystemConfig.\n\n\r\n\x05\x04?\x02\x01\x04\x12\x04\x95\x08\x02\n\n\r\
    \n\x05\x04?\x02\x01\x06\x12\x04\x95\x08\x0b-\n\r\n\x05\x04?\x02\x01\x01\
    \x12\x04\x95\x08.4\n\r\n\x05\x04?\x02\x01\x03\x12\x04\x95\x0878\n\xc7\
    \x01\n\x04\x04?\x02\x02\x12\x04\x9b\x08\x02?\x1a\xb8\x01\x20Encapsulatio\
    nPriorities\x20is\x20an\x20ordered\x20list\x20of\x20encapsulation\x20typ\
    es\x20to\x20be\n\x20used\x20in\x20priority\x20by\x20the\x20vrouter.\x20V\
    alid\x20encapsulation\x20types\x20include\x20MPLSoGRE,\n\x20MPLSoUDP,\
    \x20and\x20VXLAN.\n\x20+optional\n\n\r\n\x05\x04?\x02\x02\x04\x12\x04\
    \x9b\x08\x02\n\n\r\n\x05\x04?\x02\x02\x06\x12\x04\x9b\x08\x0b\"\n\r\n\
    \x05\x04?\x02\x02\x01\x12\x04\x9b\x08#:\n\r\n\x05\x04?\x02\x02\x03\x12\
    \x04\x9b\x08=>\n\x0c\n\x04\x04?\x02\x03\x12\x04\x9d\x08\x023\n\r\n\x05\
    \x04?\x02\x03\x04\x12\x04\x9d\x08\x02\n\n\r\n\x05\x04?\x02\x03\x06\x12\
    \x04\x9d\x08\x0b\x1c\n\r\n\x05\x04?\x02\x03\x01\x12\x04\x9d\x08\x1d.\n\r\
    \n\x05\x04?\x02\x03\x03\x12\x04\x9d\x0812\na\n\x04\x04?\x02\x04\x12\x04\
    \xa1\x08\x029\x1aS\x20PortTranslationPools\x20contains\x20the\x20defined\
    \x20SNAT\x20port\x20translation\x20pools.\n\x20+optional\n\n\r\n\x05\x04\
    ?\x02\x04\x04\x12\x04\xa1\x08\x02\n\n\r\n\x05\x04?\x02\x04\x06\x12\x04\
    \xa1\x08\x0b\x1f\n\r\n\x05\x04?\x02\x04\x01\x12\x04\xa1\x08\x204\n\r\n\
    \x05\x04?\x02\x04\x03\x12\x04\xa1\x0878\n~\n\x04\x04?\x02\x05\x12\x04\
    \xa6\x08\x02$\x1ap\x20FlowExportRate\x20is\x20the\x20rate\x20at\x20which\
    \x20each\x20vrouter\x20will\x20sample\x20and\x20export\n\x20flow\x20reco\
    rds\x20to\x20analytics.\n\x20+optional\n\n\r\n\x05\x04?\x02\x05\x04\x12\
    \x04\xa6\x08\x02\n\n\r\n\x05\x04?\x02\x05\x05\x12\x04\xa6\x08\x0b\x10\n\
    \r\n\x05\x04?\x02\x05\x01\x12\x04\xa6\x08\x11\x1f\n\r\n\x05\x04?\x02\x05\
    \x03\x12\x04\xa6\x08\"#\n[\n\x02\x04@\x12\x06\xaa\x08\0\xad\x08\x01\x1aM\
    \x20GlobalVrouterConfigStatus\x20defines\x20the\x20observed\x20state\x20\
    of\x20GlobalVrouterConfig\n\n\x0b\n\x03\x04@\x01\x12\x04\xaa\x08\x08!\n$\
    \n\x04\x04@\x02\0\x12\x04\xac\x08\x02)\x1a\x16\x20Common\x20status\x20fi\
    elds\n\n\r\n\x05\x04@\x02\0\x04\x12\x04\xac\x08\x02\n\n\r\n\x05\x04@\x02\
    \0\x06\x12\x04\xac\x08\x0b\x17\n\r\n\x05\x04@\x02\0\x01\x12\x04\xac\x08\
    \x18$\n\r\n\x05\x04@\x02\0\x03\x12\x04\xac\x08'(\nP\n\x02\x04A\x12\x06\
    \xb0\x08\0\xb6\x08\x01\x1aB\x20IPRange\x20specifies\x20the\x20start\x20a\
    nd\x20end\x20for\x20a\x20range\x20of\x20IP\x20addresses.\n\n\x0b\n\x03\
    \x04A\x01\x12\x04\xb0\x08\x08\x0f\nM\n\x04\x04A\x02\0\x12\x04\xb2\x08\
    \x02\x1b\x1a?\x20From\x20indicates\x20beginning\x20IP\x20address\x20for\
    \x20the\x20allocation\x20range.\n\n\r\n\x05\x04A\x02\0\x04\x12\x04\xb2\
    \x08\x02\n\n\r\n\x05\x04A\x02\0\x05\x12\x04\xb2\x08\x0b\x11\n\r\n\x05\
    \x04A\x02\0\x01\x12\x04\xb2\x08\x12\x16\n\r\n\x05\x04A\x02\0\x03\x12\x04\
    \xb2\x08\x19\x1a\nF\n\x04\x04A\x02\x01\x12\x04\xb5\x08\x02\x19\x1a8\x20T\
    o\x20indicates\x20last\x20IP\x20address\x20for\x20the\x20allocation\x20r\
    ange.\n\n\r\n\x05\x04A\x02\x01\x04\x12\x04\xb5\x08\x02\n\n\r\n\x05\x04A\
    \x02\x01\x05\x12\x04\xb5\x08\x0b\x11\n\r\n\x05\x04A\x02\x01\x01\x12\x04\
    \xb5\x08\x12\x14\n\r\n\x05\x04A\x02\x01\x03\x12\x04\xb5\x08\x17\x18\n\
    \x82\x01\n\x02\x04B\x12\x06\xba\x08\0\xbd\x08\x01\x1at\x20ImportVirtualN\
    etworkRouter\x20is\x20a\x20list\x20of\x20other\x20VirtualNetworkRouters\
    \x20imported\n\x20by\x20the\x20current\x20VirtualNetworkRouter.\n\n\x0b\
    \n\x03\x04B\x01\x12\x04\xba\x08\x08\"\nM\n\x04\x04B\x02\0\x12\x04\xbc\
    \x08\x02?\x1a?\x20VirtualNetworkRouters\x20is\x20a\x20list\x20of\x20Virt\
    ualNetworkRouterEntry.\n\n\r\n\x05\x04B\x02\0\x04\x12\x04\xbc\x08\x02\n\
    \n\r\n\x05\x04B\x02\0\x06\x12\x04\xbc\x08\x0b$\n\r\n\x05\x04B\x02\0\x01\
    \x12\x04\xbc\x08%:\n\r\n\x05\x04B\x02\0\x03\x12\x04\xbc\x08=>\n\xe0\x01\
    \n\x02\x04C\x12\x06\xc2\x08\0\xd4\x08\x01\x1a\xd1\x01\x20InstanceIP\x20r\
    epresents\x20an\x20IP\x20address\x20and\x20its\x20configuration\x20used\
    \x20for\x20interfaces.\n\x20+k8s:openapi-gen=true\n\x20+resource:path=in\
    stanceips,strategy=InstanceIPStrategy,shortname=iip,categories=contrail;\
    ipam;networking\n\n\x0b\n\x03\x04C\x01\x12\x04\xc2\x08\x08\x12\n\xa0\x01\
    \n\x04\x04C\x02\0\x12\x04\xc6\x08\x02H\x1a\x91\x01\x20Standard\x20object\
    's\x20metadata.\n\x20More\x20info:\x20https://git.k8s.io/community/contr\
    ibutors/devel/sig-architecture/api-conventions.md#metadata\n\x20+optiona\
    l\n\n\r\n\x05\x04C\x02\0\x04\x12\x04\xc6\x08\x02\n\n\r\n\x05\x04C\x02\0\
    \x06\x12\x04\xc6\x08\x0b:\n\r\n\x05\x04C\x02\0\x01\x12\x04\xc6\x08;C\n\r\
    \n\x05\x04C\x02\0\x03\x12\x04\xc6\x08FG\n\xc1\x01\n\x04\x04C\x02\x01\x12\
    \x04\xcb\x08\x02#\x1a\xb2\x01\x20Specification\x20of\x20the\x20desired\
    \x20state\x20of\x20the\x20InstanceIP.\n\x20More\x20info:\x20https://git.\
    k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#\
    spec-and-status\n\x20+optional\n\n\r\n\x05\x04C\x02\x01\x04\x12\x04\xcb\
    \x08\x02\n\n\r\n\x05\x04C\x02\x01\x06\x12\x04\xcb\x08\x0b\x19\n\r\n\x05\
    \x04C\x02\x01\x01\x12\x04\xcb\x08\x1a\x1e\n\r\n\x05\x04C\x02\x01\x03\x12\
    \x04\xcb\x08!\"\n\x88\x02\n\x04\x04C\x02\x02\x12\x04\xd3\x08\x02'\x1a\
    \xf9\x01\x20The\x20most\x20recently\x20observed\x20status\x20of\x20the\
    \x20InstanceIP.\n\x20This\x20data\x20may\x20not\x20be\x20up-to-date.\n\
    \x20Populated\x20by\x20the\x20system.\n\x20Read-only.\n\x20More\x20info:\
    \x20https://git.k8s.io/community/contributors/devel/sig-architecture/api\
    -conventions.md#spec-and-status\n\x20+optional\n\n\r\n\x05\x04C\x02\x02\
    \x04\x12\x04\xd3\x08\x02\n\n\r\n\x05\x04C\x02\x02\x06\x12\x04\xd3\x08\
    \x0b\x1b\n\r\n\x05\x04C\x02\x02\x01\x12\x04\xd3\x08\x1c\"\n\r\n\x05\x04C\
    \x02\x02\x03\x12\x04\xd3\x08%&\n7\n\x02\x04D\x12\x06\xd7\x08\0\xdf\x08\
    \x01\x1a)\x20InstanceIPList\x20is\x20a\x20list\x20of\x20InstanceIP.\n\n\
    \x0b\n\x03\x04D\x01\x12\x04\xd7\x08\x08\x16\n\xac\x01\n\x04\x04D\x02\0\
    \x12\x04\xdb\x08\x02F\x1a\x9d\x01\x20Standard\x20list's\x20metadata.\n\
    \x20More\x20info:\x20https://git.k8s.io/community/contributors/devel/sig\
    -architecture/api-conventions.md#lists-and-simple-kinds\n\x20+optional\n\
    \n\r\n\x05\x04D\x02\0\x04\x12\x04\xdb\x08\x02\n\n\r\n\x05\x04D\x02\0\x06\
    \x12\x04\xdb\x08\x0b8\n\r\n\x05\x04D\x02\0\x01\x12\x04\xdb\x089A\n\r\n\
    \x05\x04D\x02\0\x03\x12\x04\xdb\x08DE\nU\n\x04\x04D\x02\x01\x12\x04\xde\
    \x08\x02\x20\x1aG\x20Items\x20contains\x20all\x20of\x20the\x20InstanceIP\
    \x20instances\x20in\x20the\x20InstanceIPList.\n\n\r\n\x05\x04D\x02\x01\
    \x04\x12\x04\xde\x08\x02\n\n\r\n\x05\x04D\x02\x01\x06\x12\x04\xde\x08\
    \x0b\x15\n\r\n\x05\x04D\x02\x01\x01\x12\x04\xde\x08\x16\x1b\n\r\n\x05\
    \x04D\x02\x01\x03\x12\x04\xde\x08\x1e\x1f\nK\n\x02\x04E\x12\x06\xe2\x08\
    \0\xfe\x08\x01\x1a=\x20InstanceIPSpec\x20defines\x20the\x20desired\x20st\
    ate\x20of\x20the\x20InstanceIP.\n\n\x0b\n\x03\x04E\x01\x12\x04\xe2\x08\
    \x08\x16\n\"\n\x04\x04E\x02\0\x12\x04\xe4\x08\x02%\x1a\x14\x20Common\x20\
    spec\x20fields\n\n\r\n\x05\x04E\x02\0\x04\x12\x04\xe4\x08\x02\n\n\r\n\
    \x05\x04E\x02\0\x06\x12\x04\xe4\x08\x0b\x15\n\r\n\x05\x04E\x02\0\x01\x12\
    \x04\xe4\x08\x16\x20\n\r\n\x05\x04E\x02\0\x03\x12\x04\xe4\x08#$\n;\n\x04\
    \x04E\x02\x01\x12\x04\xe8\x08\x02(\x1a-\x20IP\x20address\x20value\x20for\
    \x20InstanceIP.\n\x20+optional\n\n\r\n\x05\x04E\x02\x01\x04\x12\x04\xe8\
    \x08\x02\n\n\r\n\x05\x04E\x02\x01\x05\x12\x04\xe8\x08\x0b\x11\n\r\n\x05\
    \x04E\x02\x01\x01\x12\x04\xe8\x08\x12#\n\r\n\x05\x04E\x02\x01\x03\x12\
    \x04\xe8\x08&'\n_\n\x04\x04E\x02\x02\x12\x04\xec\x08\x02'\x1aQ\x20IP\x20\
    address\x20family\x20for\x20the\x20InstanceIP:\x20\"v4\"\x20or\x20\"v6\"\
    \x20for\x20IPv4\x20or\x20IPv6.\n\x20+optional\n\n\r\n\x05\x04E\x02\x02\
    \x04\x12\x04\xec\x08\x02\n\n\r\n\x05\x04E\x02\x02\x05\x12\x04\xec\x08\
    \x0b\x11\n\r\n\x05\x04E\x02\x02\x01\x12\x04\xec\x08\x12\"\n\r\n\x05\x04E\
    \x02\x02\x03\x12\x04\xec\x08%&\nH\n\x04\x04E\x02\x03\x12\x04\xf0\x08\x02\
    \x1b\x1a:\x20Subnet\x20is\x20the\x20CIDR\x20the\x20InstanceIP\x20belongs\
    \x20to.\n\x20+optional\n\n\r\n\x05\x04E\x02\x03\x04\x12\x04\xf0\x08\x02\
    \n\n\r\n\x05\x04E\x02\x03\x05\x12\x04\xf0\x08\x0b\x11\n\r\n\x05\x04E\x02\
    \x03\x01\x12\x04\xf0\x08\x12\x16\n\r\n\x05\x04E\x02\x03\x03\x12\x04\xf0\
    \x08\x19\x1a\nk\n\x04\x04E\x02\x04\x12\x04\xf4\x08\x029\x1a]\x20VirtualN\
    etworkReference\x20determines\x20the\x20VirtualNetwork\x20the\x20Instanc\
    eIP\x20belongs\x20to.\n\x20+optional\n\n\r\n\x05\x04E\x02\x04\x04\x12\
    \x04\xf4\x08\x02\n\n\r\n\x05\x04E\x02\x04\x06\x12\x04\xf4\x08\x0b\x1c\n\
    \r\n\x05\x04E\x02\x04\x01\x12\x04\xf4\x08\x1d4\n\r\n\x05\x04E\x02\x04\
    \x03\x12\x04\xf4\x0878\n\x7f\n\x04\x04E\x02\x05\x12\x04\xf9\x08\x02C\x1a\
    q\x20VirtualMachineInterfaceReferences\x20determines\x20the\x20VirtualMa\
    chineInterface\n\x20the\x20InstanceIP\x20belongs\x20to.\n\x20+optional\n\
    \n\r\n\x05\x04E\x02\x05\x04\x12\x04\xf9\x08\x02\n\n\r\n\x05\x04E\x02\x05\
    \x06\x12\x04\xf9\x08\x0b\x1c\n\r\n\x05\x04E\x02\x05\x01\x12\x04\xf9\x08\
    \x1d>\n\r\n\x05\x04E\x02\x05\x03\x12\x04\xf9\x08AB\n^\n\x04\x04E\x02\x06\
    \x12\x04\xfd\x08\x02\"\x1aP\x20IPRangeKeys\x20is\x20used\x20to\x20identi\
    fy\x20the\x20subnet\x20range\x20for\x20IP\x20allocation.\n\x20+optional\
    \n\n\r\n\x05\x04E\x02\x06\x04\x12\x04\xfd\x08\x02\n\n\r\n\x05\x04E\x02\
    \x06\x05\x12\x04\xfd\x08\x0b\x11\n\r\n\x05\x04E\x02\x06\x01\x12\x04\xfd\
    \x08\x12\x1d\n\r\n\x05\x04E\x02\x06\x03\x12\x04\xfd\x08\x20!\nN\n\x02\
    \x04F\x12\x06\x81\t\0\x88\t\x01\x1a@\x20InstanceIPStatus\x20defines\x20t\
    he\x20observed\x20state\x20of\x20the\x20InstanceIP.\n\n\x0b\n\x03\x04F\
    \x01\x12\x04\x81\t\x08\x18\n$\n\x04\x04F\x02\0\x12\x04\x83\t\x02)\x1a\
    \x16\x20Common\x20status\x20fields\n\n\r\n\x05\x04F\x02\0\x04\x12\x04\
    \x83\t\x02\n\n\r\n\x05\x04F\x02\0\x06\x12\x04\x83\t\x0b\x17\n\r\n\x05\
    \x04F\x02\0\x01\x12\x04\x83\t\x18$\n\r\n\x05\x04F\x02\0\x03\x12\x04\x83\
    \t'(\n[\n\x04\x04F\x02\x01\x12\x04\x87\t\x021\x1aM\x20SubnetReference\
    \x20refers\x20to\x20the\x20Subnet\x20this\x20InstanceIP\x20belongs\x20to\
    .\n\x20+optional\n\n\r\n\x05\x04F\x02\x01\x04\x12\x04\x87\t\x02\n\n\r\n\
    \x05\x04F\x02\x01\x06\x12\x04\x87\t\x0b\x1c\n\r\n\x05\x04F\x02\x01\x01\
    \x12\x04\x87\t\x1d,\n\r\n\x05\x04F\x02\x01\x03\x12\x04\x87\t/0\nb\n\x02\
    \x04G\x12\x06\x8b\t\0\x9e\t\x01\x1aT\x20LinklocalServiceEntryType\x20spe\
    cifies\x20parameters\x20for\x20configurable\x20LinkLocalServices.\n\n\
    \x0b\n\x03\x04G\x01\x12\x04\x8b\t\x08!\nE\n\x04\x04G\x02\0\x12\x04\x8d\t\
    \x02-\x1a7\x20DNS\x20name\x20to\x20which\x20link\x20local\x20service\x20\
    will\x20be\x20proxied.\n\n\r\n\x05\x04G\x02\0\x04\x12\x04\x8d\t\x02\n\n\
    \r\n\x05\x04G\x02\0\x05\x12\x04\x8d\t\x0b\x11\n\r\n\x05\x04G\x02\0\x01\
    \x12\x04\x8d\t\x12(\n\r\n\x05\x04G\x02\0\x03\x12\x04\x8d\t+,\nR\n\x04\
    \x04G\x02\x01\x12\x04\x90\t\x02(\x1aD\x20Destination\x20ip\x20address\
    \x20to\x20which\x20link\x20local\x20traffic\x20will\x20forwarded.\n\n\r\
    \n\x05\x04G\x02\x01\x04\x12\x04\x90\t\x02\n\n\r\n\x05\x04G\x02\x01\x05\
    \x12\x04\x90\t\x0b\x11\n\r\n\x05\x04G\x02\x01\x01\x12\x04\x90\t\x12#\n\r\
    \n\x05\x04G\x02\x01\x03\x12\x04\x90\t&'\nW\n\x04\x04G\x02\x02\x12\x04\
    \x93\t\x02)\x1aI\x20Destination\x20TCP\x20port\x20number\x20to\x20which\
    \x20link\x20local\x20traffic\x20will\x20forwarded.\n\n\r\n\x05\x04G\x02\
    \x02\x04\x12\x04\x93\t\x02\n\n\r\n\x05\x04G\x02\x02\x05\x12\x04\x93\t\
    \x0b\x10\n\r\n\x05\x04G\x02\x02\x01\x12\x04\x93\t\x11$\n\r\n\x05\x04G\
    \x02\x02\x03\x12\x04\x93\t'(\n5\n\x04\x04G\x02\x03\x12\x04\x96\t\x02)\
    \x1a'\x20ip\x20address\x20of\x20the\x20link\x20local\x20service.\n\n\r\n\
    \x05\x04G\x02\x03\x04\x12\x04\x96\t\x02\n\n\r\n\x05\x04G\x02\x03\x05\x12\
    \x04\x96\t\x0b\x11\n\r\n\x05\x04G\x02\x03\x01\x12\x04\x96\t\x12$\n\r\n\
    \x05\x04G\x02\x03\x03\x12\x04\x96\t'(\nv\n\x04\x04G\x02\x04\x12\x04\x9a\
    \t\x02+\x1ah\x20Name\x20of\x20the\x20link\x20local\x20service.\x20VM\x20\
    name\x20resolution\x20of\x20this\x20name\x20will\x20result\x20in\n\x20\
    \x20link\x20local\x20ip\x20address\n\n\r\n\x05\x04G\x02\x04\x04\x12\x04\
    \x9a\t\x02\n\n\r\n\x05\x04G\x02\x04\x05\x12\x04\x9a\t\x0b\x11\n\r\n\x05\
    \x04G\x02\x04\x01\x12\x04\x9a\t\x12&\n\r\n\x05\x04G\x02\x04\x03\x12\x04\
    \x9a\t)*\nA\n\x04\x04G\x02\x05\x12\x04\x9d\t\x02*\x1a3\x20Destination\
    \x20TCP\x20port\x20number\x20of\x20link\x20local\x20service\n\n\r\n\x05\
    \x04G\x02\x05\x04\x12\x04\x9d\t\x02\n\n\r\n\x05\x04G\x02\x05\x05\x12\x04\
    \x9d\t\x0b\x10\n\r\n\x05\x04G\x02\x05\x01\x12\x04\x9d\t\x11%\n\r\n\x05\
    \x04G\x02\x05\x03\x12\x04\x9d\t()\n>\n\x02\x04H\x12\x06\xa1\t\0\xa3\t\
    \x01\x1a0\x20LinklocalServices\x20is\x20list\x20of\x20LinkLocalServices\
    \n\n\x0b\n\x03\x04H\x01\x12\x04\xa1\t\x08\x19\n\x0c\n\x04\x04H\x02\0\x12\
    \x04\xa2\t\x02?\n\r\n\x05\x04H\x02\0\x04\x12\x04\xa2\t\x02\n\n\r\n\x05\
    \x04H\x02\0\x06\x12\x04\xa2\t\x0b$\n\r\n\x05\x04H\x02\0\x01\x12\x04\xa2\
    \t%:\n\r\n\x05\x04H\x02\0\x03\x12\x04\xa2\t=>\n4\n\x02\x04I\x12\x06\xa6\
    \t\0\xa9\t\x01\x1a&\x20MACAddresses\x20is\x20a\x20list\x20of\x20MACAddre\
    ss\n\n\x0b\n\x03\x04I\x01\x12\x04\xa6\t\x08\x14\nX\n\x04\x04I\x02\0\x12\
    \x04\xa8\t\x02!\x1aJ\x20MACAddresses\x20is\x20list\x20of\x20unique\x20id\
    entifier\x20assigned\x20to\x20network\x20interface.\n\n\r\n\x05\x04I\x02\
    \0\x04\x12\x04\xa8\t\x02\n\n\r\n\x05\x04I\x02\0\x05\x12\x04\xa8\t\x0b\
    \x11\n\r\n\x05\x04I\x02\0\x01\x12\x04\xa8\t\x12\x1c\n\r\n\x05\x04I\x02\0\
    \x03\x12\x04\xa8\t\x1f\x20\n[\n\x02\x04J\x12\x06\xac\t\0\xb0\t\x01\x1aM\
    \x20PolicyBasedForwardingRule\x20is\x20the\x20automatically\x20generated\
    \x20Forwarding\x20policy.\n\n\x0b\n\x03\x04J\x01\x12\x04\xac\t\x08!\ng\n\
    \x04\x04J\x02\0\x12\x04\xaf\t\x02\x20\x1aY\x20Direction\x20specifies\x20\
    traffic\x20direction\x20allowed\x20for\x20PolicyBasedForwardingRule.\n\
    \x20+optional\n\n\r\n\x05\x04J\x02\0\x04\x12\x04\xaf\t\x02\n\n\r\n\x05\
    \x04J\x02\0\x05\x12\x04\xaf\t\x0b\x11\n\r\n\x05\x04J\x02\0\x01\x12\x04\
    \xaf\t\x12\x1b\n\r\n\x05\x04J\x02\0\x03\x12\x04\xaf\t\x1e\x1f\nP\n\x02\
    \x04K\x12\x06\xb3\t\0\xbb\t\x01\x1aB\x20PortRange\x20encapsulates\x20the\
    \x20start\x20and\x20end\x20of\x20a\x20range\x20of\x20IP\x20ports.\n\n\
    \x0b\n\x03\x04K\x01\x12\x04\xb3\t\x08\x11\ni\n\x04\x04K\x02\0\x12\x04\
    \xb6\t\x02\x1f\x1a[\x20StartPort\x20represents\x20the\x20starting\x20por\
    t\x20number.\n\x20It\x20must\x20be\x20less\x20than\x20or\x20equal\x20to\
    \x20EndPort.\n\n\r\n\x05\x04K\x02\0\x04\x12\x04\xb6\t\x02\n\n\r\n\x05\
    \x04K\x02\0\x05\x12\x04\xb6\t\x0b\x10\n\r\n\x05\x04K\x02\0\x01\x12\x04\
    \xb6\t\x11\x1a\n\r\n\x05\x04K\x02\0\x03\x12\x04\xb6\t\x1d\x1e\nt\n\x04\
    \x04K\x02\x01\x12\x04\xba\t\x02\x1d\x1af\x20EndPort\x20represents\x20the\
    \x20last\x20allocatable\x20port\x20number.\n\x20It\x20must\x20be\x20grea\
    ter\x20than\x20or\x20equal\x20to\x20StartPort.\n\n\r\n\x05\x04K\x02\x01\
    \x04\x12\x04\xba\t\x02\n\n\r\n\x05\x04K\x02\x01\x05\x12\x04\xba\t\x0b\
    \x10\n\r\n\x05\x04K\x02\x01\x01\x12\x04\xba\t\x11\x18\n\r\n\x05\x04K\x02\
    \x01\x03\x12\x04\xba\t\x1b\x1c\n\xa9\x02\n\x02\x04L\x12\x06\xc1\t\0\xce\
    \t\x01\x1a\x9a\x02\x20PortTranslationPool\x20represents\x20a\x20range\
    \x20or\x20quantity\x20of\x20available\x20ports\x20for\x20a\n\x20given\
    \x20protocol.\x20Protocol\x20is\x20required.\x20PortRange\x20is\x20optio\
    nal\x20defaults\x20to\x20nil.\n\x20PortCount\x20is\x20optional\x20defaul\
    ts\x20to\x200.\x20Only\x20one\x20of\x20PortRange\x20and\x20PortCount\x20\
    may\n\x20be\x20set\x20for\x20the\x20PortTranslationPool\x20to\x20be\x20v\
    alid.\n\n\x0b\n\x03\x04L\x01\x12\x04\xc1\t\x08\x1b\nB\n\x04\x04L\x02\0\
    \x12\x04\xc3\t\x02\x1f\x1a4\x20Protocol\x20specifies\x20the\x20protocol\
    \x20this\x20pools\x20is\x20for.\n\n\r\n\x05\x04L\x02\0\x04\x12\x04\xc3\t\
    \x02\n\n\r\n\x05\x04L\x02\0\x05\x12\x04\xc3\t\x0b\x11\n\r\n\x05\x04L\x02\
    \0\x01\x12\x04\xc3\t\x12\x1a\n\r\n\x05\x04L\x02\0\x03\x12\x04\xc3\t\x1d\
    \x1e\n\x8b\x01\n\x04\x04L\x02\x01\x12\x04\xc8\t\x02#\x1a}\x20PortRange\
    \x20defines\x20the\x20range\x20from\x20which\x20port\x20numbers\x20may\
    \x20be\x20allocated.\n\x20If\x20PortRange\x20is\x20set,\x20PortCount\x20\
    must\x20be\x200.\n\x20+optional\n\n\r\n\x05\x04L\x02\x01\x04\x12\x04\xc8\
    \t\x02\n\n\r\n\x05\x04L\x02\x01\x06\x12\x04\xc8\t\x0b\x14\n\r\n\x05\x04L\
    \x02\x01\x01\x12\x04\xc8\t\x15\x1e\n\r\n\x05\x04L\x02\x01\x03\x12\x04\
    \xc8\t!\"\n\x9b\x01\n\x04\x04L\x02\x02\x12\x04\xcd\t\x02\x1f\x1a\x8c\x01\
    \x20PortCount\x20defines\x20the\x20maximum\x20amount\x20of\x20port\x20nu\
    mbers\x20to\x20be\x20allocated.\n\x20If\x20PortCount\x20is\x20greater\
    \x20than\x200,\x20PortRange\x20must\x20be\x20empty.\n\x20+optional\n\n\r\
    \n\x05\x04L\x02\x02\x04\x12\x04\xcd\t\x02\n\n\r\n\x05\x04L\x02\x02\x05\
    \x12\x04\xcd\t\x0b\x10\n\r\n\x05\x04L\x02\x02\x01\x12\x04\xcd\t\x11\x1a\
    \n\r\n\x05\x04L\x02\x02\x03\x12\x04\xcd\t\x1d\x1e\nd\n\x02\x04M\x12\x06\
    \xd2\t\0\xd6\t\x01\x1aV\x20PortTranslationPools\x20represents\x20a\x20co\
    llection\x20of\x20PortTranslationPool\n\x20configurations.\n\n\x0b\n\x03\
    \x04M\x01\x12\x04\xd2\t\x08\x1c\nN\n\x04\x04M\x02\0\x12\x04\xd5\t\x02)\
    \x1a@\x20Pools\x20is\x20the\x20list\x20of\x20PortTranslationPool\x20inst\
    ances.\n\x20+optional\n\n\r\n\x05\x04M\x02\0\x04\x12\x04\xd5\t\x02\n\n\r\
    \n\x05\x04M\x02\0\x06\x12\x04\xd5\t\x0b\x1e\n\r\n\x05\x04M\x02\0\x01\x12\
    \x04\xd5\t\x1f$\n\r\n\x05\x04M\x02\0\x03\x12\x04\xd5\t'(\n1\n\x02\x04N\
    \x12\x06\xd9\t\0\xe1\t\x01\x1a#\x20PortType\x20defines\x20the\x20Port\
    \x20number.\n\n\x0b\n\x03\x04N\x01\x12\x04\xd9\t\x08\x10\na\n\x04\x04N\
    \x02\0\x12\x04\xdc\t\x02\x1f\x1aS\x20StartPort\x20defines\x20the\x20star\
    ting\x20port\x20number\x20of\x20the\x20FirewallServiceType.\n\x20+option\
    al\n\n\r\n\x05\x04N\x02\0\x04\x12\x04\xdc\t\x02\n\n\r\n\x05\x04N\x02\0\
    \x05\x12\x04\xdc\t\x0b\x10\n\r\n\x05\x04N\x02\0\x01\x12\x04\xdc\t\x11\
    \x1a\n\r\n\x05\x04N\x02\0\x03\x12\x04\xdc\t\x1d\x1e\n]\n\x04\x04N\x02\
    \x01\x12\x04\xe0\t\x02\x1d\x1aO\x20EndPort\x20defines\x20the\x20ending\
    \x20port\x20number\x20of\x20the\x20FirewallServiceType.\n\x20+optional\n\
    \n\r\n\x05\x04N\x02\x01\x04\x12\x04\xe0\t\x02\n\n\r\n\x05\x04N\x02\x01\
    \x05\x12\x04\xe0\t\x0b\x10\n\r\n\x05\x04N\x02\x01\x01\x12\x04\xe0\t\x11\
    \x18\n\r\n\x05\x04N\x02\x01\x03\x12\x04\xe0\t\x1b\x1c\nH\n\x02\x04O\x12\
    \x06\xe4\t\0\xeb\t\x01\x1a:\x20Range\x20is\x20a\x20list\x20of\x20IPRange\
    s\x20associated\x20with\x20a\x20given\x20key.\n\n\x0b\n\x03\x04O\x01\x12\
    \x04\xe4\t\x08\r\n\x8b\x01\n\x04\x04O\x02\0\x12\x04\xe7\t\x02\x1a\x1a}\
    \x20Key\x20is\x20a\x20text\x20string\x20defining\x20the\x20Range\x20coll\
    ection.\x20Setting\x20a\x20Range\x20with\n\x20an\x20existing\x20key\x20w\
    ill\x20overwrite\x20the\x20exiting\x20Range.\n\n\r\n\x05\x04O\x02\0\x04\
    \x12\x04\xe7\t\x02\n\n\r\n\x05\x04O\x02\0\x05\x12\x04\xe7\t\x0b\x11\n\r\
    \n\x05\x04O\x02\0\x01\x12\x04\xe7\t\x12\x15\n\r\n\x05\x04O\x02\0\x03\x12\
    \x04\xe7\t\x18\x19\n<\n\x04\x04O\x02\x01\x12\x04\xea\t\x02\x20\x1a.\x20I\
    PRanges\x20lists\x20one\x20or\x20more\x20IPRange\x20instance.\n\n\r\n\
    \x05\x04O\x02\x01\x04\x12\x04\xea\t\x02\n\n\r\n\x05\x04O\x02\x01\x06\x12\
    \x04\xea\t\x0b\x12\n\r\n\x05\x04O\x02\x01\x01\x12\x04\xea\t\x13\x1b\n\r\
    \n\x05\x04O\x02\x01\x03\x12\x04\xea\t\x1e\x1f\n\xc0\x01\n\x02\x04P\x12\
    \x06\xf0\t\0\xf9\t\x01\x1a\xb1\x01\x20ReconcilerState\x20describes\x20a\
    \x20resource's\x20reconciliation\x20status\x20including\x20the\x20State\
    \n\x20of\x20the\x20reconciliation\x20as\x20well\x20as\x20an\x20Observati\
    on\x20with\x20additional\x20information\x20about\n\x20the\x20State.\n\n\
    \x0b\n\x03\x04P\x01\x12\x04\xf0\t\x08\x17\n\x9e\x01\n\x04\x04P\x02\0\x12\
    \x04\xf3\t\x02\x1c\x1a\x8f\x01\x20State\x20describe\x20the\x20current\
    \x20readiness\x20of\x20a\x20resource\x20after\x20the\x20last\x20reconcil\
    iation.\n\x20The\x20possible\x20states\x20include\x20Pending,\x20Success\
    ,\x20and\x20Failure.\n\n\r\n\x05\x04P\x02\0\x04\x12\x04\xf3\t\x02\n\n\r\
    \n\x05\x04P\x02\0\x05\x12\x04\xf3\t\x0b\x11\n\r\n\x05\x04P\x02\0\x01\x12\
    \x04\xf3\t\x12\x17\n\r\n\x05\x04P\x02\0\x03\x12\x04\xf3\t\x1a\x1b\n\xd0\
    \x01\n\x04\x04P\x02\x01\x12\x04\xf8\t\x02\"\x1a\xc1\x01\x20Observation\
    \x20provides\x20additional\x20information\x20related\x20to\x20the\x20sta\
    te\x20of\x20the\n\x20resource.\x20For\x20example,\x20if\x20a\x20reconcil\
    iation\x20error\x20occurs,\x20Observation\x20will\n\x20contain\x20a\x20b\
    rief\x20description\x20of\x20the\x20problem.\n\n\r\n\x05\x04P\x02\x01\
    \x04\x12\x04\xf8\t\x02\n\n\r\n\x05\x04P\x02\x01\x05\x12\x04\xf8\t\x0b\
    \x11\n\r\n\x05\x04P\x02\x01\x01\x12\x04\xf8\t\x12\x1d\n\r\n\x05\x04P\x02\
    \x01\x03\x12\x04\xf8\t\x20!\n\x93\x01\n\x02\x04Q\x12\x06\xfd\t\0\x81\n\
    \x01\x1a\x84\x01\x20ResourceReference\x20is\x20an\x20ObjectReference\x20\
    to\x20a\x20Contrail\x20resource\x20that\x20contains\n\x20the\x20Contrail\
    FqName\x20of\x20the\x20resource\x20being\x20referenced.\n\n\x0b\n\x03\
    \x04Q\x01\x12\x04\xfd\t\x08\x19\n\x0c\n\x04\x04Q\x02\0\x12\x04\xfe\t\x02\
    B\n\r\n\x05\x04Q\x02\0\x04\x12\x04\xfe\t\x02\n\n\r\n\x05\x04Q\x02\0\x06\
    \x12\x04\xfe\t\x0b-\n\r\n\x05\x04Q\x02\0\x01\x12\x04\xfe\t.=\n\r\n\x05\
    \x04Q\x02\0\x03\x12\x04\xfe\t@A\n\x0c\n\x04\x04Q\x02\x01\x12\x04\x80\n\
    \x02-\n\r\n\x05\x04Q\x02\x01\x04\x12\x04\x80\n\x02\n\n\r\n\x05\x04Q\x02\
    \x01\x06\x12\x04\x80\n\x0b\x19\n\r\n\x05\x04Q\x02\x01\x01\x12\x04\x80\n\
    \x1a(\n\r\n\x05\x04Q\x02\x01\x03\x12\x04\x80\n+,\nO\n\x02\x04R\x12\x06\
    \x84\n\0\x8c\n\x01\x1aA\x20RouteOriginOverride\x20is\x20used\x20to\x20ov\
    erride\x20route\x20origin\x20attribute.\n\n\x0b\n\x03\x04R\x01\x12\x04\
    \x84\n\x08\x1b\nQ\n\x04\x04R\x02\0\x12\x04\x87\n\x02#\x1aC\x20Set\x20tru\
    e\x20to\x20override\x20Route\x20origin\x20with\x20the\x20given\x20value\
    \n\x20+optional\n\n\r\n\x05\x04R\x02\0\x04\x12\x04\x87\n\x02\n\n\r\n\x05\
    \x04R\x02\0\x05\x12\x04\x87\n\x0b\x0f\n\r\n\x05\x04R\x02\0\x01\x12\x04\
    \x87\n\x10\x1e\n\r\n\x05\x04R\x02\0\x03\x12\x04\x87\n!\"\n9\n\x04\x04R\
    \x02\x01\x12\x04\x8b\n\x02\x1d\x1a+\x20User\x20define\x20route\x20origin\
    \x20value\n\x20+optional\n\n\r\n\x05\x04R\x02\x01\x04\x12\x04\x8b\n\x02\
    \n\n\r\n\x05\x04R\x02\x01\x05\x12\x04\x8b\n\x0b\x11\n\r\n\x05\x04R\x02\
    \x01\x01\x12\x04\x8b\n\x12\x18\n\r\n\x05\x04R\x02\x01\x03\x12\x04\x8b\n\
    \x1b\x1c\n\xb8\x02\n\x02\x04S\x12\x06\x93\n\0\xa5\n\x01\x1a\xa9\x02\x20R\
    outeTarget\x20is\x20a\x20route-target\x20extended\x20community,\x20a\x20\
    type\x20of\x20BGP\x20extended\n\x20community\x20that\x20used\x20to\x20de\
    fine\x20VPN\x20membership.\x20The\x20route\x20target\x20appears\x20in\
    \x20a\n\x20field\x20in\x20route\x20update.\n\x20+k8s:openapi-gen=true\n\
    \x20+resource:path=routetargets,strategy=RouteTargetStrategy,shortname=r\
    t,categories=contrail;routing\n\n\x0b\n\x03\x04S\x01\x12\x04\x93\n\x08\
    \x13\n\xa0\x01\n\x04\x04S\x02\0\x12\x04\x97\n\x02H\x1a\x91\x01\x20Standa\
    rd\x20object's\x20metadata.\n\x20More\x20info:\x20https://git.k8s.io/com\
    munity/contributors/devel/sig-architecture/api-conventions.md#metadata\n\
    \x20+optional\n\n\r\n\x05\x04S\x02\0\x04\x12\x04\x97\n\x02\n\n\r\n\x05\
    \x04S\x02\0\x06\x12\x04\x97\n\x0b:\n\r\n\x05\x04S\x02\0\x01\x12\x04\x97\
    \n;C\n\r\n\x05\x04S\x02\0\x03\x12\x04\x97\nFG\n\xc2\x01\n\x04\x04S\x02\
    \x01\x12\x04\x9c\n\x02$\x1a\xb3\x01\x20Specification\x20of\x20the\x20des\
    ired\x20state\x20of\x20the\x20RouteTarget.\n\x20More\x20info:\x20https:/\
    /git.k8s.io/community/contributors/devel/sig-architecture/api-convention\
    s.md#spec-and-status\n\x20+optional\n\n\r\n\x05\x04S\x02\x01\x04\x12\x04\
    \x9c\n\x02\n\n\r\n\x05\x04S\x02\x01\x06\x12\x04\x9c\n\x0b\x1a\n\r\n\x05\
    \x04S\x02\x01\x01\x12\x04\x9c\n\x1b\x1f\n\r\n\x05\x04S\x02\x01\x03\x12\
    \x04\x9c\n\"#\n\x89\x02\n\x04\x04S\x02\x02\x12\x04\xa4\n\x02(\x1a\xfa\
    \x01\x20The\x20most\x20recently\x20observed\x20status\x20of\x20the\x20Ro\
    uteTarget.\n\x20This\x20data\x20may\x20not\x20be\x20up-to-date.\n\x20Pop\
    ulated\x20by\x20the\x20system.\n\x20Read-only.\n\x20More\x20info:\x20htt\
    ps://git.k8s.io/community/contributors/devel/sig-architecture/api-conven\
    tions.md#spec-and-status\n\x20+optional\n\n\r\n\x05\x04S\x02\x02\x04\x12\
    \x04\xa4\n\x02\n\n\r\n\x05\x04S\x02\x02\x06\x12\x04\xa4\n\x0b\x1c\n\r\n\
    \x05\x04S\x02\x02\x01\x12\x04\xa4\n\x1d#\n\r\n\x05\x04S\x02\x02\x03\x12\
    \x04\xa4\n&'\n9\n\x02\x04T\x12\x06\xa8\n\0\xb0\n\x01\x1a+\x20RouteTarget\
    List\x20is\x20a\x20list\x20of\x20RouteTarget.\n\n\x0b\n\x03\x04T\x01\x12\
    \x04\xa8\n\x08\x17\n\xac\x01\n\x04\x04T\x02\0\x12\x04\xac\n\x02F\x1a\x9d\
    \x01\x20Standard\x20list's\x20metadata.\n\x20More\x20info:\x20https://gi\
    t.k8s.io/community/contributors/devel/sig-architecture/api-conventions.m\
    d#lists-and-simple-kinds\n\x20+optional\n\n\r\n\x05\x04T\x02\0\x04\x12\
    \x04\xac\n\x02\n\n\r\n\x05\x04T\x02\0\x06\x12\x04\xac\n\x0b8\n\r\n\x05\
    \x04T\x02\0\x01\x12\x04\xac\n9A\n\r\n\x05\x04T\x02\0\x03\x12\x04\xac\nDE\
    \nW\n\x04\x04T\x02\x01\x12\x04\xaf\n\x02!\x1aI\x20Items\x20contains\x20a\
    ll\x20of\x20the\x20RouteTarget\x20instances\x20in\x20the\x20RouteTargetL\
    ist.\n\n\r\n\x05\x04T\x02\x01\x04\x12\x04\xaf\n\x02\n\n\r\n\x05\x04T\x02\
    \x01\x06\x12\x04\xaf\n\x0b\x16\n\r\n\x05\x04T\x02\x01\x01\x12\x04\xaf\n\
    \x17\x1c\n\r\n\x05\x04T\x02\x01\x03\x12\x04\xaf\n\x1f\x20\nv\n\x02\x04U\
    \x12\x06\xb4\n\0\xbc\n\x01\x1ah\x20RouteTargetReference\x20contains\x20a\
    \x20RouteTarget\x20reference\x20and\x20the\n\x20import/export\x20mode\
    \x20in\x20their\x20attributes.\n\n\x0b\n\x03\x04U\x01\x12\x04\xb4\n\x08\
    \x1c\n\x0c\n\x04\x04U\x02\0\x12\x04\xb5\n\x023\n\r\n\x05\x04U\x02\0\x04\
    \x12\x04\xb5\n\x02\n\n\r\n\x05\x04U\x02\0\x06\x12\x04\xb5\n\x0b\x1c\n\r\
    \n\x05\x04U\x02\0\x01\x12\x04\xb5\n\x1d.\n\r\n\x05\x04U\x02\0\x03\x12\
    \x04\xb5\n12\n\x84\x02\n\x04\x04U\x02\x01\x12\x04\xbb\n\x029\x1a\xf5\x01\
    \x20Attributes\x20contains\x20the\x20ImportExport\x20flag.\x20When\x20Im\
    portExport\x20is\x20blank\x20(the\x20default),\n\x20both\x20import\x20an\
    d\x20export\x20are\x20supported.\x20Setting\x20ImportExport\x20to\x20\"i\
    mport\"\x20enables\n\x20import-only\x20mode.\x20Setting\x20it\x20to\x20\
    \"export\"\x20enables\x20export-only\x20mode.\n\x20+optional\n\n\r\n\x05\
    \x04U\x02\x01\x04\x12\x04\xbb\n\x02\n\n\r\n\x05\x04U\x02\x01\x06\x12\x04\
    \xbb\n\x0b)\n\r\n\x05\x04U\x02\x01\x01\x12\x04\xbb\n*4\n\r\n\x05\x04U\
    \x02\x01\x03\x12\x04\xbb\n78\n^\n\x02\x04V\x12\x06\xbf\n\0\xc6\n\x01\x1a\
    P\x20RouteTargetReferenceAttributes\x20allows\x20the\x20configuration\
    \x20of\x20import/export\x20mode.\n\n\x0b\n\x03\x04V\x01\x12\x04\xbf\n\
    \x08&\n\x9d\x02\n\x04\x04V\x02\0\x12\x04\xc5\n\x02#\x1a\x8e\x02\x20Impor\
    tExport\x20determines\x20the\x20import/export\x20mode.\x20By\x20default,\
    \x20this\x20field\x20is\n\x20empty.\x20When\x20ImportExport\x20is\x20bla\
    nk,\x20bott\x20import\x20and\x20export\x20are\x20supported.\n\x20Setting\
    \x20ImportExport\x20to\x20\"import\"\x20enables\x20import-only\x20mode.\
    \x20Setting\x20it\x20to\n\x20\"export\"\x20enables\x20export-only\x20mod\
    e.\n\x20+optional\n\n\r\n\x05\x04V\x02\0\x04\x12\x04\xc5\n\x02\n\n\r\n\
    \x05\x04V\x02\0\x05\x12\x04\xc5\n\x0b\x11\n\r\n\x05\x04V\x02\0\x01\x12\
    \x04\xc5\n\x12\x1e\n\r\n\x05\x04V\x02\0\x03\x12\x04\xc5\n!\"\nK\n\x02\
    \x04W\x12\x06\xc9\n\0\xcc\n\x01\x1a=\x20RouteTargetSpec\x20defines\x20th\
    e\x20desired\x20state\x20of\x20a\x20RouteTarget.\n\n\x0b\n\x03\x04W\x01\
    \x12\x04\xc9\n\x08\x17\n\"\n\x04\x04W\x02\0\x12\x04\xcb\n\x02%\x1a\x14\
    \x20Common\x20spec\x20fields\n\n\r\n\x05\x04W\x02\0\x04\x12\x04\xcb\n\
    \x02\n\n\r\n\x05\x04W\x02\0\x06\x12\x04\xcb\n\x0b\x15\n\r\n\x05\x04W\x02\
    \0\x01\x12\x04\xcb\n\x16\x20\n\r\n\x05\x04W\x02\0\x03\x12\x04\xcb\n#$\nN\
    \n\x02\x04X\x12\x06\xcf\n\0\xd2\n\x01\x1a@\x20RouteTargetStatus\x20defin\
    es\x20the\x20observed\x20state\x20of\x20a\x20RouteTarget.\n\n\x0b\n\x03\
    \x04X\x01\x12\x04\xcf\n\x08\x19\n$\n\x04\x04X\x02\0\x12\x04\xd1\n\x02)\
    \x1a\x16\x20Common\x20status\x20fields\n\n\r\n\x05\x04X\x02\0\x04\x12\
    \x04\xd1\n\x02\n\n\r\n\x05\x04X\x02\0\x06\x12\x04\xd1\n\x0b\x17\n\r\n\
    \x05\x04X\x02\0\x01\x12\x04\xd1\n\x18$\n\r\n\x05\x04X\x02\0\x03\x12\x04\
    \xd1\n'(\n\x99\x02\n\x02\x04Y\x12\x06\xd8\n\0\xea\n\x01\x1a\x8a\x02\x20R\
    outingInstance\x20is\x20a\x20group\x20of\x20customer\x20attachment\x20po\
    ints\x20with\x20the\x20same\n\x20connectivity\x20policies.\x20Correspond\
    ing\x20to\x20the\x20VRF\x20in\x20L3VPN/EVPN.\n\x20+k8s:openapi-gen=true\
    \n\x20+resource:path=routinginstances,strategy=RoutingInstanceStrategy,s\
    hortname=ri,categories=contrail;routing\n\n\x0b\n\x03\x04Y\x01\x12\x04\
    \xd8\n\x08\x17\n\xa0\x01\n\x04\x04Y\x02\0\x12\x04\xdc\n\x02H\x1a\x91\x01\
    \x20Standard\x20object's\x20metadata.\n\x20More\x20info:\x20https://git.\
    k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#\
    metadata\n\x20+optional\n\n\r\n\x05\x04Y\x02\0\x04\x12\x04\xdc\n\x02\n\n\
    \r\n\x05\x04Y\x02\0\x06\x12\x04\xdc\n\x0b:\n\r\n\x05\x04Y\x02\0\x01\x12\
    \x04\xdc\n;C\n\r\n\x05\x04Y\x02\0\x03\x12\x04\xdc\nFG\n\xc6\x01\n\x04\
    \x04Y\x02\x01\x12\x04\xe1\n\x02(\x1a\xb7\x01\x20Specification\x20of\x20t\
    he\x20desired\x20state\x20of\x20the\x20RoutingInstance.\n\x20More\x20inf\
    o:\x20https://git.k8s.io/community/contributors/devel/sig-architecture/a\
    pi-conventions.md#spec-and-status\n\x20+optional\n\n\r\n\x05\x04Y\x02\
    \x01\x04\x12\x04\xe1\n\x02\n\n\r\n\x05\x04Y\x02\x01\x06\x12\x04\xe1\n\
    \x0b\x1e\n\r\n\x05\x04Y\x02\x01\x01\x12\x04\xe1\n\x1f#\n\r\n\x05\x04Y\
    \x02\x01\x03\x12\x04\xe1\n&'\n\x8d\x02\n\x04\x04Y\x02\x02\x12\x04\xe9\n\
    \x02,\x1a\xfe\x01\x20The\x20most\x20recently\x20observed\x20status\x20of\
    \x20the\x20RoutingInstance.\n\x20This\x20data\x20may\x20not\x20be\x20up-\
    to-date.\n\x20Populated\x20by\x20the\x20system.\n\x20Read-only.\n\x20Mor\
    e\x20info:\x20https://git.k8s.io/community/contributors/devel/sig-archit\
    ecture/api-conventions.md#spec-and-status\n\x20+optional\n\n\r\n\x05\x04\
    Y\x02\x02\x04\x12\x04\xe9\n\x02\n\n\r\n\x05\x04Y\x02\x02\x06\x12\x04\xe9\
    \n\x0b\x20\n\r\n\x05\x04Y\x02\x02\x01\x12\x04\xe9\n!'\n\r\n\x05\x04Y\x02\
    \x02\x03\x12\x04\xe9\n*+\nA\n\x02\x04Z\x12\x06\xed\n\0\xf5\n\x01\x1a3\
    \x20RoutingInstanceList\x20is\x20a\x20list\x20of\x20RoutingInstance.\n\n\
    \x0b\n\x03\x04Z\x01\x12\x04\xed\n\x08\x1b\n\xac\x01\n\x04\x04Z\x02\0\x12\
    \x04\xf1\n\x02F\x1a\x9d\x01\x20Standard\x20list's\x20metadata.\n\x20More\
    \x20info:\x20https://git.k8s.io/community/contributors/devel/sig-archite\
    cture/api-conventions.md#lists-and-simple-kinds\n\x20+optional\n\n\r\n\
    \x05\x04Z\x02\0\x04\x12\x04\xf1\n\x02\n\n\r\n\x05\x04Z\x02\0\x06\x12\x04\
    \xf1\n\x0b8\n\r\n\x05\x04Z\x02\0\x01\x12\x04\xf1\n9A\n\r\n\x05\x04Z\x02\
    \0\x03\x12\x04\xf1\nDE\n_\n\x04\x04Z\x02\x01\x12\x04\xf4\n\x02%\x1aQ\x20\
    Items\x20contains\x20all\x20of\x20the\x20RoutingInstance\x20instances\
    \x20in\x20the\x20RoutingInstanceList.\n\n\r\n\x05\x04Z\x02\x01\x04\x12\
    \x04\xf4\n\x02\n\n\r\n\x05\x04Z\x02\x01\x06\x12\x04\xf4\n\x0b\x1a\n\r\n\
    \x05\x04Z\x02\x01\x01\x12\x04\xf4\n\x1b\x20\n\r\n\x05\x04Z\x02\x01\x03\
    \x12\x04\xf4\n#$\n\x8c\x01\n\x02\x04[\x12\x06\xf9\n\0\xff\n\x01\x1a~\x20\
    RoutingInstanceReference\x20contains\x20a\x20RoutingInstance\x20referenc\
    e\x20and\x20an\x20Attributes\n\x20instance\x20defining\x20a\x20policy\
    \x20forwarding\x20rule.\n\n\x0b\n\x03\x04[\x01\x12\x04\xf9\n\x08\x20\n\
    \x0c\n\x04\x04[\x02\0\x12\x04\xfa\n\x023\n\r\n\x05\x04[\x02\0\x04\x12\
    \x04\xfa\n\x02\n\n\r\n\x05\x04[\x02\0\x06\x12\x04\xfa\n\x0b\x1c\n\r\n\
    \x05\x04[\x02\0\x01\x12\x04\xfa\n\x1d.\n\r\n\x05\x04[\x02\0\x03\x12\x04\
    \xfa\n12\n\xa4\x01\n\x04\x04[\x02\x01\x12\x04\xfe\n\x024\x1a\x95\x01\x20\
    Attributes\x20contains\x20a\x20policy\x20forwarding\x20rule\x20which\x20\
    specifies\x20the\x20traffic\n\x20direction\x20(ingress,\x20egress\x20or\
    \x20both)\x20for\x20the\x20routes\x20to\x20an\x20optimal\x20gateway.\n\n\
    \r\n\x05\x04[\x02\x01\x04\x12\x04\xfe\n\x02\n\n\r\n\x05\x04[\x02\x01\x06\
    \x12\x04\xfe\n\x0b$\n\r\n\x05\x04[\x02\x01\x01\x12\x04\xfe\n%/\n\r\n\x05\
    \x04[\x02\x01\x03\x12\x04\xfe\n23\nU\n\x02\x04\\\x12\x06\x82\x0b\0\x8d\
    \x0b\x01\x1aG\x20RoutingInstanceSpec\x20defines\x20the\x20desired\x20sta\
    te\x20of\x20the\x20RoutingInstance.\n\n\x0b\n\x03\x04\\\x01\x12\x04\x82\
    \x0b\x08\x1b\n\"\n\x04\x04\\\x02\0\x12\x04\x84\x0b\x02%\x1a\x14\x20Commo\
    n\x20spec\x20fields\n\n\r\n\x05\x04\\\x02\0\x04\x12\x04\x84\x0b\x02\n\n\
    \r\n\x05\x04\\\x02\0\x06\x12\x04\x84\x0b\x0b\x15\n\r\n\x05\x04\\\x02\0\
    \x01\x12\x04\x84\x0b\x16\x20\n\r\n\x05\x04\\\x02\0\x03\x12\x04\x84\x0b#$\
    \n>\n\x04\x04\\\x02\x01\x12\x04\x87\x0b\x029\x1a0\x20Object\x20reference\
    \x20to\x20the\x20parent\x20VirtualNetwork.\n\n\r\n\x05\x04\\\x02\x01\x04\
    \x12\x04\x87\x0b\x02\n\n\r\n\x05\x04\\\x02\x01\x06\x12\x04\x87\x0b\x0b-\
    \n\r\n\x05\x04\\\x02\x01\x01\x12\x04\x87\x0b.4\n\r\n\x05\x04\\\x02\x01\
    \x03\x12\x04\x87\x0b78\n\xb7\x01\n\x04\x04\\\x02\x02\x12\x04\x8c\x0b\x02\
    :\x1a\xa8\x01\x20RouteTargetReferences\x20contains\x20RouteTarget\x20ref\
    erences\x20assigned\x20by\x20the\x20user.\n\x20The\x20RoutingInstance's\
    \x20default\x20RouteTarget\x20is\x20defined\x20in\x20RoutingInstanceStat\
    us.\n\x20+optional\n\n\r\n\x05\x04\\\x02\x02\x04\x12\x04\x8c\x0b\x02\n\n\
    \r\n\x05\x04\\\x02\x02\x06\x12\x04\x8c\x0b\x0b\x1f\n\r\n\x05\x04\\\x02\
    \x02\x01\x12\x04\x8c\x0b\x205\n\r\n\x05\x04\\\x02\x02\x03\x12\x04\x8c\
    \x0b89\nX\n\x02\x04]\x12\x06\x90\x0b\0\xaa\x0b\x01\x1aJ\x20RoutingInstan\
    ceStatus\x20defines\x20the\x20observed\x20state\x20of\x20the\x20RoutingI\
    nstance.\n\n\x0b\n\x03\x04]\x01\x12\x04\x90\x0b\x08\x1d\n$\n\x04\x04]\
    \x02\0\x12\x04\x92\x0b\x02)\x1a\x16\x20Common\x20status\x20fields\n\n\r\
    \n\x05\x04]\x02\0\x04\x12\x04\x92\x0b\x02\n\n\r\n\x05\x04]\x02\0\x06\x12\
    \x04\x92\x0b\x0b\x17\n\r\n\x05\x04]\x02\0\x01\x12\x04\x92\x0b\x18$\n\r\n\
    \x05\x04]\x02\0\x03\x12\x04\x92\x0b'(\n\xb1\x01\n\x04\x04]\x02\x01\x12\
    \x04\x98\x0b\x02\x1e\x1a\xa2\x01\x20Is\x20this\x20the\x20default\x20rout\
    ing\x20instance\x20for\x20the\x20VirtualNetwork?\x20This\n\x20field\x20c\
    ontains\x20internal\x20service\x20chaining\x20information,\x20and\x20sho\
    uld\x20not\x20be\n\x20modified.\n\x20+optional\n\n\r\n\x05\x04]\x02\x01\
    \x04\x12\x04\x98\x0b\x02\n\n\r\n\x05\x04]\x02\x01\x05\x12\x04\x98\x0b\
    \x0b\x0f\n\r\n\x05\x04]\x02\x01\x01\x12\x04\x98\x0b\x10\x19\n\r\n\x05\
    \x04]\x02\x01\x03\x12\x04\x98\x0b\x1c\x1d\n_\n\x04\x04]\x02\x02\x12\x04\
    \x9c\x0b\x02.\x1aQ\x20FabricSNAT\x20toggles\x20connectivity\x20to\x20und\
    erlay\x20network\x20by\x20port\x20mapping.\n\x20+optional\n\n\r\n\x05\
    \x04]\x02\x02\x04\x12\x04\x9c\x0b\x02\n\n\r\n\x05\x04]\x02\x02\x05\x12\
    \x04\x9c\x0b\x0b\x0f\n\r\n\x05\x04]\x02\x02\x01\x12\x04\x9c\x0b\x10)\n\r\
    \n\x05\x04]\x02\x02\x03\x12\x04\x9c\x0b,-\n\xf9\x01\n\x04\x04]\x02\x03\
    \x12\x04\xa3\x0b\x02@\x1a\xea\x01\x20DefaultRouteTargetReference\x20cont\
    ains\x20a\x20reference\x20to\x20the\x20default\x20RouteTarget\n\x20and\
    \x20the\x20import/export\x20mode\x20in\x20their\x20attributes.\n\x20Only\
    \x20set\x20by\x20the\x20system\x20as\x20user\x20must\x20pass\x20by\x20hi\
    gher\x20level\x20resources\x20to\n\x20add\x20remove\x20Route\x20Target.\
    \n\x20+optional\n\n\r\n\x05\x04]\x02\x03\x04\x12\x04\xa3\x0b\x02\n\n\r\n\
    \x05\x04]\x02\x03\x06\x12\x04\xa3\x0b\x0b\x1f\n\r\n\x05\x04]\x02\x03\x01\
    \x12\x04\xa3\x0b\x20;\n\r\n\x05\x04]\x02\x03\x03\x12\x04\xa3\x0b>?\n\xe7\
    \x01\n\x04\x04]\x02\x04\x12\x04\xa9\x0b\x02d\x1a\xd8\x01\x20VirtualNetwo\
    rkRouterRouteTargetReferences\x20are\x20RouteTarget\x20references\x20of\
    \x20VirtualNetworkRouters\n\x20selecting\x20this\x20RoutingInstance's\
    \x20parent\x20VirtualNetwork,\x20as\x20well\x20as\x20those\x20of\n\x20im\
    ported\x20VirtualNetworkRouters.\n\x20+optional\n\n\x0f\n\x05\x04]\x02\
    \x04\x04\x12\x06\xa9\x0b\x02\xa3\x0b@\n\r\n\x05\x04]\x02\x04\x06\x12\x04\
    \xa9\x0b\x025\n\r\n\x05\x04]\x02\x04\x01\x12\x04\xa9\x0b6_\n\r\n\x05\x04\
    ]\x02\x04\x03\x12\x04\xa9\x0bbc\n\xca\x02\n\x02\x04^\x12\x06\xb1\x0b\0\
    \xc3\x0b\x01\x1a\xbb\x02\x20Subnet\x20represents\x20a\x20block\x20of\x20\
    IP\x20addresses\x20and\x20its\x20configuration.\n\x20IPAM\x20allocates\
    \x20and\x20releases\x20IP\x20address\x20from\x20that\x20block\x20on\x20d\
    emand.\n\x20It\x20can\x20be\x20used\x20by\x20different\x20VirtualNetwork\
    \x20in\x20the\x20mean\x20time.\n\x20+k8s:openapi-gen=true\n\x20+resource\
    :path=subnets,strategy=SubnetStrategy,shortname=sn,categories=contrail;i\
    pam;networking\n\n\x0b\n\x03\x04^\x01\x12\x04\xb1\x0b\x08\x0e\n\xa0\x01\
    \n\x04\x04^\x02\0\x12\x04\xb5\x0b\x02H\x1a\x91\x01\x20Standard\x20object\
    's\x20metadata.\n\x20More\x20info:\x20https://git.k8s.io/community/contr\
    ibutors/devel/sig-architecture/api-conventions.md#metadata\n\x20+optiona\
    l\n\n\r\n\x05\x04^\x02\0\x04\x12\x04\xb5\x0b\x02\n\n\r\n\x05\x04^\x02\0\
    \x06\x12\x04\xb5\x0b\x0b:\n\r\n\x05\x04^\x02\0\x01\x12\x04\xb5\x0b;C\n\r\
    \n\x05\x04^\x02\0\x03\x12\x04\xb5\x0bFG\n\xbd\x01\n\x04\x04^\x02\x01\x12\
    \x04\xba\x0b\x02\x1f\x1a\xae\x01\x20Specification\x20of\x20the\x20desire\
    d\x20state\x20of\x20the\x20Subnet.\n\x20More\x20info:\x20https://git.k8s\
    .io/community/contributors/devel/sig-architecture/api-conventions.md#spe\
    c-and-status\n\x20+optional\n\n\r\n\x05\x04^\x02\x01\x04\x12\x04\xba\x0b\
    \x02\n\n\r\n\x05\x04^\x02\x01\x06\x12\x04\xba\x0b\x0b\x15\n\r\n\x05\x04^\
    \x02\x01\x01\x12\x04\xba\x0b\x16\x1a\n\r\n\x05\x04^\x02\x01\x03\x12\x04\
    \xba\x0b\x1d\x1e\n\x84\x02\n\x04\x04^\x02\x02\x12\x04\xc2\x0b\x02#\x1a\
    \xf5\x01\x20The\x20most\x20recently\x20observed\x20status\x20of\x20the\
    \x20Subnet.\n\x20This\x20data\x20may\x20not\x20be\x20up-to-date.\n\x20Po\
    pulated\x20by\x20the\x20system.\n\x20Read-only.\n\x20More\x20info:\x20ht\
    tps://git.k8s.io/community/contributors/devel/sig-architecture/api-conve\
    ntions.md#spec-and-status\n\x20+optional\n\n\r\n\x05\x04^\x02\x02\x04\
    \x12\x04\xc2\x0b\x02\n\n\r\n\x05\x04^\x02\x02\x06\x12\x04\xc2\x0b\x0b\
    \x17\n\r\n\x05\x04^\x02\x02\x01\x12\x04\xc2\x0b\x18\x1e\n\r\n\x05\x04^\
    \x02\x02\x03\x12\x04\xc2\x0b!\"\n/\n\x02\x04_\x12\x06\xc6\x0b\0\xce\x0b\
    \x01\x1a!\x20SubnetList\x20is\x20a\x20list\x20of\x20Subnet.\n\n\x0b\n\
    \x03\x04_\x01\x12\x04\xc6\x0b\x08\x12\n\xac\x01\n\x04\x04_\x02\0\x12\x04\
    \xca\x0b\x02F\x1a\x9d\x01\x20Standard\x20list's\x20metadata.\n\x20More\
    \x20info:\x20https://git.k8s.io/community/contributors/devel/sig-archite\
    cture/api-conventions.md#lists-and-simple-kinds\n\x20+optional\n\n\r\n\
    \x05\x04_\x02\0\x04\x12\x04\xca\x0b\x02\n\n\r\n\x05\x04_\x02\0\x06\x12\
    \x04\xca\x0b\x0b8\n\r\n\x05\x04_\x02\0\x01\x12\x04\xca\x0b9A\n\r\n\x05\
    \x04_\x02\0\x03\x12\x04\xca\x0bDE\nM\n\x04\x04_\x02\x01\x12\x04\xcd\x0b\
    \x02\x1c\x1a?\x20Items\x20contains\x20all\x20of\x20the\x20Subnet\x20inst\
    ances\x20in\x20the\x20SubnetList.\n\n\r\n\x05\x04_\x02\x01\x04\x12\x04\
    \xcd\x0b\x02\n\n\r\n\x05\x04_\x02\x01\x06\x12\x04\xcd\x0b\x0b\x11\n\r\n\
    \x05\x04_\x02\x01\x01\x12\x04\xcd\x0b\x12\x17\n\r\n\x05\x04_\x02\x01\x03\
    \x12\x04\xcd\x0b\x1a\x1b\n\xa1\x01\n\x02\x04`\x12\x06\xd2\x0b\0\xd6\x0b\
    \x01\x1a\x92\x01\x20SubnetReference\x20contains\x20a\x20Subnet\x20refere\
    nce\x20and\x20a\x20BGPSessionIPAttributes\n\x20instance\x20defining\x20t\
    he\x20BGPaaSPrimaryIP\x20and\x20BGPaaSSecondaryIP\x20addresses.\n\n\x0b\
    \n\x03\x04`\x01\x12\x04\xd2\x0b\x08\x17\n\x0c\n\x04\x04`\x02\0\x12\x04\
    \xd3\x0b\x023\n\r\n\x05\x04`\x02\0\x04\x12\x04\xd3\x0b\x02\n\n\r\n\x05\
    \x04`\x02\0\x06\x12\x04\xd3\x0b\x0b\x1c\n\r\n\x05\x04`\x02\0\x01\x12\x04\
    \xd3\x0b\x1d.\n\r\n\x05\x04`\x02\0\x03\x12\x04\xd3\x0b12\n\x0c\n\x04\x04\
    `\x02\x01\x12\x04\xd5\x0b\x021\n\r\n\x05\x04`\x02\x01\x04\x12\x04\xd5\
    \x0b\x02\n\n\r\n\x05\x04`\x02\x01\x06\x12\x04\xd5\x0b\x0b!\n\r\n\x05\x04\
    `\x02\x01\x01\x12\x04\xd5\x0b\",\n\r\n\x05\x04`\x02\x01\x03\x12\x04\xd5\
    \x0b/0\nA\n\x02\x04a\x12\x06\xd9\x0b\0\x80\x0c\x01\x1a3\x20SubnetSpec\
    \x20defines\x20the\x20desired\x20state\x20of\x20a\x20Subnet.\n\n\x0b\n\
    \x03\x04a\x01\x12\x04\xd9\x0b\x08\x12\n\"\n\x04\x04a\x02\0\x12\x04\xdb\
    \x0b\x02%\x1a\x14\x20Common\x20spec\x20fields\n\n\r\n\x05\x04a\x02\0\x04\
    \x12\x04\xdb\x0b\x02\n\n\r\n\x05\x04a\x02\0\x06\x12\x04\xdb\x0b\x0b\x15\
    \n\r\n\x05\x04a\x02\0\x01\x12\x04\xdb\x0b\x16\x20\n\r\n\x05\x04a\x02\0\
    \x03\x12\x04\xdb\x0b#$\n9\n\x04\x04a\x02\x01\x12\x04\xdf\x0b\x02\x1b\x1a\
    +\x20Subnet\x20range\x20in\x20CIDR\x20notation.\n\x20+optional\n\n\r\n\
    \x05\x04a\x02\x01\x04\x12\x04\xdf\x0b\x02\n\n\r\n\x05\x04a\x02\x01\x05\
    \x12\x04\xdf\x0b\x0b\x11\n\r\n\x05\x04a\x02\x01\x01\x12\x04\xdf\x0b\x12\
    \x16\n\r\n\x05\x04a\x02\x01\x03\x12\x04\xdf\x0b\x19\x1a\n{\n\x04\x04a\
    \x02\x02\x12\x04\xe4\x0b\x02%\x1am\x20Default\x20Gateway\x20IP\x20addres\
    s\x20in\x20the\x20subnet.\n\x20If\x20not\x20provided,\x20one\x20is\x20au\
    to-generated\x20by\x20the\x20system.\n\x20+optional\n\n\r\n\x05\x04a\x02\
    \x02\x04\x12\x04\xe4\x0b\x02\n\n\r\n\x05\x04a\x02\x02\x05\x12\x04\xe4\
    \x0b\x0b\x11\n\r\n\x05\x04a\x02\x02\x01\x12\x04\xe4\x0b\x12\x20\n\r\n\
    \x05\x04a\x02\x02\x03\x12\x04\xe4\x0b#$\nJ\n\x04\x04a\x02\x03\x12\x04\
    \xe8\x0b\x02%\x1a<\x20List\x20of\x20DNS\x20servers\x20associated\x20with\
    \x20the\x20subnet.\n\x20+optional\n\n\r\n\x05\x04a\x02\x03\x04\x12\x04\
    \xe8\x0b\x02\n\n\r\n\x05\x04a\x02\x03\x05\x12\x04\xe8\x0b\x0b\x11\n\r\n\
    \x05\x04a\x02\x03\x01\x12\x04\xe8\x0b\x12\x20\n\r\n\x05\x04a\x02\x03\x03\
    \x12\x04\xe8\x0b#$\n\xab\x01\n\x04\x04a\x02\x04\x12\x04\xee\x0b\x02\x1c\
    \x1a\x9c\x01\x20Ranges,\x20when\x20present,\x20define\x20the\x20IP\x20al\
    location\x20ranges\x20corresponding\x20to\n\x20a\x20given\x20key.\n\x20I\
    f\x20not\x20provided,\x20IP\x20allocation\x20is\x20determined\x20by\x20t\
    he\x20CIDR.\n\x20+optional\n\n\r\n\x05\x04a\x02\x04\x04\x12\x04\xee\x0b\
    \x02\n\n\r\n\x05\x04a\x02\x04\x06\x12\x04\xee\x0b\x0b\x10\n\r\n\x05\x04a\
    \x02\x04\x01\x12\x04\xee\x0b\x11\x17\n\r\n\x05\x04a\x02\x04\x03\x12\x04\
    \xee\x0b\x1a\x1b\n\x9a\x03\n\x04\x04a\x02\x05\x12\x04\xf6\x0b\x022\x1a\
    \x8b\x03\x20Disables\x20auto\x20allocation\x20of\x20BGPaaSPrimaryIP\x20a\
    nd\x20BGPaaSecondaryIP.\x20False\x20by\n\x20default,\x20automatic\x20all\
    ocation\x20is\x20enabled.\x20IPs\x20are\x20auto\x20allocated\x20when\x20\
    at\n\x20least\x20one\x20BGPAsAService\x20is\x20configured\x20under\x20th\
    is\x20subnet.\x20If\x20DisableBGPaaSIPAutoAllocation\n\x20is\x20set\x20t\
    o\x20true,\x20BGPaaSPrimaryIP\x20and\x20BGPaaSSecondaryIP\x20must\x20be\
    \x20specified.\n\x20Leave\x20this\x20flag\x20false\x20if\x20the\x20BGPAs\
    AService\x20feature\x20is\x20not\x20required.\n\x20+optional\n\n\r\n\x05\
    \x04a\x02\x05\x04\x12\x04\xf6\x0b\x02\n\n\r\n\x05\x04a\x02\x05\x05\x12\
    \x04\xf6\x0b\x0b\x0f\n\r\n\x05\x04a\x02\x05\x01\x12\x04\xf6\x0b\x10-\n\r\
    \n\x05\x04a\x02\x05\x03\x12\x04\xf6\x0b01\nT\n\x04\x04a\x02\x06\x12\x04\
    \xfa\x0b\x02&\x1aF\x20Primary\x20IP\x20address\x20used\x20for\x20the\x20\
    BGP\x20as\x20a\x20service\x20session.\n\x20+optional\n\n\r\n\x05\x04a\
    \x02\x06\x04\x12\x04\xfa\x0b\x02\n\n\r\n\x05\x04a\x02\x06\x05\x12\x04\
    \xfa\x0b\x0b\x11\n\r\n\x05\x04a\x02\x06\x01\x12\x04\xfa\x0b\x12!\n\r\n\
    \x05\x04a\x02\x06\x03\x12\x04\xfa\x0b$%\n\x7f\n\x04\x04a\x02\x07\x12\x04\
    \xff\x0b\x02(\x1aq\x20Secondary\x20IP\x20address\x20used\x20for\x20the\
    \x20BGP\x20as\x20a\x20service\x20session\x20when\x20the\n\x20second\x20c\
    ontrol\x20node\x20is\x20present.\n\x20+optional\n\n\r\n\x05\x04a\x02\x07\
    \x04\x12\x04\xff\x0b\x02\n\n\r\n\x05\x04a\x02\x07\x05\x12\x04\xff\x0b\
    \x0b\x11\n\r\n\x05\x04a\x02\x07\x01\x12\x04\xff\x0b\x12#\n\r\n\x05\x04a\
    \x02\x07\x03\x12\x04\xff\x0b&'\nD\n\x02\x04b\x12\x06\x83\x0c\0\x8e\x0c\
    \x01\x1a6\x20SubnetStatus\x20defines\x20the\x20observed\x20state\x20of\
    \x20a\x20Subnet.\n\n\x0b\n\x03\x04b\x01\x12\x04\x83\x0c\x08\x14\n$\n\x04\
    \x04b\x02\0\x12\x04\x85\x0c\x02)\x1a\x16\x20Common\x20status\x20fields\n\
    \n\r\n\x05\x04b\x02\0\x04\x12\x04\x85\x0c\x02\n\n\r\n\x05\x04b\x02\0\x06\
    \x12\x04\x85\x0c\x0b\x17\n\r\n\x05\x04b\x02\0\x01\x12\x04\x85\x0c\x18$\n\
    \r\n\x05\x04b\x02\0\x03\x12\x04\x85\x0c'(\na\n\x04\x04b\x02\x01\x12\x04\
    \x89\x0c\x02\x1d\x1aS\x20IPCount\x20is\x20the\x20current\x20number\x20of\
    \x20allocated\x20IP\x20addresses\x20in\x20the\x20Subnet.\n\x20+optional\
    \n\n\r\n\x05\x04b\x02\x01\x04\x12\x04\x89\x0c\x02\n\n\r\n\x05\x04b\x02\
    \x01\x05\x12\x04\x89\x0c\x0b\x10\n\r\n\x05\x04b\x02\x01\x01\x12\x04\x89\
    \x0c\x11\x18\n\r\n\x05\x04b\x02\x01\x03\x12\x04\x89\x0c\x1b\x1c\nf\n\x04\
    \x04b\x02\x02\x12\x04\x8d\x0c\x02&\x1aX\x20AllocationUsage\x20is\x20curr\
    ent\x20percentage\x20of\x20allocated\x20addresses\x20in\x20the\x20Subnet\
    .\n\x20+optional\n\n\r\n\x05\x04b\x02\x02\x04\x12\x04\x8d\x0c\x02\n\n\r\
    \n\x05\x04b\x02\x02\x05\x12\x04\x8d\x0c\x0b\x11\n\r\n\x05\x04b\x02\x02\
    \x01\x12\x04\x8d\x0c\x12!\n\r\n\x05\x04b\x02\x02\x03\x12\x04\x8d\x0c$%\n\
    \xa9\x01\n\x02\x04c\x12\x06\x93\x0c\0\xa4\x0c\x01\x1a\x9a\x01\x20Tag\x20\
    is\x20the\x20representation\x20of\x20the\x20Tag\x20resource.\n\x20+k8s:o\
    penapi-gen=true\n\x20+resource:path=tags,strategy=TagStrategy,shortname=\
    t,categories=contrail;security\n\n\x0b\n\x03\x04c\x01\x12\x04\x93\x0c\
    \x08\x0b\n\xa0\x01\n\x04\x04c\x02\0\x12\x04\x97\x0c\x02H\x1a\x91\x01\x20\
    Standard\x20object's\x20metadata.\n\x20More\x20info:\x20https://git.k8s.\
    io/community/contributors/devel/sig-architecture/api-conventions.md#meta\
    data\n\x20+optional\n\n\r\n\x05\x04c\x02\0\x04\x12\x04\x97\x0c\x02\n\n\r\
    \n\x05\x04c\x02\0\x06\x12\x04\x97\x0c\x0b:\n\r\n\x05\x04c\x02\0\x01\x12\
    \x04\x97\x0c;C\n\r\n\x05\x04c\x02\0\x03\x12\x04\x97\x0cFG\n\xbf\x01\n\
    \x04\x04c\x02\x01\x12\x04\x9c\x0c\x02\x1c\x1a\xb0\x01\x20Specification\
    \x20of\x20the\x20desired\x20state\x20of\x20Tag\x20resource.\n\x20More\
    \x20info:\x20https://git.k8s.io/community/contributors/devel/sig-archite\
    cture/api-conventions.md#spec-and-status\n\x20+optional\n\n\r\n\x05\x04c\
    \x02\x01\x04\x12\x04\x9c\x0c\x02\n\n\r\n\x05\x04c\x02\x01\x06\x12\x04\
    \x9c\x0c\x0b\x12\n\r\n\x05\x04c\x02\x01\x01\x12\x04\x9c\x0c\x13\x17\n\r\
    \n\x05\x04c\x02\x01\x03\x12\x04\x9c\x0c\x1a\x1b\n\xe6\x01\n\x04\x04c\x02\
    \x02\x12\x04\xa3\x0c\x02\x20\x1a\xd7\x01\x20The\x20most\x20recently\x20o\
    bserved\x20status\x20of\x20the\x20Tag\x20object.\n\x20Populated\x20by\
    \x20the\x20system.\n\x20Read-only.\n\x20More\x20info:\x20https://git.k8s\
    .io/community/contributors/devel/sig-architecture/api-conventions.md#spe\
    c-and-status\n\x20+optional\n\n\r\n\x05\x04c\x02\x02\x04\x12\x04\xa3\x0c\
    \x02\n\n\r\n\x05\x04c\x02\x02\x06\x12\x04\xa3\x0c\x0b\x14\n\r\n\x05\x04c\
    \x02\x02\x01\x12\x04\xa3\x0c\x15\x1b\n\r\n\x05\x04c\x02\x02\x03\x12\x04\
    \xa3\x0c\x1e\x1f\n)\n\x02\x04d\x12\x06\xa7\x0c\0\xaf\x0c\x01\x1a\x1b\x20\
    TagList\x20is\x20a\x20list\x20of\x20Tag.\n\n\x0b\n\x03\x04d\x01\x12\x04\
    \xa7\x0c\x08\x0f\n\xac\x01\n\x04\x04d\x02\0\x12\x04\xab\x0c\x02F\x1a\x9d\
    \x01\x20Standard\x20list's\x20metadata.\n\x20More\x20info:\x20https://gi\
    t.k8s.io/community/contributors/devel/sig-architecture/api-conventions.m\
    d#lists-and-simple-kinds\n\x20+optional\n\n\r\n\x05\x04d\x02\0\x04\x12\
    \x04\xab\x0c\x02\n\n\r\n\x05\x04d\x02\0\x06\x12\x04\xab\x0c\x0b8\n\r\n\
    \x05\x04d\x02\0\x01\x12\x04\xab\x0c9A\n\r\n\x05\x04d\x02\0\x03\x12\x04\
    \xab\x0cDE\nG\n\x04\x04d\x02\x01\x12\x04\xae\x0c\x02\x19\x1a9\x20Items\
    \x20contains\x20all\x20of\x20the\x20Tag\x20instances\x20in\x20the\x20Tag\
    List.\n\n\r\n\x05\x04d\x02\x01\x04\x12\x04\xae\x0c\x02\n\n\r\n\x05\x04d\
    \x02\x01\x06\x12\x04\xae\x0c\x0b\x0e\n\r\n\x05\x04d\x02\x01\x01\x12\x04\
    \xae\x0c\x0f\x14\n\r\n\x05\x04d\x02\x01\x03\x12\x04\xae\x0c\x17\x18\n8\n\
    \x02\x04e\x12\x06\xb2\x0c\0\xbe\x0c\x01\x1a*\x20TagSpec\x20defines\x20th\
    e\x20desired\x20state\x20of\x20Tag\n\n\x0b\n\x03\x04e\x01\x12\x04\xb2\
    \x0c\x08\x0f\n\"\n\x04\x04e\x02\0\x12\x04\xb4\x0c\x02%\x1a\x14\x20Common\
    \x20spec\x20fields\n\n\r\n\x05\x04e\x02\0\x04\x12\x04\xb4\x0c\x02\n\n\r\
    \n\x05\x04e\x02\0\x06\x12\x04\xb4\x0c\x0b\x15\n\r\n\x05\x04e\x02\0\x01\
    \x12\x04\xb4\x0c\x16\x20\n\r\n\x05\x04e\x02\0\x03\x12\x04\xb4\x0c#$\nM\n\
    \x04\x04e\x02\x01\x12\x04\xb7\x0c\x02\"\x1a?\x20TagTypeName\x20defines\
    \x20name\x20of\x20Tag\x20Type\x20object\x20in\x20string\x20format.\n\n\r\
    \n\x05\x04e\x02\x01\x04\x12\x04\xb7\x0c\x02\n\n\r\n\x05\x04e\x02\x01\x05\
    \x12\x04\xb7\x0c\x0b\x11\n\r\n\x05\x04e\x02\x01\x01\x12\x04\xb7\x0c\x12\
    \x1d\n\r\n\x05\x04e\x02\x01\x03\x12\x04\xb7\x0c\x20!\nL\n\x04\x04e\x02\
    \x02\x12\x04\xba\x0c\x02\x1f\x1a>\x20TagValue\x20defines\x20namee\x20of\
    \x20Tag\x20Value\x20object\x20in\x20string\x20format.\n\n\r\n\x05\x04e\
    \x02\x02\x04\x12\x04\xba\x0c\x02\n\n\r\n\x05\x04e\x02\x02\x05\x12\x04\
    \xba\x0c\x0b\x11\n\r\n\x05\x04e\x02\x02\x01\x12\x04\xba\x0c\x12\x1a\n\r\
    \n\x05\x04e\x02\x02\x03\x12\x04\xba\x0c\x1d\x1e\n[\n\x04\x04e\x02\x03\
    \x12\x04\xbd\x0c\x022\x1aM\x20TagTypeReference\x20is\x20reference\x20to\
    \x20Tagtype\x20object\x20attachd\x20to\x20this\x20Tag\x20object.\n\n\r\n\
    \x05\x04e\x02\x03\x04\x12\x04\xbd\x0c\x02\n\n\r\n\x05\x04e\x02\x03\x06\
    \x12\x04\xbd\x0c\x0b\x1c\n\r\n\x05\x04e\x02\x03\x01\x12\x04\xbd\x0c\x1d-\
    \n\r\n\x05\x04e\x02\x03\x03\x12\x04\xbd\x0c01\n<\n\x02\x04f\x12\x06\xc1\
    \x0c\0\xc8\x0c\x01\x1a.\x20TagStatus\x20defines\x20the\x20observed\x20st\
    ate\x20of\x20Tag.\n\n\x0b\n\x03\x04f\x01\x12\x04\xc1\x0c\x08\x11\n%\n\
    \x04\x04f\x02\0\x12\x04\xc3\x0c\x02)\x1a\x17\x20Common\x20status\x20fiel\
    ds.\n\n\r\n\x05\x04f\x02\0\x04\x12\x04\xc3\x0c\x02\n\n\r\n\x05\x04f\x02\
    \0\x06\x12\x04\xc3\x0c\x0b\x17\n\r\n\x05\x04f\x02\0\x01\x12\x04\xc3\x0c\
    \x18$\n\r\n\x05\x04f\x02\0\x03\x12\x04\xc3\x0c'(\nz\n\x04\x04f\x02\x01\
    \x12\x04\xc7\x0c\x02\x1c\x1al\x20TagID\x20is\x20an\x20internal\x20repres\
    entation\x20of\x20Tag\x20object\x20encapsulating\n\x20tag\x20type\x20and\
    \x20value\x20in\x20hexadecimal\x20format.\n\n\r\n\x05\x04f\x02\x01\x04\
    \x12\x04\xc7\x0c\x02\n\n\r\n\x05\x04f\x02\x01\x05\x12\x04\xc7\x0c\x0b\
    \x11\n\r\n\x05\x04f\x02\x01\x01\x12\x04\xc7\x0c\x12\x17\n\r\n\x05\x04f\
    \x02\x01\x03\x12\x04\xc7\x0c\x1a\x1b\n\xba\x01\n\x02\x04g\x12\x06\xcd\
    \x0c\0\xde\x0c\x01\x1a\xab\x01\x20TagType\x20is\x20the\x20representation\
    \x20of\x20the\x20TagType\x20resource.\n\x20+k8s:openapi-gen=true\n\x20+r\
    esource:path=tagtypes,strategy=TagTypeStrategy,shortname=tt,categories=c\
    ontrail;security\n\n\x0b\n\x03\x04g\x01\x12\x04\xcd\x0c\x08\x0f\n\xa0\
    \x01\n\x04\x04g\x02\0\x12\x04\xd1\x0c\x02H\x1a\x91\x01\x20Standard\x20ob\
    ject's\x20metadata.\n\x20More\x20info:\x20https://git.k8s.io/community/c\
    ontributors/devel/sig-architecture/api-conventions.md#metadata\n\x20+opt\
    ional\n\n\r\n\x05\x04g\x02\0\x04\x12\x04\xd1\x0c\x02\n\n\r\n\x05\x04g\
    \x02\0\x06\x12\x04\xd1\x0c\x0b:\n\r\n\x05\x04g\x02\0\x01\x12\x04\xd1\x0c\
    ;C\n\r\n\x05\x04g\x02\0\x03\x12\x04\xd1\x0cFG\n\xc3\x01\n\x04\x04g\x02\
    \x01\x12\x04\xd6\x0c\x02\x20\x1a\xb4\x01\x20Specification\x20of\x20the\
    \x20desired\x20state\x20of\x20TagType\x20resource.\n\x20More\x20info:\
    \x20https://git.k8s.io/community/contributors/devel/sig-architecture/api\
    -conventions.md#spec-and-status\n\x20+optional\n\n\r\n\x05\x04g\x02\x01\
    \x04\x12\x04\xd6\x0c\x02\n\n\r\n\x05\x04g\x02\x01\x06\x12\x04\xd6\x0c\
    \x0b\x16\n\r\n\x05\x04g\x02\x01\x01\x12\x04\xd6\x0c\x17\x1b\n\r\n\x05\
    \x04g\x02\x01\x03\x12\x04\xd6\x0c\x1e\x1f\n\xea\x01\n\x04\x04g\x02\x02\
    \x12\x04\xdd\x0c\x02$\x1a\xdb\x01\x20The\x20most\x20recently\x20observed\
    \x20status\x20of\x20the\x20TagType\x20object.\n\x20Populated\x20by\x20th\
    e\x20system.\n\x20Read-only.\n\x20More\x20info:\x20https://git.k8s.io/co\
    mmunity/contributors/devel/sig-architecture/api-conventions.md#spec-and-\
    status\n\x20+optional\n\n\r\n\x05\x04g\x02\x02\x04\x12\x04\xdd\x0c\x02\n\
    \n\r\n\x05\x04g\x02\x02\x06\x12\x04\xdd\x0c\x0b\x18\n\r\n\x05\x04g\x02\
    \x02\x01\x12\x04\xdd\x0c\x19\x1f\n\r\n\x05\x04g\x02\x02\x03\x12\x04\xdd\
    \x0c\"#\n1\n\x02\x04h\x12\x06\xe1\x0c\0\xe9\x0c\x01\x1a#\x20TagTypeList\
    \x20is\x20a\x20list\x20of\x20TagType.\n\n\x0b\n\x03\x04h\x01\x12\x04\xe1\
    \x0c\x08\x13\n\xac\x01\n\x04\x04h\x02\0\x12\x04\xe5\x0c\x02F\x1a\x9d\x01\
    \x20Standard\x20list's\x20metadata.\n\x20More\x20info:\x20https://git.k8\
    s.io/community/contributors/devel/sig-architecture/api-conventions.md#li\
    sts-and-simple-kinds\n\x20+optional\n\n\r\n\x05\x04h\x02\0\x04\x12\x04\
    \xe5\x0c\x02\n\n\r\n\x05\x04h\x02\0\x06\x12\x04\xe5\x0c\x0b8\n\r\n\x05\
    \x04h\x02\0\x01\x12\x04\xe5\x0c9A\n\r\n\x05\x04h\x02\0\x03\x12\x04\xe5\
    \x0cDE\nO\n\x04\x04h\x02\x01\x12\x04\xe8\x0c\x02\x1d\x1aA\x20Items\x20co\
    ntains\x20all\x20of\x20the\x20TagType\x20instances\x20in\x20the\x20TagTy\
    peList.\n\n\r\n\x05\x04h\x02\x01\x04\x12\x04\xe8\x0c\x02\n\n\r\n\x05\x04\
    h\x02\x01\x06\x12\x04\xe8\x0c\x0b\x12\n\r\n\x05\x04h\x02\x01\x01\x12\x04\
    \xe8\x0c\x13\x18\n\r\n\x05\x04h\x02\x01\x03\x12\x04\xe8\x0c\x1b\x1c\n@\n\
    \x02\x04i\x12\x06\xec\x0c\0\xef\x0c\x01\x1a2\x20TagTypeSpec\x20defines\
    \x20the\x20desired\x20state\x20of\x20TagType\n\n\x0b\n\x03\x04i\x01\x12\
    \x04\xec\x0c\x08\x13\n\"\n\x04\x04i\x02\0\x12\x04\xee\x0c\x02%\x1a\x14\
    \x20Common\x20spec\x20fields\n\n\r\n\x05\x04i\x02\0\x04\x12\x04\xee\x0c\
    \x02\n\n\r\n\x05\x04i\x02\0\x06\x12\x04\xee\x0c\x0b\x15\n\r\n\x05\x04i\
    \x02\0\x01\x12\x04\xee\x0c\x16\x20\n\r\n\x05\x04i\x02\0\x03\x12\x04\xee\
    \x0c#$\nC\n\x02\x04j\x12\x06\xf2\x0c\0\xf9\x0c\x01\x1a5\x20TagTypeStatus\
    \x20defines\x20the\x20observed\x20state\x20of\x20TagType\n\n\x0b\n\x03\
    \x04j\x01\x12\x04\xf2\x0c\x08\x15\n$\n\x04\x04j\x02\0\x12\x04\xf4\x0c\
    \x02)\x1a\x16\x20Common\x20status\x20fields\n\n\r\n\x05\x04j\x02\0\x04\
    \x12\x04\xf4\x0c\x02\n\n\r\n\x05\x04j\x02\0\x06\x12\x04\xf4\x0c\x0b\x17\
    \n\r\n\x05\x04j\x02\0\x01\x12\x04\xf4\x0c\x18$\n\r\n\x05\x04j\x02\0\x03\
    \x12\x04\xf4\x0c'(\ny\n\x04\x04j\x02\x01\x12\x04\xf8\x0c\x02\x20\x1ak\
    \x20TagTypeID\x20is\x20an\x20internal\x20representation\x20of\x20TagType\
    \x20object,\x20encapsulating\n\x20tag\x20type\x20in\x20hexadecimal\x20fo\
    rmat.\n\n\r\n\x05\x04j\x02\x01\x04\x12\x04\xf8\x0c\x02\n\n\r\n\x05\x04j\
    \x02\x01\x05\x12\x04\xf8\x0c\x0b\x11\n\r\n\x05\x04j\x02\x01\x01\x12\x04\
    \xf8\x0c\x12\x1b\n\r\n\x05\x04j\x02\x01\x03\x12\x04\xf8\x0c\x1e\x1f\n\
    \x89\x02\n\x02\x04k\x12\x06\xff\x0c\0\x91\r\x01\x1a\xfa\x01\x20VirtualMa\
    chine\x20represents\x20a\x20computational\x20resource,\x20for\x20example\
    ,\x20a\x20virtual\x20machine,\n\x20bare\x20metal\x20server,\x20or\x20con\
    tainer.\n\x20+k8s:openapi-gen=true\n\x20+resource:path=virtualmachines,s\
    trategy=VirtualMachineStrategy,shortname=vm,categories=contrail;networki\
    ng\n\n\x0b\n\x03\x04k\x01\x12\x04\xff\x0c\x08\x16\n\xa0\x01\n\x04\x04k\
    \x02\0\x12\x04\x83\r\x02H\x1a\x91\x01\x20Standard\x20object's\x20metadat\
    a.\n\x20More\x20info:\x20https://git.k8s.io/community/contributors/devel\
    /sig-architecture/api-conventions.md#metadata\n\x20+optional\n\n\r\n\x05\
    \x04k\x02\0\x04\x12\x04\x83\r\x02\n\n\r\n\x05\x04k\x02\0\x06\x12\x04\x83\
    \r\x0b:\n\r\n\x05\x04k\x02\0\x01\x12\x04\x83\r;C\n\r\n\x05\x04k\x02\0\
    \x03\x12\x04\x83\rFG\n\xc5\x01\n\x04\x04k\x02\x01\x12\x04\x88\r\x02'\x1a\
    \xb6\x01\x20Specification\x20of\x20the\x20desired\x20state\x20of\x20the\
    \x20VirtualMachine.\n\x20More\x20info:\x20https://git.k8s.io/community/c\
    ontributors/devel/sig-architecture/api-conventions.md#spec-and-status\n\
    \x20+optional\n\n\r\n\x05\x04k\x02\x01\x04\x12\x04\x88\r\x02\n\n\r\n\x05\
    \x04k\x02\x01\x06\x12\x04\x88\r\x0b\x1d\n\r\n\x05\x04k\x02\x01\x01\x12\
    \x04\x88\r\x1e\"\n\r\n\x05\x04k\x02\x01\x03\x12\x04\x88\r%&\n\x8c\x02\n\
    \x04\x04k\x02\x02\x12\x04\x90\r\x02+\x1a\xfd\x01\x20The\x20most\x20recen\
    tly\x20observed\x20status\x20of\x20the\x20VirtualMachine.\n\x20This\x20d\
    ata\x20may\x20not\x20be\x20up-to-date.\n\x20Populated\x20by\x20the\x20sy\
    stem.\n\x20Read-only.\n\x20More\x20info:\x20https://git.k8s.io/community\
    /contributors/devel/sig-architecture/api-conventions.md#spec-and-status\
    \n\x20+optional\n\n\r\n\x05\x04k\x02\x02\x04\x12\x04\x90\r\x02\n\n\r\n\
    \x05\x04k\x02\x02\x06\x12\x04\x90\r\x0b\x1f\n\r\n\x05\x04k\x02\x02\x01\
    \x12\x04\x90\r\x20&\n\r\n\x05\x04k\x02\x02\x03\x12\x04\x90\r)*\n\xf4\x02\
    \n\x02\x04l\x12\x06\x98\r\0\x9e\r\x01\x1a\xe5\x02\x20VirtualMachineInter\
    face\x20represents\x20an\x20interface(port)\x20into\x20virtual\x20networ\
    k.\n\x20It\x20may\x20or\x20may\x20not\x20have\x20corresponding\x20virtua\
    l\x20machine.\x20A\x20virtual\x20machine\n\x20interface\x20has\x20at\x20\
    least\x20a\x20MAC\x20address\x20and\x20an\x20IP\x20address.\n\x20+k8s:op\
    enapi-gen=true\n\x20+resource:path=virtualmachineinterfaces,strategy=Vir\
    tualMachineInterfaceStrategy,shortname=vmi,categories=contrail;networkin\
    g\n\n\x0b\n\x03\x04l\x01\x12\x04\x98\r\x08\x1f\n\x0c\n\x04\x04l\x02\0\
    \x12\x04\x99\r\x02H\n\r\n\x05\x04l\x02\0\x04\x12\x04\x99\r\x02\n\n\r\n\
    \x05\x04l\x02\0\x06\x12\x04\x99\r\x0b:\n\r\n\x05\x04l\x02\0\x01\x12\x04\
    \x99\r;C\n\r\n\x05\x04l\x02\0\x03\x12\x04\x99\rFG\n\x0c\n\x04\x04l\x02\
    \x01\x12\x04\x9b\r\x020\n\r\n\x05\x04l\x02\x01\x04\x12\x04\x9b\r\x02\n\n\
    \r\n\x05\x04l\x02\x01\x06\x12\x04\x9b\r\x0b&\n\r\n\x05\x04l\x02\x01\x01\
    \x12\x04\x9b\r'+\n\r\n\x05\x04l\x02\x01\x03\x12\x04\x9b\r./\n\x0c\n\x04\
    \x04l\x02\x02\x12\x04\x9d\r\x024\n\r\n\x05\x04l\x02\x02\x04\x12\x04\x9d\
    \r\x02\n\n\r\n\x05\x04l\x02\x02\x06\x12\x04\x9d\r\x0b(\n\r\n\x05\x04l\
    \x02\x02\x01\x12\x04\x9d\r)/\n\r\n\x05\x04l\x02\x02\x03\x12\x04\x9d\r23\
    \nQ\n\x02\x04m\x12\x06\xa1\r\0\xa9\r\x01\x1aC\x20VirtualMachineInterface\
    List\x20is\x20a\x20list\x20of\x20VirtualMachineInterface.\n\n\x0b\n\x03\
    \x04m\x01\x12\x04\xa1\r\x08#\n\xac\x01\n\x04\x04m\x02\0\x12\x04\xa5\r\
    \x02F\x1a\x9d\x01\x20Standard\x20list's\x20metadata.\n\x20More\x20info:\
    \x20https://git.k8s.io/community/contributors/devel/sig-architecture/api\
    -conventions.md#lists-and-simple-kinds\n\x20+optional\n\n\r\n\x05\x04m\
    \x02\0\x04\x12\x04\xa5\r\x02\n\n\r\n\x05\x04m\x02\0\x06\x12\x04\xa5\r\
    \x0b8\n\r\n\x05\x04m\x02\0\x01\x12\x04\xa5\r9A\n\r\n\x05\x04m\x02\0\x03\
    \x12\x04\xa5\rDE\no\n\x04\x04m\x02\x01\x12\x04\xa8\r\x02-\x1aa\x20Items\
    \x20contains\x20all\x20of\x20the\x20VirtualMachineInterface\x20instances\
    \x20in\x20the\x20VirtualMachineInterfaceList.\n\n\r\n\x05\x04m\x02\x01\
    \x04\x12\x04\xa8\r\x02\n\n\r\n\x05\x04m\x02\x01\x06\x12\x04\xa8\r\x0b\"\
    \n\r\n\x05\x04m\x02\x01\x01\x12\x04\xa8\r#(\n\r\n\x05\x04m\x02\x01\x03\
    \x12\x04\xa8\r+,\nC\n\x02\x04n\x12\x06\xac\r\0\xb1\r\x01\x1a5\x20Advance\
    d\x20Properties\x20of\x20the\x20VirtualMachineInterface.\n\n\x0b\n\x03\
    \x04n\x01\x12\x04\xac\r\x08)\no\n\x04\x04n\x02\0\x12\x04\xb0\r\x02*\x1aa\
    \x20802.1Q\x20VLAN\x20tag\x20to\x20be\x20used\x20if\x20this\x20interface\
    \x20is\x20a\x20sub-interface\x20of\n\x20other\x20interface.\n\x20+option\
    al\n\n\r\n\x05\x04n\x02\0\x04\x12\x04\xb0\r\x02\n\n\r\n\x05\x04n\x02\0\
    \x05\x12\x04\xb0\r\x0b\x11\n\r\n\x05\x04n\x02\0\x01\x12\x04\xb0\r\x12%\n\
    \r\n\x05\x04n\x02\0\x03\x12\x04\xb0\r()\na\n\x02\x04o\x12\x06\xb4\r\0\
    \xe0\r\x01\x1aS\x20VirtualMachineInterfaceSpec\x20defines\x20the\x20desi\
    red\x20state\x20of\x20VirtualMachineInterface.\n\n\x0b\n\x03\x04o\x01\
    \x12\x04\xb4\r\x08#\n\"\n\x04\x04o\x02\0\x12\x04\xb6\r\x02%\x1a\x14\x20C\
    ommon\x20spec\x20fields\n\n\r\n\x05\x04o\x02\0\x04\x12\x04\xb6\r\x02\n\n\
    \r\n\x05\x04o\x02\0\x06\x12\x04\xb6\r\x0b\x15\n\r\n\x05\x04o\x02\0\x01\
    \x12\x04\xb6\r\x16\x20\n\r\n\x05\x04o\x02\0\x03\x12\x04\xb6\r#$\nF\n\x04\
    \x04o\x02\x01\x12\x04\xb9\r\x029\x1a8\x20Object\x20reference\x20to\x20na\
    mespace\x20or\x20virtualrouter\x20parent.\n\n\r\n\x05\x04o\x02\x01\x04\
    \x12\x04\xb9\r\x02\n\n\r\n\x05\x04o\x02\x01\x06\x12\x04\xb9\r\x0b-\n\r\n\
    \x05\x04o\x02\x01\x01\x12\x04\xb9\r.4\n\r\n\x05\x04o\x02\x01\x03\x12\x04\
    \xb9\r78\np\n\x04\x04o\x02\x02\x12\x04\xbd\r\x02@\x1ab\x20MAC\x20address\
    \x20of\x20the\x20virtual\x20machine\x20interface,\x20automatically\x20as\
    signed\x20by\n\x20system\x20if\x20not\x20provided.\n\n\r\n\x05\x04o\x02\
    \x02\x04\x12\x04\xbd\r\x02\n\n\r\n\x05\x04o\x02\x02\x06\x12\x04\xbd\r\
    \x0b\x17\n\r\n\x05\x04o\x02\x02\x01\x12\x04\xbd\r\x18;\n\r\n\x05\x04o\
    \x02\x02\x03\x12\x04\xbd\r>?\n`\n\x04\x04o\x02\x03\x12\x04\xc0\r\x029\
    \x1aR\x20VirtualNetworkReference\x20determines\x20the\x20Virtual\x20Netw\
    ork\x20the\x20interface\x20belongs\x20to.\n\n\r\n\x05\x04o\x02\x03\x04\
    \x12\x04\xc0\r\x02\n\n\r\n\x05\x04o\x02\x03\x06\x12\x04\xc0\r\x0b\x1c\n\
    \r\n\x05\x04o\x02\x03\x01\x12\x04\xc0\r\x1d4\n\r\n\x05\x04o\x02\x03\x03\
    \x12\x04\xc0\r78\nl\n\x04\x04o\x02\x04\x12\x04\xc5\r\x02:\x1a^\x20Virtua\
    lMachineReferences\x20determines\x20the\x20VirtualMachine\x20the\x20inte\
    rface\x20belongs\n\x20to.\n\x20+optional\n\n\r\n\x05\x04o\x02\x04\x04\
    \x12\x04\xc5\r\x02\n\n\r\n\x05\x04o\x02\x04\x06\x12\x04\xc5\r\x0b\x1c\n\
    \r\n\x05\x04o\x02\x04\x01\x12\x04\xc5\r\x1d5\n\r\n\x05\x04o\x02\x04\x03\
    \x12\x04\xc5\r89\n\xa0\x02\n\x04\x04o\x02\x05\x12\x04\xcb\r\x029\x1a\x91\
    \x02\x20DisablePolicy\x20disables\x20all\x20policy\x20checks\x20for\x20i\
    ngress\x20and\x20egress\x20traffic\n\x20from\x20this\x20interface.\x20Fl\
    ow\x20table\x20entries\x20are\x20not\x20created.\x20Features\x20that\n\
    \x20require\x20policy\x20will\x20not\x20work\x20on\x20this\x20interface,\
    \x20these\x20include\x20security\n\x20group,\x20floating\x20IP,\x20servi\
    ce\x20chain,\x20linklocal\x20services.\n\n\r\n\x05\x04o\x02\x05\x04\x12\
    \x04\xcb\r\x02\n\n\r\n\x05\x04o\x02\x05\x05\x12\x04\xcb\r\x0b\x0f\n\r\n\
    \x05\x04o\x02\x05\x01\x12\x04\xcb\r\x104\n\r\n\x05\x04o\x02\x05\x03\x12\
    \x04\xcb\r78\n^\n\x04\x04o\x02\x06\x12\x04\xcf\r\x027\x1aP\x20List\x20of\
    \x20(IP\x20address,\x20MAC)\x20other\x20than\x20instance\x20ip\x20on\x20\
    this\x20interface.\n\x20+optional\n\n\r\n\x05\x04o\x02\x06\x04\x12\x04\
    \xcf\r\x02\n\n\r\n\x05\x04o\x02\x06\x06\x12\x04\xcf\r\x0b\x1e\n\r\n\x05\
    \x04o\x02\x06\x01\x12\x04\xcf\r\x1f2\n\r\n\x05\x04o\x02\x06\x03\x12\x04\
    \xcf\r56\n4\n\x04\x04o\x02\x07\x12\x04\xd2\r\x02(\x1a&\x20Port\x20securi\
    ty\x20status\x20on\x20the\x20network.\n\n\r\n\x05\x04o\x02\x07\x04\x12\
    \x04\xd2\r\x02\n\n\r\n\x05\x04o\x02\x07\x05\x12\x04\xd2\r\x0b\x0f\n\r\n\
    \x05\x04o\x02\x07\x01\x12\x04\xd2\r\x10#\n\r\n\x05\x04o\x02\x07\x03\x12\
    \x04\xd2\r&'\n\x87\x01\n\x04\x04o\x02\x08\x12\x04\xd7\r\x02C\x1ay\x20Vir\
    tualMachineInterfaceReferences\x20determines\x20the\x20VirtualMachineInt\
    erface\n\x20instances\x20that\x20are\x20sub-interfaces.\n\x20+optional\n\
    \n\r\n\x05\x04o\x02\x08\x04\x12\x04\xd7\r\x02\n\n\r\n\x05\x04o\x02\x08\
    \x06\x12\x04\xd7\r\x0b\x1c\n\r\n\x05\x04o\x02\x08\x01\x12\x04\xd7\r\x1d>\
    \n\r\n\x05\x04o\x02\x08\x03\x12\x04\xd7\rAB\n=\n\x04\x04o\x02\t\x12\x04\
    \xdb\r\x02=\x1a/\x20VirtualMachineInterface\x20properties\n\x20+optional\
    \n\n\r\n\x05\x04o\x02\t\x04\x12\x04\xdb\r\x02\n\n\r\n\x05\x04o\x02\t\x06\
    \x12\x04\xdb\r\x0b,\n\r\n\x05\x04o\x02\t\x01\x12\x04\xdb\r-7\n\r\n\x05\
    \x04o\x02\t\x03\x12\x04\xdb\r:<\nV\n\x04\x04o\x02\n\x12\x04\xdf\r\x020\
    \x1aH\x20Reference\x20to\x20Tag\x20attached\x20to\x20this\x20Virtual\x20\
    Machine\x20Interface\n\x20+optional\n\n\r\n\x05\x04o\x02\n\x04\x12\x04\
    \xdf\r\x02\n\n\r\n\x05\x04o\x02\n\x06\x12\x04\xdf\r\x0b\x1c\n\r\n\x05\
    \x04o\x02\n\x01\x12\x04\xdf\r\x1d*\n\r\n\x05\x04o\x02\n\x03\x12\x04\xdf\
    \r-/\nc\n\x02\x04p\x12\x06\xe3\r\0\xee\r\x01\x1aU\x20VirtualMachineInter\
    faceStatus\x20defines\x20the\x20observed\x20state\x20of\x20VirtualMachin\
    eInterface\n\n\x0b\n\x03\x04p\x01\x12\x04\xe3\r\x08%\n$\n\x04\x04p\x02\0\
    \x12\x04\xe5\r\x02)\x1a\x16\x20Common\x20status\x20fields\n\n\r\n\x05\
    \x04p\x02\0\x04\x12\x04\xe5\r\x02\n\n\r\n\x05\x04p\x02\0\x06\x12\x04\xe5\
    \r\x0b\x17\n\r\n\x05\x04p\x02\0\x01\x12\x04\xe5\r\x18$\n\r\n\x05\x04p\
    \x02\0\x03\x12\x04\xe5\r'(\n\xbe\x01\n\x04\x04p\x02\x01\x12\x04\xe9\r\
    \x02B\x1a\xaf\x01\x20RoutingInstanceReferences\x20lists\x20all\x20routin\
    g\x20instance\x20the\x20interface\x20is\x20associated\x20to.\n\x20Should\
    \x20at\x20least\x20contains\x20the\x20reference\x20to\x20its\x20Virtual\
    \x20Network\x20primary\x20Routing\x20Instance.\n\n\r\n\x05\x04p\x02\x01\
    \x04\x12\x04\xe9\r\x02\n\n\r\n\x05\x04p\x02\x01\x06\x12\x04\xe9\r\x0b#\n\
    \r\n\x05\x04p\x02\x01\x01\x12\x04\xe9\r$=\n\r\n\x05\x04p\x02\x01\x03\x12\
    \x04\xe9\r@A\n\x93\x01\n\x04\x04p\x02\x02\x12\x04\xed\r\x024\x1a\x84\x01\
    \x20BGPRouterReference\x20is\x20bgpaas-client\x20BGPRouter\x20reference\
    \x20for\x20BGP\x20neighbor.\n\x20Holds\x20the\x20corresponding\x20BGPRou\
    terRef\x20from\x20BGPAsAService\n\n\r\n\x05\x04p\x02\x02\x04\x12\x04\xed\
    \r\x02\n\n\r\n\x05\x04p\x02\x02\x06\x12\x04\xed\r\x0b\x1c\n\r\n\x05\x04p\
    \x02\x02\x01\x12\x04\xed\r\x1d/\n\r\n\x05\x04p\x02\x02\x03\x12\x04\xed\r\
    23\n?\n\x02\x04q\x12\x06\xf1\r\0\xf9\r\x01\x1a1\x20VirtualMachineList\
    \x20is\x20a\x20list\x20of\x20VirtualMachine.\n\n\x0b\n\x03\x04q\x01\x12\
    \x04\xf1\r\x08\x1a\n\xac\x01\n\x04\x04q\x02\0\x12\x04\xf5\r\x02F\x1a\x9d\
    \x01\x20Standard\x20list's\x20metadata.\n\x20More\x20info:\x20https://gi\
    t.k8s.io/community/contributors/devel/sig-architecture/api-conventions.m\
    d#lists-and-simple-kinds\n\x20+optional\n\n\r\n\x05\x04q\x02\0\x04\x12\
    \x04\xf5\r\x02\n\n\r\n\x05\x04q\x02\0\x06\x12\x04\xf5\r\x0b8\n\r\n\x05\
    \x04q\x02\0\x01\x12\x04\xf5\r9A\n\r\n\x05\x04q\x02\0\x03\x12\x04\xf5\rDE\
    \n]\n\x04\x04q\x02\x01\x12\x04\xf8\r\x02$\x1aO\x20Items\x20contains\x20a\
    ll\x20of\x20the\x20VirtualMachine\x20instances\x20in\x20the\x20VirtualMa\
    chineList.\n\n\r\n\x05\x04q\x02\x01\x04\x12\x04\xf8\r\x02\n\n\r\n\x05\
    \x04q\x02\x01\x06\x12\x04\xf8\r\x0b\x19\n\r\n\x05\x04q\x02\x01\x01\x12\
    \x04\xf8\r\x1a\x1f\n\r\n\x05\x04q\x02\x01\x03\x12\x04\xf8\r\"#\nQ\n\x02\
    \x04r\x12\x06\xfc\r\0\x8f\x0e\x01\x1aC\x20VirtualMachineSpec\x20defines\
    \x20the\x20desired\x20state\x20of\x20a\x20VirtualMachine.\n\n\x0b\n\x03\
    \x04r\x01\x12\x04\xfc\r\x08\x1a\n\"\n\x04\x04r\x02\0\x12\x04\xfe\r\x02%\
    \x1a\x14\x20Common\x20spec\x20fields\n\n\r\n\x05\x04r\x02\0\x04\x12\x04\
    \xfe\r\x02\n\n\r\n\x05\x04r\x02\0\x06\x12\x04\xfe\r\x0b\x15\n\r\n\x05\
    \x04r\x02\0\x01\x12\x04\xfe\r\x16\x20\n\r\n\x05\x04r\x02\0\x03\x12\x04\
    \xfe\r#$\n\xbd\x01\n\x04\x04r\x02\x01\x12\x04\x84\x0e\x02!\x1a\xae\x01\
    \x20ServerType\x20indicates\x20the\x20computational\x20type\x20of\x20the\
    \x20VirtualMachine\x20resource.\n\x20Valid\x20values\x20for\x20ServerTyp\
    e\x20include\x20virtual-server,\x20baremetal-server,\x20or\n\x20containe\
    r.\n\x20+optional\n\n\r\n\x05\x04r\x02\x01\x04\x12\x04\x84\x0e\x02\n\n\r\
    \n\x05\x04r\x02\x01\x05\x12\x04\x84\x0e\x0b\x11\n\r\n\x05\x04r\x02\x01\
    \x01\x12\x04\x84\x0e\x12\x1c\n\r\n\x05\x04r\x02\x01\x03\x12\x04\x84\x0e\
    \x1f\x20\nF\n\x04\x04r\x02\x02\x12\x04\x87\x0e\x02!\x1a8\x20ServerName\
    \x20is\x20the\x20name\x20of\x20the\x20VirtualMachine\x20resource.\n\n\r\
    \n\x05\x04r\x02\x02\x04\x12\x04\x87\x0e\x02\n\n\r\n\x05\x04r\x02\x02\x05\
    \x12\x04\x87\x0e\x0b\x11\n\r\n\x05\x04r\x02\x02\x01\x12\x04\x87\x0e\x12\
    \x1c\n\r\n\x05\x04r\x02\x02\x03\x12\x04\x87\x0e\x1f\x20\nP\n\x04\x04r\
    \x02\x03\x12\x04\x8a\x0e\x02&\x1aB\x20ServerNamespace\x20is\x20the\x20na\
    mespace\x20of\x20the\x20VirtualMachine\x20resource.\n\n\r\n\x05\x04r\x02\
    \x03\x04\x12\x04\x8a\x0e\x02\n\n\r\n\x05\x04r\x02\x03\x05\x12\x04\x8a\
    \x0e\x0b\x11\n\r\n\x05\x04r\x02\x03\x01\x12\x04\x8a\x0e\x12!\n\r\n\x05\
    \x04r\x02\x03\x03\x12\x04\x8a\x0e$%\ng\n\x04\x04r\x02\x04\x12\x04\x8e\
    \x0e\x02(\x1aY\x20ServerClusterName\x20is\x20the\x20name\x20of\x20the\
    \x20cluster\x20the\x20VirtualMachine\x20resource\n\x20is\x20to\x20run\
    \x20on.\n\n\r\n\x05\x04r\x02\x04\x04\x12\x04\x8e\x0e\x02\n\n\r\n\x05\x04\
    r\x02\x04\x05\x12\x04\x8e\x0e\x0b\x11\n\r\n\x05\x04r\x02\x04\x01\x12\x04\
    \x8e\x0e\x12#\n\r\n\x05\x04r\x02\x04\x03\x12\x04\x8e\x0e&'\nV\n\x02\x04s\
    \x12\x06\x92\x0e\0\x95\x0e\x01\x1aH\x20VirtualMachineStatus\x20defines\
    \x20the\x20observed\x20state\x20of\x20the\x20VirtualMachine.\n\n\x0b\n\
    \x03\x04s\x01\x12\x04\x92\x0e\x08\x1c\n$\n\x04\x04s\x02\0\x12\x04\x94\
    \x0e\x02)\x1a\x16\x20Common\x20status\x20fields\n\n\r\n\x05\x04s\x02\0\
    \x04\x12\x04\x94\x0e\x02\n\n\r\n\x05\x04s\x02\0\x06\x12\x04\x94\x0e\x0b\
    \x17\n\r\n\x05\x04s\x02\0\x01\x12\x04\x94\x0e\x18$\n\r\n\x05\x04s\x02\0\
    \x03\x12\x04\x94\x0e'(\n\xe6\x02\n\x02\x04t\x12\x06\x9d\x0e\0\xaf\x0e\
    \x01\x1a\xd7\x02\x20VirtualNetwork\x20is\x20a\x20collection\x20of\x20end\
    points\x20(interface\x20or\x20IP(s)\x20or\x20MAC(s))\n\x20that\x20can\
    \x20communicate\x20with\x20each\x20other.\n\x20It\x20is\x20also\x20a\x20\
    collection\x20of\x20subnets\x20whose\x20default\x20gateways\x20are\x20co\
    nnected\x20by\n\x20an\x20implicit\x20router.\n\x20+k8s:openapi-gen=true\
    \n\x20+resource:path=virtualnetworks,strategy=VirtualNetworkStrategy,sho\
    rtname=vn,categories=contrail;networking\n\n\x0b\n\x03\x04t\x01\x12\x04\
    \x9d\x0e\x08\x16\n\xa0\x01\n\x04\x04t\x02\0\x12\x04\xa1\x0e\x02H\x1a\x91\
    \x01\x20Standard\x20object's\x20metadata.\n\x20More\x20info:\x20https://\
    git.k8s.io/community/contributors/devel/sig-architecture/api-conventions\
    .md#metadata\n\x20+optional\n\n\r\n\x05\x04t\x02\0\x04\x12\x04\xa1\x0e\
    \x02\n\n\r\n\x05\x04t\x02\0\x06\x12\x04\xa1\x0e\x0b:\n\r\n\x05\x04t\x02\
    \0\x01\x12\x04\xa1\x0e;C\n\r\n\x05\x04t\x02\0\x03\x12\x04\xa1\x0eFG\n\
    \xc5\x01\n\x04\x04t\x02\x01\x12\x04\xa6\x0e\x02'\x1a\xb6\x01\x20Specific\
    ation\x20of\x20the\x20desired\x20state\x20of\x20the\x20VirtualNetwork.\n\
    \x20More\x20info:\x20https://git.k8s.io/community/contributors/devel/sig\
    -architecture/api-conventions.md#spec-and-status\n\x20+optional\n\n\r\n\
    \x05\x04t\x02\x01\x04\x12\x04\xa6\x0e\x02\n\n\r\n\x05\x04t\x02\x01\x06\
    \x12\x04\xa6\x0e\x0b\x1d\n\r\n\x05\x04t\x02\x01\x01\x12\x04\xa6\x0e\x1e\
    \"\n\r\n\x05\x04t\x02\x01\x03\x12\x04\xa6\x0e%&\n\x8c\x02\n\x04\x04t\x02\
    \x02\x12\x04\xae\x0e\x02+\x1a\xfd\x01\x20The\x20most\x20recently\x20obse\
    rved\x20status\x20of\x20the\x20VirtualNetwork.\n\x20This\x20data\x20may\
    \x20not\x20be\x20up-to-date.\n\x20Populated\x20by\x20the\x20system.\n\
    \x20Read-only.\n\x20More\x20info:\x20https://git.k8s.io/community/contri\
    butors/devel/sig-architecture/api-conventions.md#spec-and-status\n\x20+o\
    ptional\n\n\r\n\x05\x04t\x02\x02\x04\x12\x04\xae\x0e\x02\n\n\r\n\x05\x04\
    t\x02\x02\x06\x12\x04\xae\x0e\x0b\x1f\n\r\n\x05\x04t\x02\x02\x01\x12\x04\
    \xae\x0e\x20&\n\r\n\x05\x04t\x02\x02\x03\x12\x04\xae\x0e)*\n?\n\x02\x04u\
    \x12\x06\xb2\x0e\0\xba\x0e\x01\x1a1\x20VirtualNetworkList\x20is\x20a\x20\
    list\x20of\x20VirtualNetwork.\n\n\x0b\n\x03\x04u\x01\x12\x04\xb2\x0e\x08\
    \x1a\n\xac\x01\n\x04\x04u\x02\0\x12\x04\xb6\x0e\x02F\x1a\x9d\x01\x20Stan\
    dard\x20list's\x20metadata.\n\x20More\x20info:\x20https://git.k8s.io/com\
    munity/contributors/devel/sig-architecture/api-conventions.md#lists-and-\
    simple-kinds\n\x20+optional\n\n\r\n\x05\x04u\x02\0\x04\x12\x04\xb6\x0e\
    \x02\n\n\r\n\x05\x04u\x02\0\x06\x12\x04\xb6\x0e\x0b8\n\r\n\x05\x04u\x02\
    \0\x01\x12\x04\xb6\x0e9A\n\r\n\x05\x04u\x02\0\x03\x12\x04\xb6\x0eDE\n]\n\
    \x04\x04u\x02\x01\x12\x04\xb9\x0e\x02$\x1aO\x20Items\x20contains\x20all\
    \x20of\x20the\x20VirtualNetwork\x20instances\x20in\x20the\x20VirtualNetw\
    orkList.\n\n\r\n\x05\x04u\x02\x01\x04\x12\x04\xb9\x0e\x02\n\n\r\n\x05\
    \x04u\x02\x01\x06\x12\x04\xb9\x0e\x0b\x19\n\r\n\x05\x04u\x02\x01\x01\x12\
    \x04\xb9\x0e\x1a\x1f\n\r\n\x05\x04u\x02\x01\x03\x12\x04\xb9\x0e\"#\nu\n\
    \x02\x04v\x12\x06\xbe\x0e\0\xc2\x0e\x01\x1ag\x20VirtualNetworkRouteTarge\
    tReferenceList\x20contains\x20RouteTarget\x20references\x20and\n\x20thei\
    r\x20import/export\x20mode.\n\n\x0b\n\x03\x04v\x01\x12\x04\xbe\x0e\x08.\
    \n]\n\x04\x04v\x02\0\x12\x04\xc1\x0e\x02:\x1aO\x20RouteTargetReferences\
    \x20is\x20the\x20actual\x20list\x20of\x20RouteTargetReferences.\n\x20+op\
    tional\n\n\r\n\x05\x04v\x02\0\x04\x12\x04\xc1\x0e\x02\n\n\r\n\x05\x04v\
    \x02\0\x06\x12\x04\xc1\x0e\x0b\x1f\n\r\n\x05\x04v\x02\0\x01\x12\x04\xc1\
    \x0e\x205\n\r\n\x05\x04v\x02\0\x03\x12\x04\xc1\x0e89\n\xd4\x01\n\x02\x04\
    w\x12\x06\xc8\x0e\0\xda\x0e\x01\x1a\xc5\x01\x20VirtualNetworkRouter\x20e\
    stablishes\x20connectivity\x20between\x20two\x20or\x20more\n\x20VirtualN\
    etworks\n\x20+k8s:openapi-gen=true\n\x20+resource:path=virtualnetworkrou\
    ters,strategy=VirtualNetworkRouterStrategy,shortname=vnr\n\n\x0b\n\x03\
    \x04w\x01\x12\x04\xc8\x0e\x08\x1c\n\xa0\x01\n\x04\x04w\x02\0\x12\x04\xcc\
    \x0e\x02H\x1a\x91\x01\x20Standard\x20object's\x20metadata.\n\x20More\x20\
    info:\x20https://git.k8s.io/community/contributors/devel/sig-architectur\
    e/api-conventions.md#metadata\n\x20+optional\n\n\r\n\x05\x04w\x02\0\x04\
    \x12\x04\xcc\x0e\x02\n\n\r\n\x05\x04w\x02\0\x06\x12\x04\xcc\x0e\x0b:\n\r\
    \n\x05\x04w\x02\0\x01\x12\x04\xcc\x0e;C\n\r\n\x05\x04w\x02\0\x03\x12\x04\
    \xcc\x0eFG\n\xcb\x01\n\x04\x04w\x02\x01\x12\x04\xd1\x0e\x02-\x1a\xbc\x01\
    \x20Specification\x20of\x20the\x20desired\x20state\x20of\x20the\x20Virtu\
    alNetworkRouter.\n\x20More\x20info:\x20https://git.k8s.io/community/cont\
    ributors/devel/sig-architecture/api-conventions.md#spec-and-status\n\x20\
    +optional\n\n\r\n\x05\x04w\x02\x01\x04\x12\x04\xd1\x0e\x02\n\n\r\n\x05\
    \x04w\x02\x01\x06\x12\x04\xd1\x0e\x0b#\n\r\n\x05\x04w\x02\x01\x01\x12\
    \x04\xd1\x0e$(\n\r\n\x05\x04w\x02\x01\x03\x12\x04\xd1\x0e+,\n\x92\x02\n\
    \x04\x04w\x02\x02\x12\x04\xd9\x0e\x021\x1a\x83\x02\x20The\x20most\x20rec\
    ently\x20observed\x20status\x20of\x20the\x20VirtualNetworkRouter.\n\x20T\
    his\x20data\x20may\x20not\x20be\x20up-to-date.\n\x20Populated\x20by\x20t\
    he\x20system.\n\x20Read-only.\n\x20More\x20info:\x20https://git.k8s.io/c\
    ommunity/contributors/devel/sig-architecture/api-conventions.md#spec-and\
    -status\n\x20+optional\n\n\r\n\x05\x04w\x02\x02\x04\x12\x04\xd9\x0e\x02\
    \n\n\r\n\x05\x04w\x02\x02\x06\x12\x04\xd9\x0e\x0b%\n\r\n\x05\x04w\x02\
    \x02\x01\x12\x04\xd9\x0e&,\n\r\n\x05\x04w\x02\x02\x03\x12\x04\xd9\x0e/0\
    \n\xb7\x01\n\x02\x04x\x12\x06\xde\x0e\0\xe4\x0e\x01\x1a\xa8\x01\x20Virtu\
    alNetworkRouterEntry\x20is\x20a\x20combination\x20of\x20VirtualNetworkRo\
    uterSelector\x20and\n\x20NamespaceSelector.\x20Together,\x20these\x20two\
    \x20LabelSelectors\x20identify\x20a\x20VirtualNetworkRouter.\n\n\x0b\n\
    \x03\x04x\x01\x12\x04\xde\x0e\x08!\nB\n\x04\x04x\x02\0\x12\x04\xe0\x0e\
    \x02_\x1a4\x20LabelSelector\x20to\x20identify\x20the\x20VirtualNetworkRo\
    uter\n\n\r\n\x05\x04x\x02\0\x04\x12\x04\xe0\x0e\x02\n\n\r\n\x05\x04x\x02\
    \0\x06\x12\x04\xe0\x0e\x0b=\n\r\n\x05\x04x\x02\0\x01\x12\x04\xe0\x0e>Z\n\
    \r\n\x05\x04x\x02\0\x03\x12\x04\xe0\x0e]^\nT\n\x04\x04x\x02\x01\x12\x04\
    \xe3\x0e\x02T\x1aF\x20LabelSelector\x20to\x20identify\x20the\x20Namespac\
    e\x20of\x20the\x20VirtualNetworkRouter.\n\n\r\n\x05\x04x\x02\x01\x04\x12\
    \x04\xe3\x0e\x02\n\n\r\n\x05\x04x\x02\x01\x06\x12\x04\xe3\x0e\x0b=\n\r\n\
    \x05\x04x\x02\x01\x01\x12\x04\xe3\x0e>O\n\r\n\x05\x04x\x02\x01\x03\x12\
    \x04\xe3\x0eRS\nK\n\x02\x04y\x12\x06\xe7\x0e\0\xef\x0e\x01\x1a=\x20Virtu\
    alNetworkRouterList\x20is\x20a\x20list\x20of\x20VirtualNetworkRouter.\n\
    \n\x0b\n\x03\x04y\x01\x12\x04\xe7\x0e\x08\x20\n\xac\x01\n\x04\x04y\x02\0\
    \x12\x04\xeb\x0e\x02F\x1a\x9d\x01\x20Standard\x20list's\x20metadata.\n\
    \x20More\x20info:\x20https://git.k8s.io/community/contributors/devel/sig\
    -architecture/api-conventions.md#lists-and-simple-kinds\n\x20+optional\n\
    \n\r\n\x05\x04y\x02\0\x04\x12\x04\xeb\x0e\x02\n\n\r\n\x05\x04y\x02\0\x06\
    \x12\x04\xeb\x0e\x0b8\n\r\n\x05\x04y\x02\0\x01\x12\x04\xeb\x0e9A\n\r\n\
    \x05\x04y\x02\0\x03\x12\x04\xeb\x0eDE\ni\n\x04\x04y\x02\x01\x12\x04\xee\
    \x0e\x02*\x1a[\x20Items\x20contains\x20all\x20of\x20the\x20VirtualNetwor\
    kRouter\x20instances\x20in\x20the\x20VirtualNetworkRouterList.\n\n\r\n\
    \x05\x04y\x02\x01\x04\x12\x04\xee\x0e\x02\n\n\r\n\x05\x04y\x02\x01\x06\
    \x12\x04\xee\x0e\x0b\x1f\n\r\n\x05\x04y\x02\x01\x01\x12\x04\xee\x0e\x20%\
    \n\r\n\x05\x04y\x02\x01\x03\x12\x04\xee\x0e()\n_\n\x02\x04z\x12\x06\xf2\
    \x0e\0\x85\x0f\x01\x1aQ\x20VirtualNetworkRouterSpec\x20defines\x20the\
    \x20desired\x20state\x20of\x20the\x20VirtualNetworkRouter.\n\n\x0b\n\x03\
    \x04z\x01\x12\x04\xf2\x0e\x08\x20\n\"\n\x04\x04z\x02\0\x12\x04\xf4\x0e\
    \x02%\x1a\x14\x20Common\x20spec\x20fields\n\n\r\n\x05\x04z\x02\0\x04\x12\
    \x04\xf4\x0e\x02\n\n\r\n\x05\x04z\x02\0\x06\x12\x04\xf4\x0e\x0b\x15\n\r\
    \n\x05\x04z\x02\0\x01\x12\x04\xf4\x0e\x16\x20\n\r\n\x05\x04z\x02\0\x03\
    \x12\x04\xf4\x0e#$\n[\n\x04\x04z\x02\x01\x12\x04\xf8\x0e\x02\x1b\x1aM\
    \x20Type\x20of\x20the\x20VirtualNetworkRouter.\n\x20Supported\x20types\
    \x20are\x20mesh,\x20spoke\x20and\x20hub.\n\n\r\n\x05\x04z\x02\x01\x04\
    \x12\x04\xf8\x0e\x02\n\n\r\n\x05\x04z\x02\x01\x05\x12\x04\xf8\x0e\x0b\
    \x11\n\r\n\x05\x04z\x02\x01\x01\x12\x04\xf8\x0e\x12\x16\n\r\n\x05\x04z\
    \x02\x01\x03\x12\x04\xf8\x0e\x19\x1a\n\xd8\x01\n\x04\x04z\x02\x02\x12\
    \x04\xfd\x0e\x02Y\x1a\xc9\x01\x20VirtualNetworkSelector\x20is\x20a\x20La\
    belSelector\x20to\x20identify\x20VirtualNetworks\x20that\n\x20this\x20Vi\
    rtualNetworkRouter\x20should\x20connect\x20to.\n\x20VirtualNetworkRouter\
    \x20shares\x20its\x20RouteTarget\x20to\x20the\x20connected\x20VirtualNet\
    works.\n\n\r\n\x05\x04z\x02\x02\x04\x12\x04\xfd\x0e\x02\n\n\r\n\x05\x04z\
    \x02\x02\x06\x12\x04\xfd\x0e\x0b=\n\r\n\x05\x04z\x02\x02\x01\x12\x04\xfd\
    \x0e>T\n\r\n\x05\x04z\x02\x02\x03\x12\x04\xfd\x0eWX\n\xa6\x02\n\x04\x04z\
    \x02\x03\x12\x04\x84\x0f\x021\x1a\x97\x02\x20VirtualNetworkRouter\x20can\
    \x20import\x20other\x20VirtualNetworkRouters\x20to\x20enable\n\x20connec\
    tivity\x20between\x20the\x20VirtualNetworks\x20selected\x20by\x20this\
    \x20VirtualNetworkRouter\x20and\n\x20VirtualNetworks\x20selected\x20by\
    \x20the\x20imported\x20VirtualNetworkRouter\n\x20Specify\x20list\x20of\
    \x20VirtualNetworkRouters\x20to\x20import.\n\x20+optional\n\n\r\n\x05\
    \x04z\x02\x03\x04\x12\x04\x84\x0f\x02\n\n\r\n\x05\x04z\x02\x03\x06\x12\
    \x04\x84\x0f\x0b%\n\r\n\x05\x04z\x02\x03\x01\x12\x04\x84\x0f&,\n\r\n\x05\
    \x04z\x02\x03\x03\x12\x04\x84\x0f/0\nb\n\x02\x04{\x12\x06\x88\x0f\0\x8b\
    \x0f\x01\x1aT\x20VirtualNetworkRouterStatus\x20defines\x20the\x20observe\
    d\x20state\x20of\x20the\x20VirtualNetworkRouter.\n\n\x0b\n\x03\x04{\x01\
    \x12\x04\x88\x0f\x08\"\n$\n\x04\x04{\x02\0\x12\x04\x8a\x0f\x02)\x1a\x16\
    \x20Common\x20status\x20fields\n\n\r\n\x05\x04{\x02\0\x04\x12\x04\x8a\
    \x0f\x02\n\n\r\n\x05\x04{\x02\0\x06\x12\x04\x8a\x0f\x0b\x17\n\r\n\x05\
    \x04{\x02\0\x01\x12\x04\x8a\x0f\x18$\n\r\n\x05\x04{\x02\0\x03\x12\x04\
    \x8a\x0f'(\nQ\n\x02\x04|\x12\x06\x8e\x0f\0\xc3\x0f\x01\x1aC\x20VirtualNe\
    tworkSpec\x20defines\x20the\x20desired\x20state\x20of\x20a\x20VirtualNet\
    work.\n\n\x0b\n\x03\x04|\x01\x12\x04\x8e\x0f\x08\x1a\n\"\n\x04\x04|\x02\
    \0\x12\x04\x90\x0f\x02%\x1a\x14\x20Common\x20spec\x20fields\n\n\r\n\x05\
    \x04|\x02\0\x04\x12\x04\x90\x0f\x02\n\n\r\n\x05\x04|\x02\0\x06\x12\x04\
    \x90\x0f\x0b\x15\n\r\n\x05\x04|\x02\0\x01\x12\x04\x90\x0f\x16\x20\n\r\n\
    \x05\x04|\x02\0\x03\x12\x04\x90\x0f#$\n_\n\x04\x04|\x02\x01\x12\x04\x94\
    \x0f\x02\x1f\x1aQ\x20FabricSNAT\x20toggles\x20connectivity\x20to\x20unde\
    rlay\x20network\x20by\x20port\x20mapping.\n\x20+optional\n\n\r\n\x05\x04\
    |\x02\x01\x04\x12\x04\x94\x0f\x02\n\n\r\n\x05\x04|\x02\x01\x05\x12\x04\
    \x94\x0f\x0b\x0f\n\r\n\x05\x04|\x02\x01\x01\x12\x04\x94\x0f\x10\x1a\n\r\
    \n\x05\x04|\x02\x01\x03\x12\x04\x94\x0f\x1d\x1e\n=\n\x04\x04|\x02\x02\
    \x12\x04\x98\x0f\x023\x1a/\x20Reference\x20to\x20the\x20v4\x20family\x20\
    subnet.\n\x20+optional\n\n\r\n\x05\x04|\x02\x02\x04\x12\x04\x98\x0f\x02\
    \n\n\r\n\x05\x04|\x02\x02\x06\x12\x04\x98\x0f\x0b\x1c\n\r\n\x05\x04|\x02\
    \x02\x01\x12\x04\x98\x0f\x1d.\n\r\n\x05\x04|\x02\x02\x03\x12\x04\x98\x0f\
    12\n=\n\x04\x04|\x02\x03\x12\x04\x9c\x0f\x023\x1a/\x20Reference\x20to\
    \x20the\x20v6\x20family\x20subnet.\n\x20+optional\n\n\r\n\x05\x04|\x02\
    \x03\x04\x12\x04\x9c\x0f\x02\n\n\r\n\x05\x04|\x02\x03\x06\x12\x04\x9c\
    \x0f\x0b\x1c\n\r\n\x05\x04|\x02\x03\x01\x12\x04\x9c\x0f\x1d.\n\r\n\x05\
    \x04|\x02\x03\x03\x12\x04\x9c\x0f12\n\x88\x01\n\x04\x04|\x02\x04\x12\x04\
    \xa1\x0f\x02&\x1az\x20RouteTargetList\x20is\x20a\x20list\x20of\x20route\
    \x20targets\x20that\x20are\x20used\x20as\x20both\x20import\n\x20and\x20e\
    xport\x20for\x20this\x20virtual\x20network.\n\x20+optional\n\n\r\n\x05\
    \x04|\x02\x04\x04\x12\x04\xa1\x0f\x02\n\n\r\n\x05\x04|\x02\x04\x05\x12\
    \x04\xa1\x0f\x0b\x11\n\r\n\x05\x04|\x02\x04\x01\x12\x04\xa1\x0f\x12!\n\r\
    \n\x05\x04|\x02\x04\x03\x12\x04\xa1\x0f$%\n~\n\x04\x04|\x02\x05\x12\x04\
    \xa6\x0f\x02,\x1ap\x20ImportRouteTargetList\x20is\x20a\x20list\x20of\x20\
    route\x20targets\x20that\x20are\x20used\x20as\x20import\n\x20for\x20this\
    \x20virtual\x20network.\n\x20+optional\n\n\r\n\x05\x04|\x02\x05\x04\x12\
    \x04\xa6\x0f\x02\n\n\r\n\x05\x04|\x02\x05\x05\x12\x04\xa6\x0f\x0b\x11\n\
    \r\n\x05\x04|\x02\x05\x01\x12\x04\xa6\x0f\x12'\n\r\n\x05\x04|\x02\x05\
    \x03\x12\x04\xa6\x0f*+\nx\n\x04\x04|\x02\x06\x12\x04\xab\x0f\x02,\x1aj\
    \x20RouteTargetList\x20is\x20a\x20list\x20of\x20route\x20targets\x20that\
    \x20are\x20used\x20as\x20import\x20for\n\x20this\x20virtual\x20network.\
    \n\x20+optional\n\n\r\n\x05\x04|\x02\x06\x04\x12\x04\xab\x0f\x02\n\n\r\n\
    \x05\x04|\x02\x06\x05\x12\x04\xab\x0f\x0b\x11\n\r\n\x05\x04|\x02\x06\x01\
    \x12\x04\xab\x0f\x12'\n\r\n\x05\x04|\x02\x06\x03\x12\x04\xab\x0f*+\nz\n\
    \x04\x04|\x02\x07\x12\x04\xb0\x0f\x02;\x1al\x20VirtualNetworkProperties\
    \x20defines\x20additional\x20configuration\x20parameters\x20for\n\x20eac\
    h\x20virtual\x20network.\n\x20+optional\n\n\r\n\x05\x04|\x02\x07\x04\x12\
    \x04\xb0\x0f\x02\n\n\r\n\x05\x04|\x02\x07\x06\x12\x04\xb0\x0f\x0b\x1d\n\
    \r\n\x05\x04|\x02\x07\x01\x12\x04\xb0\x0f\x1e6\n\r\n\x05\x04|\x02\x07\
    \x03\x12\x04\xb0\x0f9:\nx\n\x04\x04|\x02\x08\x12\x04\xb5\x0f\x02:\x1aj\
    \x20ProviderNetworkReference\x20is\x20the\x20reference\x20to\x20a\x20pro\
    vider\x20virtual\x20network,\n\x20example:\x20ip-fabric.\n\x20+optional\
    \n\n\r\n\x05\x04|\x02\x08\x04\x12\x04\xb5\x0f\x02\n\n\r\n\x05\x04|\x02\
    \x08\x06\x12\x04\xb5\x0f\x0b\x1c\n\r\n\x05\x04|\x02\x08\x01\x12\x04\xb5\
    \x0f\x1d5\n\r\n\x05\x04|\x02\x08\x03\x12\x04\xb5\x0f89\n\xec\x01\n\x04\
    \x04|\x02\t\x12\x04\xbb\x0f\x02'\x1a\xdd\x01\x20IsProviderNetwork\x20is\
    \x20a\x20flag\x20that\x20needs\x20to\x20be\x20set\x20to\x20true\x20if\
    \x20VN\x20is\x20a\x20Provider\x20Network\n\x20Cannot\x20be\x20updated\
    \x20from\x20true\x20to\x20false.\x20Both\x20IsProviderNetwork\x20and\n\
    \x20FabricForwarding\x20cannot\x20be\x20set\x20to\x20true\x20at\x20the\
    \x20same\x20time.\n\x20+optional\n\n\r\n\x05\x04|\x02\t\x04\x12\x04\xbb\
    \x0f\x02\n\n\r\n\x05\x04|\x02\t\x05\x12\x04\xbb\x0f\x0b\x0f\n\r\n\x05\
    \x04|\x02\t\x01\x12\x04\xbb\x0f\x10!\n\r\n\x05\x04|\x02\t\x03\x12\x04\
    \xbb\x0f$&\n\xc7\x02\n\x04\x04|\x02\n\x12\x04\xc2\x0f\x02&\x1a\xb8\x02\
    \x20FabricForwarding\x20when\x20set\x20to\x20true\x20adds\x20the\x20ip-f\
    abric\x20VN\x20as\x20a\x20provider\x20network\n\x20to\x20this\x20virtual\
    \x20network.\x20If\x20provider\x20network\x20already\x20has\x20a\x20refe\
    rence\x20to\x20a\x20different\n\x20network,\x20it\x20will\x20be\x20overr\
    iden\x20to\x20the\x20ip-fabric\x20VN.\x20Both\x20IsProviderNetwork\x20an\
    d\n\x20FabricForwarding\x20cannot\x20be\x20set\x20to\x20true\x20at\x20th\
    e\x20same\x20time.\n\x20+optional\n\n\r\n\x05\x04|\x02\n\x04\x12\x04\xc2\
    \x0f\x02\n\n\r\n\x05\x04|\x02\n\x05\x12\x04\xc2\x0f\x0b\x0f\n\r\n\x05\
    \x04|\x02\n\x01\x12\x04\xc2\x0f\x10\x20\n\r\n\x05\x04|\x02\n\x03\x12\x04\
    \xc2\x0f#%\nT\n\x02\x04}\x12\x06\xc6\x0f\0\xcd\x0f\x01\x1aF\x20VirtualNe\
    tworkStatus\x20defines\x20the\x20observed\x20state\x20of\x20a\x20Virtual\
    Network.\n\n\x0b\n\x03\x04}\x01\x12\x04\xc6\x0f\x08\x1c\n$\n\x04\x04}\
    \x02\0\x12\x04\xc8\x0f\x02)\x1a\x16\x20Common\x20status\x20fields\n\n\r\
    \n\x05\x04}\x02\0\x04\x12\x04\xc8\x0f\x02\n\n\r\n\x05\x04}\x02\0\x06\x12\
    \x04\xc8\x0f\x0b\x17\n\r\n\x05\x04}\x02\0\x01\x12\x04\xc8\x0f\x18$\n\r\n\
    \x05\x04}\x02\0\x03\x12\x04\xc8\x0f'(\nV\n\x04\x04}\x02\x01\x12\x04\xcc\
    \x0f\x02-\x1aH\x20System\x20assigned\x20unique\x2032-bit\x20ID\x20for\
    \x20every\x20virtual\x20network.\n\x20+optional\n\n\r\n\x05\x04}\x02\x01\
    \x04\x12\x04\xcc\x0f\x02\n\n\r\n\x05\x04}\x02\x01\x05\x12\x04\xcc\x0f\
    \x0b\x10\n\r\n\x05\x04}\x02\x01\x01\x12\x04\xcc\x0f\x11(\n\r\n\x05\x04}\
    \x02\x01\x03\x12\x04\xcc\x0f+,\n:\n\x02\x04~\x12\x06\xd0\x0f\0\xdc\x0f\
    \x01\x1a,\x20Advanced\x20properties\x20of\x20the\x20VirtualNetwork.\n\n\
    \x0b\n\x03\x04~\x01\x12\x04\xd0\x0f\x08\x1a\n\x9e\x01\n\x04\x04~\x02\0\
    \x12\x04\xd5\x0f\x02\x1a\x1a\x8f\x01\x20Rpf\x20property\x20enables\x20or\
    \x20disables\x20unicast\x20Reverse\x20Path\x20Forwarding\x20(RPF)\x20on\
    \n\x20the\x20VirtualNetwork.\n\x20By\x20Default,\x20Rpf\x20is\x20set\x20\
    to\x20enabled.\n\x20+optional\n\n\r\n\x05\x04~\x02\0\x04\x12\x04\xd5\x0f\
    \x02\n\n\r\n\x05\x04~\x02\0\x05\x12\x04\xd5\x0f\x0b\x11\n\r\n\x05\x04~\
    \x02\0\x01\x12\x04\xd5\x0f\x12\x15\n\r\n\x05\x04~\x02\0\x03\x12\x04\xd5\
    \x0f\x18\x19\n\xb7\x01\n\x04\x04~\x02\x01\x12\x04\xdb\x0f\x02%\x1a\xa8\
    \x01\x20ForwardingMode\x20is\x20the\x20Packet\x20forwarding\x20mode\x20f\
    or\x20this\x20VirtualNetwork.\n\x20Supported\x20Options\x20are\x20l2,\
    \x20l3\x20and\x20l2_l3.\n\x20By\x20Default,\x20ForwardingMode\x20is\x20s\
    et\x20to\x20l2_l3.\n\x20+optional\n\n\r\n\x05\x04~\x02\x01\x04\x12\x04\
    \xdb\x0f\x02\n\n\r\n\x05\x04~\x02\x01\x05\x12\x04\xdb\x0f\x0b\x11\n\r\n\
    \x05\x04~\x02\x01\x01\x12\x04\xdb\x0f\x12\x20\n\r\n\x05\x04~\x02\x01\x03\
    \x12\x04\xdb\x0f#$\n\xfe\x01\n\x02\x04\x7f\x12\x06\xe2\x0f\0\xe8\x0f\x01\
    \x1a\xef\x01\x20VirtualRouter\x20is\x20packet\x20forwarding\x20system\
    \x20on\x20devices\x20such\x20as\x20compute\n\x20nodes(servers),\x20TOR(s\
    ),\x20routers.\n\x20+k8s:openapi-gen=true\n\x20+resource:path=virtualrou\
    ters,strategy=VirtualRouterStrategy,shortname=vr,categories=contrail;con\
    trail-cluster\n\n\x0b\n\x03\x04\x7f\x01\x12\x04\xe2\x0f\x08\x15\n\x0c\n\
    \x04\x04\x7f\x02\0\x12\x04\xe3\x0f\x02H\n\r\n\x05\x04\x7f\x02\0\x04\x12\
    \x04\xe3\x0f\x02\n\n\r\n\x05\x04\x7f\x02\0\x06\x12\x04\xe3\x0f\x0b:\n\r\
    \n\x05\x04\x7f\x02\0\x01\x12\x04\xe3\x0f;C\n\r\n\x05\x04\x7f\x02\0\x03\
    \x12\x04\xe3\x0fFG\n\x0c\n\x04\x04\x7f\x02\x01\x12\x04\xe5\x0f\x02&\n\r\
    \n\x05\x04\x7f\x02\x01\x04\x12\x04\xe5\x0f\x02\n\n\r\n\x05\x04\x7f\x02\
    \x01\x06\x12\x04\xe5\x0f\x0b\x1c\n\r\n\x05\x04\x7f\x02\x01\x01\x12\x04\
    \xe5\x0f\x1d!\n\r\n\x05\x04\x7f\x02\x01\x03\x12\x04\xe5\x0f$%\n\x0c\n\
    \x04\x04\x7f\x02\x02\x12\x04\xe7\x0f\x02*\n\r\n\x05\x04\x7f\x02\x02\x04\
    \x12\x04\xe7\x0f\x02\n\n\r\n\x05\x04\x7f\x02\x02\x06\x12\x04\xe7\x0f\x0b\
    \x1e\n\r\n\x05\x04\x7f\x02\x02\x01\x12\x04\xe7\x0f\x1f%\n\r\n\x05\x04\
    \x7f\x02\x02\x03\x12\x04\xe7\x0f()\n>\n\x03\x04\x80\x01\x12\x06\xeb\x0f\
    \0\xf3\x0f\x01\x1a/\x20VirtualRouterList\x20is\x20a\x20list\x20of\x20Vir\
    tualRouter.\n\n\x0c\n\x04\x04\x80\x01\x01\x12\x04\xeb\x0f\x08\x19\n\xad\
    \x01\n\x05\x04\x80\x01\x02\0\x12\x04\xef\x0f\x02F\x1a\x9d\x01\x20Standar\
    d\x20list's\x20metadata.\n\x20More\x20info:\x20https://git.k8s.io/commun\
    ity/contributors/devel/sig-architecture/api-conventions.md#lists-and-sim\
    ple-kinds\n\x20+optional\n\n\x0e\n\x06\x04\x80\x01\x02\0\x04\x12\x04\xef\
    \x0f\x02\n\n\x0e\n\x06\x04\x80\x01\x02\0\x06\x12\x04\xef\x0f\x0b8\n\x0e\
    \n\x06\x04\x80\x01\x02\0\x01\x12\x04\xef\x0f9A\n\x0e\n\x06\x04\x80\x01\
    \x02\0\x03\x12\x04\xef\x0fDE\n\\\n\x05\x04\x80\x01\x02\x01\x12\x04\xf2\
    \x0f\x02#\x1aM\x20Items\x20contains\x20all\x20of\x20the\x20VirtualRouter\
    \x20instances\x20in\x20the\x20VirtualRouterList.\n\n\x0e\n\x06\x04\x80\
    \x01\x02\x01\x04\x12\x04\xf2\x0f\x02\n\n\x0e\n\x06\x04\x80\x01\x02\x01\
    \x06\x12\x04\xf2\x0f\x0b\x18\n\x0e\n\x06\x04\x80\x01\x02\x01\x01\x12\x04\
    \xf2\x0f\x19\x1e\n\x0e\n\x06\x04\x80\x01\x02\x01\x03\x12\x04\xf2\x0f!\"\
    \nM\n\x03\x04\x81\x01\x12\x06\xf6\x0f\0\x92\x10\x01\x1a>\x20VirtualRoute\
    rSpec\x20defines\x20the\x20desired\x20state\x20of\x20VirtualRouter\n\n\
    \x0c\n\x04\x04\x81\x01\x01\x12\x04\xf6\x0f\x08\x19\n#\n\x05\x04\x81\x01\
    \x02\0\x12\x04\xf8\x0f\x02%\x1a\x14\x20Common\x20spec\x20fields\n\n\x0e\
    \n\x06\x04\x81\x01\x02\0\x04\x12\x04\xf8\x0f\x02\n\n\x0e\n\x06\x04\x81\
    \x01\x02\0\x06\x12\x04\xf8\x0f\x0b\x15\n\x0e\n\x06\x04\x81\x01\x02\0\x01\
    \x12\x04\xf8\x0f\x16\x20\n\x0e\n\x06\x04\x81\x01\x02\0\x03\x12\x04\xf8\
    \x0f#$\nV\n\x05\x04\x81\x01\x02\x01\x12\x04\xfb\x0f\x029\x1aG\x20Parent\
    \x20contains\x20the\x20ObjectReference\x20to\x20the\x20parent\x20GlobalS\
    ystemConfig.\n\n\x0e\n\x06\x04\x81\x01\x02\x01\x04\x12\x04\xfb\x0f\x02\n\
    \n\x0e\n\x06\x04\x81\x01\x02\x01\x06\x12\x04\xfb\x0f\x0b-\n\x0e\n\x06\
    \x04\x81\x01\x02\x01\x01\x12\x04\xfb\x0f.4\n\x0e\n\x06\x04\x81\x01\x02\
    \x01\x03\x12\x04\xfb\x0f78\n\x9f\x02\n\x05\x04\x81\x01\x02\x02\x12\x04\
    \x82\x10\x02-\x1a\x8f\x02\x20This\x20VirtualRouter's\x20data\x20path\x20\
    is\x20using\x20DPDK\x20library.\x20Virtual\x20machine\x20interfaces\n\
    \x20scheduled\x20on\x20this\x20compute\x20node\x20will\x20be\x20tagged\
    \x20with\x20additional\x20flags\x20so\x20that\x20they\n\x20are\x20spawne\
    d\x20with\x20user\x20space\x20virtio\x20driver.\x20It\x20is\x20only\x20a\
    pplicable\x20for\x20embedded\n\x20VirtualRouters.\n\x20+optional\n\n\x0e\
    \n\x06\x04\x81\x01\x02\x02\x04\x12\x04\x82\x10\x02\n\n\x0e\n\x06\x04\x81\
    \x01\x02\x02\x05\x12\x04\x82\x10\x0b\x0f\n\x0e\n\x06\x04\x81\x01\x02\x02\
    \x01\x12\x04\x82\x10\x10(\n\x0e\n\x06\x04\x81\x01\x02\x02\x03\x12\x04\
    \x82\x10+,\n<\n\x05\x04\x81\x01\x02\x03\x12\x04\x85\x10\x02-\x1a-\x20IP\
    \x20address\x20of\x20the\x20VirtualRouter\x20(required).\n\n\x0e\n\x06\
    \x04\x81\x01\x02\x03\x04\x12\x04\x85\x10\x02\n\n\x0e\n\x06\x04\x81\x01\
    \x02\x03\x05\x12\x04\x85\x10\x0b\x11\n\x0e\n\x06\x04\x81\x01\x02\x03\x01\
    \x12\x04\x85\x10\x12(\n\x0e\n\x06\x04\x81\x01\x02\x03\x03\x12\x04\x85\
    \x10+,\nD\n\x05\x04\x81\x01\x02\x04\x12\x04\x89\x10\x02(\x1a5\x20The\x20\
    type\x20of\x20VirtualRouter\x20in\x20the\x20system.\n\x20+optional\n\n\
    \x0e\n\x06\x04\x81\x01\x02\x04\x04\x12\x04\x89\x10\x02\n\n\x0e\n\x06\x04\
    \x81\x01\x02\x04\x05\x12\x04\x89\x10\x0b\x11\n\x0e\n\x06\x04\x81\x01\x02\
    \x04\x01\x12\x04\x89\x10\x12#\n\x0e\n\x06\x04\x81\x01\x02\x04\x03\x12\
    \x04\x89\x10&'\n\xe7\x01\n\x05\x04\x81\x01\x02\x05\x12\x04\x91\x10\x02:\
    \x1a\xd7\x01\x20VirtualMachineReferences\x20is\x20the\x20list\x20of\x20a\
    ll\x20VirtualMachine\x20instances\x20on\n\x20this\x20vrouter.\x20This\
    \x20link\x20is\x20present\x20for\x20virtual\x20machines\x20associated\
    \x20to\n\x20Kubernetes\x20Pods.\n\x20+optional\n\x20+patchMergeKey=uid\n\
    \x20+patchStrategy=merge\n\n\x0e\n\x06\x04\x81\x01\x02\x05\x04\x12\x04\
    \x91\x10\x02\n\n\x0e\n\x06\x04\x81\x01\x02\x05\x06\x12\x04\x91\x10\x0b\
    \x1c\n\x0e\n\x06\x04\x81\x01\x02\x05\x01\x12\x04\x91\x10\x1d5\n\x0e\n\
    \x06\x04\x81\x01\x02\x05\x03\x12\x04\x91\x1089\nP\n\x03\x04\x82\x01\x12\
    \x06\x95\x10\0\x98\x10\x01\x1aA\x20VirtualRouterStatus\x20defines\x20the\
    \x20observed\x20state\x20of\x20VirtualRouter\n\n\x0c\n\x04\x04\x82\x01\
    \x01\x12\x04\x95\x10\x08\x1b\n%\n\x05\x04\x82\x01\x02\0\x12\x04\x97\x10\
    \x02)\x1a\x16\x20Common\x20status\x20fields\n\n\x0e\n\x06\x04\x82\x01\
    \x02\0\x04\x12\x04\x97\x10\x02\n\n\x0e\n\x06\x04\x82\x01\x02\0\x06\x12\
    \x04\x97\x10\x0b\x17\n\x0e\n\x06\x04\x82\x01\x02\0\x01\x12\x04\x97\x10\
    \x18$\n\x0e\n\x06\x04\x82\x01\x02\0\x03\x12\x04\x97\x10'(\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
