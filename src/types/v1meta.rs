// This file is generated by rust-protobuf 2.27.1. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `v1meta.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_27_1;

//#[path = "runtime.rs"] mod runtime;
//use super::runtime;
#[derive(PartialEq,Clone,Default)]
pub struct APIGroup {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    pub versions: ::protobuf::RepeatedField<GroupVersionForDiscovery>,
    pub preferredVersion: ::protobuf::SingularPtrField<GroupVersionForDiscovery>,
    pub serverAddressByClientCIDRs: ::protobuf::RepeatedField<ServerAddressByClientCIDR>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a APIGroup {
    fn default() -> &'a APIGroup {
        <APIGroup as ::protobuf::Message>::default_instance()
    }
}

impl APIGroup {
    pub fn new() -> APIGroup {
        ::std::default::Default::default()
    }

    // optional string name = 1;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionForDiscovery versions = 2;


    pub fn get_versions(&self) -> &[GroupVersionForDiscovery] {
        &self.versions
    }
    pub fn clear_versions(&mut self) {
        self.versions.clear();
    }

    // Param is passed by value, moved
    pub fn set_versions(&mut self, v: ::protobuf::RepeatedField<GroupVersionForDiscovery>) {
        self.versions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_versions(&mut self) -> &mut ::protobuf::RepeatedField<GroupVersionForDiscovery> {
        &mut self.versions
    }

    // Take field
    pub fn take_versions(&mut self) -> ::protobuf::RepeatedField<GroupVersionForDiscovery> {
        ::std::mem::replace(&mut self.versions, ::protobuf::RepeatedField::new())
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.GroupVersionForDiscovery preferredVersion = 3;


    pub fn get_preferredVersion(&self) -> &GroupVersionForDiscovery {
        self.preferredVersion.as_ref().unwrap_or_else(|| <GroupVersionForDiscovery as ::protobuf::Message>::default_instance())
    }
    pub fn clear_preferredVersion(&mut self) {
        self.preferredVersion.clear();
    }

    pub fn has_preferredVersion(&self) -> bool {
        self.preferredVersion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_preferredVersion(&mut self, v: GroupVersionForDiscovery) {
        self.preferredVersion = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_preferredVersion(&mut self) -> &mut GroupVersionForDiscovery {
        if self.preferredVersion.is_none() {
            self.preferredVersion.set_default();
        }
        self.preferredVersion.as_mut().unwrap()
    }

    // Take field
    pub fn take_preferredVersion(&mut self) -> GroupVersionForDiscovery {
        self.preferredVersion.take().unwrap_or_else(|| GroupVersionForDiscovery::new())
    }

    // repeated .k8s.io.apimachinery.pkg.apis.meta.v1.ServerAddressByClientCIDR serverAddressByClientCIDRs = 4;


    pub fn get_serverAddressByClientCIDRs(&self) -> &[ServerAddressByClientCIDR] {
        &self.serverAddressByClientCIDRs
    }
    pub fn clear_serverAddressByClientCIDRs(&mut self) {
        self.serverAddressByClientCIDRs.clear();
    }

    // Param is passed by value, moved
    pub fn set_serverAddressByClientCIDRs(&mut self, v: ::protobuf::RepeatedField<ServerAddressByClientCIDR>) {
        self.serverAddressByClientCIDRs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_serverAddressByClientCIDRs(&mut self) -> &mut ::protobuf::RepeatedField<ServerAddressByClientCIDR> {
        &mut self.serverAddressByClientCIDRs
    }

    // Take field
    pub fn take_serverAddressByClientCIDRs(&mut self) -> ::protobuf::RepeatedField<ServerAddressByClientCIDR> {
        ::std::mem::replace(&mut self.serverAddressByClientCIDRs, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for APIGroup {
    fn is_initialized(&self) -> bool {
        for v in &self.versions {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.preferredVersion {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.serverAddressByClientCIDRs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.versions)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.preferredVersion)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.serverAddressByClientCIDRs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.versions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.preferredVersion.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.serverAddressByClientCIDRs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        for v in &self.versions {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.preferredVersion.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.serverAddressByClientCIDRs {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> APIGroup {
        APIGroup::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &APIGroup| { &m.name },
                |m: &mut APIGroup| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GroupVersionForDiscovery>>(
                "versions",
                |m: &APIGroup| { &m.versions },
                |m: &mut APIGroup| { &mut m.versions },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GroupVersionForDiscovery>>(
                "preferredVersion",
                |m: &APIGroup| { &m.preferredVersion },
                |m: &mut APIGroup| { &mut m.preferredVersion },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ServerAddressByClientCIDR>>(
                "serverAddressByClientCIDRs",
                |m: &APIGroup| { &m.serverAddressByClientCIDRs },
                |m: &mut APIGroup| { &mut m.serverAddressByClientCIDRs },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<APIGroup>(
                "APIGroup",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static APIGroup {
        static instance: ::protobuf::rt::LazyV2<APIGroup> = ::protobuf::rt::LazyV2::INIT;
        instance.get(APIGroup::new)
    }
}

impl ::protobuf::Clear for APIGroup {
    fn clear(&mut self) {
        self.name.clear();
        self.versions.clear();
        self.preferredVersion.clear();
        self.serverAddressByClientCIDRs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for APIGroup {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for APIGroup {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct APIGroupList {
    // message fields
    pub groups: ::protobuf::RepeatedField<APIGroup>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a APIGroupList {
    fn default() -> &'a APIGroupList {
        <APIGroupList as ::protobuf::Message>::default_instance()
    }
}

impl APIGroupList {
    pub fn new() -> APIGroupList {
        ::std::default::Default::default()
    }

    // repeated .k8s.io.apimachinery.pkg.apis.meta.v1.APIGroup groups = 1;


    pub fn get_groups(&self) -> &[APIGroup] {
        &self.groups
    }
    pub fn clear_groups(&mut self) {
        self.groups.clear();
    }

    // Param is passed by value, moved
    pub fn set_groups(&mut self, v: ::protobuf::RepeatedField<APIGroup>) {
        self.groups = v;
    }

    // Mutable pointer to the field.
    pub fn mut_groups(&mut self) -> &mut ::protobuf::RepeatedField<APIGroup> {
        &mut self.groups
    }

    // Take field
    pub fn take_groups(&mut self) -> ::protobuf::RepeatedField<APIGroup> {
        ::std::mem::replace(&mut self.groups, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for APIGroupList {
    fn is_initialized(&self) -> bool {
        for v in &self.groups {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.groups)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.groups {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.groups {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> APIGroupList {
        APIGroupList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<APIGroup>>(
                "groups",
                |m: &APIGroupList| { &m.groups },
                |m: &mut APIGroupList| { &mut m.groups },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<APIGroupList>(
                "APIGroupList",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static APIGroupList {
        static instance: ::protobuf::rt::LazyV2<APIGroupList> = ::protobuf::rt::LazyV2::INIT;
        instance.get(APIGroupList::new)
    }
}

impl ::protobuf::Clear for APIGroupList {
    fn clear(&mut self) {
        self.groups.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for APIGroupList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for APIGroupList {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct APIResource {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    singularName: ::protobuf::SingularField<::std::string::String>,
    namespaced: ::std::option::Option<bool>,
    group: ::protobuf::SingularField<::std::string::String>,
    version: ::protobuf::SingularField<::std::string::String>,
    kind: ::protobuf::SingularField<::std::string::String>,
    pub verbs: ::protobuf::SingularPtrField<Verbs>,
    pub shortNames: ::protobuf::RepeatedField<::std::string::String>,
    pub categories: ::protobuf::RepeatedField<::std::string::String>,
    storageVersionHash: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a APIResource {
    fn default() -> &'a APIResource {
        <APIResource as ::protobuf::Message>::default_instance()
    }
}

impl APIResource {
    pub fn new() -> APIResource {
        ::std::default::Default::default()
    }

    // optional string name = 1;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string singularName = 6;


    pub fn get_singularName(&self) -> &str {
        match self.singularName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_singularName(&mut self) {
        self.singularName.clear();
    }

    pub fn has_singularName(&self) -> bool {
        self.singularName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_singularName(&mut self, v: ::std::string::String) {
        self.singularName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_singularName(&mut self) -> &mut ::std::string::String {
        if self.singularName.is_none() {
            self.singularName.set_default();
        }
        self.singularName.as_mut().unwrap()
    }

    // Take field
    pub fn take_singularName(&mut self) -> ::std::string::String {
        self.singularName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool namespaced = 2;


    pub fn get_namespaced(&self) -> bool {
        self.namespaced.unwrap_or(false)
    }
    pub fn clear_namespaced(&mut self) {
        self.namespaced = ::std::option::Option::None;
    }

    pub fn has_namespaced(&self) -> bool {
        self.namespaced.is_some()
    }

    // Param is passed by value, moved
    pub fn set_namespaced(&mut self, v: bool) {
        self.namespaced = ::std::option::Option::Some(v);
    }

    // optional string group = 8;


    pub fn get_group(&self) -> &str {
        match self.group.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_group(&mut self) {
        self.group.clear();
    }

    pub fn has_group(&self) -> bool {
        self.group.is_some()
    }

    // Param is passed by value, moved
    pub fn set_group(&mut self, v: ::std::string::String) {
        self.group = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_group(&mut self) -> &mut ::std::string::String {
        if self.group.is_none() {
            self.group.set_default();
        }
        self.group.as_mut().unwrap()
    }

    // Take field
    pub fn take_group(&mut self) -> ::std::string::String {
        self.group.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string version = 9;


    pub fn get_version(&self) -> &str {
        match self.version.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_version(&mut self) {
        self.version.clear();
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: ::std::string::String) {
        self.version = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version(&mut self) -> &mut ::std::string::String {
        if self.version.is_none() {
            self.version.set_default();
        }
        self.version.as_mut().unwrap()
    }

    // Take field
    pub fn take_version(&mut self) -> ::std::string::String {
        self.version.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string kind = 3;


    pub fn get_kind(&self) -> &str {
        match self.kind.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_kind(&mut self) {
        self.kind.clear();
    }

    pub fn has_kind(&self) -> bool {
        self.kind.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kind(&mut self, v: ::std::string::String) {
        self.kind = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kind(&mut self) -> &mut ::std::string::String {
        if self.kind.is_none() {
            self.kind.set_default();
        }
        self.kind.as_mut().unwrap()
    }

    // Take field
    pub fn take_kind(&mut self) -> ::std::string::String {
        self.kind.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.Verbs verbs = 4;


    pub fn get_verbs(&self) -> &Verbs {
        self.verbs.as_ref().unwrap_or_else(|| <Verbs as ::protobuf::Message>::default_instance())
    }
    pub fn clear_verbs(&mut self) {
        self.verbs.clear();
    }

    pub fn has_verbs(&self) -> bool {
        self.verbs.is_some()
    }

    // Param is passed by value, moved
    pub fn set_verbs(&mut self, v: Verbs) {
        self.verbs = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_verbs(&mut self) -> &mut Verbs {
        if self.verbs.is_none() {
            self.verbs.set_default();
        }
        self.verbs.as_mut().unwrap()
    }

    // Take field
    pub fn take_verbs(&mut self) -> Verbs {
        self.verbs.take().unwrap_or_else(|| Verbs::new())
    }

    // repeated string shortNames = 5;


    pub fn get_shortNames(&self) -> &[::std::string::String] {
        &self.shortNames
    }
    pub fn clear_shortNames(&mut self) {
        self.shortNames.clear();
    }

    // Param is passed by value, moved
    pub fn set_shortNames(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.shortNames = v;
    }

    // Mutable pointer to the field.
    pub fn mut_shortNames(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.shortNames
    }

    // Take field
    pub fn take_shortNames(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.shortNames, ::protobuf::RepeatedField::new())
    }

    // repeated string categories = 7;


    pub fn get_categories(&self) -> &[::std::string::String] {
        &self.categories
    }
    pub fn clear_categories(&mut self) {
        self.categories.clear();
    }

    // Param is passed by value, moved
    pub fn set_categories(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.categories = v;
    }

    // Mutable pointer to the field.
    pub fn mut_categories(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.categories
    }

    // Take field
    pub fn take_categories(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.categories, ::protobuf::RepeatedField::new())
    }

    // optional string storageVersionHash = 10;


    pub fn get_storageVersionHash(&self) -> &str {
        match self.storageVersionHash.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_storageVersionHash(&mut self) {
        self.storageVersionHash.clear();
    }

    pub fn has_storageVersionHash(&self) -> bool {
        self.storageVersionHash.is_some()
    }

    // Param is passed by value, moved
    pub fn set_storageVersionHash(&mut self, v: ::std::string::String) {
        self.storageVersionHash = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_storageVersionHash(&mut self) -> &mut ::std::string::String {
        if self.storageVersionHash.is_none() {
            self.storageVersionHash.set_default();
        }
        self.storageVersionHash.as_mut().unwrap()
    }

    // Take field
    pub fn take_storageVersionHash(&mut self) -> ::std::string::String {
        self.storageVersionHash.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for APIResource {
    fn is_initialized(&self) -> bool {
        for v in &self.verbs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.singularName)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.namespaced = ::std::option::Option::Some(tmp);
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.group)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.version)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.kind)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.verbs)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.shortNames)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.categories)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.storageVersionHash)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.singularName.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.namespaced {
            my_size += 2;
        }
        if let Some(ref v) = self.group.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        if let Some(ref v) = self.version.as_ref() {
            my_size += ::protobuf::rt::string_size(9, &v);
        }
        if let Some(ref v) = self.kind.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.verbs.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.shortNames {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        for value in &self.categories {
            my_size += ::protobuf::rt::string_size(7, &value);
        };
        if let Some(ref v) = self.storageVersionHash.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.singularName.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(v) = self.namespaced {
            os.write_bool(2, v)?;
        }
        if let Some(ref v) = self.group.as_ref() {
            os.write_string(8, &v)?;
        }
        if let Some(ref v) = self.version.as_ref() {
            os.write_string(9, &v)?;
        }
        if let Some(ref v) = self.kind.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.verbs.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.shortNames {
            os.write_string(5, &v)?;
        };
        for v in &self.categories {
            os.write_string(7, &v)?;
        };
        if let Some(ref v) = self.storageVersionHash.as_ref() {
            os.write_string(10, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> APIResource {
        APIResource::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &APIResource| { &m.name },
                |m: &mut APIResource| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "singularName",
                |m: &APIResource| { &m.singularName },
                |m: &mut APIResource| { &mut m.singularName },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "namespaced",
                |m: &APIResource| { &m.namespaced },
                |m: &mut APIResource| { &mut m.namespaced },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "group",
                |m: &APIResource| { &m.group },
                |m: &mut APIResource| { &mut m.group },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "version",
                |m: &APIResource| { &m.version },
                |m: &mut APIResource| { &mut m.version },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "kind",
                |m: &APIResource| { &m.kind },
                |m: &mut APIResource| { &mut m.kind },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Verbs>>(
                "verbs",
                |m: &APIResource| { &m.verbs },
                |m: &mut APIResource| { &mut m.verbs },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "shortNames",
                |m: &APIResource| { &m.shortNames },
                |m: &mut APIResource| { &mut m.shortNames },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "categories",
                |m: &APIResource| { &m.categories },
                |m: &mut APIResource| { &mut m.categories },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "storageVersionHash",
                |m: &APIResource| { &m.storageVersionHash },
                |m: &mut APIResource| { &mut m.storageVersionHash },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<APIResource>(
                "APIResource",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static APIResource {
        static instance: ::protobuf::rt::LazyV2<APIResource> = ::protobuf::rt::LazyV2::INIT;
        instance.get(APIResource::new)
    }
}

impl ::protobuf::Clear for APIResource {
    fn clear(&mut self) {
        self.name.clear();
        self.singularName.clear();
        self.namespaced = ::std::option::Option::None;
        self.group.clear();
        self.version.clear();
        self.kind.clear();
        self.verbs.clear();
        self.shortNames.clear();
        self.categories.clear();
        self.storageVersionHash.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for APIResource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for APIResource {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct APIResourceList {
    // message fields
    groupVersion: ::protobuf::SingularField<::std::string::String>,
    pub resources: ::protobuf::RepeatedField<APIResource>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a APIResourceList {
    fn default() -> &'a APIResourceList {
        <APIResourceList as ::protobuf::Message>::default_instance()
    }
}

impl APIResourceList {
    pub fn new() -> APIResourceList {
        ::std::default::Default::default()
    }

    // optional string groupVersion = 1;


    pub fn get_groupVersion(&self) -> &str {
        match self.groupVersion.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_groupVersion(&mut self) {
        self.groupVersion.clear();
    }

    pub fn has_groupVersion(&self) -> bool {
        self.groupVersion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_groupVersion(&mut self, v: ::std::string::String) {
        self.groupVersion = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_groupVersion(&mut self) -> &mut ::std::string::String {
        if self.groupVersion.is_none() {
            self.groupVersion.set_default();
        }
        self.groupVersion.as_mut().unwrap()
    }

    // Take field
    pub fn take_groupVersion(&mut self) -> ::std::string::String {
        self.groupVersion.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .k8s.io.apimachinery.pkg.apis.meta.v1.APIResource resources = 2;


    pub fn get_resources(&self) -> &[APIResource] {
        &self.resources
    }
    pub fn clear_resources(&mut self) {
        self.resources.clear();
    }

    // Param is passed by value, moved
    pub fn set_resources(&mut self, v: ::protobuf::RepeatedField<APIResource>) {
        self.resources = v;
    }

    // Mutable pointer to the field.
    pub fn mut_resources(&mut self) -> &mut ::protobuf::RepeatedField<APIResource> {
        &mut self.resources
    }

    // Take field
    pub fn take_resources(&mut self) -> ::protobuf::RepeatedField<APIResource> {
        ::std::mem::replace(&mut self.resources, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for APIResourceList {
    fn is_initialized(&self) -> bool {
        for v in &self.resources {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.groupVersion)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.resources)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.groupVersion.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        for value in &self.resources {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.groupVersion.as_ref() {
            os.write_string(1, &v)?;
        }
        for v in &self.resources {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> APIResourceList {
        APIResourceList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "groupVersion",
                |m: &APIResourceList| { &m.groupVersion },
                |m: &mut APIResourceList| { &mut m.groupVersion },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<APIResource>>(
                "resources",
                |m: &APIResourceList| { &m.resources },
                |m: &mut APIResourceList| { &mut m.resources },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<APIResourceList>(
                "APIResourceList",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static APIResourceList {
        static instance: ::protobuf::rt::LazyV2<APIResourceList> = ::protobuf::rt::LazyV2::INIT;
        instance.get(APIResourceList::new)
    }
}

impl ::protobuf::Clear for APIResourceList {
    fn clear(&mut self) {
        self.groupVersion.clear();
        self.resources.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for APIResourceList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for APIResourceList {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct APIVersions {
    // message fields
    pub versions: ::protobuf::RepeatedField<::std::string::String>,
    pub serverAddressByClientCIDRs: ::protobuf::RepeatedField<ServerAddressByClientCIDR>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a APIVersions {
    fn default() -> &'a APIVersions {
        <APIVersions as ::protobuf::Message>::default_instance()
    }
}

impl APIVersions {
    pub fn new() -> APIVersions {
        ::std::default::Default::default()
    }

    // repeated string versions = 1;


    pub fn get_versions(&self) -> &[::std::string::String] {
        &self.versions
    }
    pub fn clear_versions(&mut self) {
        self.versions.clear();
    }

    // Param is passed by value, moved
    pub fn set_versions(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.versions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_versions(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.versions
    }

    // Take field
    pub fn take_versions(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.versions, ::protobuf::RepeatedField::new())
    }

    // repeated .k8s.io.apimachinery.pkg.apis.meta.v1.ServerAddressByClientCIDR serverAddressByClientCIDRs = 2;


    pub fn get_serverAddressByClientCIDRs(&self) -> &[ServerAddressByClientCIDR] {
        &self.serverAddressByClientCIDRs
    }
    pub fn clear_serverAddressByClientCIDRs(&mut self) {
        self.serverAddressByClientCIDRs.clear();
    }

    // Param is passed by value, moved
    pub fn set_serverAddressByClientCIDRs(&mut self, v: ::protobuf::RepeatedField<ServerAddressByClientCIDR>) {
        self.serverAddressByClientCIDRs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_serverAddressByClientCIDRs(&mut self) -> &mut ::protobuf::RepeatedField<ServerAddressByClientCIDR> {
        &mut self.serverAddressByClientCIDRs
    }

    // Take field
    pub fn take_serverAddressByClientCIDRs(&mut self) -> ::protobuf::RepeatedField<ServerAddressByClientCIDR> {
        ::std::mem::replace(&mut self.serverAddressByClientCIDRs, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for APIVersions {
    fn is_initialized(&self) -> bool {
        for v in &self.serverAddressByClientCIDRs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.versions)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.serverAddressByClientCIDRs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.versions {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        for value in &self.serverAddressByClientCIDRs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.versions {
            os.write_string(1, &v)?;
        };
        for v in &self.serverAddressByClientCIDRs {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> APIVersions {
        APIVersions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "versions",
                |m: &APIVersions| { &m.versions },
                |m: &mut APIVersions| { &mut m.versions },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ServerAddressByClientCIDR>>(
                "serverAddressByClientCIDRs",
                |m: &APIVersions| { &m.serverAddressByClientCIDRs },
                |m: &mut APIVersions| { &mut m.serverAddressByClientCIDRs },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<APIVersions>(
                "APIVersions",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static APIVersions {
        static instance: ::protobuf::rt::LazyV2<APIVersions> = ::protobuf::rt::LazyV2::INIT;
        instance.get(APIVersions::new)
    }
}

impl ::protobuf::Clear for APIVersions {
    fn clear(&mut self) {
        self.versions.clear();
        self.serverAddressByClientCIDRs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for APIVersions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for APIVersions {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Condition {
    // message fields
    field_type: ::protobuf::SingularField<::std::string::String>,
    status: ::protobuf::SingularField<::std::string::String>,
    observedGeneration: ::std::option::Option<i64>,
    pub lastTransitionTime: ::protobuf::SingularPtrField<Time>,
    reason: ::protobuf::SingularField<::std::string::String>,
    message: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Condition {
    fn default() -> &'a Condition {
        <Condition as ::protobuf::Message>::default_instance()
    }
}

impl Condition {
    pub fn new() -> Condition {
        ::std::default::Default::default()
    }

    // optional string type = 1;


    pub fn get_field_type(&self) -> &str {
        match self.field_type.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ::std::string::String) {
        self.field_type = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut ::std::string::String {
        if self.field_type.is_none() {
            self.field_type.set_default();
        }
        self.field_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_field_type(&mut self) -> ::std::string::String {
        self.field_type.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string status = 2;


    pub fn get_status(&self) -> &str {
        match self.status.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: ::std::string::String) {
        self.status = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut ::std::string::String {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> ::std::string::String {
        self.status.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int64 observedGeneration = 3;


    pub fn get_observedGeneration(&self) -> i64 {
        self.observedGeneration.unwrap_or(0)
    }
    pub fn clear_observedGeneration(&mut self) {
        self.observedGeneration = ::std::option::Option::None;
    }

    pub fn has_observedGeneration(&self) -> bool {
        self.observedGeneration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_observedGeneration(&mut self, v: i64) {
        self.observedGeneration = ::std::option::Option::Some(v);
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time lastTransitionTime = 4;


    pub fn get_lastTransitionTime(&self) -> &Time {
        self.lastTransitionTime.as_ref().unwrap_or_else(|| <Time as ::protobuf::Message>::default_instance())
    }
    pub fn clear_lastTransitionTime(&mut self) {
        self.lastTransitionTime.clear();
    }

    pub fn has_lastTransitionTime(&self) -> bool {
        self.lastTransitionTime.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lastTransitionTime(&mut self, v: Time) {
        self.lastTransitionTime = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lastTransitionTime(&mut self) -> &mut Time {
        if self.lastTransitionTime.is_none() {
            self.lastTransitionTime.set_default();
        }
        self.lastTransitionTime.as_mut().unwrap()
    }

    // Take field
    pub fn take_lastTransitionTime(&mut self) -> Time {
        self.lastTransitionTime.take().unwrap_or_else(|| Time::new())
    }

    // optional string reason = 5;


    pub fn get_reason(&self) -> &str {
        match self.reason.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_reason(&mut self) {
        self.reason.clear();
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: ::std::string::String) {
        self.reason = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reason(&mut self) -> &mut ::std::string::String {
        if self.reason.is_none() {
            self.reason.set_default();
        }
        self.reason.as_mut().unwrap()
    }

    // Take field
    pub fn take_reason(&mut self) -> ::std::string::String {
        self.reason.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string message = 6;


    pub fn get_message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for Condition {
    fn is_initialized(&self) -> bool {
        for v in &self.lastTransitionTime {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.field_type)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.status)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.observedGeneration = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.lastTransitionTime)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.reason)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.message)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.field_type.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.status.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.observedGeneration {
            my_size += ::protobuf::rt::value_size(3, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.lastTransitionTime.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.reason.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.field_type.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.status.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.observedGeneration {
            os.write_int64(3, v)?;
        }
        if let Some(ref v) = self.lastTransitionTime.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.reason.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.message.as_ref() {
            os.write_string(6, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Condition {
        Condition::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "type",
                |m: &Condition| { &m.field_type },
                |m: &mut Condition| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "status",
                |m: &Condition| { &m.status },
                |m: &mut Condition| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "observedGeneration",
                |m: &Condition| { &m.observedGeneration },
                |m: &mut Condition| { &mut m.observedGeneration },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Time>>(
                "lastTransitionTime",
                |m: &Condition| { &m.lastTransitionTime },
                |m: &mut Condition| { &mut m.lastTransitionTime },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "reason",
                |m: &Condition| { &m.reason },
                |m: &mut Condition| { &mut m.reason },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "message",
                |m: &Condition| { &m.message },
                |m: &mut Condition| { &mut m.message },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Condition>(
                "Condition",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Condition {
        static instance: ::protobuf::rt::LazyV2<Condition> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Condition::new)
    }
}

impl ::protobuf::Clear for Condition {
    fn clear(&mut self) {
        self.field_type.clear();
        self.status.clear();
        self.observedGeneration = ::std::option::Option::None;
        self.lastTransitionTime.clear();
        self.reason.clear();
        self.message.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Condition {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Condition {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct CreateOptions {
    // message fields
    pub dryRun: ::protobuf::RepeatedField<::std::string::String>,
    fieldManager: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CreateOptions {
    fn default() -> &'a CreateOptions {
        <CreateOptions as ::protobuf::Message>::default_instance()
    }
}

impl CreateOptions {
    pub fn new() -> CreateOptions {
        ::std::default::Default::default()
    }

    // repeated string dryRun = 1;


    pub fn get_dryRun(&self) -> &[::std::string::String] {
        &self.dryRun
    }
    pub fn clear_dryRun(&mut self) {
        self.dryRun.clear();
    }

    // Param is passed by value, moved
    pub fn set_dryRun(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.dryRun = v;
    }

    // Mutable pointer to the field.
    pub fn mut_dryRun(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.dryRun
    }

    // Take field
    pub fn take_dryRun(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.dryRun, ::protobuf::RepeatedField::new())
    }

    // optional string fieldManager = 3;


    pub fn get_fieldManager(&self) -> &str {
        match self.fieldManager.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_fieldManager(&mut self) {
        self.fieldManager.clear();
    }

    pub fn has_fieldManager(&self) -> bool {
        self.fieldManager.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fieldManager(&mut self, v: ::std::string::String) {
        self.fieldManager = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fieldManager(&mut self) -> &mut ::std::string::String {
        if self.fieldManager.is_none() {
            self.fieldManager.set_default();
        }
        self.fieldManager.as_mut().unwrap()
    }

    // Take field
    pub fn take_fieldManager(&mut self) -> ::std::string::String {
        self.fieldManager.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for CreateOptions {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.dryRun)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.fieldManager)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.dryRun {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if let Some(ref v) = self.fieldManager.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.dryRun {
            os.write_string(1, &v)?;
        };
        if let Some(ref v) = self.fieldManager.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CreateOptions {
        CreateOptions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "dryRun",
                |m: &CreateOptions| { &m.dryRun },
                |m: &mut CreateOptions| { &mut m.dryRun },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "fieldManager",
                |m: &CreateOptions| { &m.fieldManager },
                |m: &mut CreateOptions| { &mut m.fieldManager },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<CreateOptions>(
                "CreateOptions",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static CreateOptions {
        static instance: ::protobuf::rt::LazyV2<CreateOptions> = ::protobuf::rt::LazyV2::INIT;
        instance.get(CreateOptions::new)
    }
}

impl ::protobuf::Clear for CreateOptions {
    fn clear(&mut self) {
        self.dryRun.clear();
        self.fieldManager.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CreateOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CreateOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct DeleteOptions {
    // message fields
    gracePeriodSeconds: ::std::option::Option<i64>,
    pub preconditions: ::protobuf::SingularPtrField<Preconditions>,
    orphanDependents: ::std::option::Option<bool>,
    propagationPolicy: ::protobuf::SingularField<::std::string::String>,
    pub dryRun: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeleteOptions {
    fn default() -> &'a DeleteOptions {
        <DeleteOptions as ::protobuf::Message>::default_instance()
    }
}

impl DeleteOptions {
    pub fn new() -> DeleteOptions {
        ::std::default::Default::default()
    }

    // optional int64 gracePeriodSeconds = 1;


    pub fn get_gracePeriodSeconds(&self) -> i64 {
        self.gracePeriodSeconds.unwrap_or(0)
    }
    pub fn clear_gracePeriodSeconds(&mut self) {
        self.gracePeriodSeconds = ::std::option::Option::None;
    }

    pub fn has_gracePeriodSeconds(&self) -> bool {
        self.gracePeriodSeconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gracePeriodSeconds(&mut self, v: i64) {
        self.gracePeriodSeconds = ::std::option::Option::Some(v);
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.Preconditions preconditions = 2;


    pub fn get_preconditions(&self) -> &Preconditions {
        self.preconditions.as_ref().unwrap_or_else(|| <Preconditions as ::protobuf::Message>::default_instance())
    }
    pub fn clear_preconditions(&mut self) {
        self.preconditions.clear();
    }

    pub fn has_preconditions(&self) -> bool {
        self.preconditions.is_some()
    }

    // Param is passed by value, moved
    pub fn set_preconditions(&mut self, v: Preconditions) {
        self.preconditions = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_preconditions(&mut self) -> &mut Preconditions {
        if self.preconditions.is_none() {
            self.preconditions.set_default();
        }
        self.preconditions.as_mut().unwrap()
    }

    // Take field
    pub fn take_preconditions(&mut self) -> Preconditions {
        self.preconditions.take().unwrap_or_else(|| Preconditions::new())
    }

    // optional bool orphanDependents = 3;


    pub fn get_orphanDependents(&self) -> bool {
        self.orphanDependents.unwrap_or(false)
    }
    pub fn clear_orphanDependents(&mut self) {
        self.orphanDependents = ::std::option::Option::None;
    }

    pub fn has_orphanDependents(&self) -> bool {
        self.orphanDependents.is_some()
    }

    // Param is passed by value, moved
    pub fn set_orphanDependents(&mut self, v: bool) {
        self.orphanDependents = ::std::option::Option::Some(v);
    }

    // optional string propagationPolicy = 4;


    pub fn get_propagationPolicy(&self) -> &str {
        match self.propagationPolicy.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_propagationPolicy(&mut self) {
        self.propagationPolicy.clear();
    }

    pub fn has_propagationPolicy(&self) -> bool {
        self.propagationPolicy.is_some()
    }

    // Param is passed by value, moved
    pub fn set_propagationPolicy(&mut self, v: ::std::string::String) {
        self.propagationPolicy = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_propagationPolicy(&mut self) -> &mut ::std::string::String {
        if self.propagationPolicy.is_none() {
            self.propagationPolicy.set_default();
        }
        self.propagationPolicy.as_mut().unwrap()
    }

    // Take field
    pub fn take_propagationPolicy(&mut self) -> ::std::string::String {
        self.propagationPolicy.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated string dryRun = 5;


    pub fn get_dryRun(&self) -> &[::std::string::String] {
        &self.dryRun
    }
    pub fn clear_dryRun(&mut self) {
        self.dryRun.clear();
    }

    // Param is passed by value, moved
    pub fn set_dryRun(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.dryRun = v;
    }

    // Mutable pointer to the field.
    pub fn mut_dryRun(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.dryRun
    }

    // Take field
    pub fn take_dryRun(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.dryRun, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for DeleteOptions {
    fn is_initialized(&self) -> bool {
        for v in &self.preconditions {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.gracePeriodSeconds = ::std::option::Option::Some(tmp);
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.preconditions)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.orphanDependents = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.propagationPolicy)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.dryRun)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.gracePeriodSeconds {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.preconditions.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.orphanDependents {
            my_size += 2;
        }
        if let Some(ref v) = self.propagationPolicy.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        for value in &self.dryRun {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.gracePeriodSeconds {
            os.write_int64(1, v)?;
        }
        if let Some(ref v) = self.preconditions.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.orphanDependents {
            os.write_bool(3, v)?;
        }
        if let Some(ref v) = self.propagationPolicy.as_ref() {
            os.write_string(4, &v)?;
        }
        for v in &self.dryRun {
            os.write_string(5, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeleteOptions {
        DeleteOptions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "gracePeriodSeconds",
                |m: &DeleteOptions| { &m.gracePeriodSeconds },
                |m: &mut DeleteOptions| { &mut m.gracePeriodSeconds },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Preconditions>>(
                "preconditions",
                |m: &DeleteOptions| { &m.preconditions },
                |m: &mut DeleteOptions| { &mut m.preconditions },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "orphanDependents",
                |m: &DeleteOptions| { &m.orphanDependents },
                |m: &mut DeleteOptions| { &mut m.orphanDependents },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "propagationPolicy",
                |m: &DeleteOptions| { &m.propagationPolicy },
                |m: &mut DeleteOptions| { &mut m.propagationPolicy },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "dryRun",
                |m: &DeleteOptions| { &m.dryRun },
                |m: &mut DeleteOptions| { &mut m.dryRun },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeleteOptions>(
                "DeleteOptions",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static DeleteOptions {
        static instance: ::protobuf::rt::LazyV2<DeleteOptions> = ::protobuf::rt::LazyV2::INIT;
        instance.get(DeleteOptions::new)
    }
}

impl ::protobuf::Clear for DeleteOptions {
    fn clear(&mut self) {
        self.gracePeriodSeconds = ::std::option::Option::None;
        self.preconditions.clear();
        self.orphanDependents = ::std::option::Option::None;
        self.propagationPolicy.clear();
        self.dryRun.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeleteOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeleteOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Duration {
    // message fields
    duration: ::std::option::Option<i64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Duration {
    fn default() -> &'a Duration {
        <Duration as ::protobuf::Message>::default_instance()
    }
}

impl Duration {
    pub fn new() -> Duration {
        ::std::default::Default::default()
    }

    // optional int64 duration = 1;


    pub fn get_duration(&self) -> i64 {
        self.duration.unwrap_or(0)
    }
    pub fn clear_duration(&mut self) {
        self.duration = ::std::option::Option::None;
    }

    pub fn has_duration(&self) -> bool {
        self.duration.is_some()
    }

    // Param is passed by value, moved
    pub fn set_duration(&mut self, v: i64) {
        self.duration = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for Duration {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.duration = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.duration {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.duration {
            os.write_int64(1, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Duration {
        Duration::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "duration",
                |m: &Duration| { &m.duration },
                |m: &mut Duration| { &mut m.duration },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Duration>(
                "Duration",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Duration {
        static instance: ::protobuf::rt::LazyV2<Duration> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Duration::new)
    }
}

impl ::protobuf::Clear for Duration {
    fn clear(&mut self) {
        self.duration = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Duration {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Duration {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ExportOptions {
    // message fields
    export: ::std::option::Option<bool>,
    exact: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ExportOptions {
    fn default() -> &'a ExportOptions {
        <ExportOptions as ::protobuf::Message>::default_instance()
    }
}

impl ExportOptions {
    pub fn new() -> ExportOptions {
        ::std::default::Default::default()
    }

    // optional bool export = 1;


    pub fn get_export(&self) -> bool {
        self.export.unwrap_or(false)
    }
    pub fn clear_export(&mut self) {
        self.export = ::std::option::Option::None;
    }

    pub fn has_export(&self) -> bool {
        self.export.is_some()
    }

    // Param is passed by value, moved
    pub fn set_export(&mut self, v: bool) {
        self.export = ::std::option::Option::Some(v);
    }

    // optional bool exact = 2;


    pub fn get_exact(&self) -> bool {
        self.exact.unwrap_or(false)
    }
    pub fn clear_exact(&mut self) {
        self.exact = ::std::option::Option::None;
    }

    pub fn has_exact(&self) -> bool {
        self.exact.is_some()
    }

    // Param is passed by value, moved
    pub fn set_exact(&mut self, v: bool) {
        self.exact = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ExportOptions {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.export = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.exact = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.export {
            my_size += 2;
        }
        if let Some(v) = self.exact {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.export {
            os.write_bool(1, v)?;
        }
        if let Some(v) = self.exact {
            os.write_bool(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ExportOptions {
        ExportOptions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "export",
                |m: &ExportOptions| { &m.export },
                |m: &mut ExportOptions| { &mut m.export },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "exact",
                |m: &ExportOptions| { &m.exact },
                |m: &mut ExportOptions| { &mut m.exact },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ExportOptions>(
                "ExportOptions",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ExportOptions {
        static instance: ::protobuf::rt::LazyV2<ExportOptions> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ExportOptions::new)
    }
}

impl ::protobuf::Clear for ExportOptions {
    fn clear(&mut self) {
        self.export = ::std::option::Option::None;
        self.exact = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ExportOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExportOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct FieldsV1 {
    // message fields
    Raw: ::protobuf::SingularField<::std::vec::Vec<u8>>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a FieldsV1 {
    fn default() -> &'a FieldsV1 {
        <FieldsV1 as ::protobuf::Message>::default_instance()
    }
}

impl FieldsV1 {
    pub fn new() -> FieldsV1 {
        ::std::default::Default::default()
    }

    // optional bytes Raw = 1;


    pub fn get_Raw(&self) -> &[u8] {
        match self.Raw.as_ref() {
            Some(v) => &v,
            None => &[],
        }
    }
    pub fn clear_Raw(&mut self) {
        self.Raw.clear();
    }

    pub fn has_Raw(&self) -> bool {
        self.Raw.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Raw(&mut self, v: ::std::vec::Vec<u8>) {
        self.Raw = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Raw(&mut self) -> &mut ::std::vec::Vec<u8> {
        if self.Raw.is_none() {
            self.Raw.set_default();
        }
        self.Raw.as_mut().unwrap()
    }

    // Take field
    pub fn take_Raw(&mut self) -> ::std::vec::Vec<u8> {
        self.Raw.take().unwrap_or_else(|| ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for FieldsV1 {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_bytes_into(wire_type, is, &mut self.Raw)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.Raw.as_ref() {
            my_size += ::protobuf::rt::bytes_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.Raw.as_ref() {
            os.write_bytes(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> FieldsV1 {
        FieldsV1::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                "Raw",
                |m: &FieldsV1| { &m.Raw },
                |m: &mut FieldsV1| { &mut m.Raw },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<FieldsV1>(
                "FieldsV1",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static FieldsV1 {
        static instance: ::protobuf::rt::LazyV2<FieldsV1> = ::protobuf::rt::LazyV2::INIT;
        instance.get(FieldsV1::new)
    }
}

impl ::protobuf::Clear for FieldsV1 {
    fn clear(&mut self) {
        self.Raw.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for FieldsV1 {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FieldsV1 {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GetOptions {
    // message fields
    resourceVersion: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetOptions {
    fn default() -> &'a GetOptions {
        <GetOptions as ::protobuf::Message>::default_instance()
    }
}

impl GetOptions {
    pub fn new() -> GetOptions {
        ::std::default::Default::default()
    }

    // optional string resourceVersion = 1;


    pub fn get_resourceVersion(&self) -> &str {
        match self.resourceVersion.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_resourceVersion(&mut self) {
        self.resourceVersion.clear();
    }

    pub fn has_resourceVersion(&self) -> bool {
        self.resourceVersion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resourceVersion(&mut self, v: ::std::string::String) {
        self.resourceVersion = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_resourceVersion(&mut self) -> &mut ::std::string::String {
        if self.resourceVersion.is_none() {
            self.resourceVersion.set_default();
        }
        self.resourceVersion.as_mut().unwrap()
    }

    // Take field
    pub fn take_resourceVersion(&mut self) -> ::std::string::String {
        self.resourceVersion.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetOptions {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.resourceVersion)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.resourceVersion.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.resourceVersion.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetOptions {
        GetOptions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "resourceVersion",
                |m: &GetOptions| { &m.resourceVersion },
                |m: &mut GetOptions| { &mut m.resourceVersion },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetOptions>(
                "GetOptions",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GetOptions {
        static instance: ::protobuf::rt::LazyV2<GetOptions> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GetOptions::new)
    }
}

impl ::protobuf::Clear for GetOptions {
    fn clear(&mut self) {
        self.resourceVersion.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GroupKind {
    // message fields
    group: ::protobuf::SingularField<::std::string::String>,
    kind: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GroupKind {
    fn default() -> &'a GroupKind {
        <GroupKind as ::protobuf::Message>::default_instance()
    }
}

impl GroupKind {
    pub fn new() -> GroupKind {
        ::std::default::Default::default()
    }

    // optional string group = 1;


    pub fn get_group(&self) -> &str {
        match self.group.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_group(&mut self) {
        self.group.clear();
    }

    pub fn has_group(&self) -> bool {
        self.group.is_some()
    }

    // Param is passed by value, moved
    pub fn set_group(&mut self, v: ::std::string::String) {
        self.group = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_group(&mut self) -> &mut ::std::string::String {
        if self.group.is_none() {
            self.group.set_default();
        }
        self.group.as_mut().unwrap()
    }

    // Take field
    pub fn take_group(&mut self) -> ::std::string::String {
        self.group.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string kind = 2;


    pub fn get_kind(&self) -> &str {
        match self.kind.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_kind(&mut self) {
        self.kind.clear();
    }

    pub fn has_kind(&self) -> bool {
        self.kind.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kind(&mut self, v: ::std::string::String) {
        self.kind = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kind(&mut self) -> &mut ::std::string::String {
        if self.kind.is_none() {
            self.kind.set_default();
        }
        self.kind.as_mut().unwrap()
    }

    // Take field
    pub fn take_kind(&mut self) -> ::std::string::String {
        self.kind.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for GroupKind {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.group)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.kind)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.group.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.kind.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.group.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.kind.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GroupKind {
        GroupKind::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "group",
                |m: &GroupKind| { &m.group },
                |m: &mut GroupKind| { &mut m.group },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "kind",
                |m: &GroupKind| { &m.kind },
                |m: &mut GroupKind| { &mut m.kind },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GroupKind>(
                "GroupKind",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GroupKind {
        static instance: ::protobuf::rt::LazyV2<GroupKind> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GroupKind::new)
    }
}

impl ::protobuf::Clear for GroupKind {
    fn clear(&mut self) {
        self.group.clear();
        self.kind.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GroupKind {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GroupKind {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GroupResource {
    // message fields
    group: ::protobuf::SingularField<::std::string::String>,
    resource: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GroupResource {
    fn default() -> &'a GroupResource {
        <GroupResource as ::protobuf::Message>::default_instance()
    }
}

impl GroupResource {
    pub fn new() -> GroupResource {
        ::std::default::Default::default()
    }

    // optional string group = 1;


    pub fn get_group(&self) -> &str {
        match self.group.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_group(&mut self) {
        self.group.clear();
    }

    pub fn has_group(&self) -> bool {
        self.group.is_some()
    }

    // Param is passed by value, moved
    pub fn set_group(&mut self, v: ::std::string::String) {
        self.group = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_group(&mut self) -> &mut ::std::string::String {
        if self.group.is_none() {
            self.group.set_default();
        }
        self.group.as_mut().unwrap()
    }

    // Take field
    pub fn take_group(&mut self) -> ::std::string::String {
        self.group.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string resource = 2;


    pub fn get_resource(&self) -> &str {
        match self.resource.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_resource(&mut self) {
        self.resource.clear();
    }

    pub fn has_resource(&self) -> bool {
        self.resource.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resource(&mut self, v: ::std::string::String) {
        self.resource = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_resource(&mut self) -> &mut ::std::string::String {
        if self.resource.is_none() {
            self.resource.set_default();
        }
        self.resource.as_mut().unwrap()
    }

    // Take field
    pub fn take_resource(&mut self) -> ::std::string::String {
        self.resource.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for GroupResource {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.group)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.resource)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.group.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.resource.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.group.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.resource.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GroupResource {
        GroupResource::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "group",
                |m: &GroupResource| { &m.group },
                |m: &mut GroupResource| { &mut m.group },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "resource",
                |m: &GroupResource| { &m.resource },
                |m: &mut GroupResource| { &mut m.resource },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GroupResource>(
                "GroupResource",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GroupResource {
        static instance: ::protobuf::rt::LazyV2<GroupResource> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GroupResource::new)
    }
}

impl ::protobuf::Clear for GroupResource {
    fn clear(&mut self) {
        self.group.clear();
        self.resource.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GroupResource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GroupResource {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GroupVersion {
    // message fields
    group: ::protobuf::SingularField<::std::string::String>,
    version: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GroupVersion {
    fn default() -> &'a GroupVersion {
        <GroupVersion as ::protobuf::Message>::default_instance()
    }
}

impl GroupVersion {
    pub fn new() -> GroupVersion {
        ::std::default::Default::default()
    }

    // optional string group = 1;


    pub fn get_group(&self) -> &str {
        match self.group.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_group(&mut self) {
        self.group.clear();
    }

    pub fn has_group(&self) -> bool {
        self.group.is_some()
    }

    // Param is passed by value, moved
    pub fn set_group(&mut self, v: ::std::string::String) {
        self.group = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_group(&mut self) -> &mut ::std::string::String {
        if self.group.is_none() {
            self.group.set_default();
        }
        self.group.as_mut().unwrap()
    }

    // Take field
    pub fn take_group(&mut self) -> ::std::string::String {
        self.group.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string version = 2;


    pub fn get_version(&self) -> &str {
        match self.version.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_version(&mut self) {
        self.version.clear();
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: ::std::string::String) {
        self.version = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version(&mut self) -> &mut ::std::string::String {
        if self.version.is_none() {
            self.version.set_default();
        }
        self.version.as_mut().unwrap()
    }

    // Take field
    pub fn take_version(&mut self) -> ::std::string::String {
        self.version.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for GroupVersion {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.group)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.version)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.group.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.version.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.group.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.version.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GroupVersion {
        GroupVersion::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "group",
                |m: &GroupVersion| { &m.group },
                |m: &mut GroupVersion| { &mut m.group },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "version",
                |m: &GroupVersion| { &m.version },
                |m: &mut GroupVersion| { &mut m.version },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GroupVersion>(
                "GroupVersion",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GroupVersion {
        static instance: ::protobuf::rt::LazyV2<GroupVersion> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GroupVersion::new)
    }
}

impl ::protobuf::Clear for GroupVersion {
    fn clear(&mut self) {
        self.group.clear();
        self.version.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GroupVersion {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GroupVersion {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GroupVersionForDiscovery {
    // message fields
    groupVersion: ::protobuf::SingularField<::std::string::String>,
    version: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GroupVersionForDiscovery {
    fn default() -> &'a GroupVersionForDiscovery {
        <GroupVersionForDiscovery as ::protobuf::Message>::default_instance()
    }
}

impl GroupVersionForDiscovery {
    pub fn new() -> GroupVersionForDiscovery {
        ::std::default::Default::default()
    }

    // optional string groupVersion = 1;


    pub fn get_groupVersion(&self) -> &str {
        match self.groupVersion.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_groupVersion(&mut self) {
        self.groupVersion.clear();
    }

    pub fn has_groupVersion(&self) -> bool {
        self.groupVersion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_groupVersion(&mut self, v: ::std::string::String) {
        self.groupVersion = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_groupVersion(&mut self) -> &mut ::std::string::String {
        if self.groupVersion.is_none() {
            self.groupVersion.set_default();
        }
        self.groupVersion.as_mut().unwrap()
    }

    // Take field
    pub fn take_groupVersion(&mut self) -> ::std::string::String {
        self.groupVersion.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string version = 2;


    pub fn get_version(&self) -> &str {
        match self.version.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_version(&mut self) {
        self.version.clear();
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: ::std::string::String) {
        self.version = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version(&mut self) -> &mut ::std::string::String {
        if self.version.is_none() {
            self.version.set_default();
        }
        self.version.as_mut().unwrap()
    }

    // Take field
    pub fn take_version(&mut self) -> ::std::string::String {
        self.version.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for GroupVersionForDiscovery {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.groupVersion)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.version)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.groupVersion.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.version.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.groupVersion.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.version.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GroupVersionForDiscovery {
        GroupVersionForDiscovery::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "groupVersion",
                |m: &GroupVersionForDiscovery| { &m.groupVersion },
                |m: &mut GroupVersionForDiscovery| { &mut m.groupVersion },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "version",
                |m: &GroupVersionForDiscovery| { &m.version },
                |m: &mut GroupVersionForDiscovery| { &mut m.version },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GroupVersionForDiscovery>(
                "GroupVersionForDiscovery",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GroupVersionForDiscovery {
        static instance: ::protobuf::rt::LazyV2<GroupVersionForDiscovery> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GroupVersionForDiscovery::new)
    }
}

impl ::protobuf::Clear for GroupVersionForDiscovery {
    fn clear(&mut self) {
        self.groupVersion.clear();
        self.version.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GroupVersionForDiscovery {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GroupVersionForDiscovery {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GroupVersionKind {
    // message fields
    group: ::protobuf::SingularField<::std::string::String>,
    version: ::protobuf::SingularField<::std::string::String>,
    kind: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GroupVersionKind {
    fn default() -> &'a GroupVersionKind {
        <GroupVersionKind as ::protobuf::Message>::default_instance()
    }
}

impl GroupVersionKind {
    pub fn new() -> GroupVersionKind {
        ::std::default::Default::default()
    }

    // optional string group = 1;


    pub fn get_group(&self) -> &str {
        match self.group.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_group(&mut self) {
        self.group.clear();
    }

    pub fn has_group(&self) -> bool {
        self.group.is_some()
    }

    // Param is passed by value, moved
    pub fn set_group(&mut self, v: ::std::string::String) {
        self.group = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_group(&mut self) -> &mut ::std::string::String {
        if self.group.is_none() {
            self.group.set_default();
        }
        self.group.as_mut().unwrap()
    }

    // Take field
    pub fn take_group(&mut self) -> ::std::string::String {
        self.group.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string version = 2;


    pub fn get_version(&self) -> &str {
        match self.version.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_version(&mut self) {
        self.version.clear();
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: ::std::string::String) {
        self.version = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version(&mut self) -> &mut ::std::string::String {
        if self.version.is_none() {
            self.version.set_default();
        }
        self.version.as_mut().unwrap()
    }

    // Take field
    pub fn take_version(&mut self) -> ::std::string::String {
        self.version.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string kind = 3;


    pub fn get_kind(&self) -> &str {
        match self.kind.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_kind(&mut self) {
        self.kind.clear();
    }

    pub fn has_kind(&self) -> bool {
        self.kind.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kind(&mut self, v: ::std::string::String) {
        self.kind = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kind(&mut self) -> &mut ::std::string::String {
        if self.kind.is_none() {
            self.kind.set_default();
        }
        self.kind.as_mut().unwrap()
    }

    // Take field
    pub fn take_kind(&mut self) -> ::std::string::String {
        self.kind.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for GroupVersionKind {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.group)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.version)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.kind)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.group.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.version.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.kind.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.group.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.version.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.kind.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GroupVersionKind {
        GroupVersionKind::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "group",
                |m: &GroupVersionKind| { &m.group },
                |m: &mut GroupVersionKind| { &mut m.group },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "version",
                |m: &GroupVersionKind| { &m.version },
                |m: &mut GroupVersionKind| { &mut m.version },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "kind",
                |m: &GroupVersionKind| { &m.kind },
                |m: &mut GroupVersionKind| { &mut m.kind },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GroupVersionKind>(
                "GroupVersionKind",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GroupVersionKind {
        static instance: ::protobuf::rt::LazyV2<GroupVersionKind> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GroupVersionKind::new)
    }
}

impl ::protobuf::Clear for GroupVersionKind {
    fn clear(&mut self) {
        self.group.clear();
        self.version.clear();
        self.kind.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GroupVersionKind {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GroupVersionKind {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct GroupVersionResource {
    // message fields
    group: ::protobuf::SingularField<::std::string::String>,
    version: ::protobuf::SingularField<::std::string::String>,
    resource: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GroupVersionResource {
    fn default() -> &'a GroupVersionResource {
        <GroupVersionResource as ::protobuf::Message>::default_instance()
    }
}

impl GroupVersionResource {
    pub fn new() -> GroupVersionResource {
        ::std::default::Default::default()
    }

    // optional string group = 1;


    pub fn get_group(&self) -> &str {
        match self.group.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_group(&mut self) {
        self.group.clear();
    }

    pub fn has_group(&self) -> bool {
        self.group.is_some()
    }

    // Param is passed by value, moved
    pub fn set_group(&mut self, v: ::std::string::String) {
        self.group = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_group(&mut self) -> &mut ::std::string::String {
        if self.group.is_none() {
            self.group.set_default();
        }
        self.group.as_mut().unwrap()
    }

    // Take field
    pub fn take_group(&mut self) -> ::std::string::String {
        self.group.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string version = 2;


    pub fn get_version(&self) -> &str {
        match self.version.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_version(&mut self) {
        self.version.clear();
    }

    pub fn has_version(&self) -> bool {
        self.version.is_some()
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: ::std::string::String) {
        self.version = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version(&mut self) -> &mut ::std::string::String {
        if self.version.is_none() {
            self.version.set_default();
        }
        self.version.as_mut().unwrap()
    }

    // Take field
    pub fn take_version(&mut self) -> ::std::string::String {
        self.version.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string resource = 3;


    pub fn get_resource(&self) -> &str {
        match self.resource.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_resource(&mut self) {
        self.resource.clear();
    }

    pub fn has_resource(&self) -> bool {
        self.resource.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resource(&mut self, v: ::std::string::String) {
        self.resource = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_resource(&mut self) -> &mut ::std::string::String {
        if self.resource.is_none() {
            self.resource.set_default();
        }
        self.resource.as_mut().unwrap()
    }

    // Take field
    pub fn take_resource(&mut self) -> ::std::string::String {
        self.resource.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for GroupVersionResource {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.group)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.version)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.resource)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.group.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.version.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.resource.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.group.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.version.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.resource.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GroupVersionResource {
        GroupVersionResource::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "group",
                |m: &GroupVersionResource| { &m.group },
                |m: &mut GroupVersionResource| { &mut m.group },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "version",
                |m: &GroupVersionResource| { &m.version },
                |m: &mut GroupVersionResource| { &mut m.version },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "resource",
                |m: &GroupVersionResource| { &m.resource },
                |m: &mut GroupVersionResource| { &mut m.resource },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<GroupVersionResource>(
                "GroupVersionResource",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static GroupVersionResource {
        static instance: ::protobuf::rt::LazyV2<GroupVersionResource> = ::protobuf::rt::LazyV2::INIT;
        instance.get(GroupVersionResource::new)
    }
}

impl ::protobuf::Clear for GroupVersionResource {
    fn clear(&mut self) {
        self.group.clear();
        self.version.clear();
        self.resource.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GroupVersionResource {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GroupVersionResource {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LabelSelector {
    // message fields
    pub matchLabels: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    pub matchExpressions: ::protobuf::RepeatedField<LabelSelectorRequirement>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LabelSelector {
    fn default() -> &'a LabelSelector {
        <LabelSelector as ::protobuf::Message>::default_instance()
    }
}

impl LabelSelector {
    pub fn new() -> LabelSelector {
        ::std::default::Default::default()
    }

    // repeated .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector.MatchLabelsEntry matchLabels = 1;


    pub fn get_matchLabels(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.matchLabels
    }
    pub fn clear_matchLabels(&mut self) {
        self.matchLabels.clear();
    }

    // Param is passed by value, moved
    pub fn set_matchLabels(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.matchLabels = v;
    }

    // Mutable pointer to the field.
    pub fn mut_matchLabels(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.matchLabels
    }

    // Take field
    pub fn take_matchLabels(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.matchLabels, ::std::collections::HashMap::new())
    }

    // repeated .k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelectorRequirement matchExpressions = 2;


    pub fn get_matchExpressions(&self) -> &[LabelSelectorRequirement] {
        &self.matchExpressions
    }
    pub fn clear_matchExpressions(&mut self) {
        self.matchExpressions.clear();
    }

    // Param is passed by value, moved
    pub fn set_matchExpressions(&mut self, v: ::protobuf::RepeatedField<LabelSelectorRequirement>) {
        self.matchExpressions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_matchExpressions(&mut self) -> &mut ::protobuf::RepeatedField<LabelSelectorRequirement> {
        &mut self.matchExpressions
    }

    // Take field
    pub fn take_matchExpressions(&mut self) -> ::protobuf::RepeatedField<LabelSelectorRequirement> {
        ::std::mem::replace(&mut self.matchExpressions, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for LabelSelector {
    fn is_initialized(&self) -> bool {
        for v in &self.matchExpressions {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.matchLabels)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.matchExpressions)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(1, &self.matchLabels);
        for value in &self.matchExpressions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(1, &self.matchLabels, os)?;
        for v in &self.matchExpressions {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LabelSelector {
        LabelSelector::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                "matchLabels",
                |m: &LabelSelector| { &m.matchLabels },
                |m: &mut LabelSelector| { &mut m.matchLabels },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LabelSelectorRequirement>>(
                "matchExpressions",
                |m: &LabelSelector| { &m.matchExpressions },
                |m: &mut LabelSelector| { &mut m.matchExpressions },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LabelSelector>(
                "LabelSelector",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LabelSelector {
        static instance: ::protobuf::rt::LazyV2<LabelSelector> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LabelSelector::new)
    }
}

impl ::protobuf::Clear for LabelSelector {
    fn clear(&mut self) {
        self.matchLabels.clear();
        self.matchExpressions.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LabelSelector {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LabelSelector {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct LabelSelectorRequirement {
    // message fields
    key: ::protobuf::SingularField<::std::string::String>,
    operator: ::protobuf::SingularField<::std::string::String>,
    pub values: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LabelSelectorRequirement {
    fn default() -> &'a LabelSelectorRequirement {
        <LabelSelectorRequirement as ::protobuf::Message>::default_instance()
    }
}

impl LabelSelectorRequirement {
    pub fn new() -> LabelSelectorRequirement {
        ::std::default::Default::default()
    }

    // optional string key = 1;


    pub fn get_key(&self) -> &str {
        match self.key.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    pub fn has_key(&self) -> bool {
        self.key.is_some()
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::string::String) {
        self.key = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::string::String {
        if self.key.is_none() {
            self.key.set_default();
        }
        self.key.as_mut().unwrap()
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::string::String {
        self.key.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string operator = 2;


    pub fn get_operator(&self) -> &str {
        match self.operator.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_operator(&mut self) {
        self.operator.clear();
    }

    pub fn has_operator(&self) -> bool {
        self.operator.is_some()
    }

    // Param is passed by value, moved
    pub fn set_operator(&mut self, v: ::std::string::String) {
        self.operator = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_operator(&mut self) -> &mut ::std::string::String {
        if self.operator.is_none() {
            self.operator.set_default();
        }
        self.operator.as_mut().unwrap()
    }

    // Take field
    pub fn take_operator(&mut self) -> ::std::string::String {
        self.operator.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated string values = 3;


    pub fn get_values(&self) -> &[::std::string::String] {
        &self.values
    }
    pub fn clear_values(&mut self) {
        self.values.clear();
    }

    // Param is passed by value, moved
    pub fn set_values(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.values = v;
    }

    // Mutable pointer to the field.
    pub fn mut_values(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.values
    }

    // Take field
    pub fn take_values(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.values, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for LabelSelectorRequirement {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.operator)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.values)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.key.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.operator.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        for value in &self.values {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.key.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.operator.as_ref() {
            os.write_string(2, &v)?;
        }
        for v in &self.values {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LabelSelectorRequirement {
        LabelSelectorRequirement::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "key",
                |m: &LabelSelectorRequirement| { &m.key },
                |m: &mut LabelSelectorRequirement| { &mut m.key },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "operator",
                |m: &LabelSelectorRequirement| { &m.operator },
                |m: &mut LabelSelectorRequirement| { &mut m.operator },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "values",
                |m: &LabelSelectorRequirement| { &m.values },
                |m: &mut LabelSelectorRequirement| { &mut m.values },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<LabelSelectorRequirement>(
                "LabelSelectorRequirement",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static LabelSelectorRequirement {
        static instance: ::protobuf::rt::LazyV2<LabelSelectorRequirement> = ::protobuf::rt::LazyV2::INIT;
        instance.get(LabelSelectorRequirement::new)
    }
}

impl ::protobuf::Clear for LabelSelectorRequirement {
    fn clear(&mut self) {
        self.key.clear();
        self.operator.clear();
        self.values.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LabelSelectorRequirement {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LabelSelectorRequirement {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct List {
    // message fields
    pub metadata: ::protobuf::SingularPtrField<ListMeta>,
    pub items: ::protobuf::RepeatedField<super::runtime::RawExtension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a List {
    fn default() -> &'a List {
        <List as ::protobuf::Message>::default_instance()
    }
}

impl List {
    pub fn new() -> List {
        ::std::default::Default::default()
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;


    pub fn get_metadata(&self) -> &ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <ListMeta as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: ListMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut ListMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> ListMeta {
        self.metadata.take().unwrap_or_else(|| ListMeta::new())
    }

    // repeated .k8s.io.apimachinery.pkg.runtime.RawExtension items = 2;


    pub fn get_items(&self) -> &[super::runtime::RawExtension] {
        &self.items
    }
    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::protobuf::RepeatedField<super::runtime::RawExtension>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::protobuf::RepeatedField<super::runtime::RawExtension> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::protobuf::RepeatedField<super::runtime::RawExtension> {
        ::std::mem::replace(&mut self.items, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for List {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.items {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.items)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.items {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> List {
        List::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ListMeta>>(
                "metadata",
                |m: &List| { &m.metadata },
                |m: &mut List| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::runtime::RawExtension>>(
                "items",
                |m: &List| { &m.items },
                |m: &mut List| { &mut m.items },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<List>(
                "List",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static List {
        static instance: ::protobuf::rt::LazyV2<List> = ::protobuf::rt::LazyV2::INIT;
        instance.get(List::new)
    }
}

impl ::protobuf::Clear for List {
    fn clear(&mut self) {
        self.metadata.clear();
        self.items.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for List {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for List {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListMeta {
    // message fields
    selfLink: ::protobuf::SingularField<::std::string::String>,
    resourceVersion: ::protobuf::SingularField<::std::string::String>,
    field_continue: ::protobuf::SingularField<::std::string::String>,
    remainingItemCount: ::std::option::Option<i64>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListMeta {
    fn default() -> &'a ListMeta {
        <ListMeta as ::protobuf::Message>::default_instance()
    }
}

impl ListMeta {
    pub fn new() -> ListMeta {
        ::std::default::Default::default()
    }

    // optional string selfLink = 1;


    pub fn get_selfLink(&self) -> &str {
        match self.selfLink.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_selfLink(&mut self) {
        self.selfLink.clear();
    }

    pub fn has_selfLink(&self) -> bool {
        self.selfLink.is_some()
    }

    // Param is passed by value, moved
    pub fn set_selfLink(&mut self, v: ::std::string::String) {
        self.selfLink = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_selfLink(&mut self) -> &mut ::std::string::String {
        if self.selfLink.is_none() {
            self.selfLink.set_default();
        }
        self.selfLink.as_mut().unwrap()
    }

    // Take field
    pub fn take_selfLink(&mut self) -> ::std::string::String {
        self.selfLink.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string resourceVersion = 2;


    pub fn get_resourceVersion(&self) -> &str {
        match self.resourceVersion.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_resourceVersion(&mut self) {
        self.resourceVersion.clear();
    }

    pub fn has_resourceVersion(&self) -> bool {
        self.resourceVersion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resourceVersion(&mut self, v: ::std::string::String) {
        self.resourceVersion = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_resourceVersion(&mut self) -> &mut ::std::string::String {
        if self.resourceVersion.is_none() {
            self.resourceVersion.set_default();
        }
        self.resourceVersion.as_mut().unwrap()
    }

    // Take field
    pub fn take_resourceVersion(&mut self) -> ::std::string::String {
        self.resourceVersion.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string continue = 3;


    pub fn get_field_continue(&self) -> &str {
        match self.field_continue.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_field_continue(&mut self) {
        self.field_continue.clear();
    }

    pub fn has_field_continue(&self) -> bool {
        self.field_continue.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_continue(&mut self, v: ::std::string::String) {
        self.field_continue = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_continue(&mut self) -> &mut ::std::string::String {
        if self.field_continue.is_none() {
            self.field_continue.set_default();
        }
        self.field_continue.as_mut().unwrap()
    }

    // Take field
    pub fn take_field_continue(&mut self) -> ::std::string::String {
        self.field_continue.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int64 remainingItemCount = 4;


    pub fn get_remainingItemCount(&self) -> i64 {
        self.remainingItemCount.unwrap_or(0)
    }
    pub fn clear_remainingItemCount(&mut self) {
        self.remainingItemCount = ::std::option::Option::None;
    }

    pub fn has_remainingItemCount(&self) -> bool {
        self.remainingItemCount.is_some()
    }

    // Param is passed by value, moved
    pub fn set_remainingItemCount(&mut self, v: i64) {
        self.remainingItemCount = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for ListMeta {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.selfLink)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.resourceVersion)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.field_continue)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.remainingItemCount = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.selfLink.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.resourceVersion.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.field_continue.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(v) = self.remainingItemCount {
            my_size += ::protobuf::rt::value_size(4, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.selfLink.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.resourceVersion.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.field_continue.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(v) = self.remainingItemCount {
            os.write_int64(4, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListMeta {
        ListMeta::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "selfLink",
                |m: &ListMeta| { &m.selfLink },
                |m: &mut ListMeta| { &mut m.selfLink },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "resourceVersion",
                |m: &ListMeta| { &m.resourceVersion },
                |m: &mut ListMeta| { &mut m.resourceVersion },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "continue",
                |m: &ListMeta| { &m.field_continue },
                |m: &mut ListMeta| { &mut m.field_continue },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "remainingItemCount",
                |m: &ListMeta| { &m.remainingItemCount },
                |m: &mut ListMeta| { &mut m.remainingItemCount },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListMeta>(
                "ListMeta",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListMeta {
        static instance: ::protobuf::rt::LazyV2<ListMeta> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListMeta::new)
    }
}

impl ::protobuf::Clear for ListMeta {
    fn clear(&mut self) {
        self.selfLink.clear();
        self.resourceVersion.clear();
        self.field_continue.clear();
        self.remainingItemCount = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListMeta {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListMeta {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ListOptions {
    // message fields
    labelSelector: ::protobuf::SingularField<::std::string::String>,
    fieldSelector: ::protobuf::SingularField<::std::string::String>,
    watch: ::std::option::Option<bool>,
    allowWatchBookmarks: ::std::option::Option<bool>,
    resourceVersion: ::protobuf::SingularField<::std::string::String>,
    resourceVersionMatch: ::protobuf::SingularField<::std::string::String>,
    timeoutSeconds: ::std::option::Option<i64>,
    limit: ::std::option::Option<i64>,
    field_continue: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ListOptions {
    fn default() -> &'a ListOptions {
        <ListOptions as ::protobuf::Message>::default_instance()
    }
}

impl ListOptions {
    pub fn new() -> ListOptions {
        ::std::default::Default::default()
    }

    // optional string labelSelector = 1;


    pub fn get_labelSelector(&self) -> &str {
        match self.labelSelector.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_labelSelector(&mut self) {
        self.labelSelector.clear();
    }

    pub fn has_labelSelector(&self) -> bool {
        self.labelSelector.is_some()
    }

    // Param is passed by value, moved
    pub fn set_labelSelector(&mut self, v: ::std::string::String) {
        self.labelSelector = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_labelSelector(&mut self) -> &mut ::std::string::String {
        if self.labelSelector.is_none() {
            self.labelSelector.set_default();
        }
        self.labelSelector.as_mut().unwrap()
    }

    // Take field
    pub fn take_labelSelector(&mut self) -> ::std::string::String {
        self.labelSelector.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string fieldSelector = 2;


    pub fn get_fieldSelector(&self) -> &str {
        match self.fieldSelector.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_fieldSelector(&mut self) {
        self.fieldSelector.clear();
    }

    pub fn has_fieldSelector(&self) -> bool {
        self.fieldSelector.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fieldSelector(&mut self, v: ::std::string::String) {
        self.fieldSelector = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fieldSelector(&mut self) -> &mut ::std::string::String {
        if self.fieldSelector.is_none() {
            self.fieldSelector.set_default();
        }
        self.fieldSelector.as_mut().unwrap()
    }

    // Take field
    pub fn take_fieldSelector(&mut self) -> ::std::string::String {
        self.fieldSelector.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool watch = 3;


    pub fn get_watch(&self) -> bool {
        self.watch.unwrap_or(false)
    }
    pub fn clear_watch(&mut self) {
        self.watch = ::std::option::Option::None;
    }

    pub fn has_watch(&self) -> bool {
        self.watch.is_some()
    }

    // Param is passed by value, moved
    pub fn set_watch(&mut self, v: bool) {
        self.watch = ::std::option::Option::Some(v);
    }

    // optional bool allowWatchBookmarks = 9;


    pub fn get_allowWatchBookmarks(&self) -> bool {
        self.allowWatchBookmarks.unwrap_or(false)
    }
    pub fn clear_allowWatchBookmarks(&mut self) {
        self.allowWatchBookmarks = ::std::option::Option::None;
    }

    pub fn has_allowWatchBookmarks(&self) -> bool {
        self.allowWatchBookmarks.is_some()
    }

    // Param is passed by value, moved
    pub fn set_allowWatchBookmarks(&mut self, v: bool) {
        self.allowWatchBookmarks = ::std::option::Option::Some(v);
    }

    // optional string resourceVersion = 4;


    pub fn get_resourceVersion(&self) -> &str {
        match self.resourceVersion.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_resourceVersion(&mut self) {
        self.resourceVersion.clear();
    }

    pub fn has_resourceVersion(&self) -> bool {
        self.resourceVersion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resourceVersion(&mut self, v: ::std::string::String) {
        self.resourceVersion = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_resourceVersion(&mut self) -> &mut ::std::string::String {
        if self.resourceVersion.is_none() {
            self.resourceVersion.set_default();
        }
        self.resourceVersion.as_mut().unwrap()
    }

    // Take field
    pub fn take_resourceVersion(&mut self) -> ::std::string::String {
        self.resourceVersion.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string resourceVersionMatch = 10;


    pub fn get_resourceVersionMatch(&self) -> &str {
        match self.resourceVersionMatch.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_resourceVersionMatch(&mut self) {
        self.resourceVersionMatch.clear();
    }

    pub fn has_resourceVersionMatch(&self) -> bool {
        self.resourceVersionMatch.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resourceVersionMatch(&mut self, v: ::std::string::String) {
        self.resourceVersionMatch = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_resourceVersionMatch(&mut self) -> &mut ::std::string::String {
        if self.resourceVersionMatch.is_none() {
            self.resourceVersionMatch.set_default();
        }
        self.resourceVersionMatch.as_mut().unwrap()
    }

    // Take field
    pub fn take_resourceVersionMatch(&mut self) -> ::std::string::String {
        self.resourceVersionMatch.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int64 timeoutSeconds = 5;


    pub fn get_timeoutSeconds(&self) -> i64 {
        self.timeoutSeconds.unwrap_or(0)
    }
    pub fn clear_timeoutSeconds(&mut self) {
        self.timeoutSeconds = ::std::option::Option::None;
    }

    pub fn has_timeoutSeconds(&self) -> bool {
        self.timeoutSeconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_timeoutSeconds(&mut self, v: i64) {
        self.timeoutSeconds = ::std::option::Option::Some(v);
    }

    // optional int64 limit = 7;


    pub fn get_limit(&self) -> i64 {
        self.limit.unwrap_or(0)
    }
    pub fn clear_limit(&mut self) {
        self.limit = ::std::option::Option::None;
    }

    pub fn has_limit(&self) -> bool {
        self.limit.is_some()
    }

    // Param is passed by value, moved
    pub fn set_limit(&mut self, v: i64) {
        self.limit = ::std::option::Option::Some(v);
    }

    // optional string continue = 8;


    pub fn get_field_continue(&self) -> &str {
        match self.field_continue.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_field_continue(&mut self) {
        self.field_continue.clear();
    }

    pub fn has_field_continue(&self) -> bool {
        self.field_continue.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_continue(&mut self, v: ::std::string::String) {
        self.field_continue = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_continue(&mut self) -> &mut ::std::string::String {
        if self.field_continue.is_none() {
            self.field_continue.set_default();
        }
        self.field_continue.as_mut().unwrap()
    }

    // Take field
    pub fn take_field_continue(&mut self) -> ::std::string::String {
        self.field_continue.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for ListOptions {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.labelSelector)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.fieldSelector)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.watch = ::std::option::Option::Some(tmp);
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.allowWatchBookmarks = ::std::option::Option::Some(tmp);
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.resourceVersion)?;
                },
                10 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.resourceVersionMatch)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.timeoutSeconds = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.limit = ::std::option::Option::Some(tmp);
                },
                8 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.field_continue)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.labelSelector.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.fieldSelector.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(v) = self.watch {
            my_size += 2;
        }
        if let Some(v) = self.allowWatchBookmarks {
            my_size += 2;
        }
        if let Some(ref v) = self.resourceVersion.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.resourceVersionMatch.as_ref() {
            my_size += ::protobuf::rt::string_size(10, &v);
        }
        if let Some(v) = self.timeoutSeconds {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.limit {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.field_continue.as_ref() {
            my_size += ::protobuf::rt::string_size(8, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.labelSelector.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.fieldSelector.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(v) = self.watch {
            os.write_bool(3, v)?;
        }
        if let Some(v) = self.allowWatchBookmarks {
            os.write_bool(9, v)?;
        }
        if let Some(ref v) = self.resourceVersion.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.resourceVersionMatch.as_ref() {
            os.write_string(10, &v)?;
        }
        if let Some(v) = self.timeoutSeconds {
            os.write_int64(5, v)?;
        }
        if let Some(v) = self.limit {
            os.write_int64(7, v)?;
        }
        if let Some(ref v) = self.field_continue.as_ref() {
            os.write_string(8, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ListOptions {
        ListOptions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "labelSelector",
                |m: &ListOptions| { &m.labelSelector },
                |m: &mut ListOptions| { &mut m.labelSelector },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "fieldSelector",
                |m: &ListOptions| { &m.fieldSelector },
                |m: &mut ListOptions| { &mut m.fieldSelector },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "watch",
                |m: &ListOptions| { &m.watch },
                |m: &mut ListOptions| { &mut m.watch },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "allowWatchBookmarks",
                |m: &ListOptions| { &m.allowWatchBookmarks },
                |m: &mut ListOptions| { &mut m.allowWatchBookmarks },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "resourceVersion",
                |m: &ListOptions| { &m.resourceVersion },
                |m: &mut ListOptions| { &mut m.resourceVersion },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "resourceVersionMatch",
                |m: &ListOptions| { &m.resourceVersionMatch },
                |m: &mut ListOptions| { &mut m.resourceVersionMatch },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "timeoutSeconds",
                |m: &ListOptions| { &m.timeoutSeconds },
                |m: &mut ListOptions| { &mut m.timeoutSeconds },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "limit",
                |m: &ListOptions| { &m.limit },
                |m: &mut ListOptions| { &mut m.limit },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "continue",
                |m: &ListOptions| { &m.field_continue },
                |m: &mut ListOptions| { &mut m.field_continue },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ListOptions>(
                "ListOptions",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ListOptions {
        static instance: ::protobuf::rt::LazyV2<ListOptions> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ListOptions::new)
    }
}

impl ::protobuf::Clear for ListOptions {
    fn clear(&mut self) {
        self.labelSelector.clear();
        self.fieldSelector.clear();
        self.watch = ::std::option::Option::None;
        self.allowWatchBookmarks = ::std::option::Option::None;
        self.resourceVersion.clear();
        self.resourceVersionMatch.clear();
        self.timeoutSeconds = ::std::option::Option::None;
        self.limit = ::std::option::Option::None;
        self.field_continue.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ListOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ManagedFieldsEntry {
    // message fields
    manager: ::protobuf::SingularField<::std::string::String>,
    operation: ::protobuf::SingularField<::std::string::String>,
    apiVersion: ::protobuf::SingularField<::std::string::String>,
    pub time: ::protobuf::SingularPtrField<Time>,
    fieldsType: ::protobuf::SingularField<::std::string::String>,
    pub fieldsV1: ::protobuf::SingularPtrField<FieldsV1>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ManagedFieldsEntry {
    fn default() -> &'a ManagedFieldsEntry {
        <ManagedFieldsEntry as ::protobuf::Message>::default_instance()
    }
}

impl ManagedFieldsEntry {
    pub fn new() -> ManagedFieldsEntry {
        ::std::default::Default::default()
    }

    // optional string manager = 1;


    pub fn get_manager(&self) -> &str {
        match self.manager.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_manager(&mut self) {
        self.manager.clear();
    }

    pub fn has_manager(&self) -> bool {
        self.manager.is_some()
    }

    // Param is passed by value, moved
    pub fn set_manager(&mut self, v: ::std::string::String) {
        self.manager = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_manager(&mut self) -> &mut ::std::string::String {
        if self.manager.is_none() {
            self.manager.set_default();
        }
        self.manager.as_mut().unwrap()
    }

    // Take field
    pub fn take_manager(&mut self) -> ::std::string::String {
        self.manager.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string operation = 2;


    pub fn get_operation(&self) -> &str {
        match self.operation.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_operation(&mut self) {
        self.operation.clear();
    }

    pub fn has_operation(&self) -> bool {
        self.operation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_operation(&mut self, v: ::std::string::String) {
        self.operation = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_operation(&mut self) -> &mut ::std::string::String {
        if self.operation.is_none() {
            self.operation.set_default();
        }
        self.operation.as_mut().unwrap()
    }

    // Take field
    pub fn take_operation(&mut self) -> ::std::string::String {
        self.operation.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string apiVersion = 3;


    pub fn get_apiVersion(&self) -> &str {
        match self.apiVersion.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_apiVersion(&mut self) {
        self.apiVersion.clear();
    }

    pub fn has_apiVersion(&self) -> bool {
        self.apiVersion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_apiVersion(&mut self, v: ::std::string::String) {
        self.apiVersion = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_apiVersion(&mut self) -> &mut ::std::string::String {
        if self.apiVersion.is_none() {
            self.apiVersion.set_default();
        }
        self.apiVersion.as_mut().unwrap()
    }

    // Take field
    pub fn take_apiVersion(&mut self) -> ::std::string::String {
        self.apiVersion.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time time = 4;


    pub fn get_time(&self) -> &Time {
        self.time.as_ref().unwrap_or_else(|| <Time as ::protobuf::Message>::default_instance())
    }
    pub fn clear_time(&mut self) {
        self.time.clear();
    }

    pub fn has_time(&self) -> bool {
        self.time.is_some()
    }

    // Param is passed by value, moved
    pub fn set_time(&mut self, v: Time) {
        self.time = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_time(&mut self) -> &mut Time {
        if self.time.is_none() {
            self.time.set_default();
        }
        self.time.as_mut().unwrap()
    }

    // Take field
    pub fn take_time(&mut self) -> Time {
        self.time.take().unwrap_or_else(|| Time::new())
    }

    // optional string fieldsType = 6;


    pub fn get_fieldsType(&self) -> &str {
        match self.fieldsType.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_fieldsType(&mut self) {
        self.fieldsType.clear();
    }

    pub fn has_fieldsType(&self) -> bool {
        self.fieldsType.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fieldsType(&mut self, v: ::std::string::String) {
        self.fieldsType = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fieldsType(&mut self) -> &mut ::std::string::String {
        if self.fieldsType.is_none() {
            self.fieldsType.set_default();
        }
        self.fieldsType.as_mut().unwrap()
    }

    // Take field
    pub fn take_fieldsType(&mut self) -> ::std::string::String {
        self.fieldsType.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.FieldsV1 fieldsV1 = 7;


    pub fn get_fieldsV1(&self) -> &FieldsV1 {
        self.fieldsV1.as_ref().unwrap_or_else(|| <FieldsV1 as ::protobuf::Message>::default_instance())
    }
    pub fn clear_fieldsV1(&mut self) {
        self.fieldsV1.clear();
    }

    pub fn has_fieldsV1(&self) -> bool {
        self.fieldsV1.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fieldsV1(&mut self, v: FieldsV1) {
        self.fieldsV1 = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fieldsV1(&mut self) -> &mut FieldsV1 {
        if self.fieldsV1.is_none() {
            self.fieldsV1.set_default();
        }
        self.fieldsV1.as_mut().unwrap()
    }

    // Take field
    pub fn take_fieldsV1(&mut self) -> FieldsV1 {
        self.fieldsV1.take().unwrap_or_else(|| FieldsV1::new())
    }
}

impl ::protobuf::Message for ManagedFieldsEntry {
    fn is_initialized(&self) -> bool {
        for v in &self.time {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.fieldsV1 {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.manager)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.operation)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.apiVersion)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.time)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.fieldsType)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.fieldsV1)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.manager.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.operation.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.apiVersion.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.time.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.fieldsType.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(ref v) = self.fieldsV1.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.manager.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.operation.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.apiVersion.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.time.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.fieldsType.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(ref v) = self.fieldsV1.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ManagedFieldsEntry {
        ManagedFieldsEntry::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "manager",
                |m: &ManagedFieldsEntry| { &m.manager },
                |m: &mut ManagedFieldsEntry| { &mut m.manager },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "operation",
                |m: &ManagedFieldsEntry| { &m.operation },
                |m: &mut ManagedFieldsEntry| { &mut m.operation },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "apiVersion",
                |m: &ManagedFieldsEntry| { &m.apiVersion },
                |m: &mut ManagedFieldsEntry| { &mut m.apiVersion },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Time>>(
                "time",
                |m: &ManagedFieldsEntry| { &m.time },
                |m: &mut ManagedFieldsEntry| { &mut m.time },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "fieldsType",
                |m: &ManagedFieldsEntry| { &m.fieldsType },
                |m: &mut ManagedFieldsEntry| { &mut m.fieldsType },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<FieldsV1>>(
                "fieldsV1",
                |m: &ManagedFieldsEntry| { &m.fieldsV1 },
                |m: &mut ManagedFieldsEntry| { &mut m.fieldsV1 },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ManagedFieldsEntry>(
                "ManagedFieldsEntry",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ManagedFieldsEntry {
        static instance: ::protobuf::rt::LazyV2<ManagedFieldsEntry> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ManagedFieldsEntry::new)
    }
}

impl ::protobuf::Clear for ManagedFieldsEntry {
    fn clear(&mut self) {
        self.manager.clear();
        self.operation.clear();
        self.apiVersion.clear();
        self.time.clear();
        self.fieldsType.clear();
        self.fieldsV1.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ManagedFieldsEntry {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ManagedFieldsEntry {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct MicroTime {
    // message fields
    seconds: ::std::option::Option<i64>,
    nanos: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a MicroTime {
    fn default() -> &'a MicroTime {
        <MicroTime as ::protobuf::Message>::default_instance()
    }
}

impl MicroTime {
    pub fn new() -> MicroTime {
        ::std::default::Default::default()
    }

    // optional int64 seconds = 1;


    pub fn get_seconds(&self) -> i64 {
        self.seconds.unwrap_or(0)
    }
    pub fn clear_seconds(&mut self) {
        self.seconds = ::std::option::Option::None;
    }

    pub fn has_seconds(&self) -> bool {
        self.seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seconds(&mut self, v: i64) {
        self.seconds = ::std::option::Option::Some(v);
    }

    // optional int32 nanos = 2;


    pub fn get_nanos(&self) -> i32 {
        self.nanos.unwrap_or(0)
    }
    pub fn clear_nanos(&mut self) {
        self.nanos = ::std::option::Option::None;
    }

    pub fn has_nanos(&self) -> bool {
        self.nanos.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nanos(&mut self, v: i32) {
        self.nanos = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for MicroTime {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.seconds = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.nanos = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.seconds {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.nanos {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.seconds {
            os.write_int64(1, v)?;
        }
        if let Some(v) = self.nanos {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> MicroTime {
        MicroTime::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "seconds",
                |m: &MicroTime| { &m.seconds },
                |m: &mut MicroTime| { &mut m.seconds },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "nanos",
                |m: &MicroTime| { &m.nanos },
                |m: &mut MicroTime| { &mut m.nanos },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<MicroTime>(
                "MicroTime",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static MicroTime {
        static instance: ::protobuf::rt::LazyV2<MicroTime> = ::protobuf::rt::LazyV2::INIT;
        instance.get(MicroTime::new)
    }
}

impl ::protobuf::Clear for MicroTime {
    fn clear(&mut self) {
        self.seconds = ::std::option::Option::None;
        self.nanos = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for MicroTime {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MicroTime {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ObjectMeta {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    generateName: ::protobuf::SingularField<::std::string::String>,
    namespace: ::protobuf::SingularField<::std::string::String>,
    selfLink: ::protobuf::SingularField<::std::string::String>,
    uid: ::protobuf::SingularField<::std::string::String>,
    resourceVersion: ::protobuf::SingularField<::std::string::String>,
    generation: ::std::option::Option<i64>,
    pub creationTimestamp: ::protobuf::SingularPtrField<Time>,
    pub deletionTimestamp: ::protobuf::SingularPtrField<Time>,
    deletionGracePeriodSeconds: ::std::option::Option<i64>,
    pub labels: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    pub annotations: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    pub ownerReferences: ::protobuf::RepeatedField<OwnerReference>,
    pub finalizers: ::protobuf::RepeatedField<::std::string::String>,
    clusterName: ::protobuf::SingularField<::std::string::String>,
    pub managedFields: ::protobuf::RepeatedField<ManagedFieldsEntry>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ObjectMeta {
    fn default() -> &'a ObjectMeta {
        <ObjectMeta as ::protobuf::Message>::default_instance()
    }
}

impl ObjectMeta {
    pub fn new() -> ObjectMeta {
        ::std::default::Default::default()
    }

    // optional string name = 1;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string generateName = 2;


    pub fn get_generateName(&self) -> &str {
        match self.generateName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_generateName(&mut self) {
        self.generateName.clear();
    }

    pub fn has_generateName(&self) -> bool {
        self.generateName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_generateName(&mut self, v: ::std::string::String) {
        self.generateName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_generateName(&mut self) -> &mut ::std::string::String {
        if self.generateName.is_none() {
            self.generateName.set_default();
        }
        self.generateName.as_mut().unwrap()
    }

    // Take field
    pub fn take_generateName(&mut self) -> ::std::string::String {
        self.generateName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string namespace = 3;


    pub fn get_namespace(&self) -> &str {
        match self.namespace.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_namespace(&mut self) {
        self.namespace.clear();
    }

    pub fn has_namespace(&self) -> bool {
        self.namespace.is_some()
    }

    // Param is passed by value, moved
    pub fn set_namespace(&mut self, v: ::std::string::String) {
        self.namespace = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_namespace(&mut self) -> &mut ::std::string::String {
        if self.namespace.is_none() {
            self.namespace.set_default();
        }
        self.namespace.as_mut().unwrap()
    }

    // Take field
    pub fn take_namespace(&mut self) -> ::std::string::String {
        self.namespace.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string selfLink = 4;


    pub fn get_selfLink(&self) -> &str {
        match self.selfLink.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_selfLink(&mut self) {
        self.selfLink.clear();
    }

    pub fn has_selfLink(&self) -> bool {
        self.selfLink.is_some()
    }

    // Param is passed by value, moved
    pub fn set_selfLink(&mut self, v: ::std::string::String) {
        self.selfLink = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_selfLink(&mut self) -> &mut ::std::string::String {
        if self.selfLink.is_none() {
            self.selfLink.set_default();
        }
        self.selfLink.as_mut().unwrap()
    }

    // Take field
    pub fn take_selfLink(&mut self) -> ::std::string::String {
        self.selfLink.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string uid = 5;


    pub fn get_uid(&self) -> &str {
        match self.uid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_uid(&mut self) {
        self.uid.clear();
    }

    pub fn has_uid(&self) -> bool {
        self.uid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_uid(&mut self, v: ::std::string::String) {
        self.uid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uid(&mut self) -> &mut ::std::string::String {
        if self.uid.is_none() {
            self.uid.set_default();
        }
        self.uid.as_mut().unwrap()
    }

    // Take field
    pub fn take_uid(&mut self) -> ::std::string::String {
        self.uid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string resourceVersion = 6;


    pub fn get_resourceVersion(&self) -> &str {
        match self.resourceVersion.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_resourceVersion(&mut self) {
        self.resourceVersion.clear();
    }

    pub fn has_resourceVersion(&self) -> bool {
        self.resourceVersion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resourceVersion(&mut self, v: ::std::string::String) {
        self.resourceVersion = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_resourceVersion(&mut self) -> &mut ::std::string::String {
        if self.resourceVersion.is_none() {
            self.resourceVersion.set_default();
        }
        self.resourceVersion.as_mut().unwrap()
    }

    // Take field
    pub fn take_resourceVersion(&mut self) -> ::std::string::String {
        self.resourceVersion.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional int64 generation = 7;


    pub fn get_generation(&self) -> i64 {
        self.generation.unwrap_or(0)
    }
    pub fn clear_generation(&mut self) {
        self.generation = ::std::option::Option::None;
    }

    pub fn has_generation(&self) -> bool {
        self.generation.is_some()
    }

    // Param is passed by value, moved
    pub fn set_generation(&mut self, v: i64) {
        self.generation = ::std::option::Option::Some(v);
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time creationTimestamp = 8;


    pub fn get_creationTimestamp(&self) -> &Time {
        self.creationTimestamp.as_ref().unwrap_or_else(|| <Time as ::protobuf::Message>::default_instance())
    }
    pub fn clear_creationTimestamp(&mut self) {
        self.creationTimestamp.clear();
    }

    pub fn has_creationTimestamp(&self) -> bool {
        self.creationTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_creationTimestamp(&mut self, v: Time) {
        self.creationTimestamp = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_creationTimestamp(&mut self) -> &mut Time {
        if self.creationTimestamp.is_none() {
            self.creationTimestamp.set_default();
        }
        self.creationTimestamp.as_mut().unwrap()
    }

    // Take field
    pub fn take_creationTimestamp(&mut self) -> Time {
        self.creationTimestamp.take().unwrap_or_else(|| Time::new())
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.Time deletionTimestamp = 9;


    pub fn get_deletionTimestamp(&self) -> &Time {
        self.deletionTimestamp.as_ref().unwrap_or_else(|| <Time as ::protobuf::Message>::default_instance())
    }
    pub fn clear_deletionTimestamp(&mut self) {
        self.deletionTimestamp.clear();
    }

    pub fn has_deletionTimestamp(&self) -> bool {
        self.deletionTimestamp.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deletionTimestamp(&mut self, v: Time) {
        self.deletionTimestamp = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_deletionTimestamp(&mut self) -> &mut Time {
        if self.deletionTimestamp.is_none() {
            self.deletionTimestamp.set_default();
        }
        self.deletionTimestamp.as_mut().unwrap()
    }

    // Take field
    pub fn take_deletionTimestamp(&mut self) -> Time {
        self.deletionTimestamp.take().unwrap_or_else(|| Time::new())
    }

    // optional int64 deletionGracePeriodSeconds = 10;


    pub fn get_deletionGracePeriodSeconds(&self) -> i64 {
        self.deletionGracePeriodSeconds.unwrap_or(0)
    }
    pub fn clear_deletionGracePeriodSeconds(&mut self) {
        self.deletionGracePeriodSeconds = ::std::option::Option::None;
    }

    pub fn has_deletionGracePeriodSeconds(&self) -> bool {
        self.deletionGracePeriodSeconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_deletionGracePeriodSeconds(&mut self, v: i64) {
        self.deletionGracePeriodSeconds = ::std::option::Option::Some(v);
    }

    // repeated .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta.LabelsEntry labels = 11;


    pub fn get_labels(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.labels
    }
    pub fn clear_labels(&mut self) {
        self.labels.clear();
    }

    // Param is passed by value, moved
    pub fn set_labels(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.labels = v;
    }

    // Mutable pointer to the field.
    pub fn mut_labels(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.labels
    }

    // Take field
    pub fn take_labels(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.labels, ::std::collections::HashMap::new())
    }

    // repeated .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta.AnnotationsEntry annotations = 12;


    pub fn get_annotations(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.annotations
    }
    pub fn clear_annotations(&mut self) {
        self.annotations.clear();
    }

    // Param is passed by value, moved
    pub fn set_annotations(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.annotations = v;
    }

    // Mutable pointer to the field.
    pub fn mut_annotations(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.annotations
    }

    // Take field
    pub fn take_annotations(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.annotations, ::std::collections::HashMap::new())
    }

    // repeated .k8s.io.apimachinery.pkg.apis.meta.v1.OwnerReference ownerReferences = 13;


    pub fn get_ownerReferences(&self) -> &[OwnerReference] {
        &self.ownerReferences
    }
    pub fn clear_ownerReferences(&mut self) {
        self.ownerReferences.clear();
    }

    // Param is passed by value, moved
    pub fn set_ownerReferences(&mut self, v: ::protobuf::RepeatedField<OwnerReference>) {
        self.ownerReferences = v;
    }

    // Mutable pointer to the field.
    pub fn mut_ownerReferences(&mut self) -> &mut ::protobuf::RepeatedField<OwnerReference> {
        &mut self.ownerReferences
    }

    // Take field
    pub fn take_ownerReferences(&mut self) -> ::protobuf::RepeatedField<OwnerReference> {
        ::std::mem::replace(&mut self.ownerReferences, ::protobuf::RepeatedField::new())
    }

    // repeated string finalizers = 14;


    pub fn get_finalizers(&self) -> &[::std::string::String] {
        &self.finalizers
    }
    pub fn clear_finalizers(&mut self) {
        self.finalizers.clear();
    }

    // Param is passed by value, moved
    pub fn set_finalizers(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.finalizers = v;
    }

    // Mutable pointer to the field.
    pub fn mut_finalizers(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.finalizers
    }

    // Take field
    pub fn take_finalizers(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.finalizers, ::protobuf::RepeatedField::new())
    }

    // optional string clusterName = 15;


    pub fn get_clusterName(&self) -> &str {
        match self.clusterName.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_clusterName(&mut self) {
        self.clusterName.clear();
    }

    pub fn has_clusterName(&self) -> bool {
        self.clusterName.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clusterName(&mut self, v: ::std::string::String) {
        self.clusterName = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_clusterName(&mut self) -> &mut ::std::string::String {
        if self.clusterName.is_none() {
            self.clusterName.set_default();
        }
        self.clusterName.as_mut().unwrap()
    }

    // Take field
    pub fn take_clusterName(&mut self) -> ::std::string::String {
        self.clusterName.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .k8s.io.apimachinery.pkg.apis.meta.v1.ManagedFieldsEntry managedFields = 17;


    pub fn get_managedFields(&self) -> &[ManagedFieldsEntry] {
        &self.managedFields
    }
    pub fn clear_managedFields(&mut self) {
        self.managedFields.clear();
    }

    // Param is passed by value, moved
    pub fn set_managedFields(&mut self, v: ::protobuf::RepeatedField<ManagedFieldsEntry>) {
        self.managedFields = v;
    }

    // Mutable pointer to the field.
    pub fn mut_managedFields(&mut self) -> &mut ::protobuf::RepeatedField<ManagedFieldsEntry> {
        &mut self.managedFields
    }

    // Take field
    pub fn take_managedFields(&mut self) -> ::protobuf::RepeatedField<ManagedFieldsEntry> {
        ::std::mem::replace(&mut self.managedFields, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for ObjectMeta {
    fn is_initialized(&self) -> bool {
        for v in &self.creationTimestamp {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.deletionTimestamp {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.ownerReferences {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.managedFields {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.generateName)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.namespace)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.selfLink)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.uid)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.resourceVersion)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.generation = ::std::option::Option::Some(tmp);
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.creationTimestamp)?;
                },
                9 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.deletionTimestamp)?;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.deletionGracePeriodSeconds = ::std::option::Option::Some(tmp);
                },
                11 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.labels)?;
                },
                12 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.annotations)?;
                },
                13 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.ownerReferences)?;
                },
                14 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.finalizers)?;
                },
                15 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.clusterName)?;
                },
                17 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.managedFields)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.generateName.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.namespace.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.selfLink.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.uid.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.resourceVersion.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        if let Some(v) = self.generation {
            my_size += ::protobuf::rt::value_size(7, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.creationTimestamp.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.deletionTimestamp.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.deletionGracePeriodSeconds {
            my_size += ::protobuf::rt::value_size(10, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(11, &self.labels);
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(12, &self.annotations);
        for value in &self.ownerReferences {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.finalizers {
            my_size += ::protobuf::rt::string_size(14, &value);
        };
        if let Some(ref v) = self.clusterName.as_ref() {
            my_size += ::protobuf::rt::string_size(15, &v);
        }
        for value in &self.managedFields {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.generateName.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.namespace.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.selfLink.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.uid.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.resourceVersion.as_ref() {
            os.write_string(6, &v)?;
        }
        if let Some(v) = self.generation {
            os.write_int64(7, v)?;
        }
        if let Some(ref v) = self.creationTimestamp.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.deletionTimestamp.as_ref() {
            os.write_tag(9, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.deletionGracePeriodSeconds {
            os.write_int64(10, v)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(11, &self.labels, os)?;
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(12, &self.annotations, os)?;
        for v in &self.ownerReferences {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.finalizers {
            os.write_string(14, &v)?;
        };
        if let Some(ref v) = self.clusterName.as_ref() {
            os.write_string(15, &v)?;
        }
        for v in &self.managedFields {
            os.write_tag(17, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ObjectMeta {
        ObjectMeta::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &ObjectMeta| { &m.name },
                |m: &mut ObjectMeta| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "generateName",
                |m: &ObjectMeta| { &m.generateName },
                |m: &mut ObjectMeta| { &mut m.generateName },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "namespace",
                |m: &ObjectMeta| { &m.namespace },
                |m: &mut ObjectMeta| { &mut m.namespace },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "selfLink",
                |m: &ObjectMeta| { &m.selfLink },
                |m: &mut ObjectMeta| { &mut m.selfLink },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "uid",
                |m: &ObjectMeta| { &m.uid },
                |m: &mut ObjectMeta| { &mut m.uid },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "resourceVersion",
                |m: &ObjectMeta| { &m.resourceVersion },
                |m: &mut ObjectMeta| { &mut m.resourceVersion },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "generation",
                |m: &ObjectMeta| { &m.generation },
                |m: &mut ObjectMeta| { &mut m.generation },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Time>>(
                "creationTimestamp",
                |m: &ObjectMeta| { &m.creationTimestamp },
                |m: &mut ObjectMeta| { &mut m.creationTimestamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Time>>(
                "deletionTimestamp",
                |m: &ObjectMeta| { &m.deletionTimestamp },
                |m: &mut ObjectMeta| { &mut m.deletionTimestamp },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "deletionGracePeriodSeconds",
                |m: &ObjectMeta| { &m.deletionGracePeriodSeconds },
                |m: &mut ObjectMeta| { &mut m.deletionGracePeriodSeconds },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                "labels",
                |m: &ObjectMeta| { &m.labels },
                |m: &mut ObjectMeta| { &mut m.labels },
            ));
            fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                "annotations",
                |m: &ObjectMeta| { &m.annotations },
                |m: &mut ObjectMeta| { &mut m.annotations },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<OwnerReference>>(
                "ownerReferences",
                |m: &ObjectMeta| { &m.ownerReferences },
                |m: &mut ObjectMeta| { &mut m.ownerReferences },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "finalizers",
                |m: &ObjectMeta| { &m.finalizers },
                |m: &mut ObjectMeta| { &mut m.finalizers },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "clusterName",
                |m: &ObjectMeta| { &m.clusterName },
                |m: &mut ObjectMeta| { &mut m.clusterName },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ManagedFieldsEntry>>(
                "managedFields",
                |m: &ObjectMeta| { &m.managedFields },
                |m: &mut ObjectMeta| { &mut m.managedFields },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ObjectMeta>(
                "ObjectMeta",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ObjectMeta {
        static instance: ::protobuf::rt::LazyV2<ObjectMeta> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ObjectMeta::new)
    }
}

impl ::protobuf::Clear for ObjectMeta {
    fn clear(&mut self) {
        self.name.clear();
        self.generateName.clear();
        self.namespace.clear();
        self.selfLink.clear();
        self.uid.clear();
        self.resourceVersion.clear();
        self.generation = ::std::option::Option::None;
        self.creationTimestamp.clear();
        self.deletionTimestamp.clear();
        self.deletionGracePeriodSeconds = ::std::option::Option::None;
        self.labels.clear();
        self.annotations.clear();
        self.ownerReferences.clear();
        self.finalizers.clear();
        self.clusterName.clear();
        self.managedFields.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ObjectMeta {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ObjectMeta {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct OwnerReference {
    // message fields
    apiVersion: ::protobuf::SingularField<::std::string::String>,
    kind: ::protobuf::SingularField<::std::string::String>,
    name: ::protobuf::SingularField<::std::string::String>,
    uid: ::protobuf::SingularField<::std::string::String>,
    controller: ::std::option::Option<bool>,
    blockOwnerDeletion: ::std::option::Option<bool>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a OwnerReference {
    fn default() -> &'a OwnerReference {
        <OwnerReference as ::protobuf::Message>::default_instance()
    }
}

impl OwnerReference {
    pub fn new() -> OwnerReference {
        ::std::default::Default::default()
    }

    // optional string apiVersion = 5;


    pub fn get_apiVersion(&self) -> &str {
        match self.apiVersion.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_apiVersion(&mut self) {
        self.apiVersion.clear();
    }

    pub fn has_apiVersion(&self) -> bool {
        self.apiVersion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_apiVersion(&mut self, v: ::std::string::String) {
        self.apiVersion = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_apiVersion(&mut self) -> &mut ::std::string::String {
        if self.apiVersion.is_none() {
            self.apiVersion.set_default();
        }
        self.apiVersion.as_mut().unwrap()
    }

    // Take field
    pub fn take_apiVersion(&mut self) -> ::std::string::String {
        self.apiVersion.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string kind = 1;


    pub fn get_kind(&self) -> &str {
        match self.kind.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_kind(&mut self) {
        self.kind.clear();
    }

    pub fn has_kind(&self) -> bool {
        self.kind.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kind(&mut self, v: ::std::string::String) {
        self.kind = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kind(&mut self) -> &mut ::std::string::String {
        if self.kind.is_none() {
            self.kind.set_default();
        }
        self.kind.as_mut().unwrap()
    }

    // Take field
    pub fn take_kind(&mut self) -> ::std::string::String {
        self.kind.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string name = 3;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string uid = 4;


    pub fn get_uid(&self) -> &str {
        match self.uid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_uid(&mut self) {
        self.uid.clear();
    }

    pub fn has_uid(&self) -> bool {
        self.uid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_uid(&mut self, v: ::std::string::String) {
        self.uid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uid(&mut self) -> &mut ::std::string::String {
        if self.uid.is_none() {
            self.uid.set_default();
        }
        self.uid.as_mut().unwrap()
    }

    // Take field
    pub fn take_uid(&mut self) -> ::std::string::String {
        self.uid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional bool controller = 6;


    pub fn get_controller(&self) -> bool {
        self.controller.unwrap_or(false)
    }
    pub fn clear_controller(&mut self) {
        self.controller = ::std::option::Option::None;
    }

    pub fn has_controller(&self) -> bool {
        self.controller.is_some()
    }

    // Param is passed by value, moved
    pub fn set_controller(&mut self, v: bool) {
        self.controller = ::std::option::Option::Some(v);
    }

    // optional bool blockOwnerDeletion = 7;


    pub fn get_blockOwnerDeletion(&self) -> bool {
        self.blockOwnerDeletion.unwrap_or(false)
    }
    pub fn clear_blockOwnerDeletion(&mut self) {
        self.blockOwnerDeletion = ::std::option::Option::None;
    }

    pub fn has_blockOwnerDeletion(&self) -> bool {
        self.blockOwnerDeletion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_blockOwnerDeletion(&mut self, v: bool) {
        self.blockOwnerDeletion = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for OwnerReference {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                5 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.apiVersion)?;
                },
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.kind)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.uid)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.controller = ::std::option::Option::Some(tmp);
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.blockOwnerDeletion = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.apiVersion.as_ref() {
            my_size += ::protobuf::rt::string_size(5, &v);
        }
        if let Some(ref v) = self.kind.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.uid.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(v) = self.controller {
            my_size += 2;
        }
        if let Some(v) = self.blockOwnerDeletion {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.apiVersion.as_ref() {
            os.write_string(5, &v)?;
        }
        if let Some(ref v) = self.kind.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.uid.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(v) = self.controller {
            os.write_bool(6, v)?;
        }
        if let Some(v) = self.blockOwnerDeletion {
            os.write_bool(7, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> OwnerReference {
        OwnerReference::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "apiVersion",
                |m: &OwnerReference| { &m.apiVersion },
                |m: &mut OwnerReference| { &mut m.apiVersion },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "kind",
                |m: &OwnerReference| { &m.kind },
                |m: &mut OwnerReference| { &mut m.kind },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &OwnerReference| { &m.name },
                |m: &mut OwnerReference| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "uid",
                |m: &OwnerReference| { &m.uid },
                |m: &mut OwnerReference| { &mut m.uid },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "controller",
                |m: &OwnerReference| { &m.controller },
                |m: &mut OwnerReference| { &mut m.controller },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "blockOwnerDeletion",
                |m: &OwnerReference| { &m.blockOwnerDeletion },
                |m: &mut OwnerReference| { &mut m.blockOwnerDeletion },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<OwnerReference>(
                "OwnerReference",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static OwnerReference {
        static instance: ::protobuf::rt::LazyV2<OwnerReference> = ::protobuf::rt::LazyV2::INIT;
        instance.get(OwnerReference::new)
    }
}

impl ::protobuf::Clear for OwnerReference {
    fn clear(&mut self) {
        self.apiVersion.clear();
        self.kind.clear();
        self.name.clear();
        self.uid.clear();
        self.controller = ::std::option::Option::None;
        self.blockOwnerDeletion = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for OwnerReference {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for OwnerReference {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PartialObjectMetadata {
    // message fields
    pub metadata: ::protobuf::SingularPtrField<ObjectMeta>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PartialObjectMetadata {
    fn default() -> &'a PartialObjectMetadata {
        <PartialObjectMetadata as ::protobuf::Message>::default_instance()
    }
}

impl PartialObjectMetadata {
    pub fn new() -> PartialObjectMetadata {
        ::std::default::Default::default()
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMeta metadata = 1;


    pub fn get_metadata(&self) -> &ObjectMeta {
        self.metadata.as_ref().unwrap_or_else(|| <ObjectMeta as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: ObjectMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut ObjectMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> ObjectMeta {
        self.metadata.take().unwrap_or_else(|| ObjectMeta::new())
    }
}

impl ::protobuf::Message for PartialObjectMetadata {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PartialObjectMetadata {
        PartialObjectMetadata::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ObjectMeta>>(
                "metadata",
                |m: &PartialObjectMetadata| { &m.metadata },
                |m: &mut PartialObjectMetadata| { &mut m.metadata },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PartialObjectMetadata>(
                "PartialObjectMetadata",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PartialObjectMetadata {
        static instance: ::protobuf::rt::LazyV2<PartialObjectMetadata> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PartialObjectMetadata::new)
    }
}

impl ::protobuf::Clear for PartialObjectMetadata {
    fn clear(&mut self) {
        self.metadata.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PartialObjectMetadata {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PartialObjectMetadata {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PartialObjectMetadataList {
    // message fields
    pub metadata: ::protobuf::SingularPtrField<ListMeta>,
    pub items: ::protobuf::RepeatedField<PartialObjectMetadata>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PartialObjectMetadataList {
    fn default() -> &'a PartialObjectMetadataList {
        <PartialObjectMetadataList as ::protobuf::Message>::default_instance()
    }
}

impl PartialObjectMetadataList {
    pub fn new() -> PartialObjectMetadataList {
        ::std::default::Default::default()
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;


    pub fn get_metadata(&self) -> &ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <ListMeta as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: ListMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut ListMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> ListMeta {
        self.metadata.take().unwrap_or_else(|| ListMeta::new())
    }

    // repeated .k8s.io.apimachinery.pkg.apis.meta.v1.PartialObjectMetadata items = 2;


    pub fn get_items(&self) -> &[PartialObjectMetadata] {
        &self.items
    }
    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::protobuf::RepeatedField<PartialObjectMetadata>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::protobuf::RepeatedField<PartialObjectMetadata> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::protobuf::RepeatedField<PartialObjectMetadata> {
        ::std::mem::replace(&mut self.items, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for PartialObjectMetadataList {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.items {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.items)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.items {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.items {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PartialObjectMetadataList {
        PartialObjectMetadataList::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ListMeta>>(
                "metadata",
                |m: &PartialObjectMetadataList| { &m.metadata },
                |m: &mut PartialObjectMetadataList| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PartialObjectMetadata>>(
                "items",
                |m: &PartialObjectMetadataList| { &m.items },
                |m: &mut PartialObjectMetadataList| { &mut m.items },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PartialObjectMetadataList>(
                "PartialObjectMetadataList",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PartialObjectMetadataList {
        static instance: ::protobuf::rt::LazyV2<PartialObjectMetadataList> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PartialObjectMetadataList::new)
    }
}

impl ::protobuf::Clear for PartialObjectMetadataList {
    fn clear(&mut self) {
        self.metadata.clear();
        self.items.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PartialObjectMetadataList {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PartialObjectMetadataList {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Patch {
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Patch {
    fn default() -> &'a Patch {
        <Patch as ::protobuf::Message>::default_instance()
    }
}

impl Patch {
    pub fn new() -> Patch {
        ::std::default::Default::default()
    }
}

impl ::protobuf::Message for Patch {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Patch {
        Patch::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let fields = ::std::vec::Vec::new();
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Patch>(
                "Patch",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Patch {
        static instance: ::protobuf::rt::LazyV2<Patch> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Patch::new)
    }
}

impl ::protobuf::Clear for Patch {
    fn clear(&mut self) {
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Patch {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Patch {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct PatchOptions {
    // message fields
    pub dryRun: ::protobuf::RepeatedField<::std::string::String>,
    force: ::std::option::Option<bool>,
    fieldManager: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PatchOptions {
    fn default() -> &'a PatchOptions {
        <PatchOptions as ::protobuf::Message>::default_instance()
    }
}

impl PatchOptions {
    pub fn new() -> PatchOptions {
        ::std::default::Default::default()
    }

    // repeated string dryRun = 1;


    pub fn get_dryRun(&self) -> &[::std::string::String] {
        &self.dryRun
    }
    pub fn clear_dryRun(&mut self) {
        self.dryRun.clear();
    }

    // Param is passed by value, moved
    pub fn set_dryRun(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.dryRun = v;
    }

    // Mutable pointer to the field.
    pub fn mut_dryRun(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.dryRun
    }

    // Take field
    pub fn take_dryRun(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.dryRun, ::protobuf::RepeatedField::new())
    }

    // optional bool force = 2;


    pub fn get_force(&self) -> bool {
        self.force.unwrap_or(false)
    }
    pub fn clear_force(&mut self) {
        self.force = ::std::option::Option::None;
    }

    pub fn has_force(&self) -> bool {
        self.force.is_some()
    }

    // Param is passed by value, moved
    pub fn set_force(&mut self, v: bool) {
        self.force = ::std::option::Option::Some(v);
    }

    // optional string fieldManager = 3;


    pub fn get_fieldManager(&self) -> &str {
        match self.fieldManager.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_fieldManager(&mut self) {
        self.fieldManager.clear();
    }

    pub fn has_fieldManager(&self) -> bool {
        self.fieldManager.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fieldManager(&mut self, v: ::std::string::String) {
        self.fieldManager = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fieldManager(&mut self) -> &mut ::std::string::String {
        if self.fieldManager.is_none() {
            self.fieldManager.set_default();
        }
        self.fieldManager.as_mut().unwrap()
    }

    // Take field
    pub fn take_fieldManager(&mut self) -> ::std::string::String {
        self.fieldManager.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for PatchOptions {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.dryRun)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.force = ::std::option::Option::Some(tmp);
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.fieldManager)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.dryRun {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if let Some(v) = self.force {
            my_size += 2;
        }
        if let Some(ref v) = self.fieldManager.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.dryRun {
            os.write_string(1, &v)?;
        };
        if let Some(v) = self.force {
            os.write_bool(2, v)?;
        }
        if let Some(ref v) = self.fieldManager.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PatchOptions {
        PatchOptions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "dryRun",
                |m: &PatchOptions| { &m.dryRun },
                |m: &mut PatchOptions| { &mut m.dryRun },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                "force",
                |m: &PatchOptions| { &m.force },
                |m: &mut PatchOptions| { &mut m.force },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "fieldManager",
                |m: &PatchOptions| { &m.fieldManager },
                |m: &mut PatchOptions| { &mut m.fieldManager },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<PatchOptions>(
                "PatchOptions",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static PatchOptions {
        static instance: ::protobuf::rt::LazyV2<PatchOptions> = ::protobuf::rt::LazyV2::INIT;
        instance.get(PatchOptions::new)
    }
}

impl ::protobuf::Clear for PatchOptions {
    fn clear(&mut self) {
        self.dryRun.clear();
        self.force = ::std::option::Option::None;
        self.fieldManager.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PatchOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PatchOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Preconditions {
    // message fields
    uid: ::protobuf::SingularField<::std::string::String>,
    resourceVersion: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Preconditions {
    fn default() -> &'a Preconditions {
        <Preconditions as ::protobuf::Message>::default_instance()
    }
}

impl Preconditions {
    pub fn new() -> Preconditions {
        ::std::default::Default::default()
    }

    // optional string uid = 1;


    pub fn get_uid(&self) -> &str {
        match self.uid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_uid(&mut self) {
        self.uid.clear();
    }

    pub fn has_uid(&self) -> bool {
        self.uid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_uid(&mut self, v: ::std::string::String) {
        self.uid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uid(&mut self) -> &mut ::std::string::String {
        if self.uid.is_none() {
            self.uid.set_default();
        }
        self.uid.as_mut().unwrap()
    }

    // Take field
    pub fn take_uid(&mut self) -> ::std::string::String {
        self.uid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string resourceVersion = 2;


    pub fn get_resourceVersion(&self) -> &str {
        match self.resourceVersion.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_resourceVersion(&mut self) {
        self.resourceVersion.clear();
    }

    pub fn has_resourceVersion(&self) -> bool {
        self.resourceVersion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_resourceVersion(&mut self, v: ::std::string::String) {
        self.resourceVersion = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_resourceVersion(&mut self) -> &mut ::std::string::String {
        if self.resourceVersion.is_none() {
            self.resourceVersion.set_default();
        }
        self.resourceVersion.as_mut().unwrap()
    }

    // Take field
    pub fn take_resourceVersion(&mut self) -> ::std::string::String {
        self.resourceVersion.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for Preconditions {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.uid)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.resourceVersion)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.uid.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.resourceVersion.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.uid.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.resourceVersion.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Preconditions {
        Preconditions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "uid",
                |m: &Preconditions| { &m.uid },
                |m: &mut Preconditions| { &mut m.uid },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "resourceVersion",
                |m: &Preconditions| { &m.resourceVersion },
                |m: &mut Preconditions| { &mut m.resourceVersion },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Preconditions>(
                "Preconditions",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Preconditions {
        static instance: ::protobuf::rt::LazyV2<Preconditions> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Preconditions::new)
    }
}

impl ::protobuf::Clear for Preconditions {
    fn clear(&mut self) {
        self.uid.clear();
        self.resourceVersion.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Preconditions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Preconditions {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct RootPaths {
    // message fields
    pub paths: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RootPaths {
    fn default() -> &'a RootPaths {
        <RootPaths as ::protobuf::Message>::default_instance()
    }
}

impl RootPaths {
    pub fn new() -> RootPaths {
        ::std::default::Default::default()
    }

    // repeated string paths = 1;


    pub fn get_paths(&self) -> &[::std::string::String] {
        &self.paths
    }
    pub fn clear_paths(&mut self) {
        self.paths.clear();
    }

    // Param is passed by value, moved
    pub fn set_paths(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.paths = v;
    }

    // Mutable pointer to the field.
    pub fn mut_paths(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.paths
    }

    // Take field
    pub fn take_paths(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.paths, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for RootPaths {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.paths)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.paths {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.paths {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RootPaths {
        RootPaths::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "paths",
                |m: &RootPaths| { &m.paths },
                |m: &mut RootPaths| { &mut m.paths },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<RootPaths>(
                "RootPaths",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static RootPaths {
        static instance: ::protobuf::rt::LazyV2<RootPaths> = ::protobuf::rt::LazyV2::INIT;
        instance.get(RootPaths::new)
    }
}

impl ::protobuf::Clear for RootPaths {
    fn clear(&mut self) {
        self.paths.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RootPaths {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RootPaths {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct ServerAddressByClientCIDR {
    // message fields
    clientCIDR: ::protobuf::SingularField<::std::string::String>,
    serverAddress: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ServerAddressByClientCIDR {
    fn default() -> &'a ServerAddressByClientCIDR {
        <ServerAddressByClientCIDR as ::protobuf::Message>::default_instance()
    }
}

impl ServerAddressByClientCIDR {
    pub fn new() -> ServerAddressByClientCIDR {
        ::std::default::Default::default()
    }

    // optional string clientCIDR = 1;


    pub fn get_clientCIDR(&self) -> &str {
        match self.clientCIDR.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_clientCIDR(&mut self) {
        self.clientCIDR.clear();
    }

    pub fn has_clientCIDR(&self) -> bool {
        self.clientCIDR.is_some()
    }

    // Param is passed by value, moved
    pub fn set_clientCIDR(&mut self, v: ::std::string::String) {
        self.clientCIDR = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_clientCIDR(&mut self) -> &mut ::std::string::String {
        if self.clientCIDR.is_none() {
            self.clientCIDR.set_default();
        }
        self.clientCIDR.as_mut().unwrap()
    }

    // Take field
    pub fn take_clientCIDR(&mut self) -> ::std::string::String {
        self.clientCIDR.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string serverAddress = 2;


    pub fn get_serverAddress(&self) -> &str {
        match self.serverAddress.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_serverAddress(&mut self) {
        self.serverAddress.clear();
    }

    pub fn has_serverAddress(&self) -> bool {
        self.serverAddress.is_some()
    }

    // Param is passed by value, moved
    pub fn set_serverAddress(&mut self, v: ::std::string::String) {
        self.serverAddress = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_serverAddress(&mut self) -> &mut ::std::string::String {
        if self.serverAddress.is_none() {
            self.serverAddress.set_default();
        }
        self.serverAddress.as_mut().unwrap()
    }

    // Take field
    pub fn take_serverAddress(&mut self) -> ::std::string::String {
        self.serverAddress.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for ServerAddressByClientCIDR {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.clientCIDR)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.serverAddress)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.clientCIDR.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.serverAddress.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.clientCIDR.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.serverAddress.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ServerAddressByClientCIDR {
        ServerAddressByClientCIDR::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "clientCIDR",
                |m: &ServerAddressByClientCIDR| { &m.clientCIDR },
                |m: &mut ServerAddressByClientCIDR| { &mut m.clientCIDR },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "serverAddress",
                |m: &ServerAddressByClientCIDR| { &m.serverAddress },
                |m: &mut ServerAddressByClientCIDR| { &mut m.serverAddress },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<ServerAddressByClientCIDR>(
                "ServerAddressByClientCIDR",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static ServerAddressByClientCIDR {
        static instance: ::protobuf::rt::LazyV2<ServerAddressByClientCIDR> = ::protobuf::rt::LazyV2::INIT;
        instance.get(ServerAddressByClientCIDR::new)
    }
}

impl ::protobuf::Clear for ServerAddressByClientCIDR {
    fn clear(&mut self) {
        self.clientCIDR.clear();
        self.serverAddress.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ServerAddressByClientCIDR {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ServerAddressByClientCIDR {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Status {
    // message fields
    pub metadata: ::protobuf::SingularPtrField<ListMeta>,
    status: ::protobuf::SingularField<::std::string::String>,
    message: ::protobuf::SingularField<::std::string::String>,
    reason: ::protobuf::SingularField<::std::string::String>,
    pub details: ::protobuf::SingularPtrField<StatusDetails>,
    code: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Status {
    fn default() -> &'a Status {
        <Status as ::protobuf::Message>::default_instance()
    }
}

impl Status {
    pub fn new() -> Status {
        ::std::default::Default::default()
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.ListMeta metadata = 1;


    pub fn get_metadata(&self) -> &ListMeta {
        self.metadata.as_ref().unwrap_or_else(|| <ListMeta as ::protobuf::Message>::default_instance())
    }
    pub fn clear_metadata(&mut self) {
        self.metadata.clear();
    }

    pub fn has_metadata(&self) -> bool {
        self.metadata.is_some()
    }

    // Param is passed by value, moved
    pub fn set_metadata(&mut self, v: ListMeta) {
        self.metadata = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_metadata(&mut self) -> &mut ListMeta {
        if self.metadata.is_none() {
            self.metadata.set_default();
        }
        self.metadata.as_mut().unwrap()
    }

    // Take field
    pub fn take_metadata(&mut self) -> ListMeta {
        self.metadata.take().unwrap_or_else(|| ListMeta::new())
    }

    // optional string status = 2;


    pub fn get_status(&self) -> &str {
        match self.status.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: ::std::string::String) {
        self.status = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut ::std::string::String {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> ::std::string::String {
        self.status.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string message = 3;


    pub fn get_message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string reason = 4;


    pub fn get_reason(&self) -> &str {
        match self.reason.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_reason(&mut self) {
        self.reason.clear();
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: ::std::string::String) {
        self.reason = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reason(&mut self) -> &mut ::std::string::String {
        if self.reason.is_none() {
            self.reason.set_default();
        }
        self.reason.as_mut().unwrap()
    }

    // Take field
    pub fn take_reason(&mut self) -> ::std::string::String {
        self.reason.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .k8s.io.apimachinery.pkg.apis.meta.v1.StatusDetails details = 5;


    pub fn get_details(&self) -> &StatusDetails {
        self.details.as_ref().unwrap_or_else(|| <StatusDetails as ::protobuf::Message>::default_instance())
    }
    pub fn clear_details(&mut self) {
        self.details.clear();
    }

    pub fn has_details(&self) -> bool {
        self.details.is_some()
    }

    // Param is passed by value, moved
    pub fn set_details(&mut self, v: StatusDetails) {
        self.details = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_details(&mut self) -> &mut StatusDetails {
        if self.details.is_none() {
            self.details.set_default();
        }
        self.details.as_mut().unwrap()
    }

    // Take field
    pub fn take_details(&mut self) -> StatusDetails {
        self.details.take().unwrap_or_else(|| StatusDetails::new())
    }

    // optional int32 code = 6;


    pub fn get_code(&self) -> i32 {
        self.code.unwrap_or(0)
    }
    pub fn clear_code(&mut self) {
        self.code = ::std::option::Option::None;
    }

    pub fn has_code(&self) -> bool {
        self.code.is_some()
    }

    // Param is passed by value, moved
    pub fn set_code(&mut self, v: i32) {
        self.code = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for Status {
    fn is_initialized(&self) -> bool {
        for v in &self.metadata {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.details {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.metadata)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.status)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.message)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.reason)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.details)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.code = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.metadata.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.status.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.reason.as_ref() {
            my_size += ::protobuf::rt::string_size(4, &v);
        }
        if let Some(ref v) = self.details.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(v) = self.code {
            my_size += ::protobuf::rt::value_size(6, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.metadata.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.status.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.message.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.reason.as_ref() {
            os.write_string(4, &v)?;
        }
        if let Some(ref v) = self.details.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(v) = self.code {
            os.write_int32(6, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Status {
        Status::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ListMeta>>(
                "metadata",
                |m: &Status| { &m.metadata },
                |m: &mut Status| { &mut m.metadata },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "status",
                |m: &Status| { &m.status },
                |m: &mut Status| { &mut m.status },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "message",
                |m: &Status| { &m.message },
                |m: &mut Status| { &mut m.message },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "reason",
                |m: &Status| { &m.reason },
                |m: &mut Status| { &mut m.reason },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StatusDetails>>(
                "details",
                |m: &Status| { &m.details },
                |m: &mut Status| { &mut m.details },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "code",
                |m: &Status| { &m.code },
                |m: &mut Status| { &mut m.code },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Status>(
                "Status",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Status {
        static instance: ::protobuf::rt::LazyV2<Status> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Status::new)
    }
}

impl ::protobuf::Clear for Status {
    fn clear(&mut self) {
        self.metadata.clear();
        self.status.clear();
        self.message.clear();
        self.reason.clear();
        self.details.clear();
        self.code = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Status {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Status {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StatusCause {
    // message fields
    reason: ::protobuf::SingularField<::std::string::String>,
    message: ::protobuf::SingularField<::std::string::String>,
    field: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StatusCause {
    fn default() -> &'a StatusCause {
        <StatusCause as ::protobuf::Message>::default_instance()
    }
}

impl StatusCause {
    pub fn new() -> StatusCause {
        ::std::default::Default::default()
    }

    // optional string reason = 1;


    pub fn get_reason(&self) -> &str {
        match self.reason.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_reason(&mut self) {
        self.reason.clear();
    }

    pub fn has_reason(&self) -> bool {
        self.reason.is_some()
    }

    // Param is passed by value, moved
    pub fn set_reason(&mut self, v: ::std::string::String) {
        self.reason = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_reason(&mut self) -> &mut ::std::string::String {
        if self.reason.is_none() {
            self.reason.set_default();
        }
        self.reason.as_mut().unwrap()
    }

    // Take field
    pub fn take_reason(&mut self) -> ::std::string::String {
        self.reason.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string message = 2;


    pub fn get_message(&self) -> &str {
        match self.message.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    pub fn has_message(&self) -> bool {
        self.message.is_some()
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        if self.message.is_none() {
            self.message.set_default();
        }
        self.message.as_mut().unwrap()
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        self.message.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string field = 3;


    pub fn get_field(&self) -> &str {
        match self.field.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_field(&mut self) {
        self.field.clear();
    }

    pub fn has_field(&self) -> bool {
        self.field.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field(&mut self, v: ::std::string::String) {
        self.field = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field(&mut self) -> &mut ::std::string::String {
        if self.field.is_none() {
            self.field.set_default();
        }
        self.field.as_mut().unwrap()
    }

    // Take field
    pub fn take_field(&mut self) -> ::std::string::String {
        self.field.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for StatusCause {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.reason)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.message)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.field)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.reason.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.message.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.field.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.reason.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.message.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.field.as_ref() {
            os.write_string(3, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StatusCause {
        StatusCause::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "reason",
                |m: &StatusCause| { &m.reason },
                |m: &mut StatusCause| { &mut m.reason },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "message",
                |m: &StatusCause| { &m.message },
                |m: &mut StatusCause| { &mut m.message },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "field",
                |m: &StatusCause| { &m.field },
                |m: &mut StatusCause| { &mut m.field },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StatusCause>(
                "StatusCause",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StatusCause {
        static instance: ::protobuf::rt::LazyV2<StatusCause> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StatusCause::new)
    }
}

impl ::protobuf::Clear for StatusCause {
    fn clear(&mut self) {
        self.reason.clear();
        self.message.clear();
        self.field.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StatusCause {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StatusCause {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct StatusDetails {
    // message fields
    name: ::protobuf::SingularField<::std::string::String>,
    group: ::protobuf::SingularField<::std::string::String>,
    kind: ::protobuf::SingularField<::std::string::String>,
    uid: ::protobuf::SingularField<::std::string::String>,
    pub causes: ::protobuf::RepeatedField<StatusCause>,
    retryAfterSeconds: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a StatusDetails {
    fn default() -> &'a StatusDetails {
        <StatusDetails as ::protobuf::Message>::default_instance()
    }
}

impl StatusDetails {
    pub fn new() -> StatusDetails {
        ::std::default::Default::default()
    }

    // optional string name = 1;


    pub fn get_name(&self) -> &str {
        match self.name.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    pub fn has_name(&self) -> bool {
        self.name.is_some()
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        if self.name.is_none() {
            self.name.set_default();
        }
        self.name.as_mut().unwrap()
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        self.name.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string group = 2;


    pub fn get_group(&self) -> &str {
        match self.group.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_group(&mut self) {
        self.group.clear();
    }

    pub fn has_group(&self) -> bool {
        self.group.is_some()
    }

    // Param is passed by value, moved
    pub fn set_group(&mut self, v: ::std::string::String) {
        self.group = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_group(&mut self) -> &mut ::std::string::String {
        if self.group.is_none() {
            self.group.set_default();
        }
        self.group.as_mut().unwrap()
    }

    // Take field
    pub fn take_group(&mut self) -> ::std::string::String {
        self.group.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string kind = 3;


    pub fn get_kind(&self) -> &str {
        match self.kind.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_kind(&mut self) {
        self.kind.clear();
    }

    pub fn has_kind(&self) -> bool {
        self.kind.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kind(&mut self, v: ::std::string::String) {
        self.kind = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kind(&mut self) -> &mut ::std::string::String {
        if self.kind.is_none() {
            self.kind.set_default();
        }
        self.kind.as_mut().unwrap()
    }

    // Take field
    pub fn take_kind(&mut self) -> ::std::string::String {
        self.kind.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string uid = 6;


    pub fn get_uid(&self) -> &str {
        match self.uid.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_uid(&mut self) {
        self.uid.clear();
    }

    pub fn has_uid(&self) -> bool {
        self.uid.is_some()
    }

    // Param is passed by value, moved
    pub fn set_uid(&mut self, v: ::std::string::String) {
        self.uid = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_uid(&mut self) -> &mut ::std::string::String {
        if self.uid.is_none() {
            self.uid.set_default();
        }
        self.uid.as_mut().unwrap()
    }

    // Take field
    pub fn take_uid(&mut self) -> ::std::string::String {
        self.uid.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // repeated .k8s.io.apimachinery.pkg.apis.meta.v1.StatusCause causes = 4;


    pub fn get_causes(&self) -> &[StatusCause] {
        &self.causes
    }
    pub fn clear_causes(&mut self) {
        self.causes.clear();
    }

    // Param is passed by value, moved
    pub fn set_causes(&mut self, v: ::protobuf::RepeatedField<StatusCause>) {
        self.causes = v;
    }

    // Mutable pointer to the field.
    pub fn mut_causes(&mut self) -> &mut ::protobuf::RepeatedField<StatusCause> {
        &mut self.causes
    }

    // Take field
    pub fn take_causes(&mut self) -> ::protobuf::RepeatedField<StatusCause> {
        ::std::mem::replace(&mut self.causes, ::protobuf::RepeatedField::new())
    }

    // optional int32 retryAfterSeconds = 5;


    pub fn get_retryAfterSeconds(&self) -> i32 {
        self.retryAfterSeconds.unwrap_or(0)
    }
    pub fn clear_retryAfterSeconds(&mut self) {
        self.retryAfterSeconds = ::std::option::Option::None;
    }

    pub fn has_retryAfterSeconds(&self) -> bool {
        self.retryAfterSeconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_retryAfterSeconds(&mut self, v: i32) {
        self.retryAfterSeconds = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for StatusDetails {
    fn is_initialized(&self) -> bool {
        for v in &self.causes {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.group)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.kind)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.uid)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.causes)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.retryAfterSeconds = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.name.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.group.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        if let Some(ref v) = self.kind.as_ref() {
            my_size += ::protobuf::rt::string_size(3, &v);
        }
        if let Some(ref v) = self.uid.as_ref() {
            my_size += ::protobuf::rt::string_size(6, &v);
        }
        for value in &self.causes {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(v) = self.retryAfterSeconds {
            my_size += ::protobuf::rt::value_size(5, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.name.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.group.as_ref() {
            os.write_string(2, &v)?;
        }
        if let Some(ref v) = self.kind.as_ref() {
            os.write_string(3, &v)?;
        }
        if let Some(ref v) = self.uid.as_ref() {
            os.write_string(6, &v)?;
        }
        for v in &self.causes {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(v) = self.retryAfterSeconds {
            os.write_int32(5, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> StatusDetails {
        StatusDetails::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "name",
                |m: &StatusDetails| { &m.name },
                |m: &mut StatusDetails| { &mut m.name },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "group",
                |m: &StatusDetails| { &m.group },
                |m: &mut StatusDetails| { &mut m.group },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "kind",
                |m: &StatusDetails| { &m.kind },
                |m: &mut StatusDetails| { &mut m.kind },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "uid",
                |m: &StatusDetails| { &m.uid },
                |m: &mut StatusDetails| { &mut m.uid },
            ));
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<StatusCause>>(
                "causes",
                |m: &StatusDetails| { &m.causes },
                |m: &mut StatusDetails| { &mut m.causes },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "retryAfterSeconds",
                |m: &StatusDetails| { &m.retryAfterSeconds },
                |m: &mut StatusDetails| { &mut m.retryAfterSeconds },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<StatusDetails>(
                "StatusDetails",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static StatusDetails {
        static instance: ::protobuf::rt::LazyV2<StatusDetails> = ::protobuf::rt::LazyV2::INIT;
        instance.get(StatusDetails::new)
    }
}

impl ::protobuf::Clear for StatusDetails {
    fn clear(&mut self) {
        self.name.clear();
        self.group.clear();
        self.kind.clear();
        self.uid.clear();
        self.causes.clear();
        self.retryAfterSeconds = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for StatusDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for StatusDetails {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TableOptions {
    // message fields
    includeObject: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TableOptions {
    fn default() -> &'a TableOptions {
        <TableOptions as ::protobuf::Message>::default_instance()
    }
}

impl TableOptions {
    pub fn new() -> TableOptions {
        ::std::default::Default::default()
    }

    // optional string includeObject = 1;


    pub fn get_includeObject(&self) -> &str {
        match self.includeObject.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_includeObject(&mut self) {
        self.includeObject.clear();
    }

    pub fn has_includeObject(&self) -> bool {
        self.includeObject.is_some()
    }

    // Param is passed by value, moved
    pub fn set_includeObject(&mut self, v: ::std::string::String) {
        self.includeObject = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_includeObject(&mut self) -> &mut ::std::string::String {
        if self.includeObject.is_none() {
            self.includeObject.set_default();
        }
        self.includeObject.as_mut().unwrap()
    }

    // Take field
    pub fn take_includeObject(&mut self) -> ::std::string::String {
        self.includeObject.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for TableOptions {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.includeObject)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.includeObject.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.includeObject.as_ref() {
            os.write_string(1, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TableOptions {
        TableOptions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "includeObject",
                |m: &TableOptions| { &m.includeObject },
                |m: &mut TableOptions| { &mut m.includeObject },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TableOptions>(
                "TableOptions",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TableOptions {
        static instance: ::protobuf::rt::LazyV2<TableOptions> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TableOptions::new)
    }
}

impl ::protobuf::Clear for TableOptions {
    fn clear(&mut self) {
        self.includeObject.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TableOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TableOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Time {
    // message fields
    seconds: ::std::option::Option<i64>,
    nanos: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Time {
    fn default() -> &'a Time {
        <Time as ::protobuf::Message>::default_instance()
    }
}

impl Time {
    pub fn new() -> Time {
        ::std::default::Default::default()
    }

    // optional int64 seconds = 1;


    pub fn get_seconds(&self) -> i64 {
        self.seconds.unwrap_or(0)
    }
    pub fn clear_seconds(&mut self) {
        self.seconds = ::std::option::Option::None;
    }

    pub fn has_seconds(&self) -> bool {
        self.seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seconds(&mut self, v: i64) {
        self.seconds = ::std::option::Option::Some(v);
    }

    // optional int32 nanos = 2;


    pub fn get_nanos(&self) -> i32 {
        self.nanos.unwrap_or(0)
    }
    pub fn clear_nanos(&mut self) {
        self.nanos = ::std::option::Option::None;
    }

    pub fn has_nanos(&self) -> bool {
        self.nanos.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nanos(&mut self, v: i32) {
        self.nanos = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for Time {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.seconds = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.nanos = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.seconds {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.nanos {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.seconds {
            os.write_int64(1, v)?;
        }
        if let Some(v) = self.nanos {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Time {
        Time::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "seconds",
                |m: &Time| { &m.seconds },
                |m: &mut Time| { &mut m.seconds },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "nanos",
                |m: &Time| { &m.nanos },
                |m: &mut Time| { &mut m.nanos },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Time>(
                "Time",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Time {
        static instance: ::protobuf::rt::LazyV2<Time> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Time::new)
    }
}

impl ::protobuf::Clear for Time {
    fn clear(&mut self) {
        self.seconds = ::std::option::Option::None;
        self.nanos = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Time {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Time {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Timestamp {
    // message fields
    seconds: ::std::option::Option<i64>,
    nanos: ::std::option::Option<i32>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Timestamp {
    fn default() -> &'a Timestamp {
        <Timestamp as ::protobuf::Message>::default_instance()
    }
}

impl Timestamp {
    pub fn new() -> Timestamp {
        ::std::default::Default::default()
    }

    // optional int64 seconds = 1;


    pub fn get_seconds(&self) -> i64 {
        self.seconds.unwrap_or(0)
    }
    pub fn clear_seconds(&mut self) {
        self.seconds = ::std::option::Option::None;
    }

    pub fn has_seconds(&self) -> bool {
        self.seconds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_seconds(&mut self, v: i64) {
        self.seconds = ::std::option::Option::Some(v);
    }

    // optional int32 nanos = 2;


    pub fn get_nanos(&self) -> i32 {
        self.nanos.unwrap_or(0)
    }
    pub fn clear_nanos(&mut self) {
        self.nanos = ::std::option::Option::None;
    }

    pub fn has_nanos(&self) -> bool {
        self.nanos.is_some()
    }

    // Param is passed by value, moved
    pub fn set_nanos(&mut self, v: i32) {
        self.nanos = ::std::option::Option::Some(v);
    }
}

impl ::protobuf::Message for Timestamp {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.seconds = ::std::option::Option::Some(tmp);
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.nanos = ::std::option::Option::Some(tmp);
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(v) = self.seconds {
            my_size += ::protobuf::rt::value_size(1, v, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(v) = self.nanos {
            my_size += ::protobuf::rt::value_size(2, v, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(v) = self.seconds {
            os.write_int64(1, v)?;
        }
        if let Some(v) = self.nanos {
            os.write_int32(2, v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Timestamp {
        Timestamp::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                "seconds",
                |m: &Timestamp| { &m.seconds },
                |m: &mut Timestamp| { &mut m.seconds },
            ));
            fields.push(::protobuf::reflect::accessor::make_option_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                "nanos",
                |m: &Timestamp| { &m.nanos },
                |m: &mut Timestamp| { &mut m.nanos },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Timestamp>(
                "Timestamp",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Timestamp {
        static instance: ::protobuf::rt::LazyV2<Timestamp> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Timestamp::new)
    }
}

impl ::protobuf::Clear for Timestamp {
    fn clear(&mut self) {
        self.seconds = ::std::option::Option::None;
        self.nanos = ::std::option::Option::None;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Timestamp {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Timestamp {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct TypeMeta {
    // message fields
    kind: ::protobuf::SingularField<::std::string::String>,
    apiVersion: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TypeMeta {
    fn default() -> &'a TypeMeta {
        <TypeMeta as ::protobuf::Message>::default_instance()
    }
}

impl TypeMeta {
    pub fn new() -> TypeMeta {
        ::std::default::Default::default()
    }

    // optional string kind = 1;


    pub fn get_kind(&self) -> &str {
        match self.kind.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_kind(&mut self) {
        self.kind.clear();
    }

    pub fn has_kind(&self) -> bool {
        self.kind.is_some()
    }

    // Param is passed by value, moved
    pub fn set_kind(&mut self, v: ::std::string::String) {
        self.kind = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_kind(&mut self) -> &mut ::std::string::String {
        if self.kind.is_none() {
            self.kind.set_default();
        }
        self.kind.as_mut().unwrap()
    }

    // Take field
    pub fn take_kind(&mut self) -> ::std::string::String {
        self.kind.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional string apiVersion = 2;


    pub fn get_apiVersion(&self) -> &str {
        match self.apiVersion.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_apiVersion(&mut self) {
        self.apiVersion.clear();
    }

    pub fn has_apiVersion(&self) -> bool {
        self.apiVersion.is_some()
    }

    // Param is passed by value, moved
    pub fn set_apiVersion(&mut self, v: ::std::string::String) {
        self.apiVersion = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_apiVersion(&mut self) -> &mut ::std::string::String {
        if self.apiVersion.is_none() {
            self.apiVersion.set_default();
        }
        self.apiVersion.as_mut().unwrap()
    }

    // Take field
    pub fn take_apiVersion(&mut self) -> ::std::string::String {
        self.apiVersion.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for TypeMeta {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.kind)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.apiVersion)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.kind.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.apiVersion.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.kind.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.apiVersion.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TypeMeta {
        TypeMeta::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "kind",
                |m: &TypeMeta| { &m.kind },
                |m: &mut TypeMeta| { &mut m.kind },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "apiVersion",
                |m: &TypeMeta| { &m.apiVersion },
                |m: &mut TypeMeta| { &mut m.apiVersion },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<TypeMeta>(
                "TypeMeta",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static TypeMeta {
        static instance: ::protobuf::rt::LazyV2<TypeMeta> = ::protobuf::rt::LazyV2::INIT;
        instance.get(TypeMeta::new)
    }
}

impl ::protobuf::Clear for TypeMeta {
    fn clear(&mut self) {
        self.kind.clear();
        self.apiVersion.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TypeMeta {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TypeMeta {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct UpdateOptions {
    // message fields
    pub dryRun: ::protobuf::RepeatedField<::std::string::String>,
    fieldManager: ::protobuf::SingularField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UpdateOptions {
    fn default() -> &'a UpdateOptions {
        <UpdateOptions as ::protobuf::Message>::default_instance()
    }
}

impl UpdateOptions {
    pub fn new() -> UpdateOptions {
        ::std::default::Default::default()
    }

    // repeated string dryRun = 1;


    pub fn get_dryRun(&self) -> &[::std::string::String] {
        &self.dryRun
    }
    pub fn clear_dryRun(&mut self) {
        self.dryRun.clear();
    }

    // Param is passed by value, moved
    pub fn set_dryRun(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.dryRun = v;
    }

    // Mutable pointer to the field.
    pub fn mut_dryRun(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.dryRun
    }

    // Take field
    pub fn take_dryRun(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.dryRun, ::protobuf::RepeatedField::new())
    }

    // optional string fieldManager = 2;


    pub fn get_fieldManager(&self) -> &str {
        match self.fieldManager.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_fieldManager(&mut self) {
        self.fieldManager.clear();
    }

    pub fn has_fieldManager(&self) -> bool {
        self.fieldManager.is_some()
    }

    // Param is passed by value, moved
    pub fn set_fieldManager(&mut self, v: ::std::string::String) {
        self.fieldManager = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_fieldManager(&mut self) -> &mut ::std::string::String {
        if self.fieldManager.is_none() {
            self.fieldManager.set_default();
        }
        self.fieldManager.as_mut().unwrap()
    }

    // Take field
    pub fn take_fieldManager(&mut self) -> ::std::string::String {
        self.fieldManager.take().unwrap_or_else(|| ::std::string::String::new())
    }
}

impl ::protobuf::Message for UpdateOptions {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.dryRun)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.fieldManager)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.dryRun {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        if let Some(ref v) = self.fieldManager.as_ref() {
            my_size += ::protobuf::rt::string_size(2, &v);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.dryRun {
            os.write_string(1, &v)?;
        };
        if let Some(ref v) = self.fieldManager.as_ref() {
            os.write_string(2, &v)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UpdateOptions {
        UpdateOptions::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "dryRun",
                |m: &UpdateOptions| { &m.dryRun },
                |m: &mut UpdateOptions| { &mut m.dryRun },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "fieldManager",
                |m: &UpdateOptions| { &m.fieldManager },
                |m: &mut UpdateOptions| { &mut m.fieldManager },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<UpdateOptions>(
                "UpdateOptions",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static UpdateOptions {
        static instance: ::protobuf::rt::LazyV2<UpdateOptions> = ::protobuf::rt::LazyV2::INIT;
        instance.get(UpdateOptions::new)
    }
}

impl ::protobuf::Clear for UpdateOptions {
    fn clear(&mut self) {
        self.dryRun.clear();
        self.fieldManager.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UpdateOptions {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateOptions {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct Verbs {
    // message fields
    pub items: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Verbs {
    fn default() -> &'a Verbs {
        <Verbs as ::protobuf::Message>::default_instance()
    }
}

impl Verbs {
    pub fn new() -> Verbs {
        ::std::default::Default::default()
    }

    // repeated string items = 1;


    pub fn get_items(&self) -> &[::std::string::String] {
        &self.items
    }
    pub fn clear_items(&mut self) {
        self.items.clear();
    }

    // Param is passed by value, moved
    pub fn set_items(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.items = v;
    }

    // Mutable pointer to the field.
    pub fn mut_items(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.items
    }

    // Take field
    pub fn take_items(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.items, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for Verbs {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.items)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.items {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.items {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Verbs {
        Verbs::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "items",
                |m: &Verbs| { &m.items },
                |m: &mut Verbs| { &mut m.items },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<Verbs>(
                "Verbs",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static Verbs {
        static instance: ::protobuf::rt::LazyV2<Verbs> = ::protobuf::rt::LazyV2::INIT;
        instance.get(Verbs::new)
    }
}

impl ::protobuf::Clear for Verbs {
    fn clear(&mut self) {
        self.items.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Verbs {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Verbs {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
pub struct WatchEvent {
    // message fields
    field_type: ::protobuf::SingularField<::std::string::String>,
    pub object: ::protobuf::SingularPtrField<super::runtime::RawExtension>,
    // special fields
    pub unknown_fields: ::protobuf::UnknownFields,
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WatchEvent {
    fn default() -> &'a WatchEvent {
        <WatchEvent as ::protobuf::Message>::default_instance()
    }
}

impl WatchEvent {
    pub fn new() -> WatchEvent {
        ::std::default::Default::default()
    }

    // optional string type = 1;


    pub fn get_field_type(&self) -> &str {
        match self.field_type.as_ref() {
            Some(v) => &v,
            None => "",
        }
    }
    pub fn clear_field_type(&mut self) {
        self.field_type.clear();
    }

    pub fn has_field_type(&self) -> bool {
        self.field_type.is_some()
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ::std::string::String) {
        self.field_type = ::protobuf::SingularField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_field_type(&mut self) -> &mut ::std::string::String {
        if self.field_type.is_none() {
            self.field_type.set_default();
        }
        self.field_type.as_mut().unwrap()
    }

    // Take field
    pub fn take_field_type(&mut self) -> ::std::string::String {
        self.field_type.take().unwrap_or_else(|| ::std::string::String::new())
    }

    // optional .k8s.io.apimachinery.pkg.runtime.RawExtension object = 2;


    pub fn get_object(&self) -> &super::runtime::RawExtension {
        self.object.as_ref().unwrap_or_else(|| <super::runtime::RawExtension as ::protobuf::Message>::default_instance())
    }
    pub fn clear_object(&mut self) {
        self.object.clear();
    }

    pub fn has_object(&self) -> bool {
        self.object.is_some()
    }

    // Param is passed by value, moved
    pub fn set_object(&mut self, v: super::runtime::RawExtension) {
        self.object = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_object(&mut self) -> &mut super::runtime::RawExtension {
        if self.object.is_none() {
            self.object.set_default();
        }
        self.object.as_mut().unwrap()
    }

    // Take field
    pub fn take_object(&mut self) -> super::runtime::RawExtension {
        self.object.take().unwrap_or_else(|| super::runtime::RawExtension::new())
    }
}

impl ::protobuf::Message for WatchEvent {
    fn is_initialized(&self) -> bool {
        for v in &self.object {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_string_into(wire_type, is, &mut self.field_type)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.object)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.field_type.as_ref() {
            my_size += ::protobuf::rt::string_size(1, &v);
        }
        if let Some(ref v) = self.object.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.field_type.as_ref() {
            os.write_string(1, &v)?;
        }
        if let Some(ref v) = self.object.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: ::std::boxed::Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WatchEvent {
        WatchEvent::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::LazyV2<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::LazyV2::INIT;
        descriptor.get(|| {
            let mut fields = ::std::vec::Vec::new();
            fields.push(::protobuf::reflect::accessor::make_singular_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                "type",
                |m: &WatchEvent| { &m.field_type },
                |m: &mut WatchEvent| { &mut m.field_type },
            ));
            fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::runtime::RawExtension>>(
                "object",
                |m: &WatchEvent| { &m.object },
                |m: &mut WatchEvent| { &mut m.object },
            ));
            ::protobuf::reflect::MessageDescriptor::new_pb_name::<WatchEvent>(
                "WatchEvent",
                fields,
                file_descriptor_proto()
            )
        })
    }

    fn default_instance() -> &'static WatchEvent {
        static instance: ::protobuf::rt::LazyV2<WatchEvent> = ::protobuf::rt::LazyV2::INIT;
        instance.get(WatchEvent::new)
    }
}

impl ::protobuf::Clear for WatchEvent {
    fn clear(&mut self) {
        self.field_type.clear();
        self.object.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WatchEvent {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WatchEvent {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0cv1meta.proto\x12$k8s.io.apimachinery.pkg.apis.meta.v1\x1a\rruntime\
    .proto\x1a\x0cschema.proto\"\xe7\x02\n\x08APIGroup\x12\x12\n\x04name\x18\
    \x01\x20\x01(\tR\x04name\x12Z\n\x08versions\x18\x02\x20\x03(\x0b2>.k8s.i\
    o.apimachinery.pkg.apis.meta.v1.GroupVersionForDiscoveryR\x08versions\
    \x12j\n\x10preferredVersion\x18\x03\x20\x01(\x0b2>.k8s.io.apimachinery.p\
    kg.apis.meta.v1.GroupVersionForDiscoveryR\x10preferredVersion\x12\x7f\n\
    \x1aserverAddressByClientCIDRs\x18\x04\x20\x03(\x0b2?.k8s.io.apimachiner\
    y.pkg.apis.meta.v1.ServerAddressByClientCIDRR\x1aserverAddressByClientCI\
    DRs\"V\n\x0cAPIGroupList\x12F\n\x06groups\x18\x01\x20\x03(\x0b2..k8s.io.\
    apimachinery.pkg.apis.meta.v1.APIGroupR\x06groups\"\xdc\x02\n\x0bAPIReso\
    urce\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\"\n\x0csingularNa\
    me\x18\x06\x20\x01(\tR\x0csingularName\x12\x1e\n\nnamespaced\x18\x02\x20\
    \x01(\x08R\nnamespaced\x12\x14\n\x05group\x18\x08\x20\x01(\tR\x05group\
    \x12\x18\n\x07version\x18\t\x20\x01(\tR\x07version\x12\x12\n\x04kind\x18\
    \x03\x20\x01(\tR\x04kind\x12A\n\x05verbs\x18\x04\x20\x01(\x0b2+.k8s.io.a\
    pimachinery.pkg.apis.meta.v1.VerbsR\x05verbs\x12\x1e\n\nshortNames\x18\
    \x05\x20\x03(\tR\nshortNames\x12\x1e\n\ncategories\x18\x07\x20\x03(\tR\n\
    categories\x12.\n\x12storageVersionHash\x18\n\x20\x01(\tR\x12storageVers\
    ionHash\"\x86\x01\n\x0fAPIResourceList\x12\"\n\x0cgroupVersion\x18\x01\
    \x20\x01(\tR\x0cgroupVersion\x12O\n\tresources\x18\x02\x20\x03(\x0b21.k8\
    s.io.apimachinery.pkg.apis.meta.v1.APIResourceR\tresources\"\xaa\x01\n\
    \x0bAPIVersions\x12\x1a\n\x08versions\x18\x01\x20\x03(\tR\x08versions\
    \x12\x7f\n\x1aserverAddressByClientCIDRs\x18\x02\x20\x03(\x0b2?.k8s.io.a\
    pimachinery.pkg.apis.meta.v1.ServerAddressByClientCIDRR\x1aserverAddress\
    ByClientCIDRs\"\xf5\x01\n\tCondition\x12\x12\n\x04type\x18\x01\x20\x01(\
    \tR\x04type\x12\x16\n\x06status\x18\x02\x20\x01(\tR\x06status\x12.\n\x12\
    observedGeneration\x18\x03\x20\x01(\x03R\x12observedGeneration\x12Z\n\
    \x12lastTransitionTime\x18\x04\x20\x01(\x0b2*.k8s.io.apimachinery.pkg.ap\
    is.meta.v1.TimeR\x12lastTransitionTime\x12\x16\n\x06reason\x18\x05\x20\
    \x01(\tR\x06reason\x12\x18\n\x07message\x18\x06\x20\x01(\tR\x07message\"\
    K\n\rCreateOptions\x12\x16\n\x06dryRun\x18\x01\x20\x03(\tR\x06dryRun\x12\
    \"\n\x0cfieldManager\x18\x03\x20\x01(\tR\x0cfieldManager\"\x8c\x02\n\rDe\
    leteOptions\x12.\n\x12gracePeriodSeconds\x18\x01\x20\x01(\x03R\x12graceP\
    eriodSeconds\x12Y\n\rpreconditions\x18\x02\x20\x01(\x0b23.k8s.io.apimach\
    inery.pkg.apis.meta.v1.PreconditionsR\rpreconditions\x12*\n\x10orphanDep\
    endents\x18\x03\x20\x01(\x08R\x10orphanDependents\x12,\n\x11propagationP\
    olicy\x18\x04\x20\x01(\tR\x11propagationPolicy\x12\x16\n\x06dryRun\x18\
    \x05\x20\x03(\tR\x06dryRun\"&\n\x08Duration\x12\x1a\n\x08duration\x18\
    \x01\x20\x01(\x03R\x08duration\"=\n\rExportOptions\x12\x16\n\x06export\
    \x18\x01\x20\x01(\x08R\x06export\x12\x14\n\x05exact\x18\x02\x20\x01(\x08\
    R\x05exact\"\x1c\n\x08FieldsV1\x12\x10\n\x03Raw\x18\x01\x20\x01(\x0cR\
    \x03Raw\"6\n\nGetOptions\x12(\n\x0fresourceVersion\x18\x01\x20\x01(\tR\
    \x0fresourceVersion\"5\n\tGroupKind\x12\x14\n\x05group\x18\x01\x20\x01(\
    \tR\x05group\x12\x12\n\x04kind\x18\x02\x20\x01(\tR\x04kind\"A\n\rGroupRe\
    source\x12\x14\n\x05group\x18\x01\x20\x01(\tR\x05group\x12\x1a\n\x08reso\
    urce\x18\x02\x20\x01(\tR\x08resource\">\n\x0cGroupVersion\x12\x14\n\x05g\
    roup\x18\x01\x20\x01(\tR\x05group\x12\x18\n\x07version\x18\x02\x20\x01(\
    \tR\x07version\"X\n\x18GroupVersionForDiscovery\x12\"\n\x0cgroupVersion\
    \x18\x01\x20\x01(\tR\x0cgroupVersion\x12\x18\n\x07version\x18\x02\x20\
    \x01(\tR\x07version\"V\n\x10GroupVersionKind\x12\x14\n\x05group\x18\x01\
    \x20\x01(\tR\x05group\x12\x18\n\x07version\x18\x02\x20\x01(\tR\x07versio\
    n\x12\x12\n\x04kind\x18\x03\x20\x01(\tR\x04kind\"b\n\x14GroupVersionReso\
    urce\x12\x14\n\x05group\x18\x01\x20\x01(\tR\x05group\x12\x18\n\x07versio\
    n\x18\x02\x20\x01(\tR\x07version\x12\x1a\n\x08resource\x18\x03\x20\x01(\
    \tR\x08resource\"\xa3\x02\n\rLabelSelector\x12f\n\x0bmatchLabels\x18\x01\
    \x20\x03(\x0b2D.k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelector.Match\
    LabelsEntryR\x0bmatchLabels\x12j\n\x10matchExpressions\x18\x02\x20\x03(\
    \x0b2>.k8s.io.apimachinery.pkg.apis.meta.v1.LabelSelectorRequirementR\
    \x10matchExpressions\x1a>\n\x10MatchLabelsEntry\x12\x10\n\x03key\x18\x01\
    \x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x02\
    8\x01\"`\n\x18LabelSelectorRequirement\x12\x10\n\x03key\x18\x01\x20\x01(\
    \tR\x03key\x12\x1a\n\x08operator\x18\x02\x20\x01(\tR\x08operator\x12\x16\
    \n\x06values\x18\x03\x20\x03(\tR\x06values\"\x97\x01\n\x04List\x12J\n\
    \x08metadata\x18\x01\x20\x01(\x0b2..k8s.io.apimachinery.pkg.apis.meta.v1\
    .ListMetaR\x08metadata\x12C\n\x05items\x18\x02\x20\x03(\x0b2-.k8s.io.api\
    machinery.pkg.runtime.RawExtensionR\x05items\"\x9c\x01\n\x08ListMeta\x12\
    \x1a\n\x08selfLink\x18\x01\x20\x01(\tR\x08selfLink\x12(\n\x0fresourceVer\
    sion\x18\x02\x20\x01(\tR\x0fresourceVersion\x12\x1a\n\x08continue\x18\
    \x03\x20\x01(\tR\x08continue\x12.\n\x12remainingItemCount\x18\x04\x20\
    \x01(\x03R\x12remainingItemCount\"\xd9\x02\n\x0bListOptions\x12$\n\rlabe\
    lSelector\x18\x01\x20\x01(\tR\rlabelSelector\x12$\n\rfieldSelector\x18\
    \x02\x20\x01(\tR\rfieldSelector\x12\x14\n\x05watch\x18\x03\x20\x01(\x08R\
    \x05watch\x120\n\x13allowWatchBookmarks\x18\t\x20\x01(\x08R\x13allowWatc\
    hBookmarks\x12(\n\x0fresourceVersion\x18\x04\x20\x01(\tR\x0fresourceVers\
    ion\x122\n\x14resourceVersionMatch\x18\n\x20\x01(\tR\x14resourceVersionM\
    atch\x12&\n\x0etimeoutSeconds\x18\x05\x20\x01(\x03R\x0etimeoutSeconds\
    \x12\x14\n\x05limit\x18\x07\x20\x01(\x03R\x05limit\x12\x1a\n\x08continue\
    \x18\x08\x20\x01(\tR\x08continue\"\x98\x02\n\x12ManagedFieldsEntry\x12\
    \x18\n\x07manager\x18\x01\x20\x01(\tR\x07manager\x12\x1c\n\toperation\
    \x18\x02\x20\x01(\tR\toperation\x12\x1e\n\napiVersion\x18\x03\x20\x01(\t\
    R\napiVersion\x12>\n\x04time\x18\x04\x20\x01(\x0b2*.k8s.io.apimachinery.\
    pkg.apis.meta.v1.TimeR\x04time\x12\x1e\n\nfieldsType\x18\x06\x20\x01(\tR\
    \nfieldsType\x12J\n\x08fieldsV1\x18\x07\x20\x01(\x0b2..k8s.io.apimachine\
    ry.pkg.apis.meta.v1.FieldsV1R\x08fieldsV1\";\n\tMicroTime\x12\x18\n\x07s\
    econds\x18\x01\x20\x01(\x03R\x07seconds\x12\x14\n\x05nanos\x18\x02\x20\
    \x01(\x05R\x05nanos\"\x86\x08\n\nObjectMeta\x12\x12\n\x04name\x18\x01\
    \x20\x01(\tR\x04name\x12\"\n\x0cgenerateName\x18\x02\x20\x01(\tR\x0cgene\
    rateName\x12\x1c\n\tnamespace\x18\x03\x20\x01(\tR\tnamespace\x12\x1a\n\
    \x08selfLink\x18\x04\x20\x01(\tR\x08selfLink\x12\x10\n\x03uid\x18\x05\
    \x20\x01(\tR\x03uid\x12(\n\x0fresourceVersion\x18\x06\x20\x01(\tR\x0fres\
    ourceVersion\x12\x1e\n\ngeneration\x18\x07\x20\x01(\x03R\ngeneration\x12\
    X\n\x11creationTimestamp\x18\x08\x20\x01(\x0b2*.k8s.io.apimachinery.pkg.\
    apis.meta.v1.TimeR\x11creationTimestamp\x12X\n\x11deletionTimestamp\x18\
    \t\x20\x01(\x0b2*.k8s.io.apimachinery.pkg.apis.meta.v1.TimeR\x11deletion\
    Timestamp\x12>\n\x1adeletionGracePeriodSeconds\x18\n\x20\x01(\x03R\x1ade\
    letionGracePeriodSeconds\x12T\n\x06labels\x18\x0b\x20\x03(\x0b2<.k8s.io.\
    apimachinery.pkg.apis.meta.v1.ObjectMeta.LabelsEntryR\x06labels\x12c\n\
    \x0bannotations\x18\x0c\x20\x03(\x0b2A.k8s.io.apimachinery.pkg.apis.meta\
    .v1.ObjectMeta.AnnotationsEntryR\x0bannotations\x12^\n\x0fownerReference\
    s\x18\r\x20\x03(\x0b24.k8s.io.apimachinery.pkg.apis.meta.v1.OwnerReferen\
    ceR\x0fownerReferences\x12\x1e\n\nfinalizers\x18\x0e\x20\x03(\tR\nfinali\
    zers\x12\x20\n\x0bclusterName\x18\x0f\x20\x01(\tR\x0bclusterName\x12^\n\
    \rmanagedFields\x18\x11\x20\x03(\x0b28.k8s.io.apimachinery.pkg.apis.meta\
    .v1.ManagedFieldsEntryR\rmanagedFields\x1a9\n\x0bLabelsEntry\x12\x10\n\
    \x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\t\
    R\x05value:\x028\x01\x1a>\n\x10AnnotationsEntry\x12\x10\n\x03key\x18\x01\
    \x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x02\
    8\x01\"\xba\x01\n\x0eOwnerReference\x12\x1e\n\napiVersion\x18\x05\x20\
    \x01(\tR\napiVersion\x12\x12\n\x04kind\x18\x01\x20\x01(\tR\x04kind\x12\
    \x12\n\x04name\x18\x03\x20\x01(\tR\x04name\x12\x10\n\x03uid\x18\x04\x20\
    \x01(\tR\x03uid\x12\x1e\n\ncontroller\x18\x06\x20\x01(\x08R\ncontroller\
    \x12.\n\x12blockOwnerDeletion\x18\x07\x20\x01(\x08R\x12blockOwnerDeletio\
    n\"e\n\x15PartialObjectMetadata\x12L\n\x08metadata\x18\x01\x20\x01(\x0b2\
    0.k8s.io.apimachinery.pkg.apis.meta.v1.ObjectMetaR\x08metadata\"\xba\x01\
    \n\x19PartialObjectMetadataList\x12J\n\x08metadata\x18\x01\x20\x01(\x0b2\
    ..k8s.io.apimachinery.pkg.apis.meta.v1.ListMetaR\x08metadata\x12Q\n\x05i\
    tems\x18\x02\x20\x03(\x0b2;.k8s.io.apimachinery.pkg.apis.meta.v1.Partial\
    ObjectMetadataR\x05items\"\x07\n\x05Patch\"`\n\x0cPatchOptions\x12\x16\n\
    \x06dryRun\x18\x01\x20\x03(\tR\x06dryRun\x12\x14\n\x05force\x18\x02\x20\
    \x01(\x08R\x05force\x12\"\n\x0cfieldManager\x18\x03\x20\x01(\tR\x0cfield\
    Manager\"K\n\rPreconditions\x12\x10\n\x03uid\x18\x01\x20\x01(\tR\x03uid\
    \x12(\n\x0fresourceVersion\x18\x02\x20\x01(\tR\x0fresourceVersion\"!\n\t\
    RootPaths\x12\x14\n\x05paths\x18\x01\x20\x03(\tR\x05paths\"a\n\x19Server\
    AddressByClientCIDR\x12\x1e\n\nclientCIDR\x18\x01\x20\x01(\tR\nclientCID\
    R\x12$\n\rserverAddress\x18\x02\x20\x01(\tR\rserverAddress\"\x81\x02\n\
    \x06Status\x12J\n\x08metadata\x18\x01\x20\x01(\x0b2..k8s.io.apimachinery\
    .pkg.apis.meta.v1.ListMetaR\x08metadata\x12\x16\n\x06status\x18\x02\x20\
    \x01(\tR\x06status\x12\x18\n\x07message\x18\x03\x20\x01(\tR\x07message\
    \x12\x16\n\x06reason\x18\x04\x20\x01(\tR\x06reason\x12M\n\x07details\x18\
    \x05\x20\x01(\x0b23.k8s.io.apimachinery.pkg.apis.meta.v1.StatusDetailsR\
    \x07details\x12\x12\n\x04code\x18\x06\x20\x01(\x05R\x04code\"U\n\x0bStat\
    usCause\x12\x16\n\x06reason\x18\x01\x20\x01(\tR\x06reason\x12\x18\n\x07m\
    essage\x18\x02\x20\x01(\tR\x07message\x12\x14\n\x05field\x18\x03\x20\x01\
    (\tR\x05field\"\xd8\x01\n\rStatusDetails\x12\x12\n\x04name\x18\x01\x20\
    \x01(\tR\x04name\x12\x14\n\x05group\x18\x02\x20\x01(\tR\x05group\x12\x12\
    \n\x04kind\x18\x03\x20\x01(\tR\x04kind\x12\x10\n\x03uid\x18\x06\x20\x01(\
    \tR\x03uid\x12I\n\x06causes\x18\x04\x20\x03(\x0b21.k8s.io.apimachinery.p\
    kg.apis.meta.v1.StatusCauseR\x06causes\x12,\n\x11retryAfterSeconds\x18\
    \x05\x20\x01(\x05R\x11retryAfterSeconds\"4\n\x0cTableOptions\x12$\n\rinc\
    ludeObject\x18\x01\x20\x01(\tR\rincludeObject\"6\n\x04Time\x12\x18\n\x07\
    seconds\x18\x01\x20\x01(\x03R\x07seconds\x12\x14\n\x05nanos\x18\x02\x20\
    \x01(\x05R\x05nanos\";\n\tTimestamp\x12\x18\n\x07seconds\x18\x01\x20\x01\
    (\x03R\x07seconds\x12\x14\n\x05nanos\x18\x02\x20\x01(\x05R\x05nanos\">\n\
    \x08TypeMeta\x12\x12\n\x04kind\x18\x01\x20\x01(\tR\x04kind\x12\x1e\n\nap\
    iVersion\x18\x02\x20\x01(\tR\napiVersion\"K\n\rUpdateOptions\x12\x16\n\
    \x06dryRun\x18\x01\x20\x03(\tR\x06dryRun\x12\"\n\x0cfieldManager\x18\x02\
    \x20\x01(\tR\x0cfieldManager\"\x1d\n\x05Verbs\x12\x14\n\x05items\x18\x01\
    \x20\x03(\tR\x05items\"g\n\nWatchEvent\x12\x12\n\x04type\x18\x01\x20\x01\
    (\tR\x04type\x12E\n\x06object\x18\x02\x20\x01(\x0b2-.k8s.io.apimachinery\
    .pkg.runtime.RawExtensionR\x06objectB\x04Z\x02v1J\xd6\x97\x03\n\x07\x12\
    \x05\x13\0\xce\x08\x01\n\x82\x05\n\x01\x0c\x12\x03\x13\0\x122\xac\x04\nC\
    opyright\x20The\x20Kubernetes\x20Authors.\n\nLicensed\x20under\x20the\
    \x20Apache\x20License,\x20Version\x202.0\x20(the\x20\"License\");\nyou\
    \x20may\x20not\x20use\x20this\x20file\x20except\x20in\x20compliance\x20w\
    ith\x20the\x20License.\nYou\x20may\x20obtain\x20a\x20copy\x20of\x20the\
    \x20License\x20at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnles\
    s\x20required\x20by\x20applicable\x20law\x20or\x20agreed\x20to\x20in\x20\
    writing,\x20software\ndistributed\x20under\x20the\x20License\x20is\x20di\
    stributed\x20on\x20an\x20\"AS\x20IS\"\x20BASIS,\nWITHOUT\x20WARRANTIES\
    \x20OR\x20CONDITIONS\x20OF\x20ANY\x20KIND,\x20either\x20express\x20or\
    \x20implied.\nSee\x20the\x20License\x20for\x20the\x20specific\x20languag\
    e\x20governing\x20permissions\x20and\nlimitations\x20under\x20the\x20Lic\
    ense.\n2I\x20This\x20file\x20was\x20autogenerated\x20by\x20go-to-protobu\
    f.\x20Do\x20not\x20edit\x20it\x20manually!\n\n\x08\n\x01\x02\x12\x03\x15\
    \x08,\n\t\n\x02\x03\0\x12\x03\x17\x07\x16\n\t\n\x02\x03\x01\x12\x03\x18\
    \x07\x15\n\x08\n\x01\x08\x12\x03\x1b\0\x19\nA\n\x04\x08\xe7\x07\0\x12\
    \x03\x1b\0\x19\x1a4\x20Package-wide\x20variables\x20from\x20generator\
    \x20\"generated\".\n\n\x0c\n\x05\x08\xe7\x07\0\x02\x12\x03\x1b\x07\x11\n\
    \r\n\x06\x08\xe7\x07\0\x02\0\x12\x03\x1b\x07\x11\n\x0e\n\x07\x08\xe7\x07\
    \0\x02\0\x01\x12\x03\x1b\x07\x11\n\x0c\n\x05\x08\xe7\x07\0\x07\x12\x03\
    \x1b\x14\x18\nh\n\x02\x04\0\x12\x04\x1f\04\x01\x1a\\\x20APIGroup\x20cont\
    ains\x20the\x20name,\x20the\x20supported\x20versions,\x20and\x20the\x20p\
    referred\x20version\n\x20of\x20a\x20group.\n\n\n\n\x03\x04\0\x01\x12\x03\
    \x1f\x08\x10\n-\n\x04\x04\0\x02\0\x12\x03!\x02\x1b\x1a\x20\x20name\x20is\
    \x20the\x20name\x20of\x20the\x20group.\n\n\x0c\n\x05\x04\0\x02\0\x04\x12\
    \x03!\x02\n\n\x0c\n\x05\x04\0\x02\0\x05\x12\x03!\x0b\x11\n\x0c\n\x05\x04\
    \0\x02\0\x01\x12\x03!\x12\x16\n\x0c\n\x05\x04\0\x02\0\x03\x12\x03!\x19\
    \x1a\nA\n\x04\x04\0\x02\x01\x12\x03$\x021\x1a4\x20versions\x20are\x20the\
    \x20versions\x20supported\x20in\x20this\x20group.\n\n\x0c\n\x05\x04\0\
    \x02\x01\x04\x12\x03$\x02\n\n\x0c\n\x05\x04\0\x02\x01\x06\x12\x03$\x0b#\
    \n\x0c\n\x05\x04\0\x02\x01\x01\x12\x03$$,\n\x0c\n\x05\x04\0\x02\x01\x03\
    \x12\x03$/0\n~\n\x04\x04\0\x02\x02\x12\x03)\x029\x1aq\x20preferredVersio\
    n\x20is\x20the\x20version\x20preferred\x20by\x20the\x20API\x20server,\
    \x20which\n\x20probably\x20is\x20the\x20storage\x20version.\n\x20+option\
    al\n\n\x0c\n\x05\x04\0\x02\x02\x04\x12\x03)\x02\n\n\x0c\n\x05\x04\0\x02\
    \x02\x06\x12\x03)\x0b#\n\x0c\n\x05\x04\0\x02\x02\x01\x12\x03)$4\n\x0c\n\
    \x05\x04\0\x02\x02\x03\x12\x03)78\n\x8a\x05\n\x04\x04\0\x02\x03\x12\x033\
    \x02D\x1a\xfc\x04\x20a\x20map\x20of\x20client\x20CIDR\x20to\x20server\
    \x20address\x20that\x20is\x20serving\x20this\x20group.\n\x20This\x20is\
    \x20to\x20help\x20clients\x20reach\x20servers\x20in\x20the\x20most\x20ne\
    twork-efficient\x20way\x20possible.\n\x20Clients\x20can\x20use\x20the\
    \x20appropriate\x20server\x20address\x20as\x20per\x20the\x20CIDR\x20that\
    \x20they\x20match.\n\x20In\x20case\x20of\x20multiple\x20matches,\x20clie\
    nts\x20should\x20use\x20the\x20longest\x20matching\x20CIDR.\n\x20The\x20\
    server\x20returns\x20only\x20those\x20CIDRs\x20that\x20it\x20thinks\x20t\
    hat\x20the\x20client\x20can\x20match.\n\x20For\x20example:\x20the\x20mas\
    ter\x20will\x20return\x20an\x20internal\x20IP\x20CIDR\x20only,\x20if\x20\
    the\x20client\x20reaches\x20the\x20server\x20using\x20an\x20internal\x20\
    IP.\n\x20Server\x20looks\x20at\x20X-Forwarded-For\x20header\x20or\x20X-R\
    eal-Ip\x20header\x20or\x20request.RemoteAddr\x20(in\x20that\x20order)\
    \x20to\x20get\x20the\x20client\x20IP.\n\x20+optional\n\n\x0c\n\x05\x04\0\
    \x02\x03\x04\x12\x033\x02\n\n\x0c\n\x05\x04\0\x02\x03\x06\x12\x033\x0b$\
    \n\x0c\n\x05\x04\0\x02\x03\x01\x12\x033%?\n\x0c\n\x05\x04\0\x02\x03\x03\
    \x12\x033BC\na\n\x02\x04\x01\x12\x048\0;\x01\x1aU\x20APIGroupList\x20is\
    \x20a\x20list\x20of\x20APIGroup,\x20to\x20allow\x20clients\x20to\x20disc\
    over\x20the\x20API\x20at\n\x20/apis.\n\n\n\n\x03\x04\x01\x01\x12\x038\
    \x08\x14\n,\n\x04\x04\x01\x02\0\x12\x03:\x02\x1f\x1a\x1f\x20groups\x20is\
    \x20a\x20list\x20of\x20APIGroup.\n\n\x0c\n\x05\x04\x01\x02\0\x04\x12\x03\
    :\x02\n\n\x0c\n\x05\x04\x01\x02\0\x06\x12\x03:\x0b\x13\n\x0c\n\x05\x04\
    \x01\x02\0\x01\x12\x03:\x14\x1a\n\x0c\n\x05\x04\x01\x02\0\x03\x12\x03:\
    \x1d\x1e\nX\n\x02\x04\x02\x12\x04>\0h\x01\x1aL\x20APIResource\x20specifi\
    es\x20the\x20name\x20of\x20a\x20resource\x20and\x20whether\x20it\x20is\
    \x20namespaced.\n\n\n\n\x03\x04\x02\x01\x12\x03>\x08\x13\n7\n\x04\x04\
    \x02\x02\0\x12\x03@\x02\x1b\x1a*\x20name\x20is\x20the\x20plural\x20name\
    \x20of\x20the\x20resource.\n\n\x0c\n\x05\x04\x02\x02\0\x04\x12\x03@\x02\
    \n\n\x0c\n\x05\x04\x02\x02\0\x05\x12\x03@\x0b\x11\n\x0c\n\x05\x04\x02\
    \x02\0\x01\x12\x03@\x12\x16\n\x0c\n\x05\x04\x02\x02\0\x03\x12\x03@\x19\
    \x1a\n\x91\x02\n\x04\x04\x02\x02\x01\x12\x03E\x02#\x1a\x83\x02\x20singul\
    arName\x20is\x20the\x20singular\x20name\x20of\x20the\x20resource.\x20\
    \x20This\x20allows\x20clients\x20to\x20handle\x20plural\x20and\x20singul\
    ar\x20opaquely.\n\x20The\x20singularName\x20is\x20more\x20correct\x20for\
    \x20reporting\x20status\x20on\x20a\x20single\x20item\x20and\x20both\x20s\
    ingular\x20and\x20plural\x20are\x20allowed\n\x20from\x20the\x20kubectl\
    \x20CLI\x20interface.\n\n\x0c\n\x05\x04\x02\x02\x01\x04\x12\x03E\x02\n\n\
    \x0c\n\x05\x04\x02\x02\x01\x05\x12\x03E\x0b\x11\n\x0c\n\x05\x04\x02\x02\
    \x01\x01\x12\x03E\x12\x1e\n\x0c\n\x05\x04\x02\x02\x01\x03\x12\x03E!\"\nG\
    \n\x04\x04\x02\x02\x02\x12\x03H\x02\x1f\x1a:\x20namespaced\x20indicates\
    \x20if\x20a\x20resource\x20is\x20namespaced\x20or\x20not.\n\n\x0c\n\x05\
    \x04\x02\x02\x02\x04\x12\x03H\x02\n\n\x0c\n\x05\x04\x02\x02\x02\x05\x12\
    \x03H\x0b\x0f\n\x0c\n\x05\x04\x02\x02\x02\x01\x12\x03H\x10\x1a\n\x0c\n\
    \x05\x04\x02\x02\x02\x03\x12\x03H\x1d\x1e\n\xc0\x01\n\x04\x04\x02\x02\
    \x03\x12\x03L\x02\x1c\x1a\xb2\x01\x20group\x20is\x20the\x20preferred\x20\
    group\x20of\x20the\x20resource.\x20\x20Empty\x20implies\x20the\x20group\
    \x20of\x20the\x20containing\x20resource\x20list.\n\x20For\x20subresource\
    s,\x20this\x20may\x20have\x20a\x20different\x20value,\x20for\x20example:\
    \x20Scale\".\n\n\x0c\n\x05\x04\x02\x02\x03\x04\x12\x03L\x02\n\n\x0c\n\
    \x05\x04\x02\x02\x03\x05\x12\x03L\x0b\x11\n\x0c\n\x05\x04\x02\x02\x03\
    \x01\x12\x03L\x12\x17\n\x0c\n\x05\x04\x02\x02\x03\x03\x12\x03L\x1a\x1b\n\
    \x80\x02\n\x04\x04\x02\x02\x04\x12\x03P\x02\x1e\x1a\xf2\x01\x20version\
    \x20is\x20the\x20preferred\x20version\x20of\x20the\x20resource.\x20\x20E\
    mpty\x20implies\x20the\x20version\x20of\x20the\x20containing\x20resource\
    \x20list\n\x20For\x20subresources,\x20this\x20may\x20have\x20a\x20differ\
    ent\x20value,\x20for\x20example:\x20v1\x20(while\x20inside\x20a\x20v1bet\
    a1\x20version\x20of\x20the\x20core\x20resource's\x20group)\".\n\n\x0c\n\
    \x05\x04\x02\x02\x04\x04\x12\x03P\x02\n\n\x0c\n\x05\x04\x02\x02\x04\x05\
    \x12\x03P\x0b\x11\n\x0c\n\x05\x04\x02\x02\x04\x01\x12\x03P\x12\x19\n\x0c\
    \n\x05\x04\x02\x02\x04\x03\x12\x03P\x1c\x1d\n^\n\x04\x04\x02\x02\x05\x12\
    \x03S\x02\x1b\x1aQ\x20kind\x20is\x20the\x20kind\x20for\x20the\x20resourc\
    e\x20(e.g.\x20'Foo'\x20is\x20the\x20kind\x20for\x20a\x20resource\x20'foo\
    ')\n\n\x0c\n\x05\x04\x02\x02\x05\x04\x12\x03S\x02\n\n\x0c\n\x05\x04\x02\
    \x02\x05\x05\x12\x03S\x0b\x11\n\x0c\n\x05\x04\x02\x02\x05\x01\x12\x03S\
    \x12\x16\n\x0c\n\x05\x04\x02\x02\x05\x03\x12\x03S\x19\x1a\n\x95\x01\n\
    \x04\x04\x02\x02\x06\x12\x03W\x02\x1b\x1a\x87\x01\x20verbs\x20is\x20a\
    \x20list\x20of\x20supported\x20kube\x20verbs\x20(this\x20includes\x20get\
    ,\x20list,\x20watch,\x20create,\n\x20update,\x20patch,\x20delete,\x20del\
    etecollection,\x20and\x20proxy)\n\n\x0c\n\x05\x04\x02\x02\x06\x04\x12\
    \x03W\x02\n\n\x0c\n\x05\x04\x02\x02\x06\x06\x12\x03W\x0b\x10\n\x0c\n\x05\
    \x04\x02\x02\x06\x01\x12\x03W\x11\x16\n\x0c\n\x05\x04\x02\x02\x06\x03\
    \x12\x03W\x19\x1a\nM\n\x04\x04\x02\x02\x07\x12\x03Z\x02!\x1a@\x20shortNa\
    mes\x20is\x20a\x20list\x20of\x20suggested\x20short\x20names\x20of\x20the\
    \x20resource.\n\n\x0c\n\x05\x04\x02\x02\x07\x04\x12\x03Z\x02\n\n\x0c\n\
    \x05\x04\x02\x02\x07\x05\x12\x03Z\x0b\x11\n\x0c\n\x05\x04\x02\x02\x07\
    \x01\x12\x03Z\x12\x1c\n\x0c\n\x05\x04\x02\x02\x07\x03\x12\x03Z\x1f\x20\n\
    b\n\x04\x04\x02\x02\x08\x12\x03]\x02!\x1aU\x20categories\x20is\x20a\x20l\
    ist\x20of\x20the\x20grouped\x20resources\x20this\x20resource\x20belongs\
    \x20to\x20(e.g.\x20'all')\n\n\x0c\n\x05\x04\x02\x02\x08\x04\x12\x03]\x02\
    \n\n\x0c\n\x05\x04\x02\x02\x08\x05\x12\x03]\x0b\x11\n\x0c\n\x05\x04\x02\
    \x02\x08\x01\x12\x03]\x12\x1c\n\x0c\n\x05\x04\x02\x02\x08\x03\x12\x03]\
    \x1f\x20\n\xc8\x03\n\x04\x04\x02\x02\t\x12\x03g\x02*\x1a\xba\x03\x20The\
    \x20hash\x20value\x20of\x20the\x20storage\x20version,\x20the\x20version\
    \x20this\x20resource\x20is\n\x20converted\x20to\x20when\x20written\x20to\
    \x20the\x20data\x20store.\x20Value\x20must\x20be\x20treated\n\x20as\x20o\
    paque\x20by\x20clients.\x20Only\x20equality\x20comparison\x20on\x20the\
    \x20value\x20is\x20valid.\n\x20This\x20is\x20an\x20alpha\x20feature\x20a\
    nd\x20may\x20change\x20or\x20be\x20removed\x20in\x20the\x20future.\n\x20\
    The\x20field\x20is\x20populated\x20by\x20the\x20apiserver\x20only\x20if\
    \x20the\n\x20StorageVersionHash\x20feature\x20gate\x20is\x20enabled.\n\
    \x20This\x20field\x20will\x20remain\x20optional\x20even\x20if\x20it\x20g\
    raduates.\n\x20+optional\n\n\x0c\n\x05\x04\x02\x02\t\x04\x12\x03g\x02\n\
    \n\x0c\n\x05\x04\x02\x02\t\x05\x12\x03g\x0b\x11\n\x0c\n\x05\x04\x02\x02\
    \t\x01\x12\x03g\x12$\n\x0c\n\x05\x04\x02\x02\t\x03\x12\x03g')\n\xb7\x01\
    \n\x02\x04\x03\x12\x04m\0s\x01\x1a\xaa\x01\x20APIResourceList\x20is\x20a\
    \x20list\x20of\x20APIResource,\x20it\x20is\x20used\x20to\x20expose\x20th\
    e\x20name\x20of\x20the\n\x20resources\x20supported\x20in\x20a\x20specifi\
    c\x20group\x20and\x20version,\x20and\x20if\x20the\x20resource\n\x20is\
    \x20namespaced.\n\n\n\n\x03\x04\x03\x01\x12\x03m\x08\x17\nQ\n\x04\x04\
    \x03\x02\0\x12\x03o\x02#\x1aD\x20groupVersion\x20is\x20the\x20group\x20a\
    nd\x20version\x20this\x20APIResourceList\x20is\x20for.\n\n\x0c\n\x05\x04\
    \x03\x02\0\x04\x12\x03o\x02\n\n\x0c\n\x05\x04\x03\x02\0\x05\x12\x03o\x0b\
    \x11\n\x0c\n\x05\x04\x03\x02\0\x01\x12\x03o\x12\x1e\n\x0c\n\x05\x04\x03\
    \x02\0\x03\x12\x03o!\"\nW\n\x04\x04\x03\x02\x01\x12\x03r\x02%\x1aJ\x20re\
    sources\x20contains\x20the\x20name\x20of\x20the\x20resources\x20and\x20i\
    f\x20they\x20are\x20namespaced.\n\n\x0c\n\x05\x04\x03\x02\x01\x04\x12\
    \x03r\x02\n\n\x0c\n\x05\x04\x03\x02\x01\x06\x12\x03r\x0b\x16\n\x0c\n\x05\
    \x04\x03\x02\x01\x01\x12\x03r\x17\x20\n\x0c\n\x05\x04\x03\x02\x01\x03\
    \x12\x03r#$\n\x9a\x02\n\x02\x04\x04\x12\x05z\0\x86\x01\x01\x1a\x8c\x02\
    \x20APIVersions\x20lists\x20the\x20versions\x20that\x20are\x20available,\
    \x20to\x20allow\x20clients\x20to\n\x20discover\x20the\x20API\x20at\x20/a\
    pi,\x20which\x20is\x20the\x20root\x20path\x20of\x20the\x20legacy\x20v1\
    \x20API.\n\n\x20+protobuf.options.(gogoproto.goproto_stringer)=false\n\
    \x20+k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object\
    \n\n\n\n\x03\x04\x04\x01\x12\x03z\x08\x13\n@\n\x04\x04\x04\x02\0\x12\x03\
    |\x02\x1f\x1a3\x20versions\x20are\x20the\x20api\x20versions\x20that\x20a\
    re\x20available.\n\n\x0c\n\x05\x04\x04\x02\0\x04\x12\x03|\x02\n\n\x0c\n\
    \x05\x04\x04\x02\0\x05\x12\x03|\x0b\x11\n\x0c\n\x05\x04\x04\x02\0\x01\
    \x12\x03|\x12\x1a\n\x0c\n\x05\x04\x04\x02\0\x03\x12\x03|\x1d\x1e\n\x80\
    \x05\n\x04\x04\x04\x02\x01\x12\x04\x85\x01\x02D\x1a\xf1\x04\x20a\x20map\
    \x20of\x20client\x20CIDR\x20to\x20server\x20address\x20that\x20is\x20ser\
    ving\x20this\x20group.\n\x20This\x20is\x20to\x20help\x20clients\x20reach\
    \x20servers\x20in\x20the\x20most\x20network-efficient\x20way\x20possible\
    .\n\x20Clients\x20can\x20use\x20the\x20appropriate\x20server\x20address\
    \x20as\x20per\x20the\x20CIDR\x20that\x20they\x20match.\n\x20In\x20case\
    \x20of\x20multiple\x20matches,\x20clients\x20should\x20use\x20the\x20lon\
    gest\x20matching\x20CIDR.\n\x20The\x20server\x20returns\x20only\x20those\
    \x20CIDRs\x20that\x20it\x20thinks\x20that\x20the\x20client\x20can\x20mat\
    ch.\n\x20For\x20example:\x20the\x20master\x20will\x20return\x20an\x20int\
    ernal\x20IP\x20CIDR\x20only,\x20if\x20the\x20client\x20reaches\x20the\
    \x20server\x20using\x20an\x20internal\x20IP.\n\x20Server\x20looks\x20at\
    \x20X-Forwarded-For\x20header\x20or\x20X-Real-Ip\x20header\x20or\x20requ\
    est.RemoteAddr\x20(in\x20that\x20order)\x20to\x20get\x20the\x20client\
    \x20IP.\n\n\r\n\x05\x04\x04\x02\x01\x04\x12\x04\x85\x01\x02\n\n\r\n\x05\
    \x04\x04\x02\x01\x06\x12\x04\x85\x01\x0b$\n\r\n\x05\x04\x04\x02\x01\x01\
    \x12\x04\x85\x01%?\n\r\n\x05\x04\x04\x02\x01\x03\x12\x04\x85\x01BC\n\x92\
    \x05\n\x02\x04\x05\x12\x06\x96\x01\0\xc9\x01\x01\x1a\x83\x05\x20Conditio\
    n\x20contains\x20details\x20for\x20one\x20aspect\x20of\x20the\x20current\
    \x20state\x20of\x20this\x20API\x20Resource.\n\x20---\n\x20This\x20struct\
    \x20is\x20intended\x20for\x20direct\x20use\x20as\x20an\x20array\x20at\
    \x20the\x20field\x20path\x20.status.conditions.\x20\x20For\x20example,\n\
    \x20type\x20FooStatus\x20struct{\n\x20\x20\x20\x20\x20//\x20Represents\
    \x20the\x20observations\x20of\x20a\x20foo's\x20current\x20state.\n\x20\
    \x20\x20\x20\x20//\x20Known\x20.status.conditions.type\x20are:\x20\"Avai\
    lable\",\x20\"Progressing\",\x20and\x20\"Degraded\"\n\x20\x20\x20\x20\
    \x20//\x20+patchMergeKey=type\n\x20\x20\x20\x20\x20//\x20+patchStrategy=\
    merge\n\x20\x20\x20\x20\x20//\x20+listType=map\n\x20\x20\x20\x20\x20//\
    \x20+listMapKey=type\n\x20\x20\x20\x20\x20Conditions\x20[]metav1.Conditi\
    on\x20`json:\"conditions,omitempty\"\x20patchStrategy:\"merge\"\x20patch\
    MergeKey:\"type\"\x20protobuf:\"bytes,1,rep,name=conditions\"`\n\n\x20\
    \x20\x20\x20\x20//\x20other\x20fields\n\x20}\n\n\x0b\n\x03\x04\x05\x01\
    \x12\x04\x96\x01\x08\x11\n\xc3\x04\n\x04\x04\x05\x02\0\x12\x04\xa0\x01\
    \x02\x1b\x1a\xb4\x04\x20type\x20of\x20condition\x20in\x20CamelCase\x20or\
    \x20in\x20foo.example.com/CamelCase.\n\x20---\n\x20Many\x20.condition.ty\
    pe\x20values\x20are\x20consistent\x20across\x20resources\x20like\x20Avai\
    lable,\x20but\x20because\x20arbitrary\x20conditions\x20can\x20be\n\x20us\
    eful\x20(see\x20.node.status.conditions),\x20the\x20ability\x20to\x20dec\
    onflict\x20is\x20important.\n\x20The\x20regex\x20it\x20matches\x20is\x20\
    (dns1123SubdomainFmt/)?(qualifiedNameFmt)\n\x20+required\n\x20+kubebuild\
    er:validation:Required\n\x20+kubebuilder:validation:Pattern=`^([a-z0-9](\
    [-a-z0-9]*[a-z0-9])?(\\.[a-z0-9]([-a-z0-9]*[a-z0-9])?)*/)?(([A-Za-z0-9][\
    -A-Za-z0-9_.]*)?[A-Za-z0-9])$`\n\x20+kubebuilder:validation:MaxLength=31\
    6\n\n\r\n\x05\x04\x05\x02\0\x04\x12\x04\xa0\x01\x02\n\n\r\n\x05\x04\x05\
    \x02\0\x05\x12\x04\xa0\x01\x0b\x11\n\r\n\x05\x04\x05\x02\0\x01\x12\x04\
    \xa0\x01\x12\x16\n\r\n\x05\x04\x05\x02\0\x03\x12\x04\xa0\x01\x19\x1a\n\
    \xa4\x01\n\x04\x04\x05\x02\x01\x12\x04\xa6\x01\x02\x1d\x1a\x95\x01\x20st\
    atus\x20of\x20the\x20condition,\x20one\x20of\x20True,\x20False,\x20Unkno\
    wn.\n\x20+required\n\x20+kubebuilder:validation:Required\n\x20+kubebuild\
    er:validation:Enum=True;False;Unknown\n\n\r\n\x05\x04\x05\x02\x01\x04\
    \x12\x04\xa6\x01\x02\n\n\r\n\x05\x04\x05\x02\x01\x05\x12\x04\xa6\x01\x0b\
    \x11\n\r\n\x05\x04\x05\x02\x01\x01\x12\x04\xa6\x01\x12\x18\n\r\n\x05\x04\
    \x05\x02\x01\x03\x12\x04\xa6\x01\x1b\x1c\n\xdc\x02\n\x04\x04\x05\x02\x02\
    \x12\x04\xad\x01\x02(\x1a\xcd\x02\x20observedGeneration\x20represents\
    \x20the\x20.metadata.generation\x20that\x20the\x20condition\x20was\x20se\
    t\x20based\x20upon.\n\x20For\x20instance,\x20if\x20.metadata.generation\
    \x20is\x20currently\x2012,\x20but\x20the\x20.status.conditions[x].observ\
    edGeneration\x20is\x209,\x20the\x20condition\x20is\x20out\x20of\x20date\
    \n\x20with\x20respect\x20to\x20the\x20current\x20state\x20of\x20the\x20i\
    nstance.\n\x20+optional\n\x20+kubebuilder:validation:Minimum=0\n\n\r\n\
    \x05\x04\x05\x02\x02\x04\x12\x04\xad\x01\x02\n\n\r\n\x05\x04\x05\x02\x02\
    \x05\x12\x04\xad\x01\x0b\x10\n\r\n\x05\x04\x05\x02\x02\x01\x12\x04\xad\
    \x01\x11#\n\r\n\x05\x04\x05\x02\x02\x03\x12\x04\xad\x01&'\n\xf3\x02\n\
    \x04\x04\x05\x02\x03\x12\x04\xb5\x01\x02'\x1a\xe4\x02\x20lastTransitionT\
    ime\x20is\x20the\x20last\x20time\x20the\x20condition\x20transitioned\x20\
    from\x20one\x20status\x20to\x20another.\n\x20This\x20should\x20be\x20whe\
    n\x20the\x20underlying\x20condition\x20changed.\x20\x20If\x20that\x20is\
    \x20not\x20known,\x20then\x20using\x20the\x20time\x20when\x20the\x20API\
    \x20field\x20changed\x20is\x20acceptable.\n\x20+required\n\x20+kubebuild\
    er:validation:Required\n\x20+kubebuilder:validation:Type=string\n\x20+ku\
    bebuilder:validation:Format=date-time\n\n\r\n\x05\x04\x05\x02\x03\x04\
    \x12\x04\xb5\x01\x02\n\n\r\n\x05\x04\x05\x02\x03\x06\x12\x04\xb5\x01\x0b\
    \x0f\n\r\n\x05\x04\x05\x02\x03\x01\x12\x04\xb5\x01\x10\"\n\r\n\x05\x04\
    \x05\x02\x03\x03\x12\x04\xb5\x01%&\n\x9a\x04\n\x04\x04\x05\x02\x04\x12\
    \x04\xc1\x01\x02\x1d\x1a\x8b\x04\x20reason\x20contains\x20a\x20programma\
    tic\x20identifier\x20indicating\x20the\x20reason\x20for\x20the\x20condit\
    ion's\x20last\x20transition.\n\x20Producers\x20of\x20specific\x20conditi\
    on\x20types\x20may\x20define\x20expected\x20values\x20and\x20meanings\
    \x20for\x20this\x20field,\n\x20and\x20whether\x20the\x20values\x20are\
    \x20considered\x20a\x20guaranteed\x20API.\n\x20The\x20value\x20should\
    \x20be\x20a\x20CamelCase\x20string.\n\x20This\x20field\x20may\x20not\x20\
    be\x20empty.\n\x20+required\n\x20+kubebuilder:validation:Required\n\x20+\
    kubebuilder:validation:MaxLength=1024\n\x20+kubebuilder:validation:MinLe\
    ngth=1\n\x20+kubebuilder:validation:Pattern=`^[A-Za-z]([A-Za-z0-9_,:]*[A\
    -Za-z0-9_])?$`\n\n\r\n\x05\x04\x05\x02\x04\x04\x12\x04\xc1\x01\x02\n\n\r\
    \n\x05\x04\x05\x02\x04\x05\x12\x04\xc1\x01\x0b\x11\n\r\n\x05\x04\x05\x02\
    \x04\x01\x12\x04\xc1\x01\x12\x18\n\r\n\x05\x04\x05\x02\x04\x03\x12\x04\
    \xc1\x01\x1b\x1c\n\xd1\x01\n\x04\x04\x05\x02\x05\x12\x04\xc8\x01\x02\x1e\
    \x1a\xc2\x01\x20message\x20is\x20a\x20human\x20readable\x20message\x20in\
    dicating\x20details\x20about\x20the\x20transition.\n\x20This\x20may\x20b\
    e\x20an\x20empty\x20string.\n\x20+required\n\x20+kubebuilder:validation:\
    Required\n\x20+kubebuilder:validation:MaxLength=32768\n\n\r\n\x05\x04\
    \x05\x02\x05\x04\x12\x04\xc8\x01\x02\n\n\r\n\x05\x04\x05\x02\x05\x05\x12\
    \x04\xc8\x01\x0b\x11\n\r\n\x05\x04\x05\x02\x05\x01\x12\x04\xc8\x01\x12\
    \x19\n\r\n\x05\x04\x05\x02\x05\x03\x12\x04\xc8\x01\x1c\x1d\nJ\n\x02\x04\
    \x06\x12\x06\xcc\x01\0\xdb\x01\x01\x1a<\x20CreateOptions\x20may\x20be\
    \x20provided\x20when\x20creating\x20an\x20API\x20object.\n\n\x0b\n\x03\
    \x04\x06\x01\x12\x04\xcc\x01\x08\x15\n\x98\x02\n\x04\x04\x06\x02\0\x12\
    \x04\xd3\x01\x02\x1d\x1a\x89\x02\x20When\x20present,\x20indicates\x20tha\
    t\x20modifications\x20should\x20not\x20be\n\x20persisted.\x20An\x20inval\
    id\x20or\x20unrecognized\x20dryRun\x20directive\x20will\n\x20result\x20i\
    n\x20an\x20error\x20response\x20and\x20no\x20further\x20processing\x20of\
    \x20the\n\x20request.\x20Valid\x20values\x20are:\n\x20-\x20All:\x20all\
    \x20dry\x20run\x20stages\x20will\x20be\x20processed\n\x20+optional\n\n\r\
    \n\x05\x04\x06\x02\0\x04\x12\x04\xd3\x01\x02\n\n\r\n\x05\x04\x06\x02\0\
    \x05\x12\x04\xd3\x01\x0b\x11\n\r\n\x05\x04\x06\x02\0\x01\x12\x04\xd3\x01\
    \x12\x18\n\r\n\x05\x04\x06\x02\0\x03\x12\x04\xd3\x01\x1b\x1c\n\x89\x02\n\
    \x04\x04\x06\x02\x01\x12\x04\xda\x01\x02#\x1a\xfa\x01\x20fieldManager\
    \x20is\x20a\x20name\x20associated\x20with\x20the\x20actor\x20or\x20entit\
    y\n\x20that\x20is\x20making\x20these\x20changes.\x20The\x20value\x20must\
    \x20be\x20less\x20than\x20or\n\x20128\x20characters\x20long,\x20and\x20o\
    nly\x20contain\x20printable\x20characters,\n\x20as\x20defined\x20by\x20h\
    ttps://golang.org/pkg/unicode/#IsPrint.\n\x20+optional\n\n\r\n\x05\x04\
    \x06\x02\x01\x04\x12\x04\xda\x01\x02\n\n\r\n\x05\x04\x06\x02\x01\x05\x12\
    \x04\xda\x01\x0b\x11\n\r\n\x05\x04\x06\x02\x01\x01\x12\x04\xda\x01\x12\
    \x1e\n\r\n\x05\x04\x06\x02\x01\x03\x12\x04\xda\x01!\"\nJ\n\x02\x04\x07\
    \x12\x06\xde\x01\0\x85\x02\x01\x1a<\x20DeleteOptions\x20may\x20be\x20pro\
    vided\x20when\x20deleting\x20an\x20API\x20object.\n\n\x0b\n\x03\x04\x07\
    \x01\x12\x04\xde\x01\x08\x15\n\xd0\x02\n\x04\x04\x07\x02\0\x12\x04\xe4\
    \x01\x02(\x1a\xc1\x02\x20The\x20duration\x20in\x20seconds\x20before\x20t\
    he\x20object\x20should\x20be\x20deleted.\x20Value\x20must\x20be\x20non-n\
    egative\x20integer.\n\x20The\x20value\x20zero\x20indicates\x20delete\x20\
    immediately.\x20If\x20this\x20value\x20is\x20nil,\x20the\x20default\x20g\
    race\x20period\x20for\x20the\n\x20specified\x20type\x20will\x20be\x20use\
    d.\n\x20Defaults\x20to\x20a\x20per\x20object\x20value\x20if\x20not\x20sp\
    ecified.\x20zero\x20means\x20delete\x20immediately.\n\x20+optional\n\n\r\
    \n\x05\x04\x07\x02\0\x04\x12\x04\xe4\x01\x02\n\n\r\n\x05\x04\x07\x02\0\
    \x05\x12\x04\xe4\x01\x0b\x10\n\r\n\x05\x04\x07\x02\0\x01\x12\x04\xe4\x01\
    \x11#\n\r\n\x05\x04\x07\x02\0\x03\x12\x04\xe4\x01&'\n\xa4\x01\n\x04\x04\
    \x07\x02\x01\x12\x04\xea\x01\x02+\x1a\x95\x01\x20Must\x20be\x20fulfilled\
    \x20before\x20a\x20deletion\x20is\x20carried\x20out.\x20If\x20not\x20pos\
    sible,\x20a\x20409\x20Conflict\x20status\x20will\x20be\n\x20returned.\n\
    \x20+k8s:conversion-gen=false\n\x20+optional\n\n\r\n\x05\x04\x07\x02\x01\
    \x04\x12\x04\xea\x01\x02\n\n\r\n\x05\x04\x07\x02\x01\x06\x12\x04\xea\x01\
    \x0b\x18\n\r\n\x05\x04\x07\x02\x01\x01\x12\x04\xea\x01\x19&\n\r\n\x05\
    \x04\x07\x02\x01\x03\x12\x04\xea\x01)*\n\xbf\x02\n\x04\x04\x07\x02\x02\
    \x12\x04\xf1\x01\x02%\x1a\xb0\x02\x20Deprecated:\x20please\x20use\x20the\
    \x20PropagationPolicy,\x20this\x20field\x20will\x20be\x20deprecated\x20i\
    n\x201.7.\n\x20Should\x20the\x20dependent\x20objects\x20be\x20orphaned.\
    \x20If\x20true/false,\x20the\x20\"orphan\"\n\x20finalizer\x20will\x20be\
    \x20added\x20to/removed\x20from\x20the\x20object's\x20finalizers\x20list\
    .\n\x20Either\x20this\x20field\x20or\x20PropagationPolicy\x20may\x20be\
    \x20set,\x20but\x20not\x20both.\n\x20+optional\n\n\r\n\x05\x04\x07\x02\
    \x02\x04\x12\x04\xf1\x01\x02\n\n\r\n\x05\x04\x07\x02\x02\x05\x12\x04\xf1\
    \x01\x0b\x0f\n\r\n\x05\x04\x07\x02\x02\x01\x12\x04\xf1\x01\x10\x20\n\r\n\
    \x05\x04\x07\x02\x02\x03\x12\x04\xf1\x01#$\n\xfa\x03\n\x04\x04\x07\x02\
    \x03\x12\x04\xfc\x01\x02(\x1a\xeb\x03\x20Whether\x20and\x20how\x20garbag\
    e\x20collection\x20will\x20be\x20performed.\n\x20Either\x20this\x20field\
    \x20or\x20OrphanDependents\x20may\x20be\x20set,\x20but\x20not\x20both.\n\
    \x20The\x20default\x20policy\x20is\x20decided\x20by\x20the\x20existing\
    \x20finalizer\x20set\x20in\x20the\n\x20metadata.finalizers\x20and\x20the\
    \x20resource-specific\x20default\x20policy.\n\x20Acceptable\x20values\
    \x20are:\x20'Orphan'\x20-\x20orphan\x20the\x20dependents;\x20'Background\
    '\x20-\n\x20allow\x20the\x20garbage\x20collector\x20to\x20delete\x20the\
    \x20dependents\x20in\x20the\x20background;\n\x20'Foreground'\x20-\x20a\
    \x20cascading\x20policy\x20that\x20deletes\x20all\x20dependents\x20in\
    \x20the\n\x20foreground.\n\x20+optional\n\n\r\n\x05\x04\x07\x02\x03\x04\
    \x12\x04\xfc\x01\x02\n\n\r\n\x05\x04\x07\x02\x03\x05\x12\x04\xfc\x01\x0b\
    \x11\n\r\n\x05\x04\x07\x02\x03\x01\x12\x04\xfc\x01\x12#\n\r\n\x05\x04\
    \x07\x02\x03\x03\x12\x04\xfc\x01&'\n\x98\x02\n\x04\x04\x07\x02\x04\x12\
    \x04\x84\x02\x02\x1d\x1a\x89\x02\x20When\x20present,\x20indicates\x20tha\
    t\x20modifications\x20should\x20not\x20be\n\x20persisted.\x20An\x20inval\
    id\x20or\x20unrecognized\x20dryRun\x20directive\x20will\n\x20result\x20i\
    n\x20an\x20error\x20response\x20and\x20no\x20further\x20processing\x20of\
    \x20the\n\x20request.\x20Valid\x20values\x20are:\n\x20-\x20All:\x20all\
    \x20dry\x20run\x20stages\x20will\x20be\x20processed\n\x20+optional\n\n\r\
    \n\x05\x04\x07\x02\x04\x04\x12\x04\x84\x02\x02\n\n\r\n\x05\x04\x07\x02\
    \x04\x05\x12\x04\x84\x02\x0b\x11\n\r\n\x05\x04\x07\x02\x04\x01\x12\x04\
    \x84\x02\x12\x18\n\r\n\x05\x04\x07\x02\x04\x03\x12\x04\x84\x02\x1b\x1c\n\
    \xc1\x01\n\x02\x04\x08\x12\x06\x8a\x02\0\x8c\x02\x01\x1a\xb2\x01\x20Dura\
    tion\x20is\x20a\x20wrapper\x20around\x20time.Duration\x20which\x20suppor\
    ts\x20correct\n\x20marshaling\x20to\x20YAML\x20and\x20JSON.\x20In\x20par\
    ticular,\x20it\x20marshals\x20into\x20strings,\x20which\n\x20can\x20be\
    \x20used\x20as\x20map\x20keys\x20in\x20json.\n\n\x0b\n\x03\x04\x08\x01\
    \x12\x04\x8a\x02\x08\x10\n\x0c\n\x04\x04\x08\x02\0\x12\x04\x8b\x02\x02\
    \x1e\n\r\n\x05\x04\x08\x02\0\x04\x12\x04\x8b\x02\x02\n\n\r\n\x05\x04\x08\
    \x02\0\x05\x12\x04\x8b\x02\x0b\x10\n\r\n\x05\x04\x08\x02\0\x01\x12\x04\
    \x8b\x02\x11\x19\n\r\n\x05\x04\x08\x02\0\x03\x12\x04\x8b\x02\x1c\x1d\n{\
    \n\x02\x04\t\x12\x06\x90\x02\0\x98\x02\x01\x1am\x20ExportOptions\x20is\
    \x20the\x20query\x20options\x20to\x20the\x20standard\x20REST\x20get\x20c\
    all.\n\x20Deprecated.\x20Planned\x20for\x20removal\x20in\x201.18.\n\n\
    \x0b\n\x03\x04\t\x01\x12\x04\x90\x02\x08\x15\n\x8b\x01\n\x04\x04\t\x02\0\
    \x12\x04\x93\x02\x02\x1b\x1a}\x20Should\x20this\x20value\x20be\x20export\
    ed.\x20\x20Export\x20strips\x20fields\x20that\x20a\x20user\x20can\x20not\
    \x20specify.\n\x20Deprecated.\x20Planned\x20for\x20removal\x20in\x201.18\
    .\n\n\r\n\x05\x04\t\x02\0\x04\x12\x04\x93\x02\x02\n\n\r\n\x05\x04\t\x02\
    \0\x05\x12\x04\x93\x02\x0b\x0f\n\r\n\x05\x04\t\x02\0\x01\x12\x04\x93\x02\
    \x10\x16\n\r\n\x05\x04\t\x02\0\x03\x12\x04\x93\x02\x19\x1a\n\x98\x01\n\
    \x04\x04\t\x02\x01\x12\x04\x97\x02\x02\x1a\x1a\x89\x01\x20Should\x20the\
    \x20export\x20be\x20exact.\x20\x20Exact\x20export\x20maintains\x20cluste\
    r-specific\x20fields\x20like\x20'Namespace'.\n\x20Deprecated.\x20Planned\
    \x20for\x20removal\x20in\x201.18.\n\n\r\n\x05\x04\t\x02\x01\x04\x12\x04\
    \x97\x02\x02\n\n\r\n\x05\x04\t\x02\x01\x05\x12\x04\x97\x02\x0b\x0f\n\r\n\
    \x05\x04\t\x02\x01\x01\x12\x04\x97\x02\x10\x15\n\r\n\x05\x04\t\x02\x01\
    \x03\x12\x04\x97\x02\x18\x19\n\xa3\x06\n\x02\x04\n\x12\x06\xa6\x02\0\xa9\
    \x02\x01\x1a\x94\x06\x20FieldsV1\x20stores\x20a\x20set\x20of\x20fields\
    \x20in\x20a\x20data\x20structure\x20like\x20a\x20Trie,\x20in\x20JSON\x20\
    format.\n\n\x20Each\x20key\x20is\x20either\x20a\x20'.'\x20representing\
    \x20the\x20field\x20itself,\x20and\x20will\x20always\x20map\x20to\x20an\
    \x20empty\x20set,\n\x20or\x20a\x20string\x20representing\x20a\x20sub-fie\
    ld\x20or\x20item.\x20The\x20string\x20will\x20follow\x20one\x20of\x20the\
    se\x20four\x20formats:\n\x20'f:<name>',\x20where\x20<name>\x20is\x20the\
    \x20name\x20of\x20a\x20field\x20in\x20a\x20struct,\x20or\x20key\x20in\
    \x20a\x20map\n\x20'v:<value>',\x20where\x20<value>\x20is\x20the\x20exact\
    \x20json\x20formatted\x20value\x20of\x20a\x20list\x20item\n\x20'i:<index\
    >',\x20where\x20<index>\x20is\x20position\x20of\x20a\x20item\x20in\x20a\
    \x20list\n\x20'k:<keys>',\x20where\x20<keys>\x20is\x20a\x20map\x20of\x20\
    \x20a\x20list\x20item's\x20key\x20fields\x20to\x20their\x20unique\x20val\
    ues\n\x20If\x20a\x20key\x20maps\x20to\x20an\x20empty\x20Fields\x20value,\
    \x20the\x20field\x20that\x20key\x20represents\x20is\x20part\x20of\x20the\
    \x20set.\n\n\x20The\x20exact\x20format\x20is\x20defined\x20in\x20sigs.k8\
    s.io/structured-merge-diff\n\x20+protobuf.options.(gogoproto.goproto_str\
    inger)=false\n\n\x0b\n\x03\x04\n\x01\x12\x04\xa6\x02\x08\x10\nC\n\x04\
    \x04\n\x02\0\x12\x04\xa8\x02\x02\x19\x1a5\x20Raw\x20is\x20the\x20underly\
    ing\x20serialization\x20of\x20this\x20object.\n\n\r\n\x05\x04\n\x02\0\
    \x04\x12\x04\xa8\x02\x02\n\n\r\n\x05\x04\n\x02\0\x05\x12\x04\xa8\x02\x0b\
    \x10\n\r\n\x05\x04\n\x02\0\x01\x12\x04\xa8\x02\x11\x14\n\r\n\x05\x04\n\
    \x02\0\x03\x12\x04\xa8\x02\x17\x18\nW\n\x02\x04\x0b\x12\x06\xac\x02\0\
    \xb4\x02\x01\x1aI\x20GetOptions\x20is\x20the\x20standard\x20query\x20opt\
    ions\x20to\x20the\x20standard\x20REST\x20get\x20call.\n\n\x0b\n\x03\x04\
    \x0b\x01\x12\x04\xac\x02\x08\x12\n\xeb\x01\n\x04\x04\x0b\x02\0\x12\x04\
    \xb3\x02\x02&\x1a\xdc\x01\x20resourceVersion\x20sets\x20a\x20constraint\
    \x20on\x20what\x20resource\x20versions\x20a\x20request\x20may\x20be\x20s\
    erved\x20from.\n\x20See\x20https://kubernetes.io/docs/reference/using-ap\
    i/api-concepts/#resource-versions\x20for\n\x20details.\n\n\x20Defaults\
    \x20to\x20unset\n\x20+optional\n\n\r\n\x05\x04\x0b\x02\0\x04\x12\x04\xb3\
    \x02\x02\n\n\r\n\x05\x04\x0b\x02\0\x05\x12\x04\xb3\x02\x0b\x11\n\r\n\x05\
    \x04\x0b\x02\0\x01\x12\x04\xb3\x02\x12!\n\r\n\x05\x04\x0b\x02\0\x03\x12\
    \x04\xb3\x02$%\n\xf1\x01\n\x02\x04\x0c\x12\x06\xba\x02\0\xbe\x02\x01\x1a\
    \xe2\x01\x20GroupKind\x20specifies\x20a\x20Group\x20and\x20a\x20Kind,\
    \x20but\x20does\x20not\x20force\x20a\x20version.\x20\x20This\x20is\x20us\
    eful\x20for\x20identifying\n\x20concepts\x20during\x20lookup\x20stages\
    \x20without\x20having\x20partially\x20valid\x20types\n\n\x20+protobuf.op\
    tions.(gogoproto.goproto_stringer)=false\n\n\x0b\n\x03\x04\x0c\x01\x12\
    \x04\xba\x02\x08\x11\n\x0c\n\x04\x04\x0c\x02\0\x12\x04\xbb\x02\x02\x1c\n\
    \r\n\x05\x04\x0c\x02\0\x04\x12\x04\xbb\x02\x02\n\n\r\n\x05\x04\x0c\x02\0\
    \x05\x12\x04\xbb\x02\x0b\x11\n\r\n\x05\x04\x0c\x02\0\x01\x12\x04\xbb\x02\
    \x12\x17\n\r\n\x05\x04\x0c\x02\0\x03\x12\x04\xbb\x02\x1a\x1b\n\x0c\n\x04\
    \x04\x0c\x02\x01\x12\x04\xbd\x02\x02\x1b\n\r\n\x05\x04\x0c\x02\x01\x04\
    \x12\x04\xbd\x02\x02\n\n\r\n\x05\x04\x0c\x02\x01\x05\x12\x04\xbd\x02\x0b\
    \x11\n\r\n\x05\x04\x0c\x02\x01\x01\x12\x04\xbd\x02\x12\x16\n\r\n\x05\x04\
    \x0c\x02\x01\x03\x12\x04\xbd\x02\x19\x1a\n\xf9\x01\n\x02\x04\r\x12\x06\
    \xc4\x02\0\xc8\x02\x01\x1a\xea\x01\x20GroupResource\x20specifies\x20a\
    \x20Group\x20and\x20a\x20Resource,\x20but\x20does\x20not\x20force\x20a\
    \x20version.\x20\x20This\x20is\x20useful\x20for\x20identifying\n\x20conc\
    epts\x20during\x20lookup\x20stages\x20without\x20having\x20partially\x20\
    valid\x20types\n\n\x20+protobuf.options.(gogoproto.goproto_stringer)=fal\
    se\n\n\x0b\n\x03\x04\r\x01\x12\x04\xc4\x02\x08\x15\n\x0c\n\x04\x04\r\x02\
    \0\x12\x04\xc5\x02\x02\x1c\n\r\n\x05\x04\r\x02\0\x04\x12\x04\xc5\x02\x02\
    \n\n\r\n\x05\x04\r\x02\0\x05\x12\x04\xc5\x02\x0b\x11\n\r\n\x05\x04\r\x02\
    \0\x01\x12\x04\xc5\x02\x12\x17\n\r\n\x05\x04\r\x02\0\x03\x12\x04\xc5\x02\
    \x1a\x1b\n\x0c\n\x04\x04\r\x02\x01\x12\x04\xc7\x02\x02\x1f\n\r\n\x05\x04\
    \r\x02\x01\x04\x12\x04\xc7\x02\x02\n\n\r\n\x05\x04\r\x02\x01\x05\x12\x04\
    \xc7\x02\x0b\x11\n\r\n\x05\x04\r\x02\x01\x01\x12\x04\xc7\x02\x12\x1a\n\r\
    \n\x05\x04\r\x02\x01\x03\x12\x04\xc7\x02\x1d\x1e\n\x9f\x01\n\x02\x04\x0e\
    \x12\x06\xcd\x02\0\xd1\x02\x01\x1a\x90\x01\x20GroupVersion\x20contains\
    \x20the\x20\"group\"\x20and\x20the\x20\"version\",\x20which\x20uniquely\
    \x20identifies\x20the\x20API.\n\n\x20+protobuf.options.(gogoproto.goprot\
    o_stringer)=false\n\n\x0b\n\x03\x04\x0e\x01\x12\x04\xcd\x02\x08\x14\n\
    \x0c\n\x04\x04\x0e\x02\0\x12\x04\xce\x02\x02\x1c\n\r\n\x05\x04\x0e\x02\0\
    \x04\x12\x04\xce\x02\x02\n\n\r\n\x05\x04\x0e\x02\0\x05\x12\x04\xce\x02\
    \x0b\x11\n\r\n\x05\x04\x0e\x02\0\x01\x12\x04\xce\x02\x12\x17\n\r\n\x05\
    \x04\x0e\x02\0\x03\x12\x04\xce\x02\x1a\x1b\n\x0c\n\x04\x04\x0e\x02\x01\
    \x12\x04\xd0\x02\x02\x1e\n\r\n\x05\x04\x0e\x02\x01\x04\x12\x04\xd0\x02\
    \x02\n\n\r\n\x05\x04\x0e\x02\x01\x05\x12\x04\xd0\x02\x0b\x11\n\r\n\x05\
    \x04\x0e\x02\x01\x01\x12\x04\xd0\x02\x12\x19\n\r\n\x05\x04\x0e\x02\x01\
    \x03\x12\x04\xd0\x02\x1c\x1d\n\x88\x01\n\x02\x04\x0f\x12\x06\xd5\x02\0\
    \xdc\x02\x01\x1az\x20GroupVersion\x20contains\x20the\x20\"group/version\
    \"\x20and\x20\"version\"\x20string\x20of\x20a\x20version.\n\x20It\x20is\
    \x20made\x20a\x20struct\x20to\x20keep\x20extensibility.\n\n\x0b\n\x03\
    \x04\x0f\x01\x12\x04\xd5\x02\x08\x20\n\\\n\x04\x04\x0f\x02\0\x12\x04\xd7\
    \x02\x02#\x1aN\x20groupVersion\x20specifies\x20the\x20API\x20group\x20an\
    d\x20version\x20in\x20the\x20form\x20\"group/version\"\n\n\r\n\x05\x04\
    \x0f\x02\0\x04\x12\x04\xd7\x02\x02\n\n\r\n\x05\x04\x0f\x02\0\x05\x12\x04\
    \xd7\x02\x0b\x11\n\r\n\x05\x04\x0f\x02\0\x01\x12\x04\xd7\x02\x12\x1e\n\r\
    \n\x05\x04\x0f\x02\0\x03\x12\x04\xd7\x02!\"\n\x90\x01\n\x04\x04\x0f\x02\
    \x01\x12\x04\xdb\x02\x02\x1e\x1a\x81\x01\x20version\x20specifies\x20the\
    \x20version\x20in\x20the\x20form\x20of\x20\"version\".\x20This\x20is\x20\
    to\x20save\n\x20the\x20clients\x20the\x20trouble\x20of\x20splitting\x20t\
    he\x20GroupVersion.\n\n\r\n\x05\x04\x0f\x02\x01\x04\x12\x04\xdb\x02\x02\
    \n\n\r\n\x05\x04\x0f\x02\x01\x05\x12\x04\xdb\x02\x0b\x11\n\r\n\x05\x04\
    \x0f\x02\x01\x01\x12\x04\xdb\x02\x12\x19\n\r\n\x05\x04\x0f\x02\x01\x03\
    \x12\x04\xdb\x02\x1c\x1d\n\xff\x01\n\x02\x04\x10\x12\x06\xe2\x02\0\xe8\
    \x02\x01\x1a\xf0\x01\x20GroupVersionKind\x20unambiguously\x20identifies\
    \x20a\x20kind.\x20\x20It\x20doesn't\x20anonymously\x20include\x20GroupVe\
    rsion\n\x20to\x20avoid\x20automatic\x20coersion.\x20\x20It\x20doesn't\
    \x20use\x20a\x20GroupVersion\x20to\x20avoid\x20custom\x20marshalling\n\n\
    \x20+protobuf.options.(gogoproto.goproto_stringer)=false\n\n\x0b\n\x03\
    \x04\x10\x01\x12\x04\xe2\x02\x08\x18\n\x0c\n\x04\x04\x10\x02\0\x12\x04\
    \xe3\x02\x02\x1c\n\r\n\x05\x04\x10\x02\0\x04\x12\x04\xe3\x02\x02\n\n\r\n\
    \x05\x04\x10\x02\0\x05\x12\x04\xe3\x02\x0b\x11\n\r\n\x05\x04\x10\x02\0\
    \x01\x12\x04\xe3\x02\x12\x17\n\r\n\x05\x04\x10\x02\0\x03\x12\x04\xe3\x02\
    \x1a\x1b\n\x0c\n\x04\x04\x10\x02\x01\x12\x04\xe5\x02\x02\x1e\n\r\n\x05\
    \x04\x10\x02\x01\x04\x12\x04\xe5\x02\x02\n\n\r\n\x05\x04\x10\x02\x01\x05\
    \x12\x04\xe5\x02\x0b\x11\n\r\n\x05\x04\x10\x02\x01\x01\x12\x04\xe5\x02\
    \x12\x19\n\r\n\x05\x04\x10\x02\x01\x03\x12\x04\xe5\x02\x1c\x1d\n\x0c\n\
    \x04\x04\x10\x02\x02\x12\x04\xe7\x02\x02\x1b\n\r\n\x05\x04\x10\x02\x02\
    \x04\x12\x04\xe7\x02\x02\n\n\r\n\x05\x04\x10\x02\x02\x05\x12\x04\xe7\x02\
    \x0b\x11\n\r\n\x05\x04\x10\x02\x02\x01\x12\x04\xe7\x02\x12\x16\n\r\n\x05\
    \x04\x10\x02\x02\x03\x12\x04\xe7\x02\x19\x1a\n\x87\x02\n\x02\x04\x11\x12\
    \x06\xee\x02\0\xf4\x02\x01\x1a\xf8\x01\x20GroupVersionResource\x20unambi\
    guously\x20identifies\x20a\x20resource.\x20\x20It\x20doesn't\x20anonymou\
    sly\x20include\x20GroupVersion\n\x20to\x20avoid\x20automatic\x20coersion\
    .\x20\x20It\x20doesn't\x20use\x20a\x20GroupVersion\x20to\x20avoid\x20cus\
    tom\x20marshalling\n\n\x20+protobuf.options.(gogoproto.goproto_stringer)\
    =false\n\n\x0b\n\x03\x04\x11\x01\x12\x04\xee\x02\x08\x1c\n\x0c\n\x04\x04\
    \x11\x02\0\x12\x04\xef\x02\x02\x1c\n\r\n\x05\x04\x11\x02\0\x04\x12\x04\
    \xef\x02\x02\n\n\r\n\x05\x04\x11\x02\0\x05\x12\x04\xef\x02\x0b\x11\n\r\n\
    \x05\x04\x11\x02\0\x01\x12\x04\xef\x02\x12\x17\n\r\n\x05\x04\x11\x02\0\
    \x03\x12\x04\xef\x02\x1a\x1b\n\x0c\n\x04\x04\x11\x02\x01\x12\x04\xf1\x02\
    \x02\x1e\n\r\n\x05\x04\x11\x02\x01\x04\x12\x04\xf1\x02\x02\n\n\r\n\x05\
    \x04\x11\x02\x01\x05\x12\x04\xf1\x02\x0b\x11\n\r\n\x05\x04\x11\x02\x01\
    \x01\x12\x04\xf1\x02\x12\x19\n\r\n\x05\x04\x11\x02\x01\x03\x12\x04\xf1\
    \x02\x1c\x1d\n\x0c\n\x04\x04\x11\x02\x02\x12\x04\xf3\x02\x02\x1f\n\r\n\
    \x05\x04\x11\x02\x02\x04\x12\x04\xf3\x02\x02\n\n\r\n\x05\x04\x11\x02\x02\
    \x05\x12\x04\xf3\x02\x0b\x11\n\r\n\x05\x04\x11\x02\x02\x01\x12\x04\xf3\
    \x02\x12\x1a\n\r\n\x05\x04\x11\x02\x02\x03\x12\x04\xf3\x02\x1d\x1e\n\xf2\
    \x01\n\x02\x04\x12\x12\x06\xfa\x02\0\x84\x03\x01\x1a\xe3\x01\x20A\x20lab\
    el\x20selector\x20is\x20a\x20label\x20query\x20over\x20a\x20set\x20of\
    \x20resources.\x20The\x20result\x20of\x20matchLabels\x20and\n\x20matchEx\
    pressions\x20are\x20ANDed.\x20An\x20empty\x20label\x20selector\x20matche\
    s\x20all\x20objects.\x20A\x20null\n\x20label\x20selector\x20matches\x20n\
    o\x20objects.\n\x20+structType=atomic\n\n\x0b\n\x03\x04\x12\x01\x12\x04\
    \xfa\x02\x08\x15\n\x9d\x02\n\x04\x04\x12\x02\0\x12\x04\xff\x02\x02&\x1a\
    \x8e\x02\x20matchLabels\x20is\x20a\x20map\x20of\x20{key,value}\x20pairs.\
    \x20A\x20single\x20{key,value}\x20in\x20the\x20matchLabels\n\x20map\x20i\
    s\x20equivalent\x20to\x20an\x20element\x20of\x20matchExpressions,\x20who\
    se\x20key\x20field\x20is\x20\"key\",\x20the\n\x20operator\x20is\x20\"In\
    \",\x20and\x20the\x20values\x20array\x20contains\x20only\x20\"value\".\
    \x20The\x20requirements\x20are\x20ANDed.\n\x20+optional\n\n\x0f\n\x05\
    \x04\x12\x02\0\x04\x12\x06\xff\x02\x02\xfa\x02\x17\n\r\n\x05\x04\x12\x02\
    \0\x06\x12\x04\xff\x02\x02\x15\n\r\n\x05\x04\x12\x02\0\x01\x12\x04\xff\
    \x02\x16!\n\r\n\x05\x04\x12\x02\0\x03\x12\x04\xff\x02$%\nq\n\x04\x04\x12\
    \x02\x01\x12\x04\x83\x03\x029\x1ac\x20matchExpressions\x20is\x20a\x20lis\
    t\x20of\x20label\x20selector\x20requirements.\x20The\x20requirements\x20\
    are\x20ANDed.\n\x20+optional\n\n\r\n\x05\x04\x12\x02\x01\x04\x12\x04\x83\
    \x03\x02\n\n\r\n\x05\x04\x12\x02\x01\x06\x12\x04\x83\x03\x0b#\n\r\n\x05\
    \x04\x12\x02\x01\x01\x12\x04\x83\x03$4\n\r\n\x05\x04\x12\x02\x01\x03\x12\
    \x04\x83\x0378\n\x89\x01\n\x02\x04\x13\x12\x06\x88\x03\0\x98\x03\x01\x1a\
    {\x20A\x20label\x20selector\x20requirement\x20is\x20a\x20selector\x20tha\
    t\x20contains\x20values,\x20a\x20key,\x20and\x20an\x20operator\x20that\n\
    \x20relates\x20the\x20key\x20and\x20values.\n\n\x0b\n\x03\x04\x13\x01\
    \x12\x04\x88\x03\x08\x20\nl\n\x04\x04\x13\x02\0\x12\x04\x8c\x03\x02\x1a\
    \x1a^\x20key\x20is\x20the\x20label\x20key\x20that\x20the\x20selector\x20\
    applies\x20to.\n\x20+patchMergeKey=key\n\x20+patchStrategy=merge\n\n\r\n\
    \x05\x04\x13\x02\0\x04\x12\x04\x8c\x03\x02\n\n\r\n\x05\x04\x13\x02\0\x05\
    \x12\x04\x8c\x03\x0b\x11\n\r\n\x05\x04\x13\x02\0\x01\x12\x04\x8c\x03\x12\
    \x15\n\r\n\x05\x04\x13\x02\0\x03\x12\x04\x8c\x03\x18\x19\n\x85\x01\n\x04\
    \x04\x13\x02\x01\x12\x04\x90\x03\x02\x1f\x1aw\x20operator\x20represents\
    \x20a\x20key's\x20relationship\x20to\x20a\x20set\x20of\x20values.\n\x20V\
    alid\x20operators\x20are\x20In,\x20NotIn,\x20Exists\x20and\x20DoesNotExi\
    st.\n\n\r\n\x05\x04\x13\x02\x01\x04\x12\x04\x90\x03\x02\n\n\r\n\x05\x04\
    \x13\x02\x01\x05\x12\x04\x90\x03\x0b\x11\n\r\n\x05\x04\x13\x02\x01\x01\
    \x12\x04\x90\x03\x12\x1a\n\r\n\x05\x04\x13\x02\x01\x03\x12\x04\x90\x03\
    \x1d\x1e\n\x89\x02\n\x04\x04\x13\x02\x02\x12\x04\x97\x03\x02\x1d\x1a\xfa\
    \x01\x20values\x20is\x20an\x20array\x20of\x20string\x20values.\x20If\x20\
    the\x20operator\x20is\x20In\x20or\x20NotIn,\n\x20the\x20values\x20array\
    \x20must\x20be\x20non-empty.\x20If\x20the\x20operator\x20is\x20Exists\
    \x20or\x20DoesNotExist,\n\x20the\x20values\x20array\x20must\x20be\x20emp\
    ty.\x20This\x20array\x20is\x20replaced\x20during\x20a\x20strategic\n\x20\
    merge\x20patch.\n\x20+optional\n\n\r\n\x05\x04\x13\x02\x02\x04\x12\x04\
    \x97\x03\x02\n\n\r\n\x05\x04\x13\x02\x02\x05\x12\x04\x97\x03\x0b\x11\n\r\
    \n\x05\x04\x13\x02\x02\x01\x12\x04\x97\x03\x12\x18\n\r\n\x05\x04\x13\x02\
    \x02\x03\x12\x04\x97\x03\x1b\x1c\nS\n\x02\x04\x14\x12\x06\x9b\x03\0\xa3\
    \x03\x01\x1aE\x20List\x20holds\x20a\x20list\x20of\x20objects,\x20which\
    \x20may\x20not\x20be\x20known\x20by\x20the\x20server.\n\n\x0b\n\x03\x04\
    \x14\x01\x12\x04\x9b\x03\x08\x0c\n\x9f\x01\n\x04\x04\x14\x02\0\x12\x04\
    \x9f\x03\x02!\x1a\x90\x01\x20Standard\x20list\x20metadata.\n\x20More\x20\
    info:\x20https://git.k8s.io/community/contributors/devel/sig-architectur\
    e/api-conventions.md#types-kinds\n\x20+optional\n\n\r\n\x05\x04\x14\x02\
    \0\x04\x12\x04\x9f\x03\x02\n\n\r\n\x05\x04\x14\x02\0\x06\x12\x04\x9f\x03\
    \x0b\x13\n\r\n\x05\x04\x14\x02\0\x01\x12\x04\x9f\x03\x14\x1c\n\r\n\x05\
    \x04\x14\x02\0\x03\x12\x04\x9f\x03\x1f\x20\n\x1f\n\x04\x04\x14\x02\x01\
    \x12\x04\xa2\x03\x02B\x1a\x11\x20List\x20of\x20objects\n\n\r\n\x05\x04\
    \x14\x02\x01\x04\x12\x04\xa2\x03\x02\n\n\r\n\x05\x04\x14\x02\x01\x06\x12\
    \x04\xa2\x03\x0b7\n\r\n\x05\x04\x14\x02\x01\x01\x12\x04\xa2\x038=\n\r\n\
    \x05\x04\x14\x02\x01\x03\x12\x04\xa2\x03@A\n\xb5\x01\n\x02\x04\x15\x12\
    \x06\xa7\x03\0\xcf\x03\x01\x1a\xa6\x01\x20ListMeta\x20describes\x20metad\
    ata\x20that\x20synthetic\x20resources\x20must\x20have,\x20including\x20l\
    ists\x20and\n\x20various\x20status\x20objects.\x20A\x20resource\x20may\
    \x20have\x20only\x20one\x20of\x20{ObjectMeta,\x20ListMeta}.\n\n\x0b\n\
    \x03\x04\x15\x01\x12\x04\xa7\x03\x08\x10\n\xf0\x01\n\x04\x04\x15\x02\0\
    \x12\x04\xb0\x03\x02\x1f\x1a\xe1\x01\x20selfLink\x20is\x20a\x20URL\x20re\
    presenting\x20this\x20object.\n\x20Populated\x20by\x20the\x20system.\n\
    \x20Read-only.\n\n\x20DEPRECATED\n\x20Kubernetes\x20will\x20stop\x20prop\
    agating\x20this\x20field\x20in\x201.20\x20release\x20and\x20the\x20field\
    \x20is\x20planned\n\x20to\x20be\x20removed\x20in\x201.21\x20release.\n\
    \x20+optional\n\n\r\n\x05\x04\x15\x02\0\x04\x12\x04\xb0\x03\x02\n\n\r\n\
    \x05\x04\x15\x02\0\x05\x12\x04\xb0\x03\x0b\x11\n\r\n\x05\x04\x15\x02\0\
    \x01\x12\x04\xb0\x03\x12\x1a\n\r\n\x05\x04\x15\x02\0\x03\x12\x04\xb0\x03\
    \x1d\x1e\n\xa4\x03\n\x04\x04\x15\x02\x01\x12\x04\xb9\x03\x02&\x1a\x95\
    \x03\x20String\x20that\x20identifies\x20the\x20server's\x20internal\x20v\
    ersion\x20of\x20this\x20object\x20that\n\x20can\x20be\x20used\x20by\x20c\
    lients\x20to\x20determine\x20when\x20objects\x20have\x20changed.\n\x20Va\
    lue\x20must\x20be\x20treated\x20as\x20opaque\x20by\x20clients\x20and\x20\
    passed\x20unmodified\x20back\x20to\x20the\x20server.\n\x20Populated\x20b\
    y\x20the\x20system.\n\x20Read-only.\n\x20More\x20info:\x20https://git.k8\
    s.io/community/contributors/devel/sig-architecture/api-conventions.md#co\
    ncurrency-control-and-consistency\n\x20+optional\n\n\r\n\x05\x04\x15\x02\
    \x01\x04\x12\x04\xb9\x03\x02\n\n\r\n\x05\x04\x15\x02\x01\x05\x12\x04\xb9\
    \x03\x0b\x11\n\r\n\x05\x04\x15\x02\x01\x01\x12\x04\xb9\x03\x12!\n\r\n\
    \x05\x04\x15\x02\x01\x03\x12\x04\xb9\x03$%\n\xe0\x04\n\x04\x04\x15\x02\
    \x02\x12\x04\xc2\x03\x02\x1f\x1a\xd1\x04\x20continue\x20may\x20be\x20set\
    \x20if\x20the\x20user\x20set\x20a\x20limit\x20on\x20the\x20number\x20of\
    \x20items\x20returned,\x20and\x20indicates\x20that\n\x20the\x20server\
    \x20has\x20more\x20data\x20available.\x20The\x20value\x20is\x20opaque\
    \x20and\x20may\x20be\x20used\x20to\x20issue\x20another\x20request\n\x20t\
    o\x20the\x20endpoint\x20that\x20served\x20this\x20list\x20to\x20retrieve\
    \x20the\x20next\x20set\x20of\x20available\x20objects.\x20Continuing\x20a\
    \n\x20consistent\x20list\x20may\x20not\x20be\x20possible\x20if\x20the\
    \x20server\x20configuration\x20has\x20changed\x20or\x20more\x20than\x20a\
    \x20few\n\x20minutes\x20have\x20passed.\x20The\x20resourceVersion\x20fie\
    ld\x20returned\x20when\x20using\x20this\x20continue\x20value\x20will\x20\
    be\n\x20identical\x20to\x20the\x20value\x20in\x20the\x20first\x20respons\
    e,\x20unless\x20you\x20have\x20received\x20this\x20token\x20from\x20an\
    \x20error\n\x20message.\n\n\r\n\x05\x04\x15\x02\x02\x04\x12\x04\xc2\x03\
    \x02\n\n\r\n\x05\x04\x15\x02\x02\x05\x12\x04\xc2\x03\x0b\x11\n\r\n\x05\
    \x04\x15\x02\x02\x01\x12\x04\xc2\x03\x12\x1a\n\r\n\x05\x04\x15\x02\x02\
    \x03\x12\x04\xc2\x03\x1d\x1e\n\xd6\x05\n\x04\x04\x15\x02\x03\x12\x04\xce\
    \x03\x02(\x1a\xc7\x05\x20remainingItemCount\x20is\x20the\x20number\x20of\
    \x20subsequent\x20items\x20in\x20the\x20list\x20which\x20are\x20not\x20i\
    ncluded\x20in\x20this\n\x20list\x20response.\x20If\x20the\x20list\x20req\
    uest\x20contained\x20label\x20or\x20field\x20selectors,\x20then\x20the\
    \x20number\x20of\n\x20remaining\x20items\x20is\x20unknown\x20and\x20the\
    \x20field\x20will\x20be\x20left\x20unset\x20and\x20omitted\x20during\x20\
    serialization.\n\x20If\x20the\x20list\x20is\x20complete\x20(either\x20be\
    cause\x20it\x20is\x20not\x20chunking\x20or\x20because\x20this\x20is\x20t\
    he\x20last\x20chunk),\n\x20then\x20there\x20are\x20no\x20more\x20remaini\
    ng\x20items\x20and\x20this\x20field\x20will\x20be\x20left\x20unset\x20an\
    d\x20omitted\x20during\n\x20serialization.\n\x20Servers\x20older\x20than\
    \x20v1.15\x20do\x20not\x20set\x20this\x20field.\n\x20The\x20intended\x20\
    use\x20of\x20the\x20remainingItemCount\x20is\x20*estimating*\x20the\x20s\
    ize\x20of\x20a\x20collection.\x20Clients\n\x20should\x20not\x20rely\x20o\
    n\x20the\x20remainingItemCount\x20to\x20be\x20set\x20or\x20to\x20be\x20e\
    xact.\n\x20+optional\n\n\r\n\x05\x04\x15\x02\x03\x04\x12\x04\xce\x03\x02\
    \n\n\r\n\x05\x04\x15\x02\x03\x05\x12\x04\xce\x03\x0b\x10\n\r\n\x05\x04\
    \x15\x02\x03\x01\x12\x04\xce\x03\x11#\n\r\n\x05\x04\x15\x02\x03\x03\x12\
    \x04\xce\x03&'\nN\n\x02\x04\x16\x12\x06\xd2\x03\0\xa5\x04\x01\x1a@\x20Li\
    stOptions\x20is\x20the\x20query\x20options\x20to\x20a\x20standard\x20RES\
    T\x20list\x20call.\n\n\x0b\n\x03\x04\x16\x01\x12\x04\xd2\x03\x08\x13\nx\
    \n\x04\x04\x16\x02\0\x12\x04\xd6\x03\x02$\x1aj\x20A\x20selector\x20to\
    \x20restrict\x20the\x20list\x20of\x20returned\x20objects\x20by\x20their\
    \x20labels.\n\x20Defaults\x20to\x20everything.\n\x20+optional\n\n\r\n\
    \x05\x04\x16\x02\0\x04\x12\x04\xd6\x03\x02\n\n\r\n\x05\x04\x16\x02\0\x05\
    \x12\x04\xd6\x03\x0b\x11\n\r\n\x05\x04\x16\x02\0\x01\x12\x04\xd6\x03\x12\
    \x1f\n\r\n\x05\x04\x16\x02\0\x03\x12\x04\xd6\x03\"#\nx\n\x04\x04\x16\x02\
    \x01\x12\x04\xdb\x03\x02$\x1aj\x20A\x20selector\x20to\x20restrict\x20the\
    \x20list\x20of\x20returned\x20objects\x20by\x20their\x20fields.\n\x20Def\
    aults\x20to\x20everything.\n\x20+optional\n\n\r\n\x05\x04\x16\x02\x01\
    \x04\x12\x04\xdb\x03\x02\n\n\r\n\x05\x04\x16\x02\x01\x05\x12\x04\xdb\x03\
    \x0b\x11\n\r\n\x05\x04\x16\x02\x01\x01\x12\x04\xdb\x03\x12\x1f\n\r\n\x05\
    \x04\x16\x02\x01\x03\x12\x04\xdb\x03\"#\n\xa8\x01\n\x04\x04\x16\x02\x02\
    \x12\x04\xe0\x03\x02\x1a\x1a\x99\x01\x20Watch\x20for\x20changes\x20to\
    \x20the\x20described\x20resources\x20and\x20return\x20them\x20as\x20a\
    \x20stream\x20of\n\x20add,\x20update,\x20and\x20remove\x20notifications.\
    \x20Specify\x20resourceVersion.\n\x20+optional\n\n\r\n\x05\x04\x16\x02\
    \x02\x04\x12\x04\xe0\x03\x02\n\n\r\n\x05\x04\x16\x02\x02\x05\x12\x04\xe0\
    \x03\x0b\x0f\n\r\n\x05\x04\x16\x02\x02\x01\x12\x04\xe0\x03\x10\x15\n\r\n\
    \x05\x04\x16\x02\x02\x03\x12\x04\xe0\x03\x18\x19\n\xf1\x03\n\x04\x04\x16\
    \x02\x03\x12\x04\xeb\x03\x02(\x1a\xe2\x03\x20allowWatchBookmarks\x20requ\
    ests\x20watch\x20events\x20with\x20type\x20\"BOOKMARK\".\n\x20Servers\
    \x20that\x20do\x20not\x20implement\x20bookmarks\x20may\x20ignore\x20this\
    \x20flag\x20and\n\x20bookmarks\x20are\x20sent\x20at\x20the\x20server's\
    \x20discretion.\x20Clients\x20should\x20not\n\x20assume\x20bookmarks\x20\
    are\x20returned\x20at\x20any\x20specific\x20interval,\x20nor\x20may\x20t\
    hey\n\x20assume\x20the\x20server\x20will\x20send\x20any\x20BOOKMARK\x20e\
    vent\x20during\x20a\x20session.\n\x20If\x20this\x20is\x20not\x20a\x20wat\
    ch,\x20this\x20field\x20is\x20ignored.\n\x20If\x20the\x20feature\x20gate\
    \x20WatchBookmarks\x20is\x20not\x20enabled\x20in\x20apiserver,\n\x20this\
    \x20field\x20is\x20ignored.\n\x20+optional\n\n\r\n\x05\x04\x16\x02\x03\
    \x04\x12\x04\xeb\x03\x02\n\n\r\n\x05\x04\x16\x02\x03\x05\x12\x04\xeb\x03\
    \x0b\x0f\n\r\n\x05\x04\x16\x02\x03\x01\x12\x04\xeb\x03\x10#\n\r\n\x05\
    \x04\x16\x02\x03\x03\x12\x04\xeb\x03&'\n\xeb\x01\n\x04\x04\x16\x02\x04\
    \x12\x04\xf3\x03\x02&\x1a\xdc\x01\x20resourceVersion\x20sets\x20a\x20con\
    straint\x20on\x20what\x20resource\x20versions\x20a\x20request\x20may\x20\
    be\x20served\x20from.\n\x20See\x20https://kubernetes.io/docs/reference/u\
    sing-api/api-concepts/#resource-versions\x20for\n\x20details.\n\n\x20Def\
    aults\x20to\x20unset\n\x20+optional\n\n\r\n\x05\x04\x16\x02\x04\x04\x12\
    \x04\xf3\x03\x02\n\n\r\n\x05\x04\x16\x02\x04\x05\x12\x04\xf3\x03\x0b\x11\
    \n\r\n\x05\x04\x16\x02\x04\x01\x12\x04\xf3\x03\x12!\n\r\n\x05\x04\x16\
    \x02\x04\x03\x12\x04\xf3\x03$%\n\xc7\x02\n\x04\x04\x16\x02\x05\x12\x04\
    \xfd\x03\x02,\x1a\xb8\x02\x20resourceVersionMatch\x20determines\x20how\
    \x20resourceVersion\x20is\x20applied\x20to\x20list\x20calls.\n\x20It\x20\
    is\x20highly\x20recommended\x20that\x20resourceVersionMatch\x20be\x20set\
    \x20for\x20list\x20calls\x20where\n\x20resourceVersion\x20is\x20set\n\
    \x20See\x20https://kubernetes.io/docs/reference/using-api/api-concepts/#\
    resource-versions\x20for\n\x20details.\n\n\x20Defaults\x20to\x20unset\n\
    \x20+optional\n\n\r\n\x05\x04\x16\x02\x05\x04\x12\x04\xfd\x03\x02\n\n\r\
    \n\x05\x04\x16\x02\x05\x05\x12\x04\xfd\x03\x0b\x11\n\r\n\x05\x04\x16\x02\
    \x05\x01\x12\x04\xfd\x03\x12&\n\r\n\x05\x04\x16\x02\x05\x03\x12\x04\xfd\
    \x03)+\n\x8c\x01\n\x04\x04\x16\x02\x06\x12\x04\x82\x04\x02$\x1a~\x20Time\
    out\x20for\x20the\x20list/watch\x20call.\n\x20This\x20limits\x20the\x20d\
    uration\x20of\x20the\x20call,\x20regardless\x20of\x20any\x20activity\x20\
    or\x20inactivity.\n\x20+optional\n\n\r\n\x05\x04\x16\x02\x06\x04\x12\x04\
    \x82\x04\x02\n\n\r\n\x05\x04\x16\x02\x06\x05\x12\x04\x82\x04\x0b\x10\n\r\
    \n\x05\x04\x16\x02\x06\x01\x12\x04\x82\x04\x11\x1f\n\r\n\x05\x04\x16\x02\
    \x06\x03\x12\x04\x82\x04\"#\n\xf3\n\n\x04\x04\x16\x02\x07\x12\x04\x94\
    \x04\x02\x1b\x1a\xe4\n\x20limit\x20is\x20a\x20maximum\x20number\x20of\
    \x20responses\x20to\x20return\x20for\x20a\x20list\x20call.\x20If\x20more\
    \x20items\x20exist,\x20the\n\x20server\x20will\x20set\x20the\x20`continu\
    e`\x20field\x20on\x20the\x20list\x20metadata\x20to\x20a\x20value\x20that\
    \x20can\x20be\x20used\x20with\x20the\n\x20same\x20initial\x20query\x20to\
    \x20retrieve\x20the\x20next\x20set\x20of\x20results.\x20Setting\x20a\x20\
    limit\x20may\x20return\x20fewer\x20than\n\x20the\x20requested\x20amount\
    \x20of\x20items\x20(up\x20to\x20zero\x20items)\x20in\x20the\x20event\x20\
    all\x20requested\x20objects\x20are\n\x20filtered\x20out\x20and\x20client\
    s\x20should\x20only\x20use\x20the\x20presence\x20of\x20the\x20continue\
    \x20field\x20to\x20determine\x20whether\n\x20more\x20results\x20are\x20a\
    vailable.\x20Servers\x20may\x20choose\x20not\x20to\x20support\x20the\x20\
    limit\x20argument\x20and\x20will\x20return\n\x20all\x20of\x20the\x20avai\
    lable\x20results.\x20If\x20limit\x20is\x20specified\x20and\x20the\x20con\
    tinue\x20field\x20is\x20empty,\x20clients\x20may\n\x20assume\x20that\x20\
    no\x20more\x20results\x20are\x20available.\x20This\x20field\x20is\x20not\
    \x20supported\x20if\x20watch\x20is\x20true.\n\n\x20The\x20server\x20guar\
    antees\x20that\x20the\x20objects\x20returned\x20when\x20using\x20continu\
    e\x20will\x20be\x20identical\x20to\x20issuing\n\x20a\x20single\x20list\
    \x20call\x20without\x20a\x20limit\x20-\x20that\x20is,\x20no\x20objects\
    \x20created,\x20modified,\x20or\x20deleted\x20after\x20the\n\x20first\
    \x20request\x20is\x20issued\x20will\x20be\x20included\x20in\x20any\x20su\
    bsequent\x20continued\x20requests.\x20This\x20is\x20sometimes\n\x20refer\
    red\x20to\x20as\x20a\x20consistent\x20snapshot,\x20and\x20ensures\x20tha\
    t\x20a\x20client\x20that\x20is\x20using\x20limit\x20to\x20receive\n\x20s\
    maller\x20chunks\x20of\x20a\x20very\x20large\x20result\x20can\x20ensure\
    \x20they\x20see\x20all\x20possible\x20objects.\x20If\x20objects\x20are\n\
    \x20updated\x20during\x20a\x20chunked\x20list\x20the\x20version\x20of\
    \x20the\x20object\x20that\x20was\x20present\x20at\x20the\x20time\x20the\
    \x20first\x20list\n\x20result\x20was\x20calculated\x20is\x20returned.\n\
    \n\r\n\x05\x04\x16\x02\x07\x04\x12\x04\x94\x04\x02\n\n\r\n\x05\x04\x16\
    \x02\x07\x05\x12\x04\x94\x04\x0b\x10\n\r\n\x05\x04\x16\x02\x07\x01\x12\
    \x04\x94\x04\x11\x16\n\r\n\x05\x04\x16\x02\x07\x03\x12\x04\x94\x04\x19\
    \x1a\n\xe4\t\n\x04\x04\x16\x02\x08\x12\x04\xa4\x04\x02\x1f\x1a\xd5\t\x20\
    The\x20continue\x20option\x20should\x20be\x20set\x20when\x20retrieving\
    \x20more\x20results\x20from\x20the\x20server.\x20Since\x20this\x20value\
    \x20is\n\x20server\x20defined,\x20clients\x20may\x20only\x20use\x20the\
    \x20continue\x20value\x20from\x20a\x20previous\x20query\x20result\x20wit\
    h\x20identical\n\x20query\x20parameters\x20(except\x20for\x20the\x20valu\
    e\x20of\x20continue)\x20and\x20the\x20server\x20may\x20reject\x20a\x20co\
    ntinue\x20value\x20it\n\x20does\x20not\x20recognize.\x20If\x20the\x20spe\
    cified\x20continue\x20value\x20is\x20no\x20longer\x20valid\x20whether\
    \x20due\x20to\x20expiration\n\x20(generally\x20five\x20to\x20fifteen\x20\
    minutes)\x20or\x20a\x20configuration\x20change\x20on\x20the\x20server,\
    \x20the\x20server\x20will\n\x20respond\x20with\x20a\x20410\x20ResourceEx\
    pired\x20error\x20together\x20with\x20a\x20continue\x20token.\x20If\x20t\
    he\x20client\x20needs\x20a\n\x20consistent\x20list,\x20it\x20must\x20res\
    tart\x20their\x20list\x20without\x20the\x20continue\x20field.\x20Otherwi\
    se,\x20the\x20client\x20may\n\x20send\x20another\x20list\x20request\x20w\
    ith\x20the\x20token\x20received\x20with\x20the\x20410\x20error,\x20the\
    \x20server\x20will\x20respond\x20with\n\x20a\x20list\x20starting\x20from\
    \x20the\x20next\x20key,\x20but\x20from\x20the\x20latest\x20snapshot,\x20\
    which\x20is\x20inconsistent\x20from\x20the\n\x20previous\x20list\x20resu\
    lts\x20-\x20objects\x20that\x20are\x20created,\x20modified,\x20or\x20del\
    eted\x20after\x20the\x20first\x20list\x20request\n\x20will\x20be\x20incl\
    uded\x20in\x20the\x20response,\x20as\x20long\x20as\x20their\x20keys\x20a\
    re\x20after\x20the\x20\"next\x20key\".\n\n\x20This\x20field\x20is\x20not\
    \x20supported\x20when\x20watch\x20is\x20true.\x20Clients\x20may\x20start\
    \x20a\x20watch\x20from\x20the\x20last\n\x20resourceVersion\x20value\x20r\
    eturned\x20by\x20the\x20server\x20and\x20not\x20miss\x20any\x20modificat\
    ions.\n\n\r\n\x05\x04\x16\x02\x08\x04\x12\x04\xa4\x04\x02\n\n\r\n\x05\
    \x04\x16\x02\x08\x05\x12\x04\xa4\x04\x0b\x11\n\r\n\x05\x04\x16\x02\x08\
    \x01\x12\x04\xa4\x04\x12\x1a\n\r\n\x05\x04\x16\x02\x08\x03\x12\x04\xa4\
    \x04\x1d\x1e\n\x84\x01\n\x02\x04\x17\x12\x06\xa9\x04\0\xc2\x04\x01\x1av\
    \x20ManagedFieldsEntry\x20is\x20a\x20workflow-id,\x20a\x20FieldSet\x20an\
    d\x20the\x20group\x20version\x20of\x20the\x20resource\n\x20that\x20the\
    \x20fieldset\x20applies\x20to.\n\n\x0b\n\x03\x04\x17\x01\x12\x04\xa9\x04\
    \x08\x1a\nO\n\x04\x04\x17\x02\0\x12\x04\xab\x04\x02\x1e\x1aA\x20Manager\
    \x20is\x20an\x20identifier\x20of\x20the\x20workflow\x20managing\x20these\
    \x20fields.\n\n\r\n\x05\x04\x17\x02\0\x04\x12\x04\xab\x04\x02\n\n\r\n\
    \x05\x04\x17\x02\0\x05\x12\x04\xab\x04\x0b\x11\n\r\n\x05\x04\x17\x02\0\
    \x01\x12\x04\xab\x04\x12\x19\n\r\n\x05\x04\x17\x02\0\x03\x12\x04\xab\x04\
    \x1c\x1d\n\xa8\x01\n\x04\x04\x17\x02\x01\x12\x04\xaf\x04\x02\x20\x1a\x99\
    \x01\x20Operation\x20is\x20the\x20type\x20of\x20operation\x20which\x20le\
    ad\x20to\x20this\x20ManagedFieldsEntry\x20being\x20created.\n\x20The\x20\
    only\x20valid\x20values\x20for\x20this\x20field\x20are\x20'Apply'\x20and\
    \x20'Update'.\n\n\r\n\x05\x04\x17\x02\x01\x04\x12\x04\xaf\x04\x02\n\n\r\
    \n\x05\x04\x17\x02\x01\x05\x12\x04\xaf\x04\x0b\x11\n\r\n\x05\x04\x17\x02\
    \x01\x01\x12\x04\xaf\x04\x12\x1b\n\r\n\x05\x04\x17\x02\x01\x03\x12\x04\
    \xaf\x04\x1e\x1f\n\x8d\x02\n\x04\x04\x17\x02\x02\x12\x04\xb5\x04\x02!\
    \x1a\xfe\x01\x20APIVersion\x20defines\x20the\x20version\x20of\x20this\
    \x20resource\x20that\x20this\x20field\x20set\n\x20applies\x20to.\x20The\
    \x20format\x20is\x20\"group/version\"\x20just\x20like\x20the\x20top-leve\
    l\n\x20APIVersion\x20field.\x20It\x20is\x20necessary\x20to\x20track\x20t\
    he\x20version\x20of\x20a\x20field\n\x20set\x20because\x20it\x20cannot\
    \x20be\x20automatically\x20converted.\n\n\r\n\x05\x04\x17\x02\x02\x04\
    \x12\x04\xb5\x04\x02\n\n\r\n\x05\x04\x17\x02\x02\x05\x12\x04\xb5\x04\x0b\
    \x11\n\r\n\x05\x04\x17\x02\x02\x01\x12\x04\xb5\x04\x12\x1c\n\r\n\x05\x04\
    \x17\x02\x02\x03\x12\x04\xb5\x04\x1f\x20\n}\n\x04\x04\x17\x02\x03\x12\
    \x04\xb9\x04\x02\x19\x1ao\x20Time\x20is\x20timestamp\x20of\x20when\x20th\
    ese\x20fields\x20were\x20set.\x20It\x20should\x20always\x20be\x20empty\
    \x20if\x20Operation\x20is\x20'Apply'\n\x20+optional\n\n\r\n\x05\x04\x17\
    \x02\x03\x04\x12\x04\xb9\x04\x02\n\n\r\n\x05\x04\x17\x02\x03\x06\x12\x04\
    \xb9\x04\x0b\x0f\n\r\n\x05\x04\x17\x02\x03\x01\x12\x04\xb9\x04\x10\x14\n\
    \r\n\x05\x04\x17\x02\x03\x03\x12\x04\xb9\x04\x17\x18\n\x95\x01\n\x04\x04\
    \x17\x02\x04\x12\x04\xbd\x04\x02!\x1a\x86\x01\x20FieldsType\x20is\x20the\
    \x20discriminator\x20for\x20the\x20different\x20fields\x20format\x20and\
    \x20version.\n\x20There\x20is\x20currently\x20only\x20one\x20possible\
    \x20value:\x20\"FieldsV1\"\n\n\r\n\x05\x04\x17\x02\x04\x04\x12\x04\xbd\
    \x04\x02\n\n\r\n\x05\x04\x17\x02\x04\x05\x12\x04\xbd\x04\x0b\x11\n\r\n\
    \x05\x04\x17\x02\x04\x01\x12\x04\xbd\x04\x12\x1c\n\r\n\x05\x04\x17\x02\
    \x04\x03\x12\x04\xbd\x04\x1f\x20\nl\n\x04\x04\x17\x02\x05\x12\x04\xc1\
    \x04\x02!\x1a^\x20FieldsV1\x20holds\x20the\x20first\x20JSON\x20version\
    \x20format\x20as\x20described\x20in\x20the\x20\"FieldsV1\"\x20type.\n\
    \x20+optional\n\n\r\n\x05\x04\x17\x02\x05\x04\x12\x04\xc1\x04\x02\n\n\r\
    \n\x05\x04\x17\x02\x05\x06\x12\x04\xc1\x04\x0b\x13\n\r\n\x05\x04\x17\x02\
    \x05\x01\x12\x04\xc1\x04\x14\x1c\n\r\n\x05\x04\x17\x02\x05\x03\x12\x04\
    \xc1\x04\x1f\x20\n\xbf\x01\n\x02\x04\x18\x12\x06\xc9\x04\0\xd4\x04\x01\
    \x1a\xb0\x01\x20MicroTime\x20is\x20version\x20of\x20Time\x20with\x20micr\
    osecond\x20level\x20precision.\n\n\x20+protobuf.options.marshal=false\n\
    \x20+protobuf.as=Timestamp\n\x20+protobuf.options.(gogoproto.goproto_str\
    inger)=false\n\n\x0b\n\x03\x04\x18\x01\x12\x04\xc9\x04\x08\x11\n\x9d\x01\
    \n\x04\x04\x18\x02\0\x12\x04\xcd\x04\x02\x1d\x1a\x8e\x01\x20Represents\
    \x20seconds\x20of\x20UTC\x20time\x20since\x20Unix\x20epoch\n\x201970-01-\
    01T00:00:00Z.\x20Must\x20be\x20from\x200001-01-01T00:00:00Z\x20to\n\x209\
    999-12-31T23:59:59Z\x20inclusive.\n\n\r\n\x05\x04\x18\x02\0\x04\x12\x04\
    \xcd\x04\x02\n\n\r\n\x05\x04\x18\x02\0\x05\x12\x04\xcd\x04\x0b\x10\n\r\n\
    \x05\x04\x18\x02\0\x01\x12\x04\xcd\x04\x11\x18\n\r\n\x05\x04\x18\x02\0\
    \x03\x12\x04\xcd\x04\x1b\x1c\n\xa2\x02\n\x04\x04\x18\x02\x01\x12\x04\xd3\
    \x04\x02\x1b\x1a\x93\x02\x20Non-negative\x20fractions\x20of\x20a\x20seco\
    nd\x20at\x20nanosecond\x20resolution.\x20Negative\n\x20second\x20values\
    \x20with\x20fractions\x20must\x20still\x20have\x20non-negative\x20nanos\
    \x20values\n\x20that\x20count\x20forward\x20in\x20time.\x20Must\x20be\
    \x20from\x200\x20to\x20999,999,999\n\x20inclusive.\x20This\x20field\x20m\
    ay\x20be\x20limited\x20in\x20precision\x20depending\x20on\x20context.\n\
    \n\r\n\x05\x04\x18\x02\x01\x04\x12\x04\xd3\x04\x02\n\n\r\n\x05\x04\x18\
    \x02\x01\x05\x12\x04\xd3\x04\x0b\x10\n\r\n\x05\x04\x18\x02\x01\x01\x12\
    \x04\xd3\x04\x11\x16\n\r\n\x05\x04\x18\x02\x01\x03\x12\x04\xd3\x04\x19\
    \x1a\n}\n\x02\x04\x19\x12\x06\xd8\x04\0\x84\x06\x01\x1ao\x20ObjectMeta\
    \x20is\x20metadata\x20that\x20all\x20persisted\x20resources\x20must\x20h\
    ave,\x20which\x20includes\x20all\x20objects\n\x20users\x20must\x20create\
    .\n\n\x0b\n\x03\x04\x19\x01\x12\x04\xd8\x04\x08\x12\n\xff\x02\n\x04\x04\
    \x19\x02\0\x12\x04\xe0\x04\x02\x1b\x1a\xf0\x02\x20Name\x20must\x20be\x20\
    unique\x20within\x20a\x20namespace.\x20Is\x20required\x20when\x20creatin\
    g\x20resources,\x20although\n\x20some\x20resources\x20may\x20allow\x20a\
    \x20client\x20to\x20request\x20the\x20generation\x20of\x20an\x20appropri\
    ate\x20name\n\x20automatically.\x20Name\x20is\x20primarily\x20intended\
    \x20for\x20creation\x20idempotence\x20and\x20configuration\n\x20definiti\
    on.\n\x20Cannot\x20be\x20updated.\n\x20More\x20info:\x20http://kubernete\
    s.io/docs/user-guide/identifiers#names\n\x20+optional\n\n\r\n\x05\x04\
    \x19\x02\0\x04\x12\x04\xe0\x04\x02\n\n\r\n\x05\x04\x19\x02\0\x05\x12\x04\
    \xe0\x04\x0b\x11\n\r\n\x05\x04\x19\x02\0\x01\x12\x04\xe0\x04\x12\x16\n\r\
    \n\x05\x04\x19\x02\0\x03\x12\x04\xe0\x04\x19\x1a\n\xbf\x07\n\x04\x04\x19\
    \x02\x01\x12\x04\xf2\x04\x02#\x1a\xb0\x07\x20GenerateName\x20is\x20an\
    \x20optional\x20prefix,\x20used\x20by\x20the\x20server,\x20to\x20generat\
    e\x20a\x20unique\n\x20name\x20ONLY\x20IF\x20the\x20Name\x20field\x20has\
    \x20not\x20been\x20provided.\n\x20If\x20this\x20field\x20is\x20used,\x20\
    the\x20name\x20returned\x20to\x20the\x20client\x20will\x20be\x20differen\
    t\n\x20than\x20the\x20name\x20passed.\x20This\x20value\x20will\x20also\
    \x20be\x20combined\x20with\x20a\x20unique\x20suffix.\n\x20The\x20provide\
    d\x20value\x20has\x20the\x20same\x20validation\x20rules\x20as\x20the\x20\
    Name\x20field,\n\x20and\x20may\x20be\x20truncated\x20by\x20the\x20length\
    \x20of\x20the\x20suffix\x20required\x20to\x20make\x20the\x20value\n\x20u\
    nique\x20on\x20the\x20server.\n\n\x20If\x20this\x20field\x20is\x20specif\
    ied\x20and\x20the\x20generated\x20name\x20exists,\x20the\x20server\x20wi\
    ll\n\x20NOT\x20return\x20a\x20409\x20-\x20instead,\x20it\x20will\x20eith\
    er\x20return\x20201\x20Created\x20or\x20500\x20with\x20Reason\n\x20Serve\
    rTimeout\x20indicating\x20a\x20unique\x20name\x20could\x20not\x20be\x20f\
    ound\x20in\x20the\x20time\x20allotted,\x20and\x20the\x20client\n\x20shou\
    ld\x20retry\x20(optionally\x20after\x20the\x20time\x20indicated\x20in\
    \x20the\x20Retry-After\x20header).\n\n\x20Applied\x20only\x20if\x20Name\
    \x20is\x20not\x20specified.\n\x20More\x20info:\x20https://git.k8s.io/com\
    munity/contributors/devel/sig-architecture/api-conventions.md#idempotenc\
    y\n\x20+optional\n\n\r\n\x05\x04\x19\x02\x01\x04\x12\x04\xf2\x04\x02\n\n\
    \r\n\x05\x04\x19\x02\x01\x05\x12\x04\xf2\x04\x0b\x11\n\r\n\x05\x04\x19\
    \x02\x01\x01\x12\x04\xf2\x04\x12\x1e\n\r\n\x05\x04\x19\x02\x01\x03\x12\
    \x04\xf2\x04!\"\n\xa8\x03\n\x04\x04\x19\x02\x02\x12\x04\xfd\x04\x02\x20\
    \x1a\x99\x03\x20Namespace\x20defines\x20the\x20space\x20within\x20which\
    \x20each\x20name\x20must\x20be\x20unique.\x20An\x20empty\x20namespace\
    \x20is\n\x20equivalent\x20to\x20the\x20\"default\"\x20namespace,\x20but\
    \x20\"default\"\x20is\x20the\x20canonical\x20representation.\n\x20Not\
    \x20all\x20objects\x20are\x20required\x20to\x20be\x20scoped\x20to\x20a\
    \x20namespace\x20-\x20the\x20value\x20of\x20this\x20field\x20for\n\x20th\
    ose\x20objects\x20will\x20be\x20empty.\n\n\x20Must\x20be\x20a\x20DNS_LAB\
    EL.\n\x20Cannot\x20be\x20updated.\n\x20More\x20info:\x20http://kubernete\
    s.io/docs/user-guide/namespaces\n\x20+optional\n\n\r\n\x05\x04\x19\x02\
    \x02\x04\x12\x04\xfd\x04\x02\n\n\r\n\x05\x04\x19\x02\x02\x05\x12\x04\xfd\
    \x04\x0b\x11\n\r\n\x05\x04\x19\x02\x02\x01\x12\x04\xfd\x04\x12\x1b\n\r\n\
    \x05\x04\x19\x02\x02\x03\x12\x04\xfd\x04\x1e\x1f\n\xf0\x01\n\x04\x04\x19\
    \x02\x03\x12\x04\x87\x05\x02\x1f\x1a\xe1\x01\x20SelfLink\x20is\x20a\x20U\
    RL\x20representing\x20this\x20object.\n\x20Populated\x20by\x20the\x20sys\
    tem.\n\x20Read-only.\n\n\x20DEPRECATED\n\x20Kubernetes\x20will\x20stop\
    \x20propagating\x20this\x20field\x20in\x201.20\x20release\x20and\x20the\
    \x20field\x20is\x20planned\n\x20to\x20be\x20removed\x20in\x201.21\x20rel\
    ease.\n\x20+optional\n\n\r\n\x05\x04\x19\x02\x03\x04\x12\x04\x87\x05\x02\
    \n\n\r\n\x05\x04\x19\x02\x03\x05\x12\x04\x87\x05\x0b\x11\n\r\n\x05\x04\
    \x19\x02\x03\x01\x12\x04\x87\x05\x12\x1a\n\r\n\x05\x04\x19\x02\x03\x03\
    \x12\x04\x87\x05\x1d\x1e\n\xbe\x02\n\x04\x04\x19\x02\x04\x12\x04\x91\x05\
    \x02\x1a\x1a\xaf\x02\x20UID\x20is\x20the\x20unique\x20in\x20time\x20and\
    \x20space\x20value\x20for\x20this\x20object.\x20It\x20is\x20typically\
    \x20generated\x20by\n\x20the\x20server\x20on\x20successful\x20creation\
    \x20of\x20a\x20resource\x20and\x20is\x20not\x20allowed\x20to\x20change\
    \x20on\x20PUT\n\x20operations.\n\n\x20Populated\x20by\x20the\x20system.\
    \n\x20Read-only.\n\x20More\x20info:\x20http://kubernetes.io/docs/user-gu\
    ide/identifiers#uids\n\x20+optional\n\n\r\n\x05\x04\x19\x02\x04\x04\x12\
    \x04\x91\x05\x02\n\n\r\n\x05\x04\x19\x02\x04\x05\x12\x04\x91\x05\x0b\x11\
    \n\r\n\x05\x04\x19\x02\x04\x01\x12\x04\x91\x05\x12\x15\n\r\n\x05\x04\x19\
    \x02\x04\x03\x12\x04\x91\x05\x18\x19\n\x93\x05\n\x04\x04\x19\x02\x05\x12\
    \x04\x9e\x05\x02&\x1a\x84\x05\x20An\x20opaque\x20value\x20that\x20repres\
    ents\x20the\x20internal\x20version\x20of\x20this\x20object\x20that\x20ca\
    n\n\x20be\x20used\x20by\x20clients\x20to\x20determine\x20when\x20objects\
    \x20have\x20changed.\x20May\x20be\x20used\x20for\x20optimistic\n\x20conc\
    urrency,\x20change\x20detection,\x20and\x20the\x20watch\x20operation\x20\
    on\x20a\x20resource\x20or\x20set\x20of\x20resources.\n\x20Clients\x20mus\
    t\x20treat\x20these\x20values\x20as\x20opaque\x20and\x20passed\x20unmodi\
    fied\x20back\x20to\x20the\x20server.\n\x20They\x20may\x20only\x20be\x20v\
    alid\x20for\x20a\x20particular\x20resource\x20or\x20set\x20of\x20resourc\
    es.\n\n\x20Populated\x20by\x20the\x20system.\n\x20Read-only.\n\x20Value\
    \x20must\x20be\x20treated\x20as\x20opaque\x20by\x20clients\x20and\x20.\n\
    \x20More\x20info:\x20https://git.k8s.io/community/contributors/devel/sig\
    -architecture/api-conventions.md#concurrency-control-and-consistency\n\
    \x20+optional\n\n\r\n\x05\x04\x19\x02\x05\x04\x12\x04\x9e\x05\x02\n\n\r\
    \n\x05\x04\x19\x02\x05\x05\x12\x04\x9e\x05\x0b\x11\n\r\n\x05\x04\x19\x02\
    \x05\x01\x12\x04\x9e\x05\x12!\n\r\n\x05\x04\x19\x02\x05\x03\x12\x04\x9e\
    \x05$%\n\x8a\x01\n\x04\x04\x19\x02\x06\x12\x04\xa3\x05\x02\x20\x1a|\x20A\
    \x20sequence\x20number\x20representing\x20a\x20specific\x20generation\
    \x20of\x20the\x20desired\x20state.\n\x20Populated\x20by\x20the\x20system\
    .\x20Read-only.\n\x20+optional\n\n\r\n\x05\x04\x19\x02\x06\x04\x12\x04\
    \xa3\x05\x02\n\n\r\n\x05\x04\x19\x02\x06\x05\x12\x04\xa3\x05\x0b\x10\n\r\
    \n\x05\x04\x19\x02\x06\x01\x12\x04\xa3\x05\x11\x1b\n\r\n\x05\x04\x19\x02\
    \x06\x03\x12\x04\xa3\x05\x1e\x1f\n\xbe\x03\n\x04\x04\x19\x02\x07\x12\x04\
    \xae\x05\x02&\x1a\xaf\x03\x20CreationTimestamp\x20is\x20a\x20timestamp\
    \x20representing\x20the\x20server\x20time\x20when\x20this\x20object\x20w\
    as\n\x20created.\x20It\x20is\x20not\x20guaranteed\x20to\x20be\x20set\x20\
    in\x20happens-before\x20order\x20across\x20separate\x20operations.\n\x20\
    Clients\x20may\x20not\x20set\x20this\x20value.\x20It\x20is\x20represente\
    d\x20in\x20RFC3339\x20form\x20and\x20is\x20in\x20UTC.\n\n\x20Populated\
    \x20by\x20the\x20system.\n\x20Read-only.\n\x20Null\x20for\x20lists.\n\
    \x20More\x20info:\x20https://git.k8s.io/community/contributors/devel/sig\
    -architecture/api-conventions.md#metadata\n\x20+optional\n\n\r\n\x05\x04\
    \x19\x02\x07\x04\x12\x04\xae\x05\x02\n\n\r\n\x05\x04\x19\x02\x07\x06\x12\
    \x04\xae\x05\x0b\x0f\n\r\n\x05\x04\x19\x02\x07\x01\x12\x04\xae\x05\x10!\
    \n\r\n\x05\x04\x19\x02\x07\x03\x12\x04\xae\x05$%\n\xfe\n\n\x04\x04\x19\
    \x02\x08\x12\x04\xc3\x05\x02&\x1a\xef\n\x20DeletionTimestamp\x20is\x20RF\
    C\x203339\x20date\x20and\x20time\x20at\x20which\x20this\x20resource\x20w\
    ill\x20be\x20deleted.\x20This\n\x20field\x20is\x20set\x20by\x20the\x20se\
    rver\x20when\x20a\x20graceful\x20deletion\x20is\x20requested\x20by\x20th\
    e\x20user,\x20and\x20is\x20not\n\x20directly\x20settable\x20by\x20a\x20c\
    lient.\x20The\x20resource\x20is\x20expected\x20to\x20be\x20deleted\x20(n\
    o\x20longer\x20visible\n\x20from\x20resource\x20lists,\x20and\x20not\x20\
    reachable\x20by\x20name)\x20after\x20the\x20time\x20in\x20this\x20field,\
    \x20once\x20the\n\x20finalizers\x20list\x20is\x20empty.\x20As\x20long\
    \x20as\x20the\x20finalizers\x20list\x20contains\x20items,\x20deletion\
    \x20is\x20blocked.\n\x20Once\x20the\x20deletionTimestamp\x20is\x20set,\
    \x20this\x20value\x20may\x20not\x20be\x20unset\x20or\x20be\x20set\x20fur\
    ther\x20into\x20the\n\x20future,\x20although\x20it\x20may\x20be\x20short\
    ened\x20or\x20the\x20resource\x20may\x20be\x20deleted\x20prior\x20to\x20\
    this\x20time.\n\x20For\x20example,\x20a\x20user\x20may\x20request\x20tha\
    t\x20a\x20pod\x20is\x20deleted\x20in\x2030\x20seconds.\x20The\x20Kubelet\
    \x20will\x20react\n\x20by\x20sending\x20a\x20graceful\x20termination\x20\
    signal\x20to\x20the\x20containers\x20in\x20the\x20pod.\x20After\x20that\
    \x2030\x20seconds,\n\x20the\x20Kubelet\x20will\x20send\x20a\x20hard\x20t\
    ermination\x20signal\x20(SIGKILL)\x20to\x20the\x20container\x20and\x20af\
    ter\x20cleanup,\n\x20remove\x20the\x20pod\x20from\x20the\x20API.\x20In\
    \x20the\x20presence\x20of\x20network\x20partitions,\x20this\x20object\
    \x20may\x20still\n\x20exist\x20after\x20this\x20timestamp,\x20until\x20a\
    n\x20administrator\x20or\x20automated\x20process\x20can\x20determine\x20\
    the\n\x20resource\x20is\x20fully\x20terminated.\n\x20If\x20not\x20set,\
    \x20graceful\x20deletion\x20of\x20the\x20object\x20has\x20not\x20been\
    \x20requested.\n\n\x20Populated\x20by\x20the\x20system\x20when\x20a\x20g\
    raceful\x20deletion\x20is\x20requested.\n\x20Read-only.\n\x20More\x20inf\
    o:\x20https://git.k8s.io/community/contributors/devel/sig-architecture/a\
    pi-conventions.md#metadata\n\x20+optional\n\n\r\n\x05\x04\x19\x02\x08\
    \x04\x12\x04\xc3\x05\x02\n\n\r\n\x05\x04\x19\x02\x08\x06\x12\x04\xc3\x05\
    \x0b\x0f\n\r\n\x05\x04\x19\x02\x08\x01\x12\x04\xc3\x05\x10!\n\r\n\x05\
    \x04\x19\x02\x08\x03\x12\x04\xc3\x05$%\n\xda\x01\n\x04\x04\x19\x02\t\x12\
    \x04\xca\x05\x021\x1a\xcb\x01\x20Number\x20of\x20seconds\x20allowed\x20f\
    or\x20this\x20object\x20to\x20gracefully\x20terminate\x20before\n\x20it\
    \x20will\x20be\x20removed\x20from\x20the\x20system.\x20Only\x20set\x20wh\
    en\x20deletionTimestamp\x20is\x20also\x20set.\n\x20May\x20only\x20be\x20\
    shortened.\n\x20Read-only.\n\x20+optional\n\n\r\n\x05\x04\x19\x02\t\x04\
    \x12\x04\xca\x05\x02\n\n\r\n\x05\x04\x19\x02\t\x05\x12\x04\xca\x05\x0b\
    \x10\n\r\n\x05\x04\x19\x02\t\x01\x12\x04\xca\x05\x11+\n\r\n\x05\x04\x19\
    \x02\t\x03\x12\x04\xca\x05.0\n\xf8\x01\n\x04\x04\x19\x02\n\x12\x04\xd1\
    \x05\x02\"\x1a\xe9\x01\x20Map\x20of\x20string\x20keys\x20and\x20values\
    \x20that\x20can\x20be\x20used\x20to\x20organize\x20and\x20categorize\n\
    \x20(scope\x20and\x20select)\x20objects.\x20May\x20match\x20selectors\
    \x20of\x20replication\x20controllers\n\x20and\x20services.\n\x20More\x20\
    info:\x20http://kubernetes.io/docs/user-guide/labels\n\x20+optional\n\n\
    \x0f\n\x05\x04\x19\x02\n\x04\x12\x06\xd1\x05\x02\xca\x051\n\r\n\x05\x04\
    \x19\x02\n\x06\x12\x04\xd1\x05\x02\x15\n\r\n\x05\x04\x19\x02\n\x01\x12\
    \x04\xd1\x05\x16\x1c\n\r\n\x05\x04\x19\x02\n\x03\x12\x04\xd1\x05\x1f!\n\
    \xb1\x02\n\x04\x04\x19\x02\x0b\x12\x04\xd8\x05\x02'\x1a\xa2\x02\x20Annot\
    ations\x20is\x20an\x20unstructured\x20key\x20value\x20map\x20stored\x20w\
    ith\x20a\x20resource\x20that\x20may\x20be\n\x20set\x20by\x20external\x20\
    tools\x20to\x20store\x20and\x20retrieve\x20arbitrary\x20metadata.\x20The\
    y\x20are\x20not\n\x20queryable\x20and\x20should\x20be\x20preserved\x20wh\
    en\x20modifying\x20objects.\n\x20More\x20info:\x20http://kubernetes.io/d\
    ocs/user-guide/annotations\n\x20+optional\n\n\x0f\n\x05\x04\x19\x02\x0b\
    \x04\x12\x06\xd8\x05\x02\xd1\x05\"\n\r\n\x05\x04\x19\x02\x0b\x06\x12\x04\
    \xd8\x05\x02\x15\n\r\n\x05\x04\x19\x02\x0b\x01\x12\x04\xd8\x05\x16!\n\r\
    \n\x05\x04\x19\x02\x0b\x03\x12\x04\xd8\x05$&\n\x85\x03\n\x04\x04\x19\x02\
    \x0c\x12\x04\xe1\x05\x02/\x1a\xf6\x02\x20List\x20of\x20objects\x20depend\
    ed\x20by\x20this\x20object.\x20If\x20ALL\x20objects\x20in\x20the\x20list\
    \x20have\n\x20been\x20deleted,\x20this\x20object\x20will\x20be\x20garbag\
    e\x20collected.\x20If\x20this\x20object\x20is\x20managed\x20by\x20a\x20c\
    ontroller,\n\x20then\x20an\x20entry\x20in\x20this\x20list\x20will\x20poi\
    nt\x20to\x20this\x20controller,\x20with\x20the\x20controller\x20field\
    \x20set\x20to\x20true.\n\x20There\x20cannot\x20be\x20more\x20than\x20one\
    \x20managing\x20controller.\n\x20+optional\n\x20+patchMergeKey=uid\n\x20\
    +patchStrategy=merge\n\n\r\n\x05\x04\x19\x02\x0c\x04\x12\x04\xe1\x05\x02\
    \n\n\r\n\x05\x04\x19\x02\x0c\x06\x12\x04\xe1\x05\x0b\x19\n\r\n\x05\x04\
    \x19\x02\x0c\x01\x12\x04\xe1\x05\x1a)\n\r\n\x05\x04\x19\x02\x0c\x03\x12\
    \x04\xe1\x05,.\n\xc6\x07\n\x04\x04\x19\x02\r\x12\x04\xf2\x05\x02\"\x1a\
    \xb7\x07\x20Must\x20be\x20empty\x20before\x20the\x20object\x20is\x20dele\
    ted\x20from\x20the\x20registry.\x20Each\x20entry\n\x20is\x20an\x20identi\
    fier\x20for\x20the\x20responsible\x20component\x20that\x20will\x20remove\
    \x20the\x20entry\n\x20from\x20the\x20list.\x20If\x20the\x20deletionTimes\
    tamp\x20of\x20the\x20object\x20is\x20non-nil,\x20entries\n\x20in\x20this\
    \x20list\x20can\x20only\x20be\x20removed.\n\x20Finalizers\x20may\x20be\
    \x20processed\x20and\x20removed\x20in\x20any\x20order.\x20\x20Order\x20i\
    s\x20NOT\x20enforced\n\x20because\x20it\x20introduces\x20significant\x20\
    risk\x20of\x20stuck\x20finalizers.\n\x20finalizers\x20is\x20a\x20shared\
    \x20field,\x20any\x20actor\x20with\x20permission\x20can\x20reorder\x20it\
    .\n\x20If\x20the\x20finalizer\x20list\x20is\x20processed\x20in\x20order,\
    \x20then\x20this\x20can\x20lead\x20to\x20a\x20situation\n\x20in\x20which\
    \x20the\x20component\x20responsible\x20for\x20the\x20first\x20finalizer\
    \x20in\x20the\x20list\x20is\n\x20waiting\x20for\x20a\x20signal\x20(field\
    \x20value,\x20external\x20system,\x20or\x20other)\x20produced\x20by\x20a\
    \n\x20component\x20responsible\x20for\x20a\x20finalizer\x20later\x20in\
    \x20the\x20list,\x20resulting\x20in\x20a\x20deadlock.\n\x20Without\x20en\
    forced\x20ordering\x20finalizers\x20are\x20free\x20to\x20order\x20amongs\
    t\x20themselves\x20and\n\x20are\x20not\x20vulnerable\x20to\x20ordering\
    \x20changes\x20in\x20the\x20list.\n\x20+optional\n\x20+patchStrategy=mer\
    ge\n\n\r\n\x05\x04\x19\x02\r\x04\x12\x04\xf2\x05\x02\n\n\r\n\x05\x04\x19\
    \x02\r\x05\x12\x04\xf2\x05\x0b\x11\n\r\n\x05\x04\x19\x02\r\x01\x12\x04\
    \xf2\x05\x12\x1c\n\r\n\x05\x04\x19\x02\r\x03\x12\x04\xf2\x05\x1f!\n\x9d\
    \x02\n\x04\x04\x19\x02\x0e\x12\x04\xf8\x05\x02#\x1a\x8e\x02\x20The\x20na\
    me\x20of\x20the\x20cluster\x20which\x20the\x20object\x20belongs\x20to.\n\
    \x20This\x20is\x20used\x20to\x20distinguish\x20resources\x20with\x20same\
    \x20name\x20and\x20namespace\x20in\x20different\x20clusters.\n\x20This\
    \x20field\x20is\x20not\x20set\x20anywhere\x20right\x20now\x20and\x20apis\
    erver\x20is\x20going\x20to\x20ignore\x20it\x20if\x20set\x20in\x20create\
    \x20or\x20update\x20request.\n\x20+optional\n\n\r\n\x05\x04\x19\x02\x0e\
    \x04\x12\x04\xf8\x05\x02\n\n\r\n\x05\x04\x19\x02\x0e\x05\x12\x04\xf8\x05\
    \x0b\x11\n\r\n\x05\x04\x19\x02\x0e\x01\x12\x04\xf8\x05\x12\x1d\n\r\n\x05\
    \x04\x19\x02\x0e\x03\x12\x04\xf8\x05\x20\"\n\xbb\x03\n\x04\x04\x19\x02\
    \x0f\x12\x04\x83\x06\x021\x1a\xac\x03\x20ManagedFields\x20maps\x20workfl\
    ow-id\x20and\x20version\x20to\x20the\x20set\x20of\x20fields\n\x20that\
    \x20are\x20managed\x20by\x20that\x20workflow.\x20This\x20is\x20mostly\
    \x20for\x20internal\n\x20housekeeping,\x20and\x20users\x20typically\x20s\
    houldn't\x20need\x20to\x20set\x20or\n\x20understand\x20this\x20field.\
    \x20A\x20workflow\x20can\x20be\x20the\x20user's\x20name,\x20a\n\x20contr\
    oller's\x20name,\x20or\x20the\x20name\x20of\x20a\x20specific\x20apply\
    \x20path\x20like\n\x20\"ci-cd\".\x20The\x20set\x20of\x20fields\x20is\x20\
    always\x20in\x20the\x20version\x20that\x20the\n\x20workflow\x20used\x20w\
    hen\x20modifying\x20the\x20object.\n\n\x20+optional\n\n\r\n\x05\x04\x19\
    \x02\x0f\x04\x12\x04\x83\x06\x02\n\n\r\n\x05\x04\x19\x02\x0f\x06\x12\x04\
    \x83\x06\x0b\x1d\n\r\n\x05\x04\x19\x02\x0f\x01\x12\x04\x83\x06\x1e+\n\r\
    \n\x05\x04\x19\x02\x0f\x03\x12\x04\x83\x06.0\n\xda\x01\n\x02\x04\x1a\x12\
    \x06\x89\x06\0\xa5\x06\x01\x1a\xcb\x01\x20OwnerReference\x20contains\x20\
    enough\x20information\x20to\x20let\x20you\x20identify\x20an\x20owning\n\
    \x20object.\x20An\x20owning\x20object\x20must\x20be\x20in\x20the\x20same\
    \x20namespace\x20as\x20the\x20dependent,\x20or\n\x20be\x20cluster-scoped\
    ,\x20so\x20there\x20is\x20no\x20namespace\x20field.\n\n\x0b\n\x03\x04\
    \x1a\x01\x12\x04\x89\x06\x08\x16\n,\n\x04\x04\x1a\x02\0\x12\x04\x8b\x06\
    \x02!\x1a\x1e\x20API\x20version\x20of\x20the\x20referent.\n\n\r\n\x05\
    \x04\x1a\x02\0\x04\x12\x04\x8b\x06\x02\n\n\r\n\x05\x04\x1a\x02\0\x05\x12\
    \x04\x8b\x06\x0b\x11\n\r\n\x05\x04\x1a\x02\0\x01\x12\x04\x8b\x06\x12\x1c\
    \n\r\n\x05\x04\x1a\x02\0\x03\x12\x04\x8b\x06\x1f\x20\n\x92\x01\n\x04\x04\
    \x1a\x02\x01\x12\x04\x8f\x06\x02\x1b\x1a\x83\x01\x20Kind\x20of\x20the\
    \x20referent.\n\x20More\x20info:\x20https://git.k8s.io/community/contrib\
    utors/devel/sig-architecture/api-conventions.md#types-kinds\n\n\r\n\x05\
    \x04\x1a\x02\x01\x04\x12\x04\x8f\x06\x02\n\n\r\n\x05\x04\x1a\x02\x01\x05\
    \x12\x04\x8f\x06\x0b\x11\n\r\n\x05\x04\x1a\x02\x01\x01\x12\x04\x8f\x06\
    \x12\x16\n\r\n\x05\x04\x1a\x02\x01\x03\x12\x04\x8f\x06\x19\x1a\nh\n\x04\
    \x04\x1a\x02\x02\x12\x04\x93\x06\x02\x1b\x1aZ\x20Name\x20of\x20the\x20re\
    ferent.\n\x20More\x20info:\x20http://kubernetes.io/docs/user-guide/ident\
    ifiers#names\n\n\r\n\x05\x04\x1a\x02\x02\x04\x12\x04\x93\x06\x02\n\n\r\n\
    \x05\x04\x1a\x02\x02\x05\x12\x04\x93\x06\x0b\x11\n\r\n\x05\x04\x1a\x02\
    \x02\x01\x12\x04\x93\x06\x12\x16\n\r\n\x05\x04\x1a\x02\x02\x03\x12\x04\
    \x93\x06\x19\x1a\nf\n\x04\x04\x1a\x02\x03\x12\x04\x97\x06\x02\x1a\x1aX\
    \x20UID\x20of\x20the\x20referent.\n\x20More\x20info:\x20http://kubernete\
    s.io/docs/user-guide/identifiers#uids\n\n\r\n\x05\x04\x1a\x02\x03\x04\
    \x12\x04\x97\x06\x02\n\n\r\n\x05\x04\x1a\x02\x03\x05\x12\x04\x97\x06\x0b\
    \x11\n\r\n\x05\x04\x1a\x02\x03\x01\x12\x04\x97\x06\x12\x15\n\r\n\x05\x04\
    \x1a\x02\x03\x03\x12\x04\x97\x06\x18\x19\nU\n\x04\x04\x1a\x02\x04\x12\
    \x04\x9b\x06\x02\x1f\x1aG\x20If\x20true,\x20this\x20reference\x20points\
    \x20to\x20the\x20managing\x20controller.\n\x20+optional\n\n\r\n\x05\x04\
    \x1a\x02\x04\x04\x12\x04\x9b\x06\x02\n\n\r\n\x05\x04\x1a\x02\x04\x05\x12\
    \x04\x9b\x06\x0b\x0f\n\r\n\x05\x04\x1a\x02\x04\x01\x12\x04\x9b\x06\x10\
    \x1a\n\r\n\x05\x04\x1a\x02\x04\x03\x12\x04\x9b\x06\x1d\x1e\n\xc9\x02\n\
    \x04\x04\x1a\x02\x05\x12\x04\xa4\x06\x02'\x1a\xba\x02\x20If\x20true,\x20\
    AND\x20if\x20the\x20owner\x20has\x20the\x20\"foregroundDeletion\"\x20fin\
    alizer,\x20then\n\x20the\x20owner\x20cannot\x20be\x20deleted\x20from\x20\
    the\x20key-value\x20store\x20until\x20this\n\x20reference\x20is\x20remov\
    ed.\n\x20Defaults\x20to\x20false.\n\x20To\x20set\x20this\x20field,\x20a\
    \x20user\x20needs\x20\"delete\"\x20permission\x20of\x20the\x20owner,\n\
    \x20otherwise\x20422\x20(Unprocessable\x20Entity)\x20will\x20be\x20retur\
    ned.\n\x20+optional\n\n\r\n\x05\x04\x1a\x02\x05\x04\x12\x04\xa4\x06\x02\
    \n\n\r\n\x05\x04\x1a\x02\x05\x05\x12\x04\xa4\x06\x0b\x0f\n\r\n\x05\x04\
    \x1a\x02\x05\x01\x12\x04\xa4\x06\x10\"\n\r\n\x05\x04\x1a\x02\x05\x03\x12\
    \x04\xa4\x06%&\n\x95\x02\n\x02\x04\x1b\x12\x06\xaa\x06\0\xaf\x06\x01\x1a\
    \x86\x02\x20PartialObjectMetadata\x20is\x20a\x20generic\x20representatio\
    n\x20of\x20any\x20object\x20with\x20ObjectMeta.\x20It\x20allows\x20clien\
    ts\n\x20to\x20get\x20access\x20to\x20a\x20particular\x20ObjectMeta\x20sc\
    hema\x20without\x20knowing\x20the\x20details\x20of\x20the\x20version.\n\
    \x20+k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object\
    \n\n\x0b\n\x03\x04\x1b\x01\x12\x04\xaa\x06\x08\x1d\n\xa0\x01\n\x04\x04\
    \x1b\x02\0\x12\x04\xae\x06\x02#\x1a\x91\x01\x20Standard\x20object's\x20m\
    etadata.\n\x20More\x20info:\x20https://git.k8s.io/community/contributors\
    /devel/sig-architecture/api-conventions.md#metadata\n\x20+optional\n\n\r\
    \n\x05\x04\x1b\x02\0\x04\x12\x04\xae\x06\x02\n\n\r\n\x05\x04\x1b\x02\0\
    \x06\x12\x04\xae\x06\x0b\x15\n\r\n\x05\x04\x1b\x02\0\x01\x12\x04\xae\x06\
    \x16\x1e\n\r\n\x05\x04\x1b\x02\0\x03\x12\x04\xae\x06!\"\n\xa9\x01\n\x02\
    \x04\x1c\x12\x06\xb3\x06\0\xbb\x06\x01\x1a\x9a\x01\x20PartialObjectMetad\
    ataList\x20contains\x20a\x20list\x20of\x20objects\x20containing\x20only\
    \x20their\x20metadata\n\x20+k8s:deepcopy-gen:interfaces=k8s.io/apimachin\
    ery/pkg/runtime.Object\n\n\x0b\n\x03\x04\x1c\x01\x12\x04\xb3\x06\x08!\n\
    \x9f\x01\n\x04\x04\x1c\x02\0\x12\x04\xb7\x06\x02!\x1a\x90\x01\x20Standar\
    d\x20list\x20metadata.\n\x20More\x20info:\x20https://git.k8s.io/communit\
    y/contributors/devel/sig-architecture/api-conventions.md#types-kinds\n\
    \x20+optional\n\n\r\n\x05\x04\x1c\x02\0\x04\x12\x04\xb7\x06\x02\n\n\r\n\
    \x05\x04\x1c\x02\0\x06\x12\x04\xb7\x06\x0b\x13\n\r\n\x05\x04\x1c\x02\0\
    \x01\x12\x04\xb7\x06\x14\x1c\n\r\n\x05\x04\x1c\x02\0\x03\x12\x04\xb7\x06\
    \x1f\x20\n:\n\x04\x04\x1c\x02\x01\x12\x04\xba\x06\x02+\x1a,\x20items\x20\
    contains\x20each\x20of\x20the\x20included\x20items.\n\n\r\n\x05\x04\x1c\
    \x02\x01\x04\x12\x04\xba\x06\x02\n\n\r\n\x05\x04\x1c\x02\x01\x06\x12\x04\
    \xba\x06\x0b\x20\n\r\n\x05\x04\x1c\x02\x01\x01\x12\x04\xba\x06!&\n\r\n\
    \x05\x04\x1c\x02\x01\x03\x12\x04\xba\x06)*\nh\n\x02\x04\x1d\x12\x06\xbe\
    \x06\0\xbf\x06\x01\x1aZ\x20Patch\x20is\x20provided\x20to\x20give\x20a\
    \x20concrete\x20name\x20and\x20type\x20to\x20the\x20Kubernetes\x20PATCH\
    \x20request\x20body.\n\n\x0b\n\x03\x04\x1d\x01\x12\x04\xbe\x06\x08\r\n\
    \x83\x01\n\x02\x04\x1e\x12\x06\xc3\x06\0\xdb\x06\x01\x1au\x20PatchOption\
    s\x20may\x20be\x20provided\x20when\x20patching\x20an\x20API\x20object.\n\
    \x20PatchOptions\x20is\x20meant\x20to\x20be\x20a\x20superset\x20of\x20Up\
    dateOptions.\n\n\x0b\n\x03\x04\x1e\x01\x12\x04\xc3\x06\x08\x14\n\x98\x02\
    \n\x04\x04\x1e\x02\0\x12\x04\xca\x06\x02\x1d\x1a\x89\x02\x20When\x20pres\
    ent,\x20indicates\x20that\x20modifications\x20should\x20not\x20be\n\x20p\
    ersisted.\x20An\x20invalid\x20or\x20unrecognized\x20dryRun\x20directive\
    \x20will\n\x20result\x20in\x20an\x20error\x20response\x20and\x20no\x20fu\
    rther\x20processing\x20of\x20the\n\x20request.\x20Valid\x20values\x20are\
    :\n\x20-\x20All:\x20all\x20dry\x20run\x20stages\x20will\x20be\x20process\
    ed\n\x20+optional\n\n\r\n\x05\x04\x1e\x02\0\x04\x12\x04\xca\x06\x02\n\n\
    \r\n\x05\x04\x1e\x02\0\x05\x12\x04\xca\x06\x0b\x11\n\r\n\x05\x04\x1e\x02\
    \0\x01\x12\x04\xca\x06\x12\x18\n\r\n\x05\x04\x1e\x02\0\x03\x12\x04\xca\
    \x06\x1b\x1c\n\xc6\x01\n\x04\x04\x1e\x02\x01\x12\x04\xd0\x06\x02\x1a\x1a\
    \xb7\x01\x20Force\x20is\x20going\x20to\x20\"force\"\x20Apply\x20requests\
    .\x20It\x20means\x20user\x20will\n\x20re-acquire\x20conflicting\x20field\
    s\x20owned\x20by\x20other\x20people.\x20Force\n\x20flag\x20must\x20be\
    \x20unset\x20for\x20non-apply\x20patch\x20requests.\n\x20+optional\n\n\r\
    \n\x05\x04\x1e\x02\x01\x04\x12\x04\xd0\x06\x02\n\n\r\n\x05\x04\x1e\x02\
    \x01\x05\x12\x04\xd0\x06\x0b\x0f\n\r\n\x05\x04\x1e\x02\x01\x01\x12\x04\
    \xd0\x06\x10\x15\n\r\n\x05\x04\x1e\x02\x01\x03\x12\x04\xd0\x06\x18\x19\n\
    \xa5\x03\n\x04\x04\x1e\x02\x02\x12\x04\xda\x06\x02#\x1a\x96\x03\x20field\
    Manager\x20is\x20a\x20name\x20associated\x20with\x20the\x20actor\x20or\
    \x20entity\n\x20that\x20is\x20making\x20these\x20changes.\x20The\x20valu\
    e\x20must\x20be\x20less\x20than\x20or\n\x20128\x20characters\x20long,\
    \x20and\x20only\x20contain\x20printable\x20characters,\n\x20as\x20define\
    d\x20by\x20https://golang.org/pkg/unicode/#IsPrint.\x20This\n\x20field\
    \x20is\x20required\x20for\x20apply\x20requests\n\x20(application/apply-p\
    atch)\x20but\x20optional\x20for\x20non-apply\x20patch\n\x20types\x20(Jso\
    nPatch,\x20MergePatch,\x20StrategicMergePatch).\n\x20+optional\n\n\r\n\
    \x05\x04\x1e\x02\x02\x04\x12\x04\xda\x06\x02\n\n\r\n\x05\x04\x1e\x02\x02\
    \x05\x12\x04\xda\x06\x0b\x11\n\r\n\x05\x04\x1e\x02\x02\x01\x12\x04\xda\
    \x06\x12\x1e\n\r\n\x05\x04\x1e\x02\x02\x03\x12\x04\xda\x06!\"\nj\n\x02\
    \x04\x1f\x12\x06\xde\x06\0\xe6\x06\x01\x1a\\\x20Preconditions\x20must\
    \x20be\x20fulfilled\x20before\x20an\x20operation\x20(update,\x20delete,\
    \x20etc.)\x20is\x20carried\x20out.\n\n\x0b\n\x03\x04\x1f\x01\x12\x04\xde\
    \x06\x08\x15\n4\n\x04\x04\x1f\x02\0\x12\x04\xe1\x06\x02\x1a\x1a&\x20Spec\
    ifies\x20the\x20target\x20UID.\n\x20+optional\n\n\r\n\x05\x04\x1f\x02\0\
    \x04\x12\x04\xe1\x06\x02\n\n\r\n\x05\x04\x1f\x02\0\x05\x12\x04\xe1\x06\
    \x0b\x11\n\r\n\x05\x04\x1f\x02\0\x01\x12\x04\xe1\x06\x12\x15\n\r\n\x05\
    \x04\x1f\x02\0\x03\x12\x04\xe1\x06\x18\x19\n?\n\x04\x04\x1f\x02\x01\x12\
    \x04\xe5\x06\x02&\x1a1\x20Specifies\x20the\x20target\x20ResourceVersion\
    \n\x20+optional\n\n\r\n\x05\x04\x1f\x02\x01\x04\x12\x04\xe5\x06\x02\n\n\
    \r\n\x05\x04\x1f\x02\x01\x05\x12\x04\xe5\x06\x0b\x11\n\r\n\x05\x04\x1f\
    \x02\x01\x01\x12\x04\xe5\x06\x12!\n\r\n\x05\x04\x1f\x02\x01\x03\x12\x04\
    \xe5\x06$%\n_\n\x02\x04\x20\x12\x06\xea\x06\0\xed\x06\x01\x1aQ\x20RootPa\
    ths\x20lists\x20the\x20paths\x20available\x20at\x20root.\n\x20For\x20exa\
    mple:\x20\"/healthz\",\x20\"/apis\".\n\n\x0b\n\x03\x04\x20\x01\x12\x04\
    \xea\x06\x08\x11\n6\n\x04\x04\x20\x02\0\x12\x04\xec\x06\x02\x1c\x1a(\x20\
    paths\x20are\x20the\x20paths\x20available\x20at\x20root.\n\n\r\n\x05\x04\
    \x20\x02\0\x04\x12\x04\xec\x06\x02\n\n\r\n\x05\x04\x20\x02\0\x05\x12\x04\
    \xec\x06\x0b\x11\n\r\n\x05\x04\x20\x02\0\x01\x12\x04\xec\x06\x12\x17\n\r\
    \n\x05\x04\x20\x02\0\x03\x12\x04\xec\x06\x1a\x1b\n\x9e\x01\n\x02\x04!\
    \x12\x06\xf0\x06\0\xf7\x06\x01\x1a\x8f\x01\x20ServerAddressByClientCIDR\
    \x20helps\x20the\x20client\x20to\x20determine\x20the\x20server\x20addres\
    s\x20that\x20they\x20should\x20use,\x20depending\x20on\x20the\x20clientC\
    IDR\x20that\x20they\x20match.\n\n\x0b\n\x03\x04!\x01\x12\x04\xf0\x06\x08\
    !\nu\n\x04\x04!\x02\0\x12\x04\xf2\x06\x02!\x1ag\x20The\x20CIDR\x20with\
    \x20which\x20clients\x20can\x20match\x20their\x20IP\x20to\x20figure\x20o\
    ut\x20the\x20server\x20address\x20that\x20they\x20should\x20use.\n\n\r\n\
    \x05\x04!\x02\0\x04\x12\x04\xf2\x06\x02\n\n\r\n\x05\x04!\x02\0\x05\x12\
    \x04\xf2\x06\x0b\x11\n\r\n\x05\x04!\x02\0\x01\x12\x04\xf2\x06\x12\x1c\n\
    \r\n\x05\x04!\x02\0\x03\x12\x04\xf2\x06\x1f\x20\n\x92\x01\n\x04\x04!\x02\
    \x01\x12\x04\xf6\x06\x02$\x1a\x83\x01\x20Address\x20of\x20this\x20server\
    ,\x20suitable\x20for\x20a\x20client\x20that\x20matches\x20the\x20above\
    \x20CIDR.\n\x20This\x20can\x20be\x20a\x20hostname,\x20hostname:port,\x20\
    IP\x20or\x20IP:port.\n\n\r\n\x05\x04!\x02\x01\x04\x12\x04\xf6\x06\x02\n\
    \n\r\n\x05\x04!\x02\x01\x05\x12\x04\xf6\x06\x0b\x11\n\r\n\x05\x04!\x02\
    \x01\x01\x12\x04\xf6\x06\x12\x1f\n\r\n\x05\x04!\x02\x01\x03\x12\x04\xf6\
    \x06\"#\nS\n\x02\x04\"\x12\x06\xfa\x06\0\x9b\x07\x01\x1aE\x20Status\x20i\
    s\x20a\x20return\x20value\x20for\x20calls\x20that\x20don't\x20return\x20\
    other\x20objects.\n\n\x0b\n\x03\x04\"\x01\x12\x04\xfa\x06\x08\x0e\n\x9f\
    \x01\n\x04\x04\"\x02\0\x12\x04\xfe\x06\x02!\x1a\x90\x01\x20Standard\x20l\
    ist\x20metadata.\n\x20More\x20info:\x20https://git.k8s.io/community/cont\
    ributors/devel/sig-architecture/api-conventions.md#types-kinds\n\x20+opt\
    ional\n\n\r\n\x05\x04\"\x02\0\x04\x12\x04\xfe\x06\x02\n\n\r\n\x05\x04\"\
    \x02\0\x06\x12\x04\xfe\x06\x0b\x13\n\r\n\x05\x04\"\x02\0\x01\x12\x04\xfe\
    \x06\x14\x1c\n\r\n\x05\x04\"\x02\0\x03\x12\x04\xfe\x06\x1f\x20\n\xc5\x01\
    \n\x04\x04\"\x02\x01\x12\x04\x84\x07\x02\x1d\x1a\xb6\x01\x20Status\x20of\
    \x20the\x20operation.\n\x20One\x20of:\x20\"Success\"\x20or\x20\"Failure\
    \".\n\x20More\x20info:\x20https://git.k8s.io/community/contributors/deve\
    l/sig-architecture/api-conventions.md#spec-and-status\n\x20+optional\n\n\
    \r\n\x05\x04\"\x02\x01\x04\x12\x04\x84\x07\x02\n\n\r\n\x05\x04\"\x02\x01\
    \x05\x12\x04\x84\x07\x0b\x11\n\r\n\x05\x04\"\x02\x01\x01\x12\x04\x84\x07\
    \x12\x18\n\r\n\x05\x04\"\x02\x01\x03\x12\x04\x84\x07\x1b\x1c\nX\n\x04\
    \x04\"\x02\x02\x12\x04\x88\x07\x02\x1e\x1aJ\x20A\x20human-readable\x20de\
    scription\x20of\x20the\x20status\x20of\x20this\x20operation.\n\x20+optio\
    nal\n\n\r\n\x05\x04\"\x02\x02\x04\x12\x04\x88\x07\x02\n\n\r\n\x05\x04\"\
    \x02\x02\x05\x12\x04\x88\x07\x0b\x11\n\r\n\x05\x04\"\x02\x02\x01\x12\x04\
    \x88\x07\x12\x19\n\r\n\x05\x04\"\x02\x02\x03\x12\x04\x88\x07\x1c\x1d\n\
    \xea\x01\n\x04\x04\"\x02\x03\x12\x04\x8f\x07\x02\x1d\x1a\xdb\x01\x20A\
    \x20machine-readable\x20description\x20of\x20why\x20this\x20operation\
    \x20is\x20in\x20the\n\x20\"Failure\"\x20status.\x20If\x20this\x20value\
    \x20is\x20empty\x20there\n\x20is\x20no\x20information\x20available.\x20A\
    \x20Reason\x20clarifies\x20an\x20HTTP\x20status\n\x20code\x20but\x20does\
    \x20not\x20override\x20it.\n\x20+optional\n\n\r\n\x05\x04\"\x02\x03\x04\
    \x12\x04\x8f\x07\x02\n\n\r\n\x05\x04\"\x02\x03\x05\x12\x04\x8f\x07\x0b\
    \x11\n\r\n\x05\x04\"\x02\x03\x01\x12\x04\x8f\x07\x12\x18\n\r\n\x05\x04\"\
    \x02\x03\x03\x12\x04\x8f\x07\x1b\x1c\n\xfa\x01\n\x04\x04\"\x02\x04\x12\
    \x04\x96\x07\x02%\x1a\xeb\x01\x20Extended\x20data\x20associated\x20with\
    \x20the\x20reason.\x20\x20Each\x20reason\x20may\x20define\x20its\n\x20ow\
    n\x20extended\x20details.\x20This\x20field\x20is\x20optional\x20and\x20t\
    he\x20data\x20returned\n\x20is\x20not\x20guaranteed\x20to\x20conform\x20\
    to\x20any\x20schema\x20except\x20that\x20defined\x20by\n\x20the\x20reaso\
    n\x20type.\n\x20+optional\n\n\r\n\x05\x04\"\x02\x04\x04\x12\x04\x96\x07\
    \x02\n\n\r\n\x05\x04\"\x02\x04\x06\x12\x04\x96\x07\x0b\x18\n\r\n\x05\x04\
    \"\x02\x04\x01\x12\x04\x96\x07\x19\x20\n\r\n\x05\x04\"\x02\x04\x03\x12\
    \x04\x96\x07#$\nT\n\x04\x04\"\x02\x05\x12\x04\x9a\x07\x02\x1a\x1aF\x20Su\
    ggested\x20HTTP\x20return\x20code\x20for\x20this\x20status,\x200\x20if\
    \x20not\x20set.\n\x20+optional\n\n\r\n\x05\x04\"\x02\x05\x04\x12\x04\x9a\
    \x07\x02\n\n\r\n\x05\x04\"\x02\x05\x05\x12\x04\x9a\x07\x0b\x10\n\r\n\x05\
    \x04\"\x02\x05\x01\x12\x04\x9a\x07\x11\x15\n\r\n\x05\x04\"\x02\x05\x03\
    \x12\x04\x9a\x07\x18\x19\n\x89\x01\n\x02\x04#\x12\x06\x9f\x07\0\xb5\x07\
    \x01\x1a{\x20StatusCause\x20provides\x20more\x20information\x20about\x20\
    an\x20api.Status\x20failure,\x20including\n\x20cases\x20when\x20multiple\
    \x20errors\x20are\x20encountered.\n\n\x0b\n\x03\x04#\x01\x12\x04\x9f\x07\
    \x08\x13\n\x90\x01\n\x04\x04#\x02\0\x12\x04\xa3\x07\x02\x1d\x1a\x81\x01\
    \x20A\x20machine-readable\x20description\x20of\x20the\x20cause\x20of\x20\
    the\x20error.\x20If\x20this\x20value\x20is\n\x20empty\x20there\x20is\x20\
    no\x20information\x20available.\n\x20+optional\n\n\r\n\x05\x04#\x02\0\
    \x04\x12\x04\xa3\x07\x02\n\n\r\n\x05\x04#\x02\0\x05\x12\x04\xa3\x07\x0b\
    \x11\n\r\n\x05\x04#\x02\0\x01\x12\x04\xa3\x07\x12\x18\n\r\n\x05\x04#\x02\
    \0\x03\x12\x04\xa3\x07\x1b\x1c\n\x83\x01\n\x04\x04#\x02\x01\x12\x04\xa8\
    \x07\x02\x1e\x1au\x20A\x20human-readable\x20description\x20of\x20the\x20\
    cause\x20of\x20the\x20error.\x20\x20This\x20field\x20may\x20be\n\x20pres\
    ented\x20as-is\x20to\x20a\x20reader.\n\x20+optional\n\n\r\n\x05\x04#\x02\
    \x01\x04\x12\x04\xa8\x07\x02\n\n\r\n\x05\x04#\x02\x01\x05\x12\x04\xa8\
    \x07\x0b\x11\n\r\n\x05\x04#\x02\x01\x01\x12\x04\xa8\x07\x12\x19\n\r\n\
    \x05\x04#\x02\x01\x03\x12\x04\xa8\x07\x1c\x1d\n\xc1\x03\n\x04\x04#\x02\
    \x02\x12\x04\xb4\x07\x02\x1c\x1a\xb2\x03\x20The\x20field\x20of\x20the\
    \x20resource\x20that\x20has\x20caused\x20this\x20error,\x20as\x20named\
    \x20by\x20its\x20JSON\n\x20serialization.\x20May\x20include\x20dot\x20an\
    d\x20postfix\x20notation\x20for\x20nested\x20attributes.\n\x20Arrays\x20\
    are\x20zero-indexed.\x20\x20Fields\x20may\x20appear\x20more\x20than\x20o\
    nce\x20in\x20an\x20array\x20of\n\x20causes\x20due\x20to\x20fields\x20hav\
    ing\x20multiple\x20errors.\n\x20Optional.\n\n\x20Examples:\n\x20\x20\x20\
    \"name\"\x20-\x20the\x20field\x20\"name\"\x20on\x20the\x20current\x20res\
    ource\n\x20\x20\x20\"items[0].name\"\x20-\x20the\x20field\x20\"name\"\
    \x20on\x20the\x20first\x20array\x20entry\x20in\x20\"items\"\n\x20+option\
    al\n\n\r\n\x05\x04#\x02\x02\x04\x12\x04\xb4\x07\x02\n\n\r\n\x05\x04#\x02\
    \x02\x05\x12\x04\xb4\x07\x0b\x11\n\r\n\x05\x04#\x02\x02\x01\x12\x04\xb4\
    \x07\x12\x17\n\r\n\x05\x04#\x02\x02\x03\x12\x04\xb4\x07\x1a\x1b\n\xff\
    \x02\n\x02\x04$\x12\x06\xbd\x07\0\xdd\x07\x01\x1a\xf0\x02\x20StatusDetai\
    ls\x20is\x20a\x20set\x20of\x20additional\x20properties\x20that\x20MAY\
    \x20be\x20set\x20by\x20the\n\x20server\x20to\x20provide\x20additional\
    \x20information\x20about\x20a\x20response.\x20The\x20Reason\n\x20field\
    \x20of\x20a\x20Status\x20object\x20defines\x20what\x20attributes\x20will\
    \x20be\x20set.\x20Clients\n\x20must\x20ignore\x20fields\x20that\x20do\
    \x20not\x20match\x20the\x20defined\x20type\x20of\x20each\x20attribute,\n\
    \x20and\x20should\x20assume\x20that\x20any\x20attribute\x20may\x20be\x20\
    empty,\x20invalid,\x20or\x20under\n\x20defined.\n\n\x0b\n\x03\x04$\x01\
    \x12\x04\xbd\x07\x08\x15\n\x9d\x01\n\x04\x04$\x02\0\x12\x04\xc1\x07\x02\
    \x1b\x1a\x8e\x01\x20The\x20name\x20attribute\x20of\x20the\x20resource\
    \x20associated\x20with\x20the\x20status\x20StatusReason\n\x20(when\x20th\
    ere\x20is\x20a\x20single\x20name\x20which\x20can\x20be\x20described).\n\
    \x20+optional\n\n\r\n\x05\x04$\x02\0\x04\x12\x04\xc1\x07\x02\n\n\r\n\x05\
    \x04$\x02\0\x05\x12\x04\xc1\x07\x0b\x11\n\r\n\x05\x04$\x02\0\x01\x12\x04\
    \xc1\x07\x12\x16\n\r\n\x05\x04$\x02\0\x03\x12\x04\xc1\x07\x19\x1a\ng\n\
    \x04\x04$\x02\x01\x12\x04\xc5\x07\x02\x1c\x1aY\x20The\x20group\x20attrib\
    ute\x20of\x20the\x20resource\x20associated\x20with\x20the\x20status\x20S\
    tatusReason.\n\x20+optional\n\n\r\n\x05\x04$\x02\x01\x04\x12\x04\xc5\x07\
    \x02\n\n\r\n\x05\x04$\x02\x01\x05\x12\x04\xc5\x07\x0b\x11\n\r\n\x05\x04$\
    \x02\x01\x01\x12\x04\xc5\x07\x12\x17\n\r\n\x05\x04$\x02\x01\x03\x12\x04\
    \xc5\x07\x1a\x1b\n\x94\x02\n\x04\x04$\x02\x02\x12\x04\xcb\x07\x02\x1b\
    \x1a\x85\x02\x20The\x20kind\x20attribute\x20of\x20the\x20resource\x20ass\
    ociated\x20with\x20the\x20status\x20StatusReason.\n\x20On\x20some\x20ope\
    rations\x20may\x20differ\x20from\x20the\x20requested\x20resource\x20Kind\
    .\n\x20More\x20info:\x20https://git.k8s.io/community/contributors/devel/\
    sig-architecture/api-conventions.md#types-kinds\n\x20+optional\n\n\r\n\
    \x05\x04$\x02\x02\x04\x12\x04\xcb\x07\x02\n\n\r\n\x05\x04$\x02\x02\x05\
    \x12\x04\xcb\x07\x0b\x11\n\r\n\x05\x04$\x02\x02\x01\x12\x04\xcb\x07\x12\
    \x16\n\r\n\x05\x04$\x02\x02\x03\x12\x04\xcb\x07\x19\x1a\n\xad\x01\n\x04\
    \x04$\x02\x03\x12\x04\xd1\x07\x02\x1a\x1a\x9e\x01\x20UID\x20of\x20the\
    \x20resource.\n\x20(when\x20there\x20is\x20a\x20single\x20resource\x20wh\
    ich\x20can\x20be\x20described).\n\x20More\x20info:\x20http://kubernetes.\
    io/docs/user-guide/identifiers#uids\n\x20+optional\n\n\r\n\x05\x04$\x02\
    \x03\x04\x12\x04\xd1\x07\x02\n\n\r\n\x05\x04$\x02\x03\x05\x12\x04\xd1\
    \x07\x0b\x11\n\r\n\x05\x04$\x02\x03\x01\x12\x04\xd1\x07\x12\x15\n\r\n\
    \x05\x04$\x02\x03\x03\x12\x04\xd1\x07\x18\x19\n\xa0\x01\n\x04\x04$\x02\
    \x04\x12\x04\xd6\x07\x02\"\x1a\x91\x01\x20The\x20Causes\x20array\x20incl\
    udes\x20more\x20details\x20associated\x20with\x20the\x20StatusReason\n\
    \x20failure.\x20Not\x20all\x20StatusReasons\x20may\x20provide\x20detaile\
    d\x20causes.\n\x20+optional\n\n\r\n\x05\x04$\x02\x04\x04\x12\x04\xd6\x07\
    \x02\n\n\r\n\x05\x04$\x02\x04\x06\x12\x04\xd6\x07\x0b\x16\n\r\n\x05\x04$\
    \x02\x04\x01\x12\x04\xd6\x07\x17\x1d\n\r\n\x05\x04$\x02\x04\x03\x12\x04\
    \xd6\x07\x20!\n\x89\x02\n\x04\x04$\x02\x05\x12\x04\xdc\x07\x02'\x1a\xfa\
    \x01\x20If\x20specified,\x20the\x20time\x20in\x20seconds\x20before\x20th\
    e\x20operation\x20should\x20be\x20retried.\x20Some\x20errors\x20may\x20i\
    ndicate\n\x20the\x20client\x20must\x20take\x20an\x20alternate\x20action\
    \x20-\x20for\x20those\x20errors\x20this\x20field\x20may\x20indicate\x20h\
    ow\x20long\x20to\x20wait\n\x20before\x20taking\x20the\x20alternate\x20ac\
    tion.\n\x20+optional\n\n\r\n\x05\x04$\x02\x05\x04\x12\x04\xdc\x07\x02\n\
    \n\r\n\x05\x04$\x02\x05\x05\x12\x04\xdc\x07\x0b\x10\n\r\n\x05\x04$\x02\
    \x05\x01\x12\x04\xdc\x07\x11\"\n\r\n\x05\x04$\x02\x05\x03\x12\x04\xdc\
    \x07%&\n\x94\x01\n\x02\x04%\x12\x06\xe1\x07\0\xe7\x07\x01\x1a\x85\x01\
    \x20TableOptions\x20are\x20used\x20when\x20a\x20Table\x20is\x20requested\
    \x20by\x20the\x20caller.\n\x20+k8s:deepcopy-gen:interfaces=k8s.io/apimac\
    hinery/pkg/runtime.Object\n\n\x0b\n\x03\x04%\x01\x12\x04\xe1\x07\x08\x14\
    \n\xed\x02\n\x04\x04%\x02\0\x12\x04\xe6\x07\x02$\x1a\xde\x02\x20includeO\
    bject\x20decides\x20whether\x20to\x20include\x20each\x20object\x20along\
    \x20with\x20its\x20columnar\x20information.\n\x20Specifying\x20\"None\"\
    \x20will\x20return\x20no\x20object,\x20specifying\x20\"Object\"\x20will\
    \x20return\x20the\x20full\x20object\x20contents,\x20and\n\x20specifying\
    \x20\"Metadata\"\x20(the\x20default)\x20will\x20return\x20the\x20object'\
    s\x20metadata\x20in\x20the\x20PartialObjectMetadata\x20kind\n\x20in\x20v\
    ersion\x20v1beta1\x20of\x20the\x20meta.k8s.io\x20API\x20group.\n\n\r\n\
    \x05\x04%\x02\0\x04\x12\x04\xe6\x07\x02\n\n\r\n\x05\x04%\x02\0\x05\x12\
    \x04\xe6\x07\x0b\x11\n\r\n\x05\x04%\x02\0\x01\x12\x04\xe6\x07\x12\x1f\n\
    \r\n\x05\x04%\x02\0\x03\x12\x04\xe6\x07\"#\n\xae\x02\n\x02\x04&\x12\x06\
    \xf0\x07\0\xfb\x07\x01\x1a\x9f\x02\x20Time\x20is\x20a\x20wrapper\x20arou\
    nd\x20time.Time\x20which\x20supports\x20correct\n\x20marshaling\x20to\
    \x20YAML\x20and\x20JSON.\x20\x20Wrappers\x20are\x20provided\x20for\x20ma\
    ny\n\x20of\x20the\x20factory\x20methods\x20that\x20the\x20time\x20packag\
    e\x20offers.\n\n\x20+protobuf.options.marshal=false\n\x20+protobuf.as=Ti\
    mestamp\n\x20+protobuf.options.(gogoproto.goproto_stringer)=false\n\n\
    \x0b\n\x03\x04&\x01\x12\x04\xf0\x07\x08\x0c\n\x9d\x01\n\x04\x04&\x02\0\
    \x12\x04\xf4\x07\x02\x1d\x1a\x8e\x01\x20Represents\x20seconds\x20of\x20U\
    TC\x20time\x20since\x20Unix\x20epoch\n\x201970-01-01T00:00:00Z.\x20Must\
    \x20be\x20from\x200001-01-01T00:00:00Z\x20to\n\x209999-12-31T23:59:59Z\
    \x20inclusive.\n\n\r\n\x05\x04&\x02\0\x04\x12\x04\xf4\x07\x02\n\n\r\n\
    \x05\x04&\x02\0\x05\x12\x04\xf4\x07\x0b\x10\n\r\n\x05\x04&\x02\0\x01\x12\
    \x04\xf4\x07\x11\x18\n\r\n\x05\x04&\x02\0\x03\x12\x04\xf4\x07\x1b\x1c\n\
    \xa2\x02\n\x04\x04&\x02\x01\x12\x04\xfa\x07\x02\x1b\x1a\x93\x02\x20Non-n\
    egative\x20fractions\x20of\x20a\x20second\x20at\x20nanosecond\x20resolut\
    ion.\x20Negative\n\x20second\x20values\x20with\x20fractions\x20must\x20s\
    till\x20have\x20non-negative\x20nanos\x20values\n\x20that\x20count\x20fo\
    rward\x20in\x20time.\x20Must\x20be\x20from\x200\x20to\x20999,999,999\n\
    \x20inclusive.\x20This\x20field\x20may\x20be\x20limited\x20in\x20precisi\
    on\x20depending\x20on\x20context.\n\n\r\n\x05\x04&\x02\x01\x04\x12\x04\
    \xfa\x07\x02\n\n\r\n\x05\x04&\x02\x01\x05\x12\x04\xfa\x07\x0b\x10\n\r\n\
    \x05\x04&\x02\x01\x01\x12\x04\xfa\x07\x11\x16\n\r\n\x05\x04&\x02\x01\x03\
    \x12\x04\xfa\x07\x19\x1a\n\xcb\x01\n\x02\x04'\x12\x06\x80\x08\0\x8b\x08\
    \x01\x1a\xbc\x01\x20Timestamp\x20is\x20a\x20struct\x20that\x20is\x20equi\
    valent\x20to\x20Time,\x20but\x20intended\x20for\n\x20protobuf\x20marshal\
    ling/unmarshalling.\x20It\x20is\x20generated\x20into\x20a\x20serializati\
    on\n\x20that\x20matches\x20Time.\x20Do\x20not\x20use\x20in\x20Go\x20stru\
    cts.\n\n\x0b\n\x03\x04'\x01\x12\x04\x80\x08\x08\x11\n\x9d\x01\n\x04\x04'\
    \x02\0\x12\x04\x84\x08\x02\x1d\x1a\x8e\x01\x20Represents\x20seconds\x20o\
    f\x20UTC\x20time\x20since\x20Unix\x20epoch\n\x201970-01-01T00:00:00Z.\
    \x20Must\x20be\x20from\x200001-01-01T00:00:00Z\x20to\n\x209999-12-31T23:\
    59:59Z\x20inclusive.\n\n\r\n\x05\x04'\x02\0\x04\x12\x04\x84\x08\x02\n\n\
    \r\n\x05\x04'\x02\0\x05\x12\x04\x84\x08\x0b\x10\n\r\n\x05\x04'\x02\0\x01\
    \x12\x04\x84\x08\x11\x18\n\r\n\x05\x04'\x02\0\x03\x12\x04\x84\x08\x1b\
    \x1c\n\xa2\x02\n\x04\x04'\x02\x01\x12\x04\x8a\x08\x02\x1b\x1a\x93\x02\
    \x20Non-negative\x20fractions\x20of\x20a\x20second\x20at\x20nanosecond\
    \x20resolution.\x20Negative\n\x20second\x20values\x20with\x20fractions\
    \x20must\x20still\x20have\x20non-negative\x20nanos\x20values\n\x20that\
    \x20count\x20forward\x20in\x20time.\x20Must\x20be\x20from\x200\x20to\x20\
    999,999,999\n\x20inclusive.\x20This\x20field\x20may\x20be\x20limited\x20\
    in\x20precision\x20depending\x20on\x20context.\n\n\r\n\x05\x04'\x02\x01\
    \x04\x12\x04\x8a\x08\x02\n\n\r\n\x05\x04'\x02\x01\x05\x12\x04\x8a\x08\
    \x0b\x10\n\r\n\x05\x04'\x02\x01\x01\x12\x04\x8a\x08\x11\x16\n\r\n\x05\
    \x04'\x02\x01\x03\x12\x04\x8a\x08\x19\x1a\n\x82\x02\n\x02\x04(\x12\x06\
    \x92\x08\0\xa1\x08\x01\x1a\xf3\x01\x20TypeMeta\x20describes\x20an\x20ind\
    ividual\x20object\x20in\x20an\x20API\x20response\x20or\x20request\n\x20w\
    ith\x20strings\x20representing\x20the\x20type\x20of\x20the\x20object\x20\
    and\x20its\x20API\x20schema\x20version.\n\x20Structures\x20that\x20are\
    \x20versioned\x20or\x20persisted\x20should\x20inline\x20TypeMeta.\n\n\
    \x20+k8s:deepcopy-gen=false\n\n\x0b\n\x03\x04(\x01\x12\x04\x92\x08\x08\
    \x10\n\xc2\x02\n\x04\x04(\x02\0\x12\x04\x99\x08\x02\x1b\x1a\xb3\x02\x20K\
    ind\x20is\x20a\x20string\x20value\x20representing\x20the\x20REST\x20reso\
    urce\x20this\x20object\x20represents.\n\x20Servers\x20may\x20infer\x20th\
    is\x20from\x20the\x20endpoint\x20the\x20client\x20submits\x20requests\
    \x20to.\n\x20Cannot\x20be\x20updated.\n\x20In\x20CamelCase.\n\x20More\
    \x20info:\x20https://git.k8s.io/community/contributors/devel/sig-archite\
    cture/api-conventions.md#types-kinds\n\x20+optional\n\n\r\n\x05\x04(\x02\
    \0\x04\x12\x04\x99\x08\x02\n\n\r\n\x05\x04(\x02\0\x05\x12\x04\x99\x08\
    \x0b\x11\n\r\n\x05\x04(\x02\0\x01\x12\x04\x99\x08\x12\x16\n\r\n\x05\x04(\
    \x02\0\x03\x12\x04\x99\x08\x19\x1a\n\xc0\x02\n\x04\x04(\x02\x01\x12\x04\
    \xa0\x08\x02!\x1a\xb1\x02\x20APIVersion\x20defines\x20the\x20versioned\
    \x20schema\x20of\x20this\x20representation\x20of\x20an\x20object.\n\x20S\
    ervers\x20should\x20convert\x20recognized\x20schemas\x20to\x20the\x20lat\
    est\x20internal\x20value,\x20and\n\x20may\x20reject\x20unrecognized\x20v\
    alues.\n\x20More\x20info:\x20https://git.k8s.io/community/contributors/d\
    evel/sig-architecture/api-conventions.md#resources\n\x20+optional\n\n\r\
    \n\x05\x04(\x02\x01\x04\x12\x04\xa0\x08\x02\n\n\r\n\x05\x04(\x02\x01\x05\
    \x12\x04\xa0\x08\x0b\x11\n\r\n\x05\x04(\x02\x01\x01\x12\x04\xa0\x08\x12\
    \x1c\n\r\n\x05\x04(\x02\x01\x03\x12\x04\xa0\x08\x1f\x20\n\x90\x01\n\x02\
    \x04)\x12\x06\xa5\x08\0\xb4\x08\x01\x1a\x81\x01\x20UpdateOptions\x20may\
    \x20be\x20provided\x20when\x20updating\x20an\x20API\x20object.\n\x20All\
    \x20fields\x20in\x20UpdateOptions\x20should\x20also\x20be\x20present\x20\
    in\x20PatchOptions.\n\n\x0b\n\x03\x04)\x01\x12\x04\xa5\x08\x08\x15\n\x98\
    \x02\n\x04\x04)\x02\0\x12\x04\xac\x08\x02\x1d\x1a\x89\x02\x20When\x20pre\
    sent,\x20indicates\x20that\x20modifications\x20should\x20not\x20be\n\x20\
    persisted.\x20An\x20invalid\x20or\x20unrecognized\x20dryRun\x20directive\
    \x20will\n\x20result\x20in\x20an\x20error\x20response\x20and\x20no\x20fu\
    rther\x20processing\x20of\x20the\n\x20request.\x20Valid\x20values\x20are\
    :\n\x20-\x20All:\x20all\x20dry\x20run\x20stages\x20will\x20be\x20process\
    ed\n\x20+optional\n\n\r\n\x05\x04)\x02\0\x04\x12\x04\xac\x08\x02\n\n\r\n\
    \x05\x04)\x02\0\x05\x12\x04\xac\x08\x0b\x11\n\r\n\x05\x04)\x02\0\x01\x12\
    \x04\xac\x08\x12\x18\n\r\n\x05\x04)\x02\0\x03\x12\x04\xac\x08\x1b\x1c\n\
    \x89\x02\n\x04\x04)\x02\x01\x12\x04\xb3\x08\x02#\x1a\xfa\x01\x20fieldMan\
    ager\x20is\x20a\x20name\x20associated\x20with\x20the\x20actor\x20or\x20e\
    ntity\n\x20that\x20is\x20making\x20these\x20changes.\x20The\x20value\x20\
    must\x20be\x20less\x20than\x20or\n\x20128\x20characters\x20long,\x20and\
    \x20only\x20contain\x20printable\x20characters,\n\x20as\x20defined\x20by\
    \x20https://golang.org/pkg/unicode/#IsPrint.\n\x20+optional\n\n\r\n\x05\
    \x04)\x02\x01\x04\x12\x04\xb3\x08\x02\n\n\r\n\x05\x04)\x02\x01\x05\x12\
    \x04\xb3\x08\x0b\x11\n\r\n\x05\x04)\x02\x01\x01\x12\x04\xb3\x08\x12\x1e\
    \n\r\n\x05\x04)\x02\x01\x03\x12\x04\xb3\x08!\"\n\xc1\x01\n\x02\x04*\x12\
    \x06\xba\x08\0\xbe\x08\x01\x1a\x80\x01\x20Verbs\x20masks\x20the\x20value\
    \x20so\x20protobuf\x20can\x20generate\n\n\x20+protobuf.nullable=true\n\
    \x20+protobuf.options.(gogoproto.goproto_stringer)=false\n\"0\x20items,\
    \x20if\x20empty,\x20will\x20result\x20in\x20an\x20empty\x20slice\n\n\x0b\
    \n\x03\x04*\x01\x12\x04\xba\x08\x08\r\n\x0c\n\x04\x04*\x02\0\x12\x04\xbd\
    \x08\x02\x1c\n\r\n\x05\x04*\x02\0\x04\x12\x04\xbd\x08\x02\n\n\r\n\x05\
    \x04*\x02\0\x05\x12\x04\xbd\x08\x0b\x11\n\r\n\x05\x04*\x02\0\x01\x12\x04\
    \xbd\x08\x12\x17\n\r\n\x05\x04*\x02\0\x03\x12\x04\xbd\x08\x1a\x1b\n\xb5\
    \x01\n\x02\x04+\x12\x06\xc5\x08\0\xce\x08\x01\x1a\xa6\x01\x20Event\x20re\
    presents\x20a\x20single\x20event\x20to\x20a\x20watched\x20resource.\n\n\
    \x20+protobuf=true\n\x20+k8s:deepcopy-gen=true\n\x20+k8s:deepcopy-gen:in\
    terfaces=k8s.io/apimachinery/pkg/runtime.Object\n\n\x0b\n\x03\x04+\x01\
    \x12\x04\xc5\x08\x08\x12\n\x0c\n\x04\x04+\x02\0\x12\x04\xc6\x08\x02\x1b\
    \n\r\n\x05\x04+\x02\0\x04\x12\x04\xc6\x08\x02\n\n\r\n\x05\x04+\x02\0\x05\
    \x12\x04\xc6\x08\x0b\x11\n\r\n\x05\x04+\x02\0\x01\x12\x04\xc6\x08\x12\
    \x16\n\r\n\x05\x04+\x02\0\x03\x12\x04\xc6\x08\x19\x1a\n\x8a\x02\n\x04\
    \x04+\x02\x01\x12\x04\xcd\x08\x02C\x1a\xfb\x01\x20Object\x20is:\n\x20\
    \x20*\x20If\x20Type\x20is\x20Added\x20or\x20Modified:\x20the\x20new\x20s\
    tate\x20of\x20the\x20object.\n\x20\x20*\x20If\x20Type\x20is\x20Deleted:\
    \x20the\x20state\x20of\x20the\x20object\x20immediately\x20before\x20dele\
    tion.\n\x20\x20*\x20If\x20Type\x20is\x20Error:\x20*Status\x20is\x20recom\
    mended;\x20other\x20types\x20may\x20make\x20sense\n\x20\x20\x20\x20depen\
    ding\x20on\x20context.\n\n\r\n\x05\x04+\x02\x01\x04\x12\x04\xcd\x08\x02\
    \n\n\r\n\x05\x04+\x02\x01\x06\x12\x04\xcd\x08\x0b7\n\r\n\x05\x04+\x02\
    \x01\x01\x12\x04\xcd\x088>\n\r\n\x05\x04+\x02\x01\x03\x12\x04\xcd\x08AB\
";

static file_descriptor_proto_lazy: ::protobuf::rt::LazyV2<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::LazyV2::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    file_descriptor_proto_lazy.get(|| {
        parse_descriptor_proto()
    })
}
